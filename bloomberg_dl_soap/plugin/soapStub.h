/* soapStub.h
   Generated by gSOAP 2.8.112 for bloomberg_dl_soap.h

gSOAP XML Web services tools
Copyright (C) 2000-2021, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <vector>
#define SOAP_NAMESPACE_OF_ns1	"http://services.bloomberg.com/datalicense/dlws/ps/20071001"

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 208112
# error "GSOAP VERSION 208112 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumeration Types                                                          *
 *                                                                            *
\******************************************************************************/


/* bloomberg_dl_soap.h:424 */
#ifndef SOAP_TYPE_ns1__MarketSector
#define SOAP_TYPE_ns1__MarketSector (134)
/* ns1:MarketSector */
enum ns1__MarketSector {
	ns1__MarketSector__Govt = 0,
	ns1__MarketSector__Corp = 1,
	ns1__MarketSector__Mtge = 2,
	ns1__MarketSector__M_Mkt = 3,
	ns1__MarketSector__Muni = 4,
	ns1__MarketSector__Pfd = 5,
	ns1__MarketSector__Equity = 6,
	ns1__MarketSector__Comdty = 7,
	ns1__MarketSector__Index = 8,
	ns1__MarketSector__Curncy = 9
};
#endif

/* bloomberg_dl_soap.h:441 */
#ifndef SOAP_TYPE_ns1__MacroType
#define SOAP_TYPE_ns1__MacroType (135)
/* ns1:MacroType */
enum ns1__MacroType {
	ns1__MacroType__BOND_USCORESRCH = 0,
	ns1__MacroType__EQUITY_USCORESRCH = 1,
	ns1__MacroType__EXCH = 2,
	ns1__MacroType__INDEX = 3,
	ns1__MacroType__PFD_USCORESRCH = 4,
	ns1__MacroType__PORTFOLIO = 5,
	ns1__MacroType__SECTYP = 6,
	ns1__MacroType__BSRCH = 7
};
#endif

/* bloomberg_dl_soap.h:456 */
#ifndef SOAP_TYPE_ns1__SecondaryQualifierOperator
#define SOAP_TYPE_ns1__SecondaryQualifierOperator (136)
/* ns1:SecondaryQualifierOperator */
enum ns1__SecondaryQualifierOperator {
	ns1__SecondaryQualifierOperator__Equals = 0,
	ns1__SecondaryQualifierOperator__NotEquals = 1,
	ns1__SecondaryQualifierOperator__GreaterThan = 2,
	ns1__SecondaryQualifierOperator__LessThan = 3
};
#endif

/* bloomberg_dl_soap.h:467 */
#ifndef SOAP_TYPE_ns1__SecondaryQualifierType
#define SOAP_TYPE_ns1__SecondaryQualifierType (137)
/* ns1:SecondaryQualifierType */
enum ns1__SecondaryQualifierType {
	ns1__SecondaryQualifierType__ACTIVE_USCOREPRICING = 0,
	ns1__SecondaryQualifierType__COUNTRY = 1,
	ns1__SecondaryQualifierType__CPN_USCORETYP = 2,
	ns1__SecondaryQualifierType__CRNCY = 3,
	ns1__SecondaryQualifierType__EXCH_USCORETRADED = 4,
	ns1__SecondaryQualifierType__MATURED = 5,
	ns1__SecondaryQualifierType__NET_USCORECPN = 6,
	ns1__SecondaryQualifierType__RATE = 7,
	ns1__SecondaryQualifierType__RATING = 8,
	ns1__SecondaryQualifierType__SECURITY_USCOREDES = 9,
	ns1__SecondaryQualifierType__SECURITY_USCORETYP = 10,
	ns1__SecondaryQualifierType__SERIES = 11,
	ns1__SecondaryQualifierType__TICKER = 12,
	ns1__SecondaryQualifierType__WAC = 13,
	ns1__SecondaryQualifierType__WALA = 14,
	ns1__SecondaryQualifierType__WAM = 15,
	ns1__SecondaryQualifierType__BVAL_USCOREOTC_USCOREFREQUENCY = 16,
	ns1__SecondaryQualifierType__BVAL_USCOREOTC_USCOREEXPIRED = 17,
	ns1__SecondaryQualifierType__BVAL_USCOREOTC_USCOREASSET = 18,
	ns1__SecondaryQualifierType__BVAL_USCOREOTC_USCORESNAPSHOT = 19,
	ns1__SecondaryQualifierType__BVAL_USCOREOTC_USCOREUNWOUND = 20
};
#endif

/* bloomberg_dl_soap.h:495 */
#ifndef SOAP_TYPE_ns1__InstrumentType
#define SOAP_TYPE_ns1__InstrumentType (138)
/* ns1:InstrumentType */
enum ns1__InstrumentType {
	ns1__InstrumentType__AUSTRIAN = 0,
	ns1__InstrumentType__BB_USCOREUNIQUE = 1,
	ns1__InstrumentType__BB_USCOREGLOBAL = 2,
	ns1__InstrumentType__BELGIAN = 3,
	ns1__InstrumentType__CATS = 4,
	ns1__InstrumentType__CEDEL = 5,
	ns1__InstrumentType__CINS = 6,
	ns1__InstrumentType__COMMON_USCORENUMBER = 7,
	ns1__InstrumentType__CUSIP = 8,
	ns1__InstrumentType__CZECH = 9,
	ns1__InstrumentType__DUTCH = 10,
	ns1__InstrumentType__EUROCLEAR = 11,
	ns1__InstrumentType__FRENCH = 12,
	ns1__InstrumentType__IRISH = 13,
	ns1__InstrumentType__ISIN = 14,
	ns1__InstrumentType__ISRAELI = 15,
	ns1__InstrumentType__ITALY = 16,
	ns1__InstrumentType__JAPAN = 17,
	ns1__InstrumentType__LUXEMBOURG = 18,
	ns1__InstrumentType__SEDOL = 19,
	ns1__InstrumentType__SPAIN = 20,
	ns1__InstrumentType__TICKER = 21,
	ns1__InstrumentType__VALOREN = 22,
	ns1__InstrumentType__WPK = 23,
	ns1__InstrumentType__BB_USCORECOMPANY = 24
};
#endif

/* bloomberg_dl_soap.h:527 */
#ifndef SOAP_TYPE_ns1__SpecialChar
#define SOAP_TYPE_ns1__SpecialChar (139)
/* ns1:SpecialChar */
enum ns1__SpecialChar {
	ns1__SpecialChar__fraction = 0,
	ns1__SpecialChar__decimal = 1,
	ns1__SpecialChar__altdecimal = 2
};
#endif

/* bloomberg_dl_soap.h:537 */
#ifndef SOAP_TYPE_ns1__ProgramFlag
#define SOAP_TYPE_ns1__ProgramFlag (140)
/* ns1:ProgramFlag */
enum ns1__ProgramFlag {
	ns1__ProgramFlag__oneshot = 0,
	ns1__ProgramFlag__daily = 1,
	ns1__ProgramFlag__weekly = 2,
	ns1__ProgramFlag__monthly = 3,
	ns1__ProgramFlag__weekday = 4,
	ns1__ProgramFlag__weekend = 5,
	ns1__ProgramFlag__adhoc = 6
};
#endif

/* bloomberg_dl_soap.h:551 */
#ifndef SOAP_TYPE_ns1__Version
#define SOAP_TYPE_ns1__Version (141)
/* ns1:Version */
enum ns1__Version {
	ns1__Version__new_ = 0
};
#endif

/* bloomberg_dl_soap.h:559 */
#ifndef SOAP_TYPE_ns1__DiffFlag
#define SOAP_TYPE_ns1__DiffFlag (142)
/* ns1:DiffFlag */
enum ns1__DiffFlag {
	ns1__DiffFlag__yes = 0,
	ns1__DiffFlag__no = 1,
	ns1__DiffFlag__changes = 2
};
#endif

/* bloomberg_dl_soap.h:569 */
#ifndef SOAP_TYPE_ns1__DateFormat
#define SOAP_TYPE_ns1__DateFormat (143)
/* ns1:DateFormat */
enum ns1__DateFormat {
	ns1__DateFormat__mmddyy = 0,
	ns1__DateFormat__yyddmm = 1,
	ns1__DateFormat__mmyydd = 2,
	ns1__DateFormat__ddmmyy = 3,
	ns1__DateFormat__yyyyddmm = 4,
	ns1__DateFormat__mmyyyydd = 5,
	ns1__DateFormat__yyyymmdd = 6,
	ns1__DateFormat__yymmdd = 7,
	ns1__DateFormat__ddyymm = 8,
	ns1__DateFormat__mmddyyyy = 9,
	ns1__DateFormat__yyyy_x002fmm_x002fdd = 10,
	ns1__DateFormat__ddyyyymm = 11,
	ns1__DateFormat__dd_mmm_yy = 12,
	ns1__DateFormat__ddmmyyyy = 13
};
#endif

/* bloomberg_dl_soap.h:590 */
#ifndef SOAP_TYPE_ns1__FieldType
#define SOAP_TYPE_ns1__FieldType (144)
/* ns1:FieldType */
enum ns1__FieldType {
	ns1__FieldType__Character = 0,
	ns1__FieldType__Numeric = 1,
	ns1__FieldType__Price = 2,
	ns1__FieldType__Security = 3,
	ns1__FieldType__Date = 4,
	ns1__FieldType__Time = 5,
	ns1__FieldType__Date_x002fTime = 6,
	ns1__FieldType__Bulk = 7,
	ns1__FieldType__Month_x002fYear = 8,
	ns1__FieldType__Boolean = 9,
	ns1__FieldType__Currency = 10,
	ns1__FieldType__Integer = 11,
	ns1__FieldType__Real = 12
};
#endif

/* bloomberg_dl_soap.h:610 */
#ifndef SOAP_TYPE_ns1__HistPeriod
#define SOAP_TYPE_ns1__HistPeriod (145)
/* ns1:HistPeriod */
enum ns1__HistPeriod {
	ns1__HistPeriod__daily = 0,
	ns1__HistPeriod__weekly = 1,
	ns1__HistPeriod__monthly = 2,
	ns1__HistPeriod__quarterly = 3,
	ns1__HistPeriod__yearly = 4
};
#endif

/* bloomberg_dl_soap.h:622 */
#ifndef SOAP_TYPE_ns1__HistOption
#define SOAP_TYPE_ns1__HistOption (146)
/* ns1:HistOption */
enum ns1__HistOption {
	ns1__HistOption__average = 0
};
#endif

/* bloomberg_dl_soap.h:630 */
#ifndef SOAP_TYPE_ns1__FilingStatus
#define SOAP_TYPE_ns1__FilingStatus (147)
/* ns1:FilingStatus */
enum ns1__FilingStatus {
	ns1__FilingStatus__mostrecent = 0,
	ns1__FilingStatus__prelim = 1,
	ns1__FilingStatus__original = 2,
	ns1__FilingStatus__restated = 3
};
#endif

/* bloomberg_dl_soap.h:641 */
#ifndef SOAP_TYPE_ns1__Periodicity
#define SOAP_TYPE_ns1__Periodicity (148)
/* ns1:Periodicity */
enum ns1__Periodicity {
	ns1__Periodicity__y = 'y',
	ns1__Periodicity__q = 'q',
	ns1__Periodicity__s = 's',
	ns1__Periodicity__a = 'a',
	ns1__Periodicity__c = 'c'
};
#endif

/* bloomberg_dl_soap.h:653 */
#ifndef SOAP_TYPE_ns1__BvalTier
#define SOAP_TYPE_ns1__BvalTier (149)
/* ns1:BvalTier */
enum ns1__BvalTier {
	ns1__BvalTier__1 = 1,
	ns1__BvalTier__2 = 2
};
#endif

/* bloomberg_dl_soap.h:662 */
#ifndef SOAP_TYPE_ns1__BvalSnapshot
#define SOAP_TYPE_ns1__BvalSnapshot (150)
/* ns1:BvalSnapshot */
enum ns1__BvalSnapshot {
	ns1__BvalSnapshot__ny4pm = 0,
	ns1__BvalSnapshot__lo4pm = 1,
	ns1__BvalSnapshot__to4pm = 2,
	ns1__BvalSnapshot__ny3pm = 3,
	ns1__BvalSnapshot__lo3pm = 4,
	ns1__BvalSnapshot__to3pm = 5,
	ns1__BvalSnapshot__lo12pm = 6,
	ns1__BvalSnapshot__to5pm = 7,
	ns1__BvalSnapshot__sy5pm = 8
};
#endif

/* bloomberg_dl_soap.h:678 */
#ifndef SOAP_TYPE_ns1__CancelStatus
#define SOAP_TYPE_ns1__CancelStatus (151)
/* ns1:CancelStatus */
enum ns1__CancelStatus {
	ns1__CancelStatus__ERROR = 0,
	ns1__CancelStatus__NOT_x0020FOUND = 1,
	ns1__CancelStatus__CANCELLED = 2
};
#endif

/* bloomberg_dl_soap.h:688 */
#ifndef SOAP_TYPE_ns1__PortSecDes
#define SOAP_TYPE_ns1__PortSecDes (152)
/* ns1:PortSecDes */
enum ns1__PortSecDes {
	ns1__PortSecDes__adjusted = 0
};
#endif

/* bloomberg_dl_soap.h:696 */
#ifndef SOAP_TYPE_ns1__ActionsDate
#define SOAP_TYPE_ns1__ActionsDate (153)
/* ns1:ActionsDate */
enum ns1__ActionsDate {
	ns1__ActionsDate__entry = 0,
	ns1__ActionsDate__effective = 1,
	ns1__ActionsDate__both = 2
};
#endif

/* bloomberg_dl_soap.h:706 */
#ifndef SOAP_TYPE_ns1__OtcBvalAction
#define SOAP_TYPE_ns1__OtcBvalAction (154)
/* ns1:OtcBvalAction */
enum ns1__OtcBvalAction {
	ns1__OtcBvalAction__insert = 0,
	ns1__OtcBvalAction__update = 1,
	ns1__OtcBvalAction__unwind = 2,
	ns1__OtcBvalAction__reprice = 3
};
#endif

/* bloomberg_dl_soap.h:717 */
#ifndef SOAP_TYPE_ns1__RegSolvency
#define SOAP_TYPE_ns1__RegSolvency (155)
/* ns1:RegSolvency */
enum ns1__RegSolvency {
	ns1__RegSolvency__no = 0,
	ns1__RegSolvency__packaged = 1
};
#endif

/* bloomberg_dl_soap.h:726 */
#ifndef SOAP_TYPE_ns1__FieldMacro
#define SOAP_TYPE_ns1__FieldMacro (156)
/* ns1:FieldMacro */
enum ns1__FieldMacro {
	ns1__FieldMacro__BO_USCORECREDIT_USCORERISK_USCORECOMPANY = 0,
	ns1__FieldMacro__BO_USCORECREDIT_USCORERISK_USCOREFITCH = 1,
	ns1__FieldMacro__BO_USCORECREDIT_USCORERISK_USCOREMOODY = 2,
	ns1__FieldMacro__BO_USCORECREDIT_USCORERISK_USCORERATINGS1 = 3,
	ns1__FieldMacro__BO_USCORECREDIT_USCORERISK_USCORERATINGS2 = 4,
	ns1__FieldMacro__BO_USCORECREDIT_USCORERISK_USCORESP = 5,
	ns1__FieldMacro__BVAL_USCOREFVHL_USCOREREG_USCORETRANSPARENCY = 6
};
#endif

/* bloomberg_dl_soap.h:740 */
#ifndef SOAP_TYPE_ns1__BvalFieldMacro
#define SOAP_TYPE_ns1__BvalFieldMacro (157)
/* ns1:BvalFieldMacro */
enum ns1__BvalFieldMacro {
	ns1__BvalFieldMacro__BVAL_USCOREALL = 0,
	ns1__BvalFieldMacro__BVAL_USCOREBOND = 1,
	ns1__BvalFieldMacro__BVAL_USCOREMTGE = 2,
	ns1__BvalFieldMacro__BVAL_USCOREMUNI = 3
};
#endif

/* bloomberg_dl_soap.h:755 */
#ifndef SOAP_TYPE_ns1__DLCategory
#define SOAP_TYPE_ns1__DLCategory (158)
/* ns1:DLCategory */
enum ns1__DLCategory {
	ns1__DLCategory__Security_x0020Master = 0,
	ns1__DLCategory__Derived_x0020Data = 1,
	ns1__DLCategory__End_x0020of_x0020Day_x0020Pricing = 2,
	ns1__DLCategory__User_x0020Entered_x0020Info_x002e = 3,
	ns1__DLCategory__Corporate_x0020Actions = 4,
	ns1__DLCategory__Historical_x0020Time_x0020Series = 5,
	ns1__DLCategory__Estimates = 6,
	ns1__DLCategory__Fundamentals = 7,
	ns1__DLCategory__Quote_x0020Composite = 8,
	ns1__DLCategory__Credit_x0020Risk = 9,
	ns1__DLCategory__Reg_x0020SSFA = 10,
	ns1__DLCategory__Bram_x0020Fair_x0020Value_x0020Hierarchy_x0020Leveling_x0020Tool = 11,
	ns1__DLCategory__Premium_x0020BRAM_x0020Transparency = 12,
	ns1__DLCategory__Price_x0020Uncertainty = 13,
	ns1__DLCategory__Not_x0020Downloadable = 14
};
#endif

/* bloomberg_dl_soap.h:781 */
#ifndef SOAP_TYPE_ns1__DLCategory2
#define SOAP_TYPE_ns1__DLCategory2 (159)
/* ns1:DLCategory2 */
enum ns1__DLCategory2 {
	ns1__DLCategory2__Security_x0020Master = 0,
	ns1__DLCategory2__Derived_x0020__x0020Intraday = 1,
	ns1__DLCategory2__Derived_x0020__x0020End_x0020of_x0020Day = 2,
	ns1__DLCategory2__Pricing_x0020__x0020Intraday = 3,
	ns1__DLCategory2__Pricing_x0020__x0020End_x0020of_x0020Day = 4,
	ns1__DLCategory2__User_x0020Entered_x0020Info_x002e = 5,
	ns1__DLCategory2__Corporate_x0020Actions = 6,
	ns1__DLCategory2__Historical_x0020Time_x0020Series = 7,
	ns1__DLCategory2__Estimates = 8,
	ns1__DLCategory2__Fundamentals = 9,
	ns1__DLCategory2__Quote_x0020Composite = 10,
	ns1__DLCategory2__Quote_x0020Composite_x0020History = 11,
	ns1__DLCategory2__Credit_x0020Risk = 12,
	ns1__DLCategory2__Packaged = 13,
	ns1__DLCategory2__Open_x0020Source = 14,
	ns1__DLCategory2__Reg_x0020SSFA = 15,
	ns1__DLCategory2__Volatility_x0020Surface = 16,
	ns1__DLCategory2__Volatility_x0020Cube = 17,
	ns1__DLCategory2__Bram_x0020Fair_x0020Value_x0020Hierarchy_x0020Leveling_x0020Tool = 18,
	ns1__DLCategory2__Credit_x0020Risk_x0020Corporate_x0020Structure = 19,
	ns1__DLCategory2__Credit_x0020Risk_x0020Capital_x0020Structure = 20,
	ns1__DLCategory2__Credit_x0020Risk_x0020Regulatory_x0020Compliance = 21,
	ns1__DLCategory2__Premium_x0020BRAM_x0020Transparency = 22,
	ns1__DLCategory2__Price_x0020Uncertainty = 23,
	ns1__DLCategory2__Not_x0020Downloadable = 24,
	ns1__DLCategory2__Central_x0020Bank_x0020Eligibility = 25,
	ns1__DLCategory2__Covered_x0020Funds = 26,
	ns1__DLCategory2__High_x0020Quality_x0020Liquid_x0020Assets = 27,
	ns1__DLCategory2__Liquidity_x0020Assessment = 28,
	ns1__DLCategory2__MiFIR = 29,
	ns1__DLCategory2__Default_x0020Risk = 30,
	ns1__DLCategory2__IFRS_x00209_x0020SPPI = 31,
	ns1__DLCategory2__Collateral_x0020Tagging = 32,
	ns1__DLCategory2__US_x0020Withholding_x0020Tax = 33,
	ns1__DLCategory2__Expected_x0020Credit_x0020Loss = 34,
	ns1__DLCategory2__Basic_x0020Tax = 35,
	ns1__DLCategory2__Investor_x0020Protection = 36
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class ns1__CancelHeaders;	/* bloomberg_dl_soap.h:166 */
class ns1__GetCorrectionsHeaders;	/* bloomberg_dl_soap.h:168 */
class ns1__GetDataHeaders;	/* bloomberg_dl_soap.h:170 */
class ns1__Period;	/* bloomberg_dl_soap.h:172 */
class ns1__Duration;	/* bloomberg_dl_soap.h:174 */
class ns1__DateRange;	/* bloomberg_dl_soap.h:176 */
class ns1__GetHistoryHeaders;	/* bloomberg_dl_soap.h:178 */
class ns1__GetFundamentalsHeaders;	/* bloomberg_dl_soap.h:180 */
class ns1__GetCompanyHeaders;	/* bloomberg_dl_soap.h:182 */
class ns1__GetActionsHeaders;	/* bloomberg_dl_soap.h:184 */
class ns1__GetPortfolioValidationHeaders;	/* bloomberg_dl_soap.h:186 */
class ns1__QuotesHeaders;	/* bloomberg_dl_soap.h:188 */
class ns1__DateTimeRange;	/* bloomberg_dl_soap.h:190 */
class ns1__TickOutputTz;	/* bloomberg_dl_soap.h:192 */
class ns1__FieldSets;	/* bloomberg_dl_soap.h:194 */
class ns1__FieldSet;	/* bloomberg_dl_soap.h:196 */
class ns1__BvalFieldSets;	/* bloomberg_dl_soap.h:198 */
class ns1__BvalFieldSet;	/* bloomberg_dl_soap.h:200 */
class ns1__ScheduledHeaders;	/* bloomberg_dl_soap.h:202 */
class ns1__Fields;	/* bloomberg_dl_soap.h:204 */
class ns1__Overrides;	/* bloomberg_dl_soap.h:206 */
class ns1__Instruments;	/* bloomberg_dl_soap.h:208 */
class ns1__FundInstruments;	/* bloomberg_dl_soap.h:210 */
class ns1__InstrumentDatas;	/* bloomberg_dl_soap.h:212 */
class ns1__HistInstrumentDatas;	/* bloomberg_dl_soap.h:214 */
class ns1__FundInstrumentDatas;	/* bloomberg_dl_soap.h:216 */
class ns1__ActionsInstrumentDatas;	/* bloomberg_dl_soap.h:218 */
class ns1__CorrectionRecords;	/* bloomberg_dl_soap.h:220 */
class ns1__QuotesInstrumentDatas;	/* bloomberg_dl_soap.h:222 */
class ns1__AllQuotesInstrumentDatas;	/* bloomberg_dl_soap.h:224 */
class ns1__Instrument;	/* bloomberg_dl_soap.h:226 */
class ns1__FundInstrument;	/* bloomberg_dl_soap.h:228 */
class ns1__Macro;	/* bloomberg_dl_soap.h:230 */
class ns1__PrimaryQualifier;	/* bloomberg_dl_soap.h:232 */
class ns1__SecondaryQualifier;	/* bloomberg_dl_soap.h:234 */
class ns1__Override;	/* bloomberg_dl_soap.h:236 */
class ns1__Actions;	/* bloomberg_dl_soap.h:238 */
class ns1__DataItem;	/* bloomberg_dl_soap.h:240 */
class ns1__InstrumentData;	/* bloomberg_dl_soap.h:242 */
class ns1__HistInstrumentData;	/* bloomberg_dl_soap.h:244 */
class ns1__FundInstrumentData;	/* bloomberg_dl_soap.h:246 */
class ns1__QuotesInstrumentData;	/* bloomberg_dl_soap.h:248 */
class ns1__AllQuotesInstrumentData;	/* bloomberg_dl_soap.h:250 */
class ns1__ActionsInstrumentData;	/* bloomberg_dl_soap.h:252 */
class ns1__CorrectionRecord;	/* bloomberg_dl_soap.h:254 */
class ns1__Data;	/* bloomberg_dl_soap.h:256 */
class ns1__QRQuotes;	/* bloomberg_dl_soap.h:258 */
class ns1__QRMQuotes;	/* bloomberg_dl_soap.h:260 */
class ns1__QRQuote;	/* bloomberg_dl_soap.h:262 */
class ns1__QRMQuoteData;	/* bloomberg_dl_soap.h:264 */
class ns1__QRMQuote;	/* bloomberg_dl_soap.h:266 */
class ns1__HistData;	/* bloomberg_dl_soap.h:268 */
class ns1__ActionStandardFields;	/* bloomberg_dl_soap.h:270 */
class ns1__BulkArray;	/* bloomberg_dl_soap.h:272 */
class ns1__BulkArrayEntry;	/* bloomberg_dl_soap.h:274 */
class ns1__ResponseStatus;	/* bloomberg_dl_soap.h:276 */
class ns1__CancelResponseStatus;	/* bloomberg_dl_soap.h:278 */
class ns1__FieldSearchCriteria;	/* bloomberg_dl_soap.h:280 */
class ns1__FieldInfos;	/* bloomberg_dl_soap.h:282 */
class ns1__FieldInfo;	/* bloomberg_dl_soap.h:284 */
class ns1__OtcBvalHeaders;	/* bloomberg_dl_soap.h:286 */
class ns1__OtcDealInformation;	/* bloomberg_dl_soap.h:288 */
class ns1__OtcDealInfos;	/* bloomberg_dl_soap.h:290 */
class ns1__PerSecurityResponse;	/* bloomberg_dl_soap.h:292 */
class ns1__SubmitGetDataRequest;	/* bloomberg_dl_soap.h:294 */
class ns1__RetrieveGetDataRequest;	/* bloomberg_dl_soap.h:298 */
class ns1__SubmitGetHistoryRequest;	/* bloomberg_dl_soap.h:302 */
class ns1__RetrieveGetHistoryRequest;	/* bloomberg_dl_soap.h:306 */
class ns1__SubmitCancelRequest;	/* bloomberg_dl_soap.h:310 */
class ns1__RetrieveCancelRequest;	/* bloomberg_dl_soap.h:314 */
class ns1__GetCorrectionsRequest;	/* bloomberg_dl_soap.h:318 */
class ns1__SubmitScheduledRequest;	/* bloomberg_dl_soap.h:322 */
class ns1__RetrieveScheduledRequest;	/* bloomberg_dl_soap.h:326 */
class ns1__ScheduledResponses;	/* bloomberg_dl_soap.h:328 */
class ns1__ScheduledResponse;	/* bloomberg_dl_soap.h:330 */
class ns1__SubmitGetFundamentalsRequest;	/* bloomberg_dl_soap.h:334 */
class ns1__RetrieveGetFundamentalsRequest;	/* bloomberg_dl_soap.h:338 */
class ns1__SubmitGetCompanyRequest;	/* bloomberg_dl_soap.h:342 */
class ns1__RetrieveGetCompanyRequest;	/* bloomberg_dl_soap.h:346 */
class ns1__GetPortfolioValidationRequest;	/* bloomberg_dl_soap.h:350 */
class ns1__SubmitGetActionsRequest;	/* bloomberg_dl_soap.h:354 */
class ns1__RetrieveGetActionsRequest;	/* bloomberg_dl_soap.h:358 */
class ns1__SubmitGetQuotesRequest;	/* bloomberg_dl_soap.h:362 */
class ns1__RetrieveGetQuotesRequest;	/* bloomberg_dl_soap.h:366 */
class ns1__SubmitGetAllQuotesRequest;	/* bloomberg_dl_soap.h:370 */
class ns1__RetrieveGetAllQuotesRequest;	/* bloomberg_dl_soap.h:374 */
class ns1__SubmitOtcbvalUploadRequest;	/* bloomberg_dl_soap.h:378 */
class ns1__RetrieveOtcbvalUploadRequest;	/* bloomberg_dl_soap.h:382 */
class ns1__SubmitOtcBvalDealsUploadRequest;	/* bloomberg_dl_soap.h:386 */
class ns1__RetrieveOtcBvalDealsUploadRequest;	/* bloomberg_dl_soap.h:390 */
class ns1__GetFieldsRequest;	/* bloomberg_dl_soap.h:394 */
class ns1__MmktBvalHeaders;	/* bloomberg_dl_soap.h:398 */
class ns1__SubmitMmktBvalDealsUploadRequest;	/* bloomberg_dl_soap.h:400 */
class ns1__RetrieveMmktBvalDealsUploadRequest;	/* bloomberg_dl_soap.h:404 */
class ns1__MmktBvalDealInformation;	/* bloomberg_dl_soap.h:406 */
class ns1__MmktBvalDealInfos;	/* bloomberg_dl_soap.h:408 */
class ns1__SubmitGetDataResponse;	/* bloomberg_dl_soap.h:296 */
class ns1__RetrieveGetDataResponse;	/* bloomberg_dl_soap.h:300 */
class ns1__SubmitGetHistoryResponse;	/* bloomberg_dl_soap.h:304 */
class ns1__RetrieveGetHistoryResponse;	/* bloomberg_dl_soap.h:308 */
class ns1__SubmitCancelResponse;	/* bloomberg_dl_soap.h:312 */
class ns1__RetrieveCancelResponse;	/* bloomberg_dl_soap.h:316 */
class ns1__GetCorrectionsResponse;	/* bloomberg_dl_soap.h:320 */
class ns1__SubmitScheduledResponse;	/* bloomberg_dl_soap.h:324 */
class ns1__RetrieveScheduledResponse;	/* bloomberg_dl_soap.h:332 */
class ns1__SubmitGetFundamentalsResponse;	/* bloomberg_dl_soap.h:336 */
class ns1__RetrieveGetFundamentalsResponse;	/* bloomberg_dl_soap.h:340 */
class ns1__SubmitGetCompanyResponse;	/* bloomberg_dl_soap.h:344 */
class ns1__RetrieveGetCompanyResponse;	/* bloomberg_dl_soap.h:348 */
class ns1__GetPortfolioValidationResponse;	/* bloomberg_dl_soap.h:352 */
class ns1__SubmitGetActionsResponse;	/* bloomberg_dl_soap.h:356 */
class ns1__RetrieveGetActionsResponse;	/* bloomberg_dl_soap.h:360 */
class ns1__SubmitGetQuotesResponse;	/* bloomberg_dl_soap.h:364 */
class ns1__RetrieveGetQuotesResponse;	/* bloomberg_dl_soap.h:368 */
class ns1__SubmitGetAllQuotesResponse;	/* bloomberg_dl_soap.h:372 */
class ns1__RetrieveGetAllQuotesResponse;	/* bloomberg_dl_soap.h:376 */
class ns1__SubmitOtcbvalUploadResponse;	/* bloomberg_dl_soap.h:380 */
class ns1__RetrieveOtcbvalUploadResponse;	/* bloomberg_dl_soap.h:384 */
class ns1__SubmitOtcBvalDealsUploadResponse;	/* bloomberg_dl_soap.h:388 */
class ns1__RetrieveOtcBvalDealsUploadResponse;	/* bloomberg_dl_soap.h:392 */
class ns1__GetFieldsResponse;	/* bloomberg_dl_soap.h:396 */
class ns1__SubmitMmktBvalDealsUploadResponse;	/* bloomberg_dl_soap.h:402 */
class ns1__RetrieveMmktBvalDealsUploadResponse;	/* bloomberg_dl_soap.h:410 */
struct __ns1__submitGetDataRequest;	/* bloomberg_dl_soap.h:4733 */
struct __ns1__retrieveGetDataResponse;	/* bloomberg_dl_soap.h:4803 */
struct __ns1__submitGetHistoryRequest;	/* bloomberg_dl_soap.h:4873 */
struct __ns1__retrieveGetHistoryResponse;	/* bloomberg_dl_soap.h:4943 */
struct __ns1__submitScheduledRequest;	/* bloomberg_dl_soap.h:5013 */
struct __ns1__retrieveScheduledResponse;	/* bloomberg_dl_soap.h:5083 */
struct __ns1__submitCancelRequest;	/* bloomberg_dl_soap.h:5153 */
struct __ns1__retrieveCancelResponse;	/* bloomberg_dl_soap.h:5223 */
struct __ns1__getCorrections;	/* bloomberg_dl_soap.h:5293 */
struct __ns1__submitGetFundamentalsRequest;	/* bloomberg_dl_soap.h:5363 */
struct __ns1__retrieveGetFundamentalsResponse;	/* bloomberg_dl_soap.h:5433 */
struct __ns1__submitGetCompanyRequest;	/* bloomberg_dl_soap.h:5503 */
struct __ns1__retrieveGetCompanyResponse;	/* bloomberg_dl_soap.h:5573 */
struct __ns1__submitGetActionsRequest;	/* bloomberg_dl_soap.h:5643 */
struct __ns1__retrieveGetActionsResponse;	/* bloomberg_dl_soap.h:5713 */
struct __ns1__getPortfolioValidation;	/* bloomberg_dl_soap.h:5783 */
struct __ns1__submitGetQuotesRequest;	/* bloomberg_dl_soap.h:5853 */
struct __ns1__retrieveGetQuotesResponse;	/* bloomberg_dl_soap.h:5923 */
struct __ns1__submitGetAllQuotesRequest;	/* bloomberg_dl_soap.h:5993 */
struct __ns1__retrieveGetAllQuotesResponse;	/* bloomberg_dl_soap.h:6063 */
struct __ns1__submitOtcbvalUploadRequest;	/* bloomberg_dl_soap.h:6133 */
struct __ns1__retrieveOtcbvalUploadResponse;	/* bloomberg_dl_soap.h:6203 */
struct __ns1__submitOtcBvalDealsUploadRequest;	/* bloomberg_dl_soap.h:6273 */
struct __ns1__retrieveOtcBvalDealsUploadResponse;	/* bloomberg_dl_soap.h:6343 */
struct __ns1__getFields;	/* bloomberg_dl_soap.h:6413 */
struct __ns1__submitMmktBvalDealsUploadRequest;	/* bloomberg_dl_soap.h:6483 */
struct __ns1__retrieveMmktBvalDealsUploadResponse;	/* bloomberg_dl_soap.h:6553 */

/* bloomberg_dl_soap.h:166 */
#ifndef SOAP_TYPE_ns1__CancelHeaders
#define SOAP_TYPE_ns1__CancelHeaders (11)
/* complex XML schema type 'ns1:CancelHeaders': */
class SOAP_CMAC ns1__CancelHeaders {
      public:
        /// Required element 'ns1:programflag' of XML schema type 'ns1:ProgramFlag'
        enum ns1__ProgramFlag programflag;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CancelHeaders
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__CancelHeaders; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CancelHeaders, default initialized and not managed by a soap context
        virtual ns1__CancelHeaders *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__CancelHeaders); }
      public:
        /// Constructor with default initializations
        ns1__CancelHeaders() : programflag(), soap() { }
        virtual ~ns1__CancelHeaders() { }
        /// Friend allocator used by soap_new_ns1__CancelHeaders(struct soap*, int)
        friend SOAP_FMAC1 ns1__CancelHeaders * SOAP_FMAC2 soap_instantiate_ns1__CancelHeaders(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:168 */
#ifndef SOAP_TYPE_ns1__GetCorrectionsHeaders
#define SOAP_TYPE_ns1__GetCorrectionsHeaders (12)
/* complex XML schema type 'ns1:GetCorrectionsHeaders': */
class SOAP_CMAC ns1__GetCorrectionsHeaders {
      public:
        /// Optional element 'ns1:dateformat' of XML schema type 'ns1:DateFormat'
        enum ns1__DateFormat *dateformat;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GetCorrectionsHeaders
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__GetCorrectionsHeaders; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GetCorrectionsHeaders, default initialized and not managed by a soap context
        virtual ns1__GetCorrectionsHeaders *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__GetCorrectionsHeaders); }
      public:
        /// Constructor with default initializations
        ns1__GetCorrectionsHeaders() : dateformat(), soap() { }
        virtual ~ns1__GetCorrectionsHeaders() { }
        /// Friend allocator used by soap_new_ns1__GetCorrectionsHeaders(struct soap*, int)
        friend SOAP_FMAC1 ns1__GetCorrectionsHeaders * SOAP_FMAC2 soap_instantiate_ns1__GetCorrectionsHeaders(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:170 */
#ifndef SOAP_TYPE_ns1__GetDataHeaders
#define SOAP_TYPE_ns1__GetDataHeaders (13)
/* complex XML schema type 'ns1:GetDataHeaders': */
class SOAP_CMAC ns1__GetDataHeaders {
      public:
        /// Optional element 'ns1:closingvalues' of XML schema type 'xsd:boolean'
        bool *closingvalues;
        /// Optional element 'ns1:dateformat' of XML schema type 'ns1:DateFormat'
        enum ns1__DateFormat *dateformat;
        /// Optional element 'ns1:derived' of XML schema type 'xsd:boolean'
        bool *derived;
        /// Optional element 'ns1:diffflag' of XML schema type 'ns1:DiffFlag'
        enum ns1__DiffFlag *diffflag;
        /// Optional element 'ns1:hist_crncy' of XML schema type 'xsd:string'
        std::string *hist_USCOREcrncy;
        /// Optional element 'ns1:historical' of XML schema type 'xsd:boolean'
        bool *historical;
        /// Optional element 'ns1:programflag' of XML schema type 'ns1:ProgramFlag'
        enum ns1__ProgramFlag *programflag;
        /// Optional element 'ns1:rundate' of XML schema type 'xsd:string'
        std::string *rundate;
        /// Optional element 'ns1:secid' of XML schema type 'ns1:InstrumentType'
        enum ns1__InstrumentType *secid;
        /// Optional element 'ns1:secmaster' of XML schema type 'xsd:boolean'
        bool *secmaster;
        /// Optional element 'ns1:sn' of XML schema type 'xsd:int'
        int *sn;
        /// Optional element 'ns1:specialchar' of XML schema type 'ns1:SpecialChar'
        enum ns1__SpecialChar *specialchar;
        /// Optional element 'ns1:time' of XML schema type 'xsd:string'
        std::string *time;
        /// Optional element 'ns1:login' of XML schema type 'xsd:string'
        std::string *login;
        /// Optional element 'ns1:usernumber' of XML schema type 'xsd:int'
        int *usernumber;
        /// Optional element 'ns1:version' of XML schema type 'ns1:Version'
        enum ns1__Version *version;
        /// Optional element 'ns1:ws' of XML schema type 'xsd:int'
        int *ws;
        /// Optional element 'ns1:yellowkey' of XML schema type 'ns1:MarketSector'
        enum ns1__MarketSector *yellowkey;
        /// Optional element 'ns1:quotecomposite' of XML schema type 'xsd:boolean'
        bool *quotecomposite;
        /// Optional element 'ns1:creditrisk' of XML schema type 'xsd:boolean'
        bool *creditrisk;
        /// Optional element 'ns1:quotecompositehist' of XML schema type 'xsd:boolean'
        bool *quotecompositehist;
        /// Optional element 'ns1:exclusive_pricing_src' of XML schema type 'xsd:boolean'
        bool *exclusive_USCOREpricing_USCOREsrc;
        /// Optional element 'ns1:estimates' of XML schema type 'xsd:boolean'
        bool *estimates;
        /// Optional element 'ns1:bvaltier' of XML schema type 'ns1:BvalTier'
        enum ns1__BvalTier *bvaltier;
        /// Optional element 'ns1:bvalsnapshot' of XML schema type 'ns1:BvalSnapshot'
        enum ns1__BvalSnapshot *bvalsnapshot;
        /// Optional element 'ns1:bvalsnapshotdate' of XML schema type 'xsd:string'
        std::string *bvalsnapshotdate;
        /// Optional element 'ns1:bvalbeta' of XML schema type 'xsd:boolean'
        bool *bvalbeta;
        /// Optional element 'ns1:pricing_source' of XML schema type 'xsd:string'
        std::string *pricing_USCOREsource;
        /// Optional element 'ns1:portsecdes' of XML schema type 'ns1:PortSecDes'
        enum ns1__PortSecDes *portsecdes;
        /// Optional element 'ns1:prp' of XML schema type 'xsd:int'
        int *prp;
        /// Optional element 'ns1:fundamentals' of XML schema type 'xsd:boolean'
        bool *fundamentals;
        /// Optional element 'ns1:pricing' of XML schema type 'xsd:boolean'
        bool *pricing;
        /// Optional element 'ns1:skip_pcs' of XML schema type 'xsd:string'
        std::string *skip_USCOREpcs;
        /// Optional element 'ns1:vol_surface' of XML schema type 'xsd:boolean'
        bool *vol_USCOREsurface;
        /// Optional element 'ns1:regssfa' of XML schema type 'xsd:boolean'
        bool *regssfa;
        /// Optional element 'ns1:regfvhl' of XML schema type 'xsd:boolean'
        bool *regfvhl;
        /// Optional element 'ns1:regtransparency' of XML schema type 'xsd:boolean'
        bool *regtransparency;
        /// Optional element 'ns1:regcomp' of XML schema type 'xsd:boolean'
        bool *regcomp;
        /// Optional element 'ns1:corpstruct' of XML schema type 'xsd:boolean'
        bool *corpstruct;
        /// Optional element 'ns1:capstruct' of XML schema type 'xsd:boolean'
        bool *capstruct;
        /// Optional element 'ns1:regsolvency' of XML schema type 'ns1:RegSolvency'
        enum ns1__RegSolvency *regsolvency;
        /// Optional element 'ns1:reghqla' of XML schema type 'xsd:boolean'
        bool *reghqla;
        /// Optional element 'ns1:reghqlaamer' of XML schema type 'xsd:boolean'
        bool *reghqlaamer;
        /// Optional element 'ns1:reghqlaeuro' of XML schema type 'xsd:boolean'
        bool *reghqlaeuro;
        /// Optional element 'ns1:reghqlaasia' of XML schema type 'xsd:boolean'
        bool *reghqlaasia;
        /// Optional element 'ns1:regcbe' of XML schema type 'xsd:boolean'
        bool *regcbe;
        /// Optional element 'ns1:regcfid' of XML schema type 'xsd:boolean'
        bool *regcfid;
        /// Optional element 'ns1:reglqa' of XML schema type 'xsd:boolean'
        bool *reglqa;
        /// Optional element 'ns1:mifir' of XML schema type 'xsd:boolean'
        bool *mifir;
        /// Optional element 'ns1:defaultrisk' of XML schema type 'xsd:boolean'
        bool *defaultrisk;
        /// Optional element 'ns1:ifrs9sppi' of XML schema type 'xsd:boolean'
        bool *ifrs9sppi;
        /// Optional element 'ns1:coltag' of XML schema type 'xsd:boolean'
        bool *coltag;
        /// Optional element 'ns1:uswhldtax' of XML schema type 'xsd:boolean'
        bool *uswhldtax;
        /// Optional element 'ns1:regecl' of XML schema type 'xsd:boolean'
        bool *regecl;
        /// Optional element 'ns1:basictax' of XML schema type 'xsd:boolean'
        bool *basictax;
        /// Optional element 'ns1:invstprot' of XML schema type 'xsd:boolean'
        bool *invstprot;
        /// Optional element 'ns1:encoding' of XML schema type 'xsd:string'
        std::string *encoding;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GetDataHeaders
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__GetDataHeaders; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GetDataHeaders, default initialized and not managed by a soap context
        virtual ns1__GetDataHeaders *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__GetDataHeaders); }
      public:
        /// Constructor with default initializations
        ns1__GetDataHeaders() : closingvalues(), dateformat(), derived(), diffflag(), hist_USCOREcrncy(), historical(), programflag(), rundate(), secid(), secmaster(), sn(), specialchar(), time(), login(), usernumber(), version(), ws(), yellowkey(), quotecomposite(), creditrisk(), quotecompositehist(), exclusive_USCOREpricing_USCOREsrc(), estimates(), bvaltier(), bvalsnapshot(), bvalsnapshotdate(), bvalbeta(), pricing_USCOREsource(), portsecdes(), prp(), fundamentals(), pricing(), skip_USCOREpcs(), vol_USCOREsurface(), regssfa(), regfvhl(), regtransparency(), regcomp(), corpstruct(), capstruct(), regsolvency(), reghqla(), reghqlaamer(), reghqlaeuro(), reghqlaasia(), regcbe(), regcfid(), reglqa(), mifir(), defaultrisk(), ifrs9sppi(), coltag(), uswhldtax(), regecl(), basictax(), invstprot(), encoding(), soap() { }
        virtual ~ns1__GetDataHeaders() { }
        /// Friend allocator used by soap_new_ns1__GetDataHeaders(struct soap*, int)
        friend SOAP_FMAC1 ns1__GetDataHeaders * SOAP_FMAC2 soap_instantiate_ns1__GetDataHeaders(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:172 */
#ifndef SOAP_TYPE_ns1__Period
#define SOAP_TYPE_ns1__Period (14)
/* complex XML schema type 'ns1:Period': */
class SOAP_CMAC ns1__Period {
      public:
        /// Required element 'ns1:start' of XML schema type 'xsd:date'
        std::string start;
        /// Required element 'ns1:end' of XML schema type 'xsd:date'
        std::string end;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Period
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__Period; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Period, default initialized and not managed by a soap context
        virtual ns1__Period *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__Period); }
      public:
        /// Constructor with default initializations
        ns1__Period() : start(), end(), soap() { }
        virtual ~ns1__Period() { }
        /// Friend allocator used by soap_new_ns1__Period(struct soap*, int)
        friend SOAP_FMAC1 ns1__Period * SOAP_FMAC2 soap_instantiate_ns1__Period(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:174 */
#ifndef SOAP_TYPE_ns1__Duration
#define SOAP_TYPE_ns1__Duration (15)
/* complex XML schema type 'ns1:Duration': */
class SOAP_CMAC ns1__Duration {
      public:
        /// Required element 'ns1:days' of XML schema type 'xsd:int'
        int days;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Duration
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__Duration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Duration, default initialized and not managed by a soap context
        virtual ns1__Duration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__Duration); }
      public:
        /// Constructor with default initializations
        ns1__Duration() : days(), soap() { }
        virtual ~ns1__Duration() { }
        /// Friend allocator used by soap_new_ns1__Duration(struct soap*, int)
        friend SOAP_FMAC1 ns1__Duration * SOAP_FMAC2 soap_instantiate_ns1__Duration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:176 */
#ifndef SOAP_TYPE_ns1__DateRange
#define SOAP_TYPE_ns1__DateRange (16)
/* complex XML schema type 'ns1:DateRange': */
class SOAP_CMAC ns1__DateRange {
      public:
        /// Optional element 'ns1:period' of XML schema type 'ns1:Period'
        ns1__Period *period;
        /// Optional element 'ns1:duration' of XML schema type 'ns1:Duration'
        ns1__Duration *duration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DateRange
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__DateRange; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DateRange, default initialized and not managed by a soap context
        virtual ns1__DateRange *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__DateRange); }
      public:
        /// Constructor with default initializations
        ns1__DateRange() : period(), duration(), soap() { }
        virtual ~ns1__DateRange() { }
        /// Friend allocator used by soap_new_ns1__DateRange(struct soap*, int)
        friend SOAP_FMAC1 ns1__DateRange * SOAP_FMAC2 soap_instantiate_ns1__DateRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:178 */
#ifndef SOAP_TYPE_ns1__GetHistoryHeaders
#define SOAP_TYPE_ns1__GetHistoryHeaders (17)
/* complex XML schema type 'ns1:GetHistoryHeaders': */
class SOAP_CMAC ns1__GetHistoryHeaders {
      public:
        /// Optional element 'ns1:daterange' of XML schema type 'ns1:DateRange'
        ns1__DateRange *daterange;
        /// Optional element 'ns1:hist_crncy' of XML schema type 'xsd:string'
        std::string *hist_USCOREcrncy;
        /// Optional element 'ns1:hist_period' of XML schema type 'ns1:HistPeriod'
        enum ns1__HistPeriod *hist_USCOREperiod;
        /// Optional element 'ns1:hist_option' of XML schema type 'ns1:HistOption'
        enum ns1__HistOption *hist_USCOREoption;
        /// Optional element 'ns1:programflag' of XML schema type 'ns1:ProgramFlag'
        enum ns1__ProgramFlag *programflag;
        /// Optional element 'ns1:pricing_source' of XML schema type 'xsd:string'
        std::string *pricing_USCOREsource;
        /// Optional element 'ns1:display_pricing_src' of XML schema type 'xsd:boolean'
        bool *display_USCOREpricing_USCOREsrc;
        /// Optional element 'ns1:rundate' of XML schema type 'xsd:string'
        std::string *rundate;
        /// Optional element 'ns1:time' of XML schema type 'xsd:string'
        std::string *time;
        /// Optional element 'ns1:secid' of XML schema type 'ns1:InstrumentType'
        enum ns1__InstrumentType *secid;
        /// Optional element 'ns1:sn' of XML schema type 'xsd:int'
        int *sn;
        /// Optional element 'ns1:login' of XML schema type 'xsd:string'
        std::string *login;
        /// Optional element 'ns1:usernumber' of XML schema type 'xsd:int'
        int *usernumber;
        /// Optional element 'ns1:version' of XML schema type 'ns1:Version'
        enum ns1__Version *version;
        /// Optional element 'ns1:ws' of XML schema type 'xsd:int'
        int *ws;
        /// Optional element 'ns1:yellowkey' of XML schema type 'ns1:MarketSector'
        enum ns1__MarketSector *yellowkey;
        /// Optional element 'ns1:portsecdes' of XML schema type 'ns1:PortSecDes'
        enum ns1__PortSecDes *portsecdes;
        /// Optional element 'ns1:prp' of XML schema type 'xsd:int'
        int *prp;
        /// Optional element 'ns1:exclusive_pricing_src' of XML schema type 'xsd:boolean'
        bool *exclusive_USCOREpricing_USCOREsrc;
        /// Optional element 'ns1:bvalbeta' of XML schema type 'xsd:boolean'
        bool *bvalbeta;
        /// Optional element 'ns1:regfvhl' of XML schema type 'xsd:boolean'
        bool *regfvhl;
        /// Optional element 'ns1:regtransparency' of XML schema type 'xsd:boolean'
        bool *regtransparency;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GetHistoryHeaders
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__GetHistoryHeaders; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GetHistoryHeaders, default initialized and not managed by a soap context
        virtual ns1__GetHistoryHeaders *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__GetHistoryHeaders); }
      public:
        /// Constructor with default initializations
        ns1__GetHistoryHeaders() : daterange(), hist_USCOREcrncy(), hist_USCOREperiod(), hist_USCOREoption(), programflag(), pricing_USCOREsource(), display_USCOREpricing_USCOREsrc(), rundate(), time(), secid(), sn(), login(), usernumber(), version(), ws(), yellowkey(), portsecdes(), prp(), exclusive_USCOREpricing_USCOREsrc(), bvalbeta(), regfvhl(), regtransparency(), soap() { }
        virtual ~ns1__GetHistoryHeaders() { }
        /// Friend allocator used by soap_new_ns1__GetHistoryHeaders(struct soap*, int)
        friend SOAP_FMAC1 ns1__GetHistoryHeaders * SOAP_FMAC2 soap_instantiate_ns1__GetHistoryHeaders(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:180 */
#ifndef SOAP_TYPE_ns1__GetFundamentalsHeaders
#define SOAP_TYPE_ns1__GetFundamentalsHeaders (18)
/* complex XML schema type 'ns1:GetFundamentalsHeaders': */
class SOAP_CMAC ns1__GetFundamentalsHeaders {
      public:
        /// Optional element 'ns1:filingstatus' of XML schema type 'ns1:FilingStatus'
        enum ns1__FilingStatus *filingstatus;
        /// Optional element 'ns1:currency' of XML schema type 'xsd:string'
        std::string *currency;
        /// Required element 'ns1:daterange' of XML schema type 'ns1:DateRange'
        ns1__DateRange *daterange;
        /// Optional element 'ns1:periodicity' of XML schema type 'ns1:Periodicity'
        enum ns1__Periodicity *periodicity;
        /// Optional element 'ns1:consolidated' of XML schema type 'xsd:boolean'
        bool *consolidated;
        /// Optional element 'ns1:adjusted' of XML schema type 'xsd:boolean'
        bool *adjusted;
        /// Optional element 'ns1:programflag' of XML schema type 'ns1:ProgramFlag'
        enum ns1__ProgramFlag *programflag;
        /// Optional element 'ns1:rundate' of XML schema type 'xsd:string'
        std::string *rundate;
        /// Optional element 'ns1:time' of XML schema type 'xsd:string'
        std::string *time;
        /// Optional element 'ns1:secid' of XML schema type 'ns1:InstrumentType'
        enum ns1__InstrumentType *secid;
        /// Optional element 'ns1:sn' of XML schema type 'xsd:int'
        int *sn;
        /// Optional element 'ns1:usernumber' of XML schema type 'xsd:int'
        int *usernumber;
        /// Optional element 'ns1:version' of XML schema type 'ns1:Version'
        enum ns1__Version *version;
        /// Optional element 'ns1:ws' of XML schema type 'xsd:int'
        int *ws;
        /// Optional element 'ns1:yellowkey' of XML schema type 'ns1:MarketSector'
        enum ns1__MarketSector *yellowkey;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GetFundamentalsHeaders
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__GetFundamentalsHeaders; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GetFundamentalsHeaders, default initialized and not managed by a soap context
        virtual ns1__GetFundamentalsHeaders *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__GetFundamentalsHeaders); }
      public:
        /// Constructor with default initializations
        ns1__GetFundamentalsHeaders() : filingstatus(), currency(), daterange(), periodicity(), consolidated(), adjusted(), programflag(), rundate(), time(), secid(), sn(), usernumber(), version(), ws(), yellowkey(), soap() { }
        virtual ~ns1__GetFundamentalsHeaders() { }
        /// Friend allocator used by soap_new_ns1__GetFundamentalsHeaders(struct soap*, int)
        friend SOAP_FMAC1 ns1__GetFundamentalsHeaders * SOAP_FMAC2 soap_instantiate_ns1__GetFundamentalsHeaders(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:182 */
#ifndef SOAP_TYPE_ns1__GetCompanyHeaders
#define SOAP_TYPE_ns1__GetCompanyHeaders (19)
/* complex XML schema type 'ns1:GetCompanyHeaders': */
class SOAP_CMAC ns1__GetCompanyHeaders {
      public:
        /// Required element 'ns1:creditrisk' of XML schema type 'xsd:boolean'
        bool creditrisk;
        /// Optional element 'ns1:dateformat' of XML schema type 'ns1:DateFormat'
        enum ns1__DateFormat *dateformat;
        /// Optional element 'ns1:programflag' of XML schema type 'ns1:ProgramFlag'
        enum ns1__ProgramFlag *programflag;
        /// Optional element 'ns1:rundate' of XML schema type 'xsd:string'
        std::string *rundate;
        /// Optional element 'ns1:secid' of XML schema type 'ns1:InstrumentType'
        enum ns1__InstrumentType *secid;
        /// Optional element 'ns1:sn' of XML schema type 'xsd:int'
        int *sn;
        /// Optional element 'ns1:specialchar' of XML schema type 'ns1:SpecialChar'
        enum ns1__SpecialChar *specialchar;
        /// Optional element 'ns1:time' of XML schema type 'xsd:string'
        std::string *time;
        /// Optional element 'ns1:usernumber' of XML schema type 'xsd:int'
        int *usernumber;
        /// Optional element 'ns1:version' of XML schema type 'ns1:Version'
        enum ns1__Version *version;
        /// Optional element 'ns1:ws' of XML schema type 'xsd:int'
        int *ws;
        /// Optional element 'ns1:yellowkey' of XML schema type 'ns1:MarketSector'
        enum ns1__MarketSector *yellowkey;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GetCompanyHeaders
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__GetCompanyHeaders; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GetCompanyHeaders, default initialized and not managed by a soap context
        virtual ns1__GetCompanyHeaders *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__GetCompanyHeaders); }
      public:
        /// Constructor with default initializations
        ns1__GetCompanyHeaders() : creditrisk(), dateformat(), programflag(), rundate(), secid(), sn(), specialchar(), time(), usernumber(), version(), ws(), yellowkey(), soap() { }
        virtual ~ns1__GetCompanyHeaders() { }
        /// Friend allocator used by soap_new_ns1__GetCompanyHeaders(struct soap*, int)
        friend SOAP_FMAC1 ns1__GetCompanyHeaders * SOAP_FMAC2 soap_instantiate_ns1__GetCompanyHeaders(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:184 */
#ifndef SOAP_TYPE_ns1__GetActionsHeaders
#define SOAP_TYPE_ns1__GetActionsHeaders (20)
/* complex XML schema type 'ns1:GetActionsHeaders': */
class SOAP_CMAC ns1__GetActionsHeaders {
      public:
        /// Optional element 'ns1:actions' of XML schema type 'ns1:Actions'
        ns1__Actions *actions;
        /// Optional element 'ns1:actions_date' of XML schema type 'ns1:ActionsDate'
        enum ns1__ActionsDate *actions_USCOREdate;
        /// Optional element 'ns1:daterange' of XML schema type 'ns1:DateRange'
        ns1__DateRange *daterange;
        /// Optional element 'ns1:dateformat' of XML schema type 'ns1:DateFormat'
        enum ns1__DateFormat *dateformat;
        /// Optional element 'ns1:programflag' of XML schema type 'ns1:ProgramFlag'
        enum ns1__ProgramFlag *programflag;
        /// Optional element 'ns1:rundate' of XML schema type 'xsd:string'
        std::string *rundate;
        /// Optional element 'ns1:time' of XML schema type 'xsd:string'
        std::string *time;
        /// Optional element 'ns1:secid' of XML schema type 'ns1:InstrumentType'
        enum ns1__InstrumentType *secid;
        /// Optional element 'ns1:sn' of XML schema type 'xsd:int'
        int *sn;
        /// Optional element 'ns1:usernumber' of XML schema type 'xsd:int'
        int *usernumber;
        /// Optional element 'ns1:version' of XML schema type 'ns1:Version'
        enum ns1__Version *version;
        /// Optional element 'ns1:ws' of XML schema type 'xsd:int'
        int *ws;
        /// Optional element 'ns1:yellowkey' of XML schema type 'ns1:MarketSector'
        enum ns1__MarketSector *yellowkey;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GetActionsHeaders
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__GetActionsHeaders; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GetActionsHeaders, default initialized and not managed by a soap context
        virtual ns1__GetActionsHeaders *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__GetActionsHeaders); }
      public:
        /// Constructor with default initializations
        ns1__GetActionsHeaders() : actions(), actions_USCOREdate(), daterange(), dateformat(), programflag(), rundate(), time(), secid(), sn(), usernumber(), version(), ws(), yellowkey(), soap() { }
        virtual ~ns1__GetActionsHeaders() { }
        /// Friend allocator used by soap_new_ns1__GetActionsHeaders(struct soap*, int)
        friend SOAP_FMAC1 ns1__GetActionsHeaders * SOAP_FMAC2 soap_instantiate_ns1__GetActionsHeaders(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:186 */
#ifndef SOAP_TYPE_ns1__GetPortfolioValidationHeaders
#define SOAP_TYPE_ns1__GetPortfolioValidationHeaders (21)
/* complex XML schema type 'ns1:GetPortfolioValidationHeaders': */
class SOAP_CMAC ns1__GetPortfolioValidationHeaders {
      public:
        /// Optional element 'ns1:closingvalues' of XML schema type 'xsd:boolean'
        bool *closingvalues;
        /// Optional element 'ns1:dateformat' of XML schema type 'ns1:DateFormat'
        enum ns1__DateFormat *dateformat;
        /// Optional element 'ns1:derived' of XML schema type 'xsd:boolean'
        bool *derived;
        /// Optional element 'ns1:diffflag' of XML schema type 'ns1:DiffFlag'
        enum ns1__DiffFlag *diffflag;
        /// Optional element 'ns1:hist_crncy' of XML schema type 'xsd:string'
        std::string *hist_USCOREcrncy;
        /// Optional element 'ns1:historical' of XML schema type 'xsd:boolean'
        bool *historical;
        /// Optional element 'ns1:programflag' of XML schema type 'ns1:ProgramFlag'
        enum ns1__ProgramFlag *programflag;
        /// Optional element 'ns1:rundate' of XML schema type 'xsd:string'
        std::string *rundate;
        /// Optional element 'ns1:secid' of XML schema type 'ns1:InstrumentType'
        enum ns1__InstrumentType *secid;
        /// Optional element 'ns1:secmaster' of XML schema type 'xsd:boolean'
        bool *secmaster;
        /// Optional element 'ns1:sn' of XML schema type 'xsd:int'
        int *sn;
        /// Optional element 'ns1:specialchar' of XML schema type 'ns1:SpecialChar'
        enum ns1__SpecialChar *specialchar;
        /// Optional element 'ns1:time' of XML schema type 'xsd:string'
        std::string *time;
        /// Optional element 'ns1:login' of XML schema type 'xsd:string'
        std::string *login;
        /// Optional element 'ns1:usernumber' of XML schema type 'xsd:int'
        int *usernumber;
        /// Optional element 'ns1:version' of XML schema type 'ns1:Version'
        enum ns1__Version *version;
        /// Optional element 'ns1:ws' of XML schema type 'xsd:int'
        int *ws;
        /// Optional element 'ns1:yellowkey' of XML schema type 'ns1:MarketSector'
        enum ns1__MarketSector *yellowkey;
        /// Optional element 'ns1:exclusive_pricing_src' of XML schema type 'xsd:boolean'
        bool *exclusive_USCOREpricing_USCOREsrc;
        /// Optional element 'ns1:bvaltier' of XML schema type 'ns1:BvalTier'
        enum ns1__BvalTier *bvaltier;
        /// Optional element 'ns1:bvalsnapshot' of XML schema type 'ns1:BvalSnapshot'
        enum ns1__BvalSnapshot *bvalsnapshot;
        /// Optional element 'ns1:bvalsnapshotdate' of XML schema type 'xsd:string'
        std::string *bvalsnapshotdate;
        /// Optional element 'ns1:bvalbeta' of XML schema type 'xsd:boolean'
        bool *bvalbeta;
        /// Optional element 'ns1:pricing_source' of XML schema type 'xsd:string'
        std::string *pricing_USCOREsource;
        /// Optional element 'ns1:portsecdes' of XML schema type 'ns1:PortSecDes'
        enum ns1__PortSecDes *portsecdes;
        /// Optional element 'ns1:prp' of XML schema type 'xsd:int'
        int *prp;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GetPortfolioValidationHeaders
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__GetPortfolioValidationHeaders; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GetPortfolioValidationHeaders, default initialized and not managed by a soap context
        virtual ns1__GetPortfolioValidationHeaders *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__GetPortfolioValidationHeaders); }
      public:
        /// Constructor with default initializations
        ns1__GetPortfolioValidationHeaders() : closingvalues(), dateformat(), derived(), diffflag(), hist_USCOREcrncy(), historical(), programflag(), rundate(), secid(), secmaster(), sn(), specialchar(), time(), login(), usernumber(), version(), ws(), yellowkey(), exclusive_USCOREpricing_USCOREsrc(), bvaltier(), bvalsnapshot(), bvalsnapshotdate(), bvalbeta(), pricing_USCOREsource(), portsecdes(), prp(), soap() { }
        virtual ~ns1__GetPortfolioValidationHeaders() { }
        /// Friend allocator used by soap_new_ns1__GetPortfolioValidationHeaders(struct soap*, int)
        friend SOAP_FMAC1 ns1__GetPortfolioValidationHeaders * SOAP_FMAC2 soap_instantiate_ns1__GetPortfolioValidationHeaders(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:188 */
#ifndef SOAP_TYPE_ns1__QuotesHeaders
#define SOAP_TYPE_ns1__QuotesHeaders (22)
/* complex XML schema type 'ns1:QuotesHeaders': */
class SOAP_CMAC ns1__QuotesHeaders {
      public:
        /// Optional element 'ns1:daterange' of XML schema type 'ns1:DateRange'
        ns1__DateRange *daterange;
        /// Optional element 'ns1:datetimerange' of XML schema type 'ns1:DateTimeRange'
        ns1__DateTimeRange *datetimerange;
        /// Optional element 'ns1:displayqrmdate' of XML schema type 'xsd:boolean'
        bool *displayqrmdate;
        /// Optional element 'ns1:login' of XML schema type 'xsd:string'
        std::string *login;
        /// Optional element 'ns1:portsecdes' of XML schema type 'ns1:PortSecDes'
        enum ns1__PortSecDes *portsecdes;
        /// Optional element 'ns1:pricing_source' of XML schema type 'xsd:string'
        std::string *pricing_USCOREsource;
        /// Optional element 'ns1:programflag' of XML schema type 'ns1:ProgramFlag'
        enum ns1__ProgramFlag *programflag;
        /// Optional element 'ns1:prp' of XML schema type 'xsd:int'
        int *prp;
        /// Optional element 'ns1:rundate' of XML schema type 'xsd:string'
        std::string *rundate;
        /// Optional element 'ns1:secid' of XML schema type 'ns1:InstrumentType'
        enum ns1__InstrumentType *secid;
        /// Optional element 'ns1:sn' of XML schema type 'xsd:int'
        int *sn;
        /// Optional element 'ns1:tickexchlength' of XML schema type 'xsd:int'
        int *tickexchlength;
        /// Optional element 'ns1:ticklocaltz' of XML schema type 'xsd:boolean'
        bool *ticklocaltz;
        /// Optional element 'ns1:tickoutputtz' of XML schema type 'ns1:TickOutputTz'
        ns1__TickOutputTz *tickoutputtz;
        /// Optional element 'ns1:time' of XML schema type 'xsd:string'
        std::string *time;
        /// Optional element 'ns1:usernumber' of XML schema type 'xsd:int'
        int *usernumber;
        /// Optional element 'ns1:version' of XML schema type 'ns1:Version'
        enum ns1__Version *version;
        /// Optional element 'ns1:ws' of XML schema type 'xsd:int'
        int *ws;
        /// Optional element 'ns1:yellowkey' of XML schema type 'ns1:MarketSector'
        enum ns1__MarketSector *yellowkey;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__QuotesHeaders
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__QuotesHeaders; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__QuotesHeaders, default initialized and not managed by a soap context
        virtual ns1__QuotesHeaders *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__QuotesHeaders); }
      public:
        /// Constructor with default initializations
        ns1__QuotesHeaders() : daterange(), datetimerange(), displayqrmdate(), login(), portsecdes(), pricing_USCOREsource(), programflag(), prp(), rundate(), secid(), sn(), tickexchlength(), ticklocaltz(), tickoutputtz(), time(), usernumber(), version(), ws(), yellowkey(), soap() { }
        virtual ~ns1__QuotesHeaders() { }
        /// Friend allocator used by soap_new_ns1__QuotesHeaders(struct soap*, int)
        friend SOAP_FMAC1 ns1__QuotesHeaders * SOAP_FMAC2 soap_instantiate_ns1__QuotesHeaders(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:190 */
#ifndef SOAP_TYPE_ns1__DateTimeRange
#define SOAP_TYPE_ns1__DateTimeRange (23)
/* complex XML schema type 'ns1:DateTimeRange': */
class SOAP_CMAC ns1__DateTimeRange {
      public:
        /// Required element 'ns1:startDateTime' of XML schema type 'xsd:dateTime'
        time_t startDateTime;
        /// Required element 'ns1:endDateTime' of XML schema type 'xsd:dateTime'
        time_t endDateTime;
        /// Required element 'ns1:region' of XML schema type 'xsd:string'
        std::string region;
        /// Optional element 'ns1:dst' of XML schema type 'xsd:boolean'
        bool *dst;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DateTimeRange
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__DateTimeRange; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DateTimeRange, default initialized and not managed by a soap context
        virtual ns1__DateTimeRange *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__DateTimeRange); }
      public:
        /// Constructor with default initializations
        ns1__DateTimeRange() : startDateTime(), endDateTime(), region(), dst(), soap() { }
        virtual ~ns1__DateTimeRange() { }
        /// Friend allocator used by soap_new_ns1__DateTimeRange(struct soap*, int)
        friend SOAP_FMAC1 ns1__DateTimeRange * SOAP_FMAC2 soap_instantiate_ns1__DateTimeRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:192 */
#ifndef SOAP_TYPE_ns1__TickOutputTz
#define SOAP_TYPE_ns1__TickOutputTz (24)
/* complex XML schema type 'ns1:TickOutputTz': */
class SOAP_CMAC ns1__TickOutputTz {
      public:
        /// Required element 'ns1:timezone' of XML schema type 'xsd:string'
        std::string timezone;
        /// Optional element 'ns1:dst' of XML schema type 'xsd:boolean'
        bool *dst;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__TickOutputTz
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__TickOutputTz; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__TickOutputTz, default initialized and not managed by a soap context
        virtual ns1__TickOutputTz *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__TickOutputTz); }
      public:
        /// Constructor with default initializations
        ns1__TickOutputTz() : timezone(), dst(), soap() { }
        virtual ~ns1__TickOutputTz() { }
        /// Friend allocator used by soap_new_ns1__TickOutputTz(struct soap*, int)
        friend SOAP_FMAC1 ns1__TickOutputTz * SOAP_FMAC2 soap_instantiate_ns1__TickOutputTz(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:194 */
#ifndef SOAP_TYPE_ns1__FieldSets
#define SOAP_TYPE_ns1__FieldSets (25)
/* complex XML schema type 'ns1:FieldSets': */
class SOAP_CMAC ns1__FieldSets {
      public:
        /// Required element 'ns1:fieldset' of XML schema type 'ns1:FieldSet'
        std::vector<ns1__FieldSet *> fieldset;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__FieldSets
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__FieldSets; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__FieldSets, default initialized and not managed by a soap context
        virtual ns1__FieldSets *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__FieldSets); }
      public:
        /// Constructor with default initializations
        ns1__FieldSets() : fieldset(), soap() { }
        virtual ~ns1__FieldSets() { }
        /// Friend allocator used by soap_new_ns1__FieldSets(struct soap*, int)
        friend SOAP_FMAC1 ns1__FieldSets * SOAP_FMAC2 soap_instantiate_ns1__FieldSets(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:196 */
#ifndef SOAP_TYPE_ns1__FieldSet
#define SOAP_TYPE_ns1__FieldSet (26)
/* complex XML schema type 'ns1:FieldSet': */
class SOAP_CMAC ns1__FieldSet {
      public:
        /// Required element 'ns1:fieldmacro' of XML schema type 'ns1:FieldMacro'
        enum ns1__FieldMacro fieldmacro;
        /// Optional element 'ns1:date' of XML schema type 'xsd:date'
        std::string *date;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__FieldSet
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__FieldSet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__FieldSet, default initialized and not managed by a soap context
        virtual ns1__FieldSet *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__FieldSet); }
      public:
        /// Constructor with default initializations
        ns1__FieldSet() : fieldmacro(), date(), soap() { }
        virtual ~ns1__FieldSet() { }
        /// Friend allocator used by soap_new_ns1__FieldSet(struct soap*, int)
        friend SOAP_FMAC1 ns1__FieldSet * SOAP_FMAC2 soap_instantiate_ns1__FieldSet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:198 */
#ifndef SOAP_TYPE_ns1__BvalFieldSets
#define SOAP_TYPE_ns1__BvalFieldSets (27)
/* complex XML schema type 'ns1:BvalFieldSets': */
class SOAP_CMAC ns1__BvalFieldSets {
      public:
        /// Required element 'ns1:fieldset' of XML schema type 'ns1:BvalFieldSet'
        std::vector<ns1__BvalFieldSet *> fieldset;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__BvalFieldSets
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__BvalFieldSets; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__BvalFieldSets, default initialized and not managed by a soap context
        virtual ns1__BvalFieldSets *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__BvalFieldSets); }
      public:
        /// Constructor with default initializations
        ns1__BvalFieldSets() : fieldset(), soap() { }
        virtual ~ns1__BvalFieldSets() { }
        /// Friend allocator used by soap_new_ns1__BvalFieldSets(struct soap*, int)
        friend SOAP_FMAC1 ns1__BvalFieldSets * SOAP_FMAC2 soap_instantiate_ns1__BvalFieldSets(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:200 */
#ifndef SOAP_TYPE_ns1__BvalFieldSet
#define SOAP_TYPE_ns1__BvalFieldSet (28)
/* complex XML schema type 'ns1:BvalFieldSet': */
class SOAP_CMAC ns1__BvalFieldSet {
      public:
        /// Required element 'ns1:fieldmacro' of XML schema type 'ns1:BvalFieldMacro'
        enum ns1__BvalFieldMacro fieldmacro;
        /// Optional element 'ns1:date' of XML schema type 'xsd:date'
        std::string *date;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__BvalFieldSet
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__BvalFieldSet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__BvalFieldSet, default initialized and not managed by a soap context
        virtual ns1__BvalFieldSet *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__BvalFieldSet); }
      public:
        /// Constructor with default initializations
        ns1__BvalFieldSet() : fieldmacro(), date(), soap() { }
        virtual ~ns1__BvalFieldSet() { }
        /// Friend allocator used by soap_new_ns1__BvalFieldSet(struct soap*, int)
        friend SOAP_FMAC1 ns1__BvalFieldSet * SOAP_FMAC2 soap_instantiate_ns1__BvalFieldSet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:202 */
#ifndef SOAP_TYPE_ns1__ScheduledHeaders
#define SOAP_TYPE_ns1__ScheduledHeaders (29)
/* complex XML schema type 'ns1:ScheduledHeaders': */
class SOAP_CMAC ns1__ScheduledHeaders {
      public:
        /// Optional element 'ns1:getdataHeaders' of XML schema type 'ns1:GetDataHeaders'
        ns1__GetDataHeaders *getdataHeaders;
        /// Optional element 'ns1:gethistoryHeaders' of XML schema type 'ns1:GetHistoryHeaders'
        ns1__GetHistoryHeaders *gethistoryHeaders;
        /// Optional element 'ns1:getfundamentalsHeaders' of XML schema type 'ns1:GetFundamentalsHeaders'
        ns1__GetFundamentalsHeaders *getfundamentalsHeaders;
        /// Optional element 'ns1:getcompanyHeaders' of XML schema type 'ns1:GetCompanyHeaders'
        ns1__GetCompanyHeaders *getcompanyHeaders;
        /// Optional element 'ns1:getactionsHeaders' of XML schema type 'ns1:GetActionsHeaders'
        ns1__GetActionsHeaders *getactionsHeaders;
        /// Optional element 'ns1:getquotesHeaders' of XML schema type 'ns1:QuotesHeaders'
        ns1__QuotesHeaders *getquotesHeaders;
        /// Optional element 'ns1:getallquotesHeaders' of XML schema type 'ns1:QuotesHeaders'
        ns1__QuotesHeaders *getallquotesHeaders;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ScheduledHeaders
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ScheduledHeaders; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ScheduledHeaders, default initialized and not managed by a soap context
        virtual ns1__ScheduledHeaders *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ScheduledHeaders); }
      public:
        /// Constructor with default initializations
        ns1__ScheduledHeaders() : getdataHeaders(), gethistoryHeaders(), getfundamentalsHeaders(), getcompanyHeaders(), getactionsHeaders(), getquotesHeaders(), getallquotesHeaders(), soap() { }
        virtual ~ns1__ScheduledHeaders() { }
        /// Friend allocator used by soap_new_ns1__ScheduledHeaders(struct soap*, int)
        friend SOAP_FMAC1 ns1__ScheduledHeaders * SOAP_FMAC2 soap_instantiate_ns1__ScheduledHeaders(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:204 */
#ifndef SOAP_TYPE_ns1__Fields
#define SOAP_TYPE_ns1__Fields (30)
/* complex XML schema type 'ns1:Fields': */
class SOAP_CMAC ns1__Fields {
      public:
        /// Required element 'ns1:field' of XML schema type 'xsd:string'
        std::vector<std::string> field;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Fields
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__Fields; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Fields, default initialized and not managed by a soap context
        virtual ns1__Fields *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__Fields); }
      public:
        /// Constructor with default initializations
        ns1__Fields() : field(), soap() { }
        virtual ~ns1__Fields() { }
        /// Friend allocator used by soap_new_ns1__Fields(struct soap*, int)
        friend SOAP_FMAC1 ns1__Fields * SOAP_FMAC2 soap_instantiate_ns1__Fields(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:206 */
#ifndef SOAP_TYPE_ns1__Overrides
#define SOAP_TYPE_ns1__Overrides (31)
/* complex XML schema type 'ns1:Overrides': */
class SOAP_CMAC ns1__Overrides {
      public:
        /// Optional element 'ns1:override' of XML schema type 'ns1:Override'
        std::vector<ns1__Override *> override_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Overrides
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__Overrides; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Overrides, default initialized and not managed by a soap context
        virtual ns1__Overrides *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__Overrides); }
      public:
        /// Constructor with default initializations
        ns1__Overrides() : override_(), soap() { }
        virtual ~ns1__Overrides() { }
        /// Friend allocator used by soap_new_ns1__Overrides(struct soap*, int)
        friend SOAP_FMAC1 ns1__Overrides * SOAP_FMAC2 soap_instantiate_ns1__Overrides(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:208 */
#ifndef SOAP_TYPE_ns1__Instruments
#define SOAP_TYPE_ns1__Instruments (32)
/* complex XML schema type 'ns1:Instruments': */
class SOAP_CMAC ns1__Instruments {
      public:
        /// Optional element 'ns1:instrument' of XML schema type 'ns1:Instrument'
        std::vector<ns1__Instrument *> instrument;
        /// Optional element 'ns1:macro' of XML schema type 'ns1:Macro'
        std::vector<ns1__Macro *> macro;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Instruments
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__Instruments; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Instruments, default initialized and not managed by a soap context
        virtual ns1__Instruments *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__Instruments); }
      public:
        /// Constructor with default initializations
        ns1__Instruments() : instrument(), macro(), soap() { }
        virtual ~ns1__Instruments() { }
        /// Friend allocator used by soap_new_ns1__Instruments(struct soap*, int)
        friend SOAP_FMAC1 ns1__Instruments * SOAP_FMAC2 soap_instantiate_ns1__Instruments(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:210 */
#ifndef SOAP_TYPE_ns1__FundInstruments
#define SOAP_TYPE_ns1__FundInstruments (33)
/* complex XML schema type 'ns1:FundInstruments': */
class SOAP_CMAC ns1__FundInstruments {
      public:
        /// Optional element 'ns1:instrument' of XML schema type 'ns1:FundInstrument'
        std::vector<ns1__FundInstrument *> instrument;
        /// Optional element 'ns1:macro' of XML schema type 'ns1:Macro'
        std::vector<ns1__Macro *> macro;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__FundInstruments
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__FundInstruments; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__FundInstruments, default initialized and not managed by a soap context
        virtual ns1__FundInstruments *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__FundInstruments); }
      public:
        /// Constructor with default initializations
        ns1__FundInstruments() : instrument(), macro(), soap() { }
        virtual ~ns1__FundInstruments() { }
        /// Friend allocator used by soap_new_ns1__FundInstruments(struct soap*, int)
        friend SOAP_FMAC1 ns1__FundInstruments * SOAP_FMAC2 soap_instantiate_ns1__FundInstruments(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:212 */
#ifndef SOAP_TYPE_ns1__InstrumentDatas
#define SOAP_TYPE_ns1__InstrumentDatas (34)
/* complex XML schema type 'ns1:InstrumentDatas': */
class SOAP_CMAC ns1__InstrumentDatas {
      public:
        /// Optional element 'ns1:instrumentData' of XML schema type 'ns1:InstrumentData'
        std::vector<ns1__InstrumentData *> instrumentData;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__InstrumentDatas
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__InstrumentDatas; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__InstrumentDatas, default initialized and not managed by a soap context
        virtual ns1__InstrumentDatas *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__InstrumentDatas); }
      public:
        /// Constructor with default initializations
        ns1__InstrumentDatas() : instrumentData(), soap() { }
        virtual ~ns1__InstrumentDatas() { }
        /// Friend allocator used by soap_new_ns1__InstrumentDatas(struct soap*, int)
        friend SOAP_FMAC1 ns1__InstrumentDatas * SOAP_FMAC2 soap_instantiate_ns1__InstrumentDatas(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:214 */
#ifndef SOAP_TYPE_ns1__HistInstrumentDatas
#define SOAP_TYPE_ns1__HistInstrumentDatas (35)
/* complex XML schema type 'ns1:HistInstrumentDatas': */
class SOAP_CMAC ns1__HistInstrumentDatas {
      public:
        /// Optional element 'ns1:instrumentData' of XML schema type 'ns1:HistInstrumentData'
        std::vector<ns1__HistInstrumentData *> instrumentData;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__HistInstrumentDatas
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__HistInstrumentDatas; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__HistInstrumentDatas, default initialized and not managed by a soap context
        virtual ns1__HistInstrumentDatas *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__HistInstrumentDatas); }
      public:
        /// Constructor with default initializations
        ns1__HistInstrumentDatas() : instrumentData(), soap() { }
        virtual ~ns1__HistInstrumentDatas() { }
        /// Friend allocator used by soap_new_ns1__HistInstrumentDatas(struct soap*, int)
        friend SOAP_FMAC1 ns1__HistInstrumentDatas * SOAP_FMAC2 soap_instantiate_ns1__HistInstrumentDatas(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:216 */
#ifndef SOAP_TYPE_ns1__FundInstrumentDatas
#define SOAP_TYPE_ns1__FundInstrumentDatas (36)
/* complex XML schema type 'ns1:FundInstrumentDatas': */
class SOAP_CMAC ns1__FundInstrumentDatas {
      public:
        /// Optional element 'ns1:instrumentData' of XML schema type 'ns1:FundInstrumentData'
        std::vector<ns1__FundInstrumentData *> instrumentData;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__FundInstrumentDatas
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__FundInstrumentDatas; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__FundInstrumentDatas, default initialized and not managed by a soap context
        virtual ns1__FundInstrumentDatas *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__FundInstrumentDatas); }
      public:
        /// Constructor with default initializations
        ns1__FundInstrumentDatas() : instrumentData(), soap() { }
        virtual ~ns1__FundInstrumentDatas() { }
        /// Friend allocator used by soap_new_ns1__FundInstrumentDatas(struct soap*, int)
        friend SOAP_FMAC1 ns1__FundInstrumentDatas * SOAP_FMAC2 soap_instantiate_ns1__FundInstrumentDatas(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:218 */
#ifndef SOAP_TYPE_ns1__ActionsInstrumentDatas
#define SOAP_TYPE_ns1__ActionsInstrumentDatas (37)
/* complex XML schema type 'ns1:ActionsInstrumentDatas': */
class SOAP_CMAC ns1__ActionsInstrumentDatas {
      public:
        /// Optional element 'ns1:instrumentData' of XML schema type 'ns1:ActionsInstrumentData'
        std::vector<ns1__ActionsInstrumentData *> instrumentData;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ActionsInstrumentDatas
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ActionsInstrumentDatas; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ActionsInstrumentDatas, default initialized and not managed by a soap context
        virtual ns1__ActionsInstrumentDatas *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ActionsInstrumentDatas); }
      public:
        /// Constructor with default initializations
        ns1__ActionsInstrumentDatas() : instrumentData(), soap() { }
        virtual ~ns1__ActionsInstrumentDatas() { }
        /// Friend allocator used by soap_new_ns1__ActionsInstrumentDatas(struct soap*, int)
        friend SOAP_FMAC1 ns1__ActionsInstrumentDatas * SOAP_FMAC2 soap_instantiate_ns1__ActionsInstrumentDatas(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:220 */
#ifndef SOAP_TYPE_ns1__CorrectionRecords
#define SOAP_TYPE_ns1__CorrectionRecords (38)
/* complex XML schema type 'ns1:CorrectionRecords': */
class SOAP_CMAC ns1__CorrectionRecords {
      public:
        /// Optional element 'ns1:correctionRecord' of XML schema type 'ns1:CorrectionRecord'
        std::vector<ns1__CorrectionRecord *> correctionRecord;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CorrectionRecords
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__CorrectionRecords; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CorrectionRecords, default initialized and not managed by a soap context
        virtual ns1__CorrectionRecords *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__CorrectionRecords); }
      public:
        /// Constructor with default initializations
        ns1__CorrectionRecords() : correctionRecord(), soap() { }
        virtual ~ns1__CorrectionRecords() { }
        /// Friend allocator used by soap_new_ns1__CorrectionRecords(struct soap*, int)
        friend SOAP_FMAC1 ns1__CorrectionRecords * SOAP_FMAC2 soap_instantiate_ns1__CorrectionRecords(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:222 */
#ifndef SOAP_TYPE_ns1__QuotesInstrumentDatas
#define SOAP_TYPE_ns1__QuotesInstrumentDatas (39)
/* complex XML schema type 'ns1:QuotesInstrumentDatas': */
class SOAP_CMAC ns1__QuotesInstrumentDatas {
      public:
        /// Optional element 'ns1:instrumentData' of XML schema type 'ns1:QuotesInstrumentData'
        std::vector<ns1__QuotesInstrumentData *> instrumentData;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__QuotesInstrumentDatas
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__QuotesInstrumentDatas; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__QuotesInstrumentDatas, default initialized and not managed by a soap context
        virtual ns1__QuotesInstrumentDatas *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__QuotesInstrumentDatas); }
      public:
        /// Constructor with default initializations
        ns1__QuotesInstrumentDatas() : instrumentData(), soap() { }
        virtual ~ns1__QuotesInstrumentDatas() { }
        /// Friend allocator used by soap_new_ns1__QuotesInstrumentDatas(struct soap*, int)
        friend SOAP_FMAC1 ns1__QuotesInstrumentDatas * SOAP_FMAC2 soap_instantiate_ns1__QuotesInstrumentDatas(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:224 */
#ifndef SOAP_TYPE_ns1__AllQuotesInstrumentDatas
#define SOAP_TYPE_ns1__AllQuotesInstrumentDatas (40)
/* complex XML schema type 'ns1:AllQuotesInstrumentDatas': */
class SOAP_CMAC ns1__AllQuotesInstrumentDatas {
      public:
        /// Optional element 'ns1:instrumentData' of XML schema type 'ns1:AllQuotesInstrumentData'
        std::vector<ns1__AllQuotesInstrumentData *> instrumentData;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__AllQuotesInstrumentDatas
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__AllQuotesInstrumentDatas; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__AllQuotesInstrumentDatas, default initialized and not managed by a soap context
        virtual ns1__AllQuotesInstrumentDatas *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__AllQuotesInstrumentDatas); }
      public:
        /// Constructor with default initializations
        ns1__AllQuotesInstrumentDatas() : instrumentData(), soap() { }
        virtual ~ns1__AllQuotesInstrumentDatas() { }
        /// Friend allocator used by soap_new_ns1__AllQuotesInstrumentDatas(struct soap*, int)
        friend SOAP_FMAC1 ns1__AllQuotesInstrumentDatas * SOAP_FMAC2 soap_instantiate_ns1__AllQuotesInstrumentDatas(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:226 */
#ifndef SOAP_TYPE_ns1__Instrument
#define SOAP_TYPE_ns1__Instrument (41)
/* complex XML schema type 'ns1:Instrument': */
class SOAP_CMAC ns1__Instrument {
      public:
        /// Required element 'ns1:id' of XML schema type 'xsd:string'
        std::string id;
        /// Optional element 'ns1:yellowkey' of XML schema type 'ns1:MarketSector'
        enum ns1__MarketSector *yellowkey;
        /// Optional element 'ns1:type' of XML schema type 'ns1:InstrumentType'
        enum ns1__InstrumentType *type;
        /// Optional element 'ns1:overrides' of XML schema type 'ns1:Overrides'
        ns1__Overrides *overrides;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Instrument
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__Instrument; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Instrument, default initialized and not managed by a soap context
        virtual ns1__Instrument *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__Instrument); }
      public:
        /// Constructor with default initializations
        ns1__Instrument() : id(), yellowkey(), type(), overrides(), soap() { }
        virtual ~ns1__Instrument() { }
        /// Friend allocator used by soap_new_ns1__Instrument(struct soap*, int)
        friend SOAP_FMAC1 ns1__Instrument * SOAP_FMAC2 soap_instantiate_ns1__Instrument(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:228 */
#ifndef SOAP_TYPE_ns1__FundInstrument
#define SOAP_TYPE_ns1__FundInstrument (42)
/* complex XML schema type 'ns1:FundInstrument': */
class SOAP_CMAC ns1__FundInstrument {
      public:
        /// Required element 'ns1:id' of XML schema type 'xsd:string'
        std::string id;
        /// Optional element 'ns1:yellowkey' of XML schema type 'ns1:MarketSector'
        enum ns1__MarketSector *yellowkey;
        /// Optional element 'ns1:type' of XML schema type 'ns1:InstrumentType'
        enum ns1__InstrumentType *type;
        /// Optional element 'ns1:overrides' of XML schema type 'ns1:Overrides'
        ns1__Overrides *overrides;
        /// Optional element 'ns1:period' of XML schema type 'ns1:Period'
        ns1__Period *period;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__FundInstrument
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__FundInstrument; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__FundInstrument, default initialized and not managed by a soap context
        virtual ns1__FundInstrument *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__FundInstrument); }
      public:
        /// Constructor with default initializations
        ns1__FundInstrument() : id(), yellowkey(), type(), overrides(), period(), soap() { }
        virtual ~ns1__FundInstrument() { }
        /// Friend allocator used by soap_new_ns1__FundInstrument(struct soap*, int)
        friend SOAP_FMAC1 ns1__FundInstrument * SOAP_FMAC2 soap_instantiate_ns1__FundInstrument(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:230 */
#ifndef SOAP_TYPE_ns1__Macro
#define SOAP_TYPE_ns1__Macro (43)
/* complex XML schema type 'ns1:Macro': */
class SOAP_CMAC ns1__Macro {
      public:
        /// Required element 'ns1:primaryQualifier' of XML schema type 'ns1:PrimaryQualifier'
        ns1__PrimaryQualifier *primaryQualifier;
        /// Sequence of 0 to 7 elements 'ns1:secondaryQualifier' of XML schema type 'ns1:SecondaryQualifier'
        std::vector<ns1__SecondaryQualifier *> secondaryQualifier;
        /// Optional element 'ns1:overrides' of XML schema type 'ns1:Overrides'
        ns1__Overrides *overrides;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Macro
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__Macro; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Macro, default initialized and not managed by a soap context
        virtual ns1__Macro *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__Macro); }
      public:
        /// Constructor with default initializations
        ns1__Macro() : primaryQualifier(), secondaryQualifier(), overrides(), soap() { }
        virtual ~ns1__Macro() { }
        /// Friend allocator used by soap_new_ns1__Macro(struct soap*, int)
        friend SOAP_FMAC1 ns1__Macro * SOAP_FMAC2 soap_instantiate_ns1__Macro(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:232 */
#ifndef SOAP_TYPE_ns1__PrimaryQualifier
#define SOAP_TYPE_ns1__PrimaryQualifier (44)
/* complex XML schema type 'ns1:PrimaryQualifier': */
class SOAP_CMAC ns1__PrimaryQualifier {
      public:
        /// Required element 'ns1:primaryQualifierType' of XML schema type 'ns1:MacroType'
        enum ns1__MacroType primaryQualifierType;
        /// Required element 'ns1:primaryQualifierValue' of XML schema type 'xsd:string'
        std::string primaryQualifierValue;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__PrimaryQualifier
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__PrimaryQualifier; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__PrimaryQualifier, default initialized and not managed by a soap context
        virtual ns1__PrimaryQualifier *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__PrimaryQualifier); }
      public:
        /// Constructor with default initializations
        ns1__PrimaryQualifier() : primaryQualifierType(), primaryQualifierValue(), soap() { }
        virtual ~ns1__PrimaryQualifier() { }
        /// Friend allocator used by soap_new_ns1__PrimaryQualifier(struct soap*, int)
        friend SOAP_FMAC1 ns1__PrimaryQualifier * SOAP_FMAC2 soap_instantiate_ns1__PrimaryQualifier(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:234 */
#ifndef SOAP_TYPE_ns1__SecondaryQualifier
#define SOAP_TYPE_ns1__SecondaryQualifier (45)
/* complex XML schema type 'ns1:SecondaryQualifier': */
class SOAP_CMAC ns1__SecondaryQualifier {
      public:
        /// Required element 'ns1:secondaryQualifierType' of XML schema type 'ns1:SecondaryQualifierType'
        enum ns1__SecondaryQualifierType secondaryQualifierType;
        /// Required element 'ns1:secondaryQualifierOperator' of XML schema type 'ns1:SecondaryQualifierOperator'
        enum ns1__SecondaryQualifierOperator secondaryQualifierOperator;
        /// Required element 'ns1:secondaryQualifierValue' of XML schema type 'xsd:string'
        std::string secondaryQualifierValue;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SecondaryQualifier
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__SecondaryQualifier; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SecondaryQualifier, default initialized and not managed by a soap context
        virtual ns1__SecondaryQualifier *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__SecondaryQualifier); }
      public:
        /// Constructor with default initializations
        ns1__SecondaryQualifier() : secondaryQualifierType(), secondaryQualifierOperator(), secondaryQualifierValue(), soap() { }
        virtual ~ns1__SecondaryQualifier() { }
        /// Friend allocator used by soap_new_ns1__SecondaryQualifier(struct soap*, int)
        friend SOAP_FMAC1 ns1__SecondaryQualifier * SOAP_FMAC2 soap_instantiate_ns1__SecondaryQualifier(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:236 */
#ifndef SOAP_TYPE_ns1__Override
#define SOAP_TYPE_ns1__Override (46)
/* complex XML schema type 'ns1:Override': */
class SOAP_CMAC ns1__Override {
      public:
        /// Required element 'ns1:field' of XML schema type 'xsd:string'
        std::string field;
        /// Required element 'ns1:value' of XML schema type 'xsd:string'
        std::string value;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Override
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__Override; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Override, default initialized and not managed by a soap context
        virtual ns1__Override *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__Override); }
      public:
        /// Constructor with default initializations
        ns1__Override() : field(), value(), soap() { }
        virtual ~ns1__Override() { }
        /// Friend allocator used by soap_new_ns1__Override(struct soap*, int)
        friend SOAP_FMAC1 ns1__Override * SOAP_FMAC2 soap_instantiate_ns1__Override(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:238 */
#ifndef SOAP_TYPE_ns1__Actions
#define SOAP_TYPE_ns1__Actions (47)
/* complex XML schema type 'ns1:Actions': */
class SOAP_CMAC ns1__Actions {
      public:
        /// Optional element 'ns1:action' of XML schema type 'xsd:string'
        std::vector<std::string> action;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Actions
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__Actions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Actions, default initialized and not managed by a soap context
        virtual ns1__Actions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__Actions); }
      public:
        /// Constructor with default initializations
        ns1__Actions() : action(), soap() { }
        virtual ~ns1__Actions() { }
        /// Friend allocator used by soap_new_ns1__Actions(struct soap*, int)
        friend SOAP_FMAC1 ns1__Actions * SOAP_FMAC2 soap_instantiate_ns1__Actions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:240 */
#ifndef SOAP_TYPE_ns1__DataItem
#define SOAP_TYPE_ns1__DataItem (48)
/* complex XML schema type 'ns1:DataItem': */
class SOAP_CMAC ns1__DataItem {
      public:
        /// Required element 'ns1:value' of XML schema type 'xsd:string'
        std::string value;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DataItem
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__DataItem; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DataItem, default initialized and not managed by a soap context
        virtual ns1__DataItem *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__DataItem); }
      public:
        /// Constructor with default initializations
        ns1__DataItem() : value(), soap() { }
        virtual ~ns1__DataItem() { }
        /// Friend allocator used by soap_new_ns1__DataItem(struct soap*, int)
        friend SOAP_FMAC1 ns1__DataItem * SOAP_FMAC2 soap_instantiate_ns1__DataItem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:242 */
#ifndef SOAP_TYPE_ns1__InstrumentData
#define SOAP_TYPE_ns1__InstrumentData (49)
/* complex XML schema type 'ns1:InstrumentData': */
class SOAP_CMAC ns1__InstrumentData {
      public:
        /// Required element 'ns1:code' of XML schema type 'xsd:string'
        std::string code;
        /// Optional element 'ns1:instrument' of XML schema type 'ns1:Instrument'
        ns1__Instrument *instrument;
        /// Optional element 'ns1:macro' of XML schema type 'ns1:Macro'
        ns1__Macro *macro;
        /// Optional element 'ns1:data' of XML schema type 'ns1:Data'
        std::vector<ns1__Data *> data;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__InstrumentData
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__InstrumentData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__InstrumentData, default initialized and not managed by a soap context
        virtual ns1__InstrumentData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__InstrumentData); }
      public:
        /// Constructor with default initializations
        ns1__InstrumentData() : code(), instrument(), macro(), data(), soap() { }
        virtual ~ns1__InstrumentData() { }
        /// Friend allocator used by soap_new_ns1__InstrumentData(struct soap*, int)
        friend SOAP_FMAC1 ns1__InstrumentData * SOAP_FMAC2 soap_instantiate_ns1__InstrumentData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:244 */
#ifndef SOAP_TYPE_ns1__HistInstrumentData
#define SOAP_TYPE_ns1__HistInstrumentData (50)
/* complex XML schema type 'ns1:HistInstrumentData': */
class SOAP_CMAC ns1__HistInstrumentData {
      public:
        /// Required element 'ns1:code' of XML schema type 'xsd:string'
        std::string code;
        /// Optional element 'ns1:instrument' of XML schema type 'ns1:Instrument'
        ns1__Instrument *instrument;
        /// Optional element 'ns1:macro' of XML schema type 'ns1:Macro'
        ns1__Macro *macro;
        /// Optional element 'ns1:pricingSource' of XML schema type 'xsd:string'
        std::string *pricingSource;
        /// Optional element 'ns1:date' of XML schema type 'xsd:date'
        std::string *date;
        /// Optional element 'ns1:data' of XML schema type 'ns1:HistData'
        std::vector<ns1__HistData *> data;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__HistInstrumentData
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__HistInstrumentData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__HistInstrumentData, default initialized and not managed by a soap context
        virtual ns1__HistInstrumentData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__HistInstrumentData); }
      public:
        /// Constructor with default initializations
        ns1__HistInstrumentData() : code(), instrument(), macro(), pricingSource(), date(), data(), soap() { }
        virtual ~ns1__HistInstrumentData() { }
        /// Friend allocator used by soap_new_ns1__HistInstrumentData(struct soap*, int)
        friend SOAP_FMAC1 ns1__HistInstrumentData * SOAP_FMAC2 soap_instantiate_ns1__HistInstrumentData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:246 */
#ifndef SOAP_TYPE_ns1__FundInstrumentData
#define SOAP_TYPE_ns1__FundInstrumentData (51)
/* complex XML schema type 'ns1:FundInstrumentData': */
class SOAP_CMAC ns1__FundInstrumentData {
      public:
        /// Required element 'ns1:code' of XML schema type 'xsd:string'
        std::string code;
        /// Optional element 'ns1:instrument' of XML schema type 'ns1:FundInstrument'
        ns1__FundInstrument *instrument;
        /// Optional element 'ns1:macro' of XML schema type 'ns1:Macro'
        ns1__Macro *macro;
        /// Optional element 'ns1:data' of XML schema type 'ns1:Data'
        std::vector<ns1__Data *> data;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__FundInstrumentData
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__FundInstrumentData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__FundInstrumentData, default initialized and not managed by a soap context
        virtual ns1__FundInstrumentData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__FundInstrumentData); }
      public:
        /// Constructor with default initializations
        ns1__FundInstrumentData() : code(), instrument(), macro(), data(), soap() { }
        virtual ~ns1__FundInstrumentData() { }
        /// Friend allocator used by soap_new_ns1__FundInstrumentData(struct soap*, int)
        friend SOAP_FMAC1 ns1__FundInstrumentData * SOAP_FMAC2 soap_instantiate_ns1__FundInstrumentData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:248 */
#ifndef SOAP_TYPE_ns1__QuotesInstrumentData
#define SOAP_TYPE_ns1__QuotesInstrumentData (52)
/* complex XML schema type 'ns1:QuotesInstrumentData': */
class SOAP_CMAC ns1__QuotesInstrumentData {
      public:
        /// Optional element 'ns1:instrument' of XML schema type 'ns1:Instrument'
        ns1__Instrument *instrument;
        /// Optional element 'ns1:macro' of XML schema type 'ns1:Macro'
        ns1__Macro *macro;
        /// Optional element 'ns1:pcs' of XML schema type 'xsd:string'
        std::string *pcs;
        /// Optional element 'ns1:quotes' of XML schema type 'ns1:QRQuotes'
        ns1__QRQuotes *quotes;
        /// Required element 'ns1:code' of XML schema type 'xsd:string'
        std::string code;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__QuotesInstrumentData
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__QuotesInstrumentData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__QuotesInstrumentData, default initialized and not managed by a soap context
        virtual ns1__QuotesInstrumentData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__QuotesInstrumentData); }
      public:
        /// Constructor with default initializations
        ns1__QuotesInstrumentData() : instrument(), macro(), pcs(), quotes(), code(), soap() { }
        virtual ~ns1__QuotesInstrumentData() { }
        /// Friend allocator used by soap_new_ns1__QuotesInstrumentData(struct soap*, int)
        friend SOAP_FMAC1 ns1__QuotesInstrumentData * SOAP_FMAC2 soap_instantiate_ns1__QuotesInstrumentData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:250 */
#ifndef SOAP_TYPE_ns1__AllQuotesInstrumentData
#define SOAP_TYPE_ns1__AllQuotesInstrumentData (53)
/* complex XML schema type 'ns1:AllQuotesInstrumentData': */
class SOAP_CMAC ns1__AllQuotesInstrumentData {
      public:
        /// Optional element 'ns1:instrument' of XML schema type 'ns1:Instrument'
        ns1__Instrument *instrument;
        /// Optional element 'ns1:macro' of XML schema type 'ns1:Macro'
        ns1__Macro *macro;
        /// Optional element 'ns1:pcs' of XML schema type 'xsd:string'
        std::string *pcs;
        /// Optional element 'ns1:quotes' of XML schema type 'ns1:QRMQuotes'
        ns1__QRMQuotes *quotes;
        /// Required element 'ns1:code' of XML schema type 'xsd:string'
        std::string code;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__AllQuotesInstrumentData
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__AllQuotesInstrumentData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__AllQuotesInstrumentData, default initialized and not managed by a soap context
        virtual ns1__AllQuotesInstrumentData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__AllQuotesInstrumentData); }
      public:
        /// Constructor with default initializations
        ns1__AllQuotesInstrumentData() : instrument(), macro(), pcs(), quotes(), code(), soap() { }
        virtual ~ns1__AllQuotesInstrumentData() { }
        /// Friend allocator used by soap_new_ns1__AllQuotesInstrumentData(struct soap*, int)
        friend SOAP_FMAC1 ns1__AllQuotesInstrumentData * SOAP_FMAC2 soap_instantiate_ns1__AllQuotesInstrumentData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:252 */
#ifndef SOAP_TYPE_ns1__ActionsInstrumentData
#define SOAP_TYPE_ns1__ActionsInstrumentData (54)
/* complex XML schema type 'ns1:ActionsInstrumentData': */
class SOAP_CMAC ns1__ActionsInstrumentData {
      public:
        /// Required element 'ns1:code' of XML schema type 'xsd:string'
        std::string code;
        /// Optional element 'ns1:instrument' of XML schema type 'ns1:Instrument'
        ns1__Instrument *instrument;
        /// Optional element 'ns1:macro' of XML schema type 'ns1:Macro'
        ns1__Macro *macro;
        /// Optional element 'ns1:standardFields' of XML schema type 'ns1:ActionStandardFields'
        ns1__ActionStandardFields *standardFields;
        /// Optional element 'ns1:data' of XML schema type 'ns1:Data'
        std::vector<ns1__Data *> data;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ActionsInstrumentData
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ActionsInstrumentData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ActionsInstrumentData, default initialized and not managed by a soap context
        virtual ns1__ActionsInstrumentData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ActionsInstrumentData); }
      public:
        /// Constructor with default initializations
        ns1__ActionsInstrumentData() : code(), instrument(), macro(), standardFields(), data(), soap() { }
        virtual ~ns1__ActionsInstrumentData() { }
        /// Friend allocator used by soap_new_ns1__ActionsInstrumentData(struct soap*, int)
        friend SOAP_FMAC1 ns1__ActionsInstrumentData * SOAP_FMAC2 soap_instantiate_ns1__ActionsInstrumentData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:254 */
#ifndef SOAP_TYPE_ns1__CorrectionRecord
#define SOAP_TYPE_ns1__CorrectionRecord (55)
/* complex XML schema type 'ns1:CorrectionRecord': */
class SOAP_CMAC ns1__CorrectionRecord {
      public:
        /// Required element 'ns1:instrument' of XML schema type 'ns1:Instrument'
        ns1__Instrument *instrument;
        /// Required element 'ns1:field' of XML schema type 'xsd:string'
        std::string field;
        /// Required element 'ns1:oldValue' of XML schema type 'xsd:string'
        std::string oldValue;
        /// Required element 'ns1:oldDateEntered' of XML schema type 'xsd:string'
        std::string oldDateEntered;
        /// Required element 'ns1:newValue' of XML schema type 'xsd:string'
        std::string newValue;
        /// Required element 'ns1:newDateEntered' of XML schema type 'xsd:string'
        std::string newDateEntered;
        /// Required element 'ns1:timeEntered' of XML schema type 'xsd:string'
        std::string timeEntered;
        /// Required element 'ns1:exchangeIndicator' of XML schema type 'xsd:string'
        std::string exchangeIndicator;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CorrectionRecord
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__CorrectionRecord; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CorrectionRecord, default initialized and not managed by a soap context
        virtual ns1__CorrectionRecord *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__CorrectionRecord); }
      public:
        /// Constructor with default initializations
        ns1__CorrectionRecord() : instrument(), field(), oldValue(), oldDateEntered(), newValue(), newDateEntered(), timeEntered(), exchangeIndicator(), soap() { }
        virtual ~ns1__CorrectionRecord() { }
        /// Friend allocator used by soap_new_ns1__CorrectionRecord(struct soap*, int)
        friend SOAP_FMAC1 ns1__CorrectionRecord * SOAP_FMAC2 soap_instantiate_ns1__CorrectionRecord(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:256 */
#ifndef SOAP_TYPE_ns1__Data
#define SOAP_TYPE_ns1__Data (56)
/* complex XML schema type 'ns1:Data': */
class SOAP_CMAC ns1__Data {
      public:
        /// Optional element 'ns1:bulkarray' of XML schema type 'ns1:BulkArray'
        std::vector<ns1__BulkArray *> bulkarray;
        /// Optional attribute 'field' of XML schema type 'xsd:string'
        std::string *field;
        /// Optional attribute 'value' of XML schema type 'xsd:string'
        std::string *value;
        /// Optional attribute 'isArray' of XML schema type 'xsd:boolean'
        bool *isArray;
        /// Optional attribute 'rows' of XML schema type 'xsd:int'
        int *rows;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Data
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__Data; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Data, default initialized and not managed by a soap context
        virtual ns1__Data *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__Data); }
      public:
        /// Constructor with default initializations
        ns1__Data() : bulkarray(), field(), value(), isArray(), rows(), soap() { }
        virtual ~ns1__Data() { }
        /// Friend allocator used by soap_new_ns1__Data(struct soap*, int)
        friend SOAP_FMAC1 ns1__Data * SOAP_FMAC2 soap_instantiate_ns1__Data(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:258 */
#ifndef SOAP_TYPE_ns1__QRQuotes
#define SOAP_TYPE_ns1__QRQuotes (57)
/* complex XML schema type 'ns1:QRQuotes': */
class SOAP_CMAC ns1__QRQuotes {
      public:
        /// Optional element 'ns1:quote' of XML schema type 'ns1:QRQuote'
        std::vector<ns1__QRQuote *> quote;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__QRQuotes
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__QRQuotes; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__QRQuotes, default initialized and not managed by a soap context
        virtual ns1__QRQuotes *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__QRQuotes); }
      public:
        /// Constructor with default initializations
        ns1__QRQuotes() : quote(), soap() { }
        virtual ~ns1__QRQuotes() { }
        /// Friend allocator used by soap_new_ns1__QRQuotes(struct soap*, int)
        friend SOAP_FMAC1 ns1__QRQuotes * SOAP_FMAC2 soap_instantiate_ns1__QRQuotes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:260 */
#ifndef SOAP_TYPE_ns1__QRMQuotes
#define SOAP_TYPE_ns1__QRMQuotes (58)
/* complex XML schema type 'ns1:QRMQuotes': */
class SOAP_CMAC ns1__QRMQuotes {
      public:
        /// Optional element 'ns1:quote' of XML schema type 'ns1:QRMQuote'
        std::vector<ns1__QRMQuote *> quote;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__QRMQuotes
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__QRMQuotes; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__QRMQuotes, default initialized and not managed by a soap context
        virtual ns1__QRMQuotes *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__QRMQuotes); }
      public:
        /// Constructor with default initializations
        ns1__QRMQuotes() : quote(), soap() { }
        virtual ~ns1__QRMQuotes() { }
        /// Friend allocator used by soap_new_ns1__QRMQuotes(struct soap*, int)
        friend SOAP_FMAC1 ns1__QRMQuotes * SOAP_FMAC2 soap_instantiate_ns1__QRMQuotes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:262 */
#ifndef SOAP_TYPE_ns1__QRQuote
#define SOAP_TYPE_ns1__QRQuote (59)
/* complex XML schema type 'ns1:QRQuote': */
class SOAP_CMAC ns1__QRQuote {
      public:
        /// Optional attribute 'dateTime' of XML schema type 'xsd:dateTime'
        time_t *dateTime;
        /// Optional attribute 'price' of XML schema type 'xsd:string'
        std::string *price;
        /// Optional attribute 'volume' of XML schema type 'xsd:string'
        std::string *volume;
        /// Optional attribute 'exCode' of XML schema type 'xsd:string'
        std::string *exCode;
        /// Optional attribute 'condCode' of XML schema type 'xsd:string'
        std::string *condCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__QRQuote
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__QRQuote; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__QRQuote, default initialized and not managed by a soap context
        virtual ns1__QRQuote *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__QRQuote); }
      public:
        /// Constructor with default initializations
        ns1__QRQuote() : dateTime(), price(), volume(), exCode(), condCode(), soap() { }
        virtual ~ns1__QRQuote() { }
        /// Friend allocator used by soap_new_ns1__QRQuote(struct soap*, int)
        friend SOAP_FMAC1 ns1__QRQuote * SOAP_FMAC2 soap_instantiate_ns1__QRQuote(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:264 */
#ifndef SOAP_TYPE_ns1__QRMQuoteData
#define SOAP_TYPE_ns1__QRMQuoteData (60)
/* complex XML schema type 'ns1:QRMQuoteData': */
class SOAP_CMAC ns1__QRMQuoteData {
      public:
        /// Optional attribute 'type' of XML schema type 'xsd:string'
        std::string *type;
        /// Optional attribute 'price' of XML schema type 'xsd:string'
        std::string *price;
        /// Optional attribute 'volume' of XML schema type 'xsd:string'
        std::string *volume;
        /// Optional attribute 'mm' of XML schema type 'xsd:string'
        std::string *mm;
        /// Optional attribute 'exCode' of XML schema type 'xsd:string'
        std::string *exCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__QRMQuoteData
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__QRMQuoteData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__QRMQuoteData, default initialized and not managed by a soap context
        virtual ns1__QRMQuoteData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__QRMQuoteData); }
      public:
        /// Constructor with default initializations
        ns1__QRMQuoteData() : type(), price(), volume(), mm(), exCode(), soap() { }
        virtual ~ns1__QRMQuoteData() { }
        /// Friend allocator used by soap_new_ns1__QRMQuoteData(struct soap*, int)
        friend SOAP_FMAC1 ns1__QRMQuoteData * SOAP_FMAC2 soap_instantiate_ns1__QRMQuoteData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:266 */
#ifndef SOAP_TYPE_ns1__QRMQuote
#define SOAP_TYPE_ns1__QRMQuote (61)
/* complex XML schema type 'ns1:QRMQuote': */
class SOAP_CMAC ns1__QRMQuote {
      public:
        /// Required element 'ns1:matchedQuote' of XML schema type 'ns1:QRMQuoteData'
        std::vector<ns1__QRMQuoteData *> matchedQuote;
        /// Optional attribute 'dateTime' of XML schema type 'xsd:dateTime'
        time_t *dateTime;
        /// Optional attribute 'condCode' of XML schema type 'xsd:string'
        std::string *condCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__QRMQuote
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__QRMQuote; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__QRMQuote, default initialized and not managed by a soap context
        virtual ns1__QRMQuote *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__QRMQuote); }
      public:
        /// Constructor with default initializations
        ns1__QRMQuote() : matchedQuote(), dateTime(), condCode(), soap() { }
        virtual ~ns1__QRMQuote() { }
        /// Friend allocator used by soap_new_ns1__QRMQuote(struct soap*, int)
        friend SOAP_FMAC1 ns1__QRMQuote * SOAP_FMAC2 soap_instantiate_ns1__QRMQuote(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:268 */
#ifndef SOAP_TYPE_ns1__HistData
#define SOAP_TYPE_ns1__HistData (62)
/* complex XML schema type 'ns1:HistData': */
class SOAP_CMAC ns1__HistData {
      public:
        /// Optional attribute 'value' of XML schema type 'xsd:string'
        std::string *value;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__HistData
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__HistData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__HistData, default initialized and not managed by a soap context
        virtual ns1__HistData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__HistData); }
      public:
        /// Constructor with default initializations
        ns1__HistData() : value(), soap() { }
        virtual ~ns1__HistData() { }
        /// Friend allocator used by soap_new_ns1__HistData(struct soap*, int)
        friend SOAP_FMAC1 ns1__HistData * SOAP_FMAC2 soap_instantiate_ns1__HistData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:270 */
#ifndef SOAP_TYPE_ns1__ActionStandardFields
#define SOAP_TYPE_ns1__ActionStandardFields (63)
/* complex XML schema type 'ns1:ActionStandardFields': */
class SOAP_CMAC ns1__ActionStandardFields {
      public:
        /// Optional element 'ns1:companyId' of XML schema type 'xsd:int'
        int *companyId;
        /// Optional element 'ns1:securityId' of XML schema type 'xsd:int'
        int *securityId;
        /// Optional element 'ns1:actionId' of XML schema type 'xsd:int'
        int *actionId;
        /// Optional element 'ns1:mnemonic' of XML schema type 'xsd:string'
        std::string *mnemonic;
        /// Optional element 'ns1:flag' of XML schema type 'xsd:string'
        std::string *flag;
        /// Optional element 'ns1:companyName' of XML schema type 'xsd:string'
        std::string *companyName;
        /// Optional element 'ns1:secIdType' of XML schema type 'xsd:string'
        std::string *secIdType;
        /// Optional element 'ns1:secId' of XML schema type 'xsd:string'
        std::string *secId;
        /// Optional element 'ns1:currency' of XML schema type 'xsd:string'
        std::string *currency;
        /// Optional element 'ns1:marketSectorDes' of XML schema type 'ns1:MarketSector'
        enum ns1__MarketSector *marketSectorDes;
        /// Optional element 'ns1:bbUnique' of XML schema type 'xsd:string'
        std::string *bbUnique;
        /// Optional element 'ns1:announceDate' of XML schema type 'xsd:string'
        std::string *announceDate;
        /// Optional element 'ns1:effectiveDate' of XML schema type 'xsd:string'
        std::string *effectiveDate;
        /// Optional element 'ns1:amendDate' of XML schema type 'xsd:string'
        std::string *amendDate;
        /// Optional element 'ns1:bbGlobal' of XML schema type 'xsd:string'
        std::string *bbGlobal;
        /// Optional element 'ns1:bbGlobalCompany' of XML schema type 'xsd:string'
        std::string *bbGlobalCompany;
        /// Optional element 'ns1:bbSecNumDes' of XML schema type 'xsd:string'
        std::string *bbSecNumDes;
        /// Optional element 'ns1:feedSource' of XML schema type 'xsd:string'
        std::string *feedSource;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ActionStandardFields
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ActionStandardFields; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ActionStandardFields, default initialized and not managed by a soap context
        virtual ns1__ActionStandardFields *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ActionStandardFields); }
      public:
        /// Constructor with default initializations
        ns1__ActionStandardFields() : companyId(), securityId(), actionId(), mnemonic(), flag(), companyName(), secIdType(), secId(), currency(), marketSectorDes(), bbUnique(), announceDate(), effectiveDate(), amendDate(), bbGlobal(), bbGlobalCompany(), bbSecNumDes(), feedSource(), soap() { }
        virtual ~ns1__ActionStandardFields() { }
        /// Friend allocator used by soap_new_ns1__ActionStandardFields(struct soap*, int)
        friend SOAP_FMAC1 ns1__ActionStandardFields * SOAP_FMAC2 soap_instantiate_ns1__ActionStandardFields(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:272 */
#ifndef SOAP_TYPE_ns1__BulkArray
#define SOAP_TYPE_ns1__BulkArray (64)
/* complex XML schema type 'ns1:BulkArray': */
class SOAP_CMAC ns1__BulkArray {
      public:
        /// Optional element 'ns1:data' of XML schema type 'ns1:BulkArrayEntry'
        std::vector<ns1__BulkArrayEntry *> data;
        /// Optional attribute 'columns' of XML schema type 'xsd:int'
        int *columns;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__BulkArray
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__BulkArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__BulkArray, default initialized and not managed by a soap context
        virtual ns1__BulkArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__BulkArray); }
      public:
        /// Constructor with default initializations
        ns1__BulkArray() : data(), columns(), soap() { }
        virtual ~ns1__BulkArray() { }
        /// Friend allocator used by soap_new_ns1__BulkArray(struct soap*, int)
        friend SOAP_FMAC1 ns1__BulkArray * SOAP_FMAC2 soap_instantiate_ns1__BulkArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:274 */
#ifndef SOAP_TYPE_ns1__BulkArrayEntry
#define SOAP_TYPE_ns1__BulkArrayEntry (65)
/* complex XML schema type 'ns1:BulkArrayEntry': */
class SOAP_CMAC ns1__BulkArrayEntry {
      public:
        /// Optional attribute 'value' of XML schema type 'xsd:string'
        std::string *value;
        /// Optional attribute 'type' of XML schema type 'ns1:FieldType'
        enum ns1__FieldType *type;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__BulkArrayEntry
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__BulkArrayEntry; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__BulkArrayEntry, default initialized and not managed by a soap context
        virtual ns1__BulkArrayEntry *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__BulkArrayEntry); }
      public:
        /// Constructor with default initializations
        ns1__BulkArrayEntry() : value(), type(), soap() { }
        virtual ~ns1__BulkArrayEntry() { }
        /// Friend allocator used by soap_new_ns1__BulkArrayEntry(struct soap*, int)
        friend SOAP_FMAC1 ns1__BulkArrayEntry * SOAP_FMAC2 soap_instantiate_ns1__BulkArrayEntry(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:276 */
#ifndef SOAP_TYPE_ns1__ResponseStatus
#define SOAP_TYPE_ns1__ResponseStatus (66)
/* complex XML schema type 'ns1:ResponseStatus': */
class SOAP_CMAC ns1__ResponseStatus {
      public:
        /// Required element 'ns1:code' of XML schema type 'xsd:int'
        int code;
        /// Required element 'ns1:description' of XML schema type 'xsd:string'
        std::string description;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ResponseStatus
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ResponseStatus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ResponseStatus, default initialized and not managed by a soap context
        virtual ns1__ResponseStatus *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ResponseStatus); }
      public:
        /// Constructor with default initializations
        ns1__ResponseStatus() : code(), description(), soap() { }
        virtual ~ns1__ResponseStatus() { }
        /// Friend allocator used by soap_new_ns1__ResponseStatus(struct soap*, int)
        friend SOAP_FMAC1 ns1__ResponseStatus * SOAP_FMAC2 soap_instantiate_ns1__ResponseStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:278 */
#ifndef SOAP_TYPE_ns1__CancelResponseStatus
#define SOAP_TYPE_ns1__CancelResponseStatus (67)
/* complex XML schema type 'ns1:CancelResponseStatus': */
class SOAP_CMAC ns1__CancelResponseStatus {
      public:
        /// Required element 'ns1:responseId' of XML schema type 'xsd:string'
        std::string responseId;
        /// Required element 'ns1:cancelStatus' of XML schema type 'ns1:CancelStatus'
        enum ns1__CancelStatus cancelStatus;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CancelResponseStatus
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__CancelResponseStatus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CancelResponseStatus, default initialized and not managed by a soap context
        virtual ns1__CancelResponseStatus *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__CancelResponseStatus); }
      public:
        /// Constructor with default initializations
        ns1__CancelResponseStatus() : responseId(), cancelStatus(), soap() { }
        virtual ~ns1__CancelResponseStatus() { }
        /// Friend allocator used by soap_new_ns1__CancelResponseStatus(struct soap*, int)
        friend SOAP_FMAC1 ns1__CancelResponseStatus * SOAP_FMAC2 soap_instantiate_ns1__CancelResponseStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:280 */
#ifndef SOAP_TYPE_ns1__FieldSearchCriteria
#define SOAP_TYPE_ns1__FieldSearchCriteria (68)
/* complex XML schema type 'ns1:FieldSearchCriteria': */
class SOAP_CMAC ns1__FieldSearchCriteria {
      public:
        /// Optional element 'ns1:keyword' of XML schema type 'xsd:string'
        std::string *keyword;
        /// Optional element 'ns1:mnemonic' of XML schema type 'xsd:string'
        std::string *mnemonic;
        /// Sequence of 0 to 5 elements 'ns1:dlCategories' of XML schema type 'ns1:DLCategory'
        std::vector<enum ns1__DLCategory> dlCategories;
        /// Optional element 'ns1:overridable' of XML schema type 'xsd:boolean'
        bool *overridable;
        /// Sequence of 0 to 10 elements 'ns1:marketsectors' of XML schema type 'ns1:MarketSector'
        std::vector<enum ns1__MarketSector> marketsectors;
        /// Sequence of 0 to 5 elements 'ns1:dlCategories2' of XML schema type 'ns1:DLCategory2'
        std::vector<enum ns1__DLCategory2> dlCategories2;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__FieldSearchCriteria
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__FieldSearchCriteria; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__FieldSearchCriteria, default initialized and not managed by a soap context
        virtual ns1__FieldSearchCriteria *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__FieldSearchCriteria); }
      public:
        /// Constructor with default initializations
        ns1__FieldSearchCriteria() : keyword(), mnemonic(), dlCategories(), overridable(), marketsectors(), dlCategories2(), soap() { }
        virtual ~ns1__FieldSearchCriteria() { }
        /// Friend allocator used by soap_new_ns1__FieldSearchCriteria(struct soap*, int)
        friend SOAP_FMAC1 ns1__FieldSearchCriteria * SOAP_FMAC2 soap_instantiate_ns1__FieldSearchCriteria(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:282 */
#ifndef SOAP_TYPE_ns1__FieldInfos
#define SOAP_TYPE_ns1__FieldInfos (69)
/* complex XML schema type 'ns1:FieldInfos': */
class SOAP_CMAC ns1__FieldInfos {
      public:
        /// Optional element 'ns1:field' of XML schema type 'ns1:FieldInfo'
        std::vector<ns1__FieldInfo *> field;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__FieldInfos
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__FieldInfos; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__FieldInfos, default initialized and not managed by a soap context
        virtual ns1__FieldInfos *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__FieldInfos); }
      public:
        /// Constructor with default initializations
        ns1__FieldInfos() : field(), soap() { }
        virtual ~ns1__FieldInfos() { }
        /// Friend allocator used by soap_new_ns1__FieldInfos(struct soap*, int)
        friend SOAP_FMAC1 ns1__FieldInfos * SOAP_FMAC2 soap_instantiate_ns1__FieldInfos(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:284 */
#ifndef SOAP_TYPE_ns1__FieldInfo
#define SOAP_TYPE_ns1__FieldInfo (70)
/* complex XML schema type 'ns1:FieldInfo': */
class SOAP_CMAC ns1__FieldInfo {
      public:
        /// Optional element 'ns1:id' of XML schema type 'xsd:string'
        std::string *id;
        /// Optional element 'ns1:mnemonic' of XML schema type 'xsd:string'
        std::string *mnemonic;
        /// Optional element 'ns1:description' of XML schema type 'xsd:string'
        std::string *description;
        /// Optional element 'ns1:dlCategory' of XML schema type 'ns1:DLCategory'
        enum ns1__DLCategory *dlCategory;
        /// Optional element 'ns1:definition' of XML schema type 'xsd:string'
        std::string *definition;
        /// Sequence of 0 to 10 elements 'ns1:marketsectors' of XML schema type 'ns1:MarketSector'
        std::vector<enum ns1__MarketSector> marketsectors;
        /// Optional element 'ns1:standardWidth' of XML schema type 'xsd:int'
        int *standardWidth;
        /// Optional element 'ns1:standardDecimalPlaces' of XML schema type 'xsd:int'
        int *standardDecimalPlaces;
        /// Optional element 'ns1:fieldType' of XML schema type 'xsd:string'
        std::string *fieldType;
        /// Optional element 'ns1:backoffice' of XML schema type 'xsd:boolean'
        bool *backoffice;
        /// Optional element 'ns1:extendedBackoffice' of XML schema type 'xsd:boolean'
        bool *extendedBackoffice;
        /// Optional element 'ns1:productionDate' of XML schema type 'xsd:date'
        std::string *productionDate;
        /// Optional element 'ns1:dlCategory2' of XML schema type 'ns1:DLCategory2'
        enum ns1__DLCategory2 *dlCategory2;
        /// Optional element 'ns1:psBoOpt' of XML schema type 'xsd:boolean'
        bool *psBoOpt;
        /// Optional element 'ns1:getHistory' of XML schema type 'xsd:boolean'
        bool *getHistory;
        /// Optional element 'ns1:getCompany' of XML schema type 'xsd:boolean'
        bool *getCompany;
        /// Optional element 'ns1:bval' of XML schema type 'xsd:boolean'
        bool *bval;
        /// Optional element 'ns1:bvalBlocked' of XML schema type 'xsd:boolean'
        bool *bvalBlocked;
        /// Optional element 'ns1:dsBvalMetered' of XML schema type 'xsd:boolean'
        bool *dsBvalMetered;
        /// Optional element 'ns1:sapiOMS' of XML schema type 'xsd:boolean'
        bool *sapiOMS;
        /// Optional element 'ns1:oldMnemonic' of XML schema type 'xsd:string'
        std::string *oldMnemonic;
        /// Optional element 'ns1:currentMaximumWidth' of XML schema type 'xsd:int'
        int *currentMaximumWidth;
        /// Optional element 'ns1:dlBoOptFundamentals' of XML schema type 'xsd:boolean'
        bool *dlBoOptFundamentals;
        /// Optional element 'ns1:dlBoOptBDVD' of XML schema type 'xsd:boolean'
        bool *dlBoOptBDVD;
        /// Optional element 'ns1:dlBoOptBEST' of XML schema type 'xsd:boolean'
        bool *dlBoOptBEST;
        /// Optional element 'ns1:dlBoOptCreditRisk' of XML schema type 'xsd:boolean'
        bool *dlBoOptCreditRisk;
        /// Optional element 'ns1:dlBoOptCapStruct' of XML schema type 'xsd:boolean'
        bool *dlBoOptCapStruct;
        /// Optional element 'ns1:dlBoOptCreditRiskGetCompany' of XML schema type 'xsd:boolean'
        bool *dlBoOptCreditRiskGetCompany;
        /// Optional element 'ns1:dlBoOptCapStructGetCompany' of XML schema type 'xsd:boolean'
        bool *dlBoOptCapStructGetCompany;
        /// Optional element 'ns1:dlBoOptRegCompliance' of XML schema type 'xsd:boolean'
        bool *dlBoOptRegCompliance;
        /// Optional element 'ns1:dlBoOptIssuerRatings' of XML schema type 'xsd:boolean'
        bool *dlBoOptIssuerRatings;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__FieldInfo
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__FieldInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__FieldInfo, default initialized and not managed by a soap context
        virtual ns1__FieldInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__FieldInfo); }
      public:
        /// Constructor with default initializations
        ns1__FieldInfo() : id(), mnemonic(), description(), dlCategory(), definition(), marketsectors(), standardWidth(), standardDecimalPlaces(), fieldType(), backoffice(), extendedBackoffice(), productionDate(), dlCategory2(), psBoOpt(), getHistory(), getCompany(), bval(), bvalBlocked(), dsBvalMetered(), sapiOMS(), oldMnemonic(), currentMaximumWidth(), dlBoOptFundamentals(), dlBoOptBDVD(), dlBoOptBEST(), dlBoOptCreditRisk(), dlBoOptCapStruct(), dlBoOptCreditRiskGetCompany(), dlBoOptCapStructGetCompany(), dlBoOptRegCompliance(), dlBoOptIssuerRatings(), soap() { }
        virtual ~ns1__FieldInfo() { }
        /// Friend allocator used by soap_new_ns1__FieldInfo(struct soap*, int)
        friend SOAP_FMAC1 ns1__FieldInfo * SOAP_FMAC2 soap_instantiate_ns1__FieldInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:286 */
#ifndef SOAP_TYPE_ns1__OtcBvalHeaders
#define SOAP_TYPE_ns1__OtcBvalHeaders (71)
/* complex XML schema type 'ns1:OtcBvalHeaders': */
class SOAP_CMAC ns1__OtcBvalHeaders {
      public:
        /// Required element 'ns1:contentType' of XML schema type 'xsd:string'
        std::string contentType;
        /// Required element 'ns1:mimeVersion' of XML schema type 'xsd:string'
        std::string mimeVersion;
        /// Required element 'ns1:contentEncoding' of XML schema type 'xsd:string'
        std::string contentEncoding;
        /// Required element 'ns1:contentDisposition' of XML schema type 'xsd:string'
        std::string contentDisposition;
        /// Required element 'ns1:fileName' of XML schema type 'xsd:string'
        std::string fileName;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__OtcBvalHeaders
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__OtcBvalHeaders; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__OtcBvalHeaders, default initialized and not managed by a soap context
        virtual ns1__OtcBvalHeaders *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__OtcBvalHeaders); }
      public:
        /// Constructor with default initializations
        ns1__OtcBvalHeaders() : contentType(), mimeVersion(), contentEncoding(), contentDisposition(), fileName(), soap() { }
        virtual ~ns1__OtcBvalHeaders() { }
        /// Friend allocator used by soap_new_ns1__OtcBvalHeaders(struct soap*, int)
        friend SOAP_FMAC1 ns1__OtcBvalHeaders * SOAP_FMAC2 soap_instantiate_ns1__OtcBvalHeaders(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:288 */
#ifndef SOAP_TYPE_ns1__OtcDealInformation
#define SOAP_TYPE_ns1__OtcDealInformation (72)
/* complex XML schema type 'ns1:OtcDealInformation': */
class SOAP_CMAC ns1__OtcDealInformation {
      public:
        /// Required element 'ns1:statusCode' of XML schema type 'ns1:ResponseStatus'
        ns1__ResponseStatus *statusCode;
        /// Optional element 'ns1:customId' of XML schema type 'xsd:string'
        std::string *customId;
        /// Optional element 'ns1:dealId' of XML schema type 'xsd:string'
        std::string *dealId;
        /// Optional element 'ns1:dealType' of XML schema type 'xsd:string'
        std::string *dealType;
        /// Optional element 'ns1:action' of XML schema type 'ns1:OtcBvalAction'
        enum ns1__OtcBvalAction *action;
        /// Optional element 'ns1:portfolioId' of XML schema type 'xsd:string'
        std::string *portfolioId;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__OtcDealInformation
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__OtcDealInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__OtcDealInformation, default initialized and not managed by a soap context
        virtual ns1__OtcDealInformation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__OtcDealInformation); }
      public:
        /// Constructor with default initializations
        ns1__OtcDealInformation() : statusCode(), customId(), dealId(), dealType(), action(), portfolioId(), soap() { }
        virtual ~ns1__OtcDealInformation() { }
        /// Friend allocator used by soap_new_ns1__OtcDealInformation(struct soap*, int)
        friend SOAP_FMAC1 ns1__OtcDealInformation * SOAP_FMAC2 soap_instantiate_ns1__OtcDealInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:290 */
#ifndef SOAP_TYPE_ns1__OtcDealInfos
#define SOAP_TYPE_ns1__OtcDealInfos (73)
/* complex XML schema type 'ns1:OtcDealInfos': */
class SOAP_CMAC ns1__OtcDealInfos {
      public:
        /// Optional element 'ns1:deal' of XML schema type 'ns1:OtcDealInformation'
        std::vector<ns1__OtcDealInformation *> deal;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__OtcDealInfos
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__OtcDealInfos; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__OtcDealInfos, default initialized and not managed by a soap context
        virtual ns1__OtcDealInfos *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__OtcDealInfos); }
      public:
        /// Constructor with default initializations
        ns1__OtcDealInfos() : deal(), soap() { }
        virtual ~ns1__OtcDealInfos() { }
        /// Friend allocator used by soap_new_ns1__OtcDealInfos(struct soap*, int)
        friend SOAP_FMAC1 ns1__OtcDealInfos * SOAP_FMAC2 soap_instantiate_ns1__OtcDealInfos(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:292 */
#ifndef SOAP_TYPE_ns1__PerSecurityResponse
#define SOAP_TYPE_ns1__PerSecurityResponse (74)
/* complex XML schema type 'ns1:PerSecurityResponse': */
class SOAP_CMAC ns1__PerSecurityResponse {
      public:
        /// Required element 'ns1:statusCode' of XML schema type 'ns1:ResponseStatus'
        ns1__ResponseStatus *statusCode;
        /// Required element 'ns1:requestId' of XML schema type 'xsd:string'
        std::string requestId;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__PerSecurityResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__PerSecurityResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__PerSecurityResponse, default initialized and not managed by a soap context
        virtual ns1__PerSecurityResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__PerSecurityResponse); }
      public:
        /// Constructor with default initializations
        ns1__PerSecurityResponse() : statusCode(), requestId(), soap() { }
        virtual ~ns1__PerSecurityResponse() { }
        /// Friend allocator used by soap_new_ns1__PerSecurityResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__PerSecurityResponse * SOAP_FMAC2 soap_instantiate_ns1__PerSecurityResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:294 */
#ifndef SOAP_TYPE_ns1__SubmitGetDataRequest
#define SOAP_TYPE_ns1__SubmitGetDataRequest (75)
/* complex XML schema type 'ns1:SubmitGetDataRequest': */
class SOAP_CMAC ns1__SubmitGetDataRequest {
      public:
        /// Required element 'ns1:headers' of XML schema type 'ns1:GetDataHeaders'
        ns1__GetDataHeaders *headers;
        /// Optional element 'ns1:fieldsets' of XML schema type 'ns1:BvalFieldSets'
        ns1__BvalFieldSets *fieldsets;
        /// Optional element 'ns1:fields' of XML schema type 'ns1:Fields'
        ns1__Fields *fields;
        /// Required element 'ns1:instruments' of XML schema type 'ns1:Instruments'
        ns1__Instruments *instruments;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SubmitGetDataRequest
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__SubmitGetDataRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SubmitGetDataRequest, default initialized and not managed by a soap context
        virtual ns1__SubmitGetDataRequest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__SubmitGetDataRequest); }
      public:
        /// Constructor with default initializations
        ns1__SubmitGetDataRequest() : headers(), fieldsets(), fields(), instruments(), soap() { }
        virtual ~ns1__SubmitGetDataRequest() { }
        /// Friend allocator used by soap_new_ns1__SubmitGetDataRequest(struct soap*, int)
        friend SOAP_FMAC1 ns1__SubmitGetDataRequest * SOAP_FMAC2 soap_instantiate_ns1__SubmitGetDataRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:298 */
#ifndef SOAP_TYPE_ns1__RetrieveGetDataRequest
#define SOAP_TYPE_ns1__RetrieveGetDataRequest (77)
/* complex XML schema type 'ns1:RetrieveGetDataRequest': */
class SOAP_CMAC ns1__RetrieveGetDataRequest {
      public:
        /// Required element 'ns1:responseId' of XML schema type 'xsd:string'
        std::string responseId;
        /// Optional element 'ns1:responseDate' of XML schema type 'xsd:date'
        std::string *responseDate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RetrieveGetDataRequest
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__RetrieveGetDataRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RetrieveGetDataRequest, default initialized and not managed by a soap context
        virtual ns1__RetrieveGetDataRequest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__RetrieveGetDataRequest); }
      public:
        /// Constructor with default initializations
        ns1__RetrieveGetDataRequest() : responseId(), responseDate(), soap() { }
        virtual ~ns1__RetrieveGetDataRequest() { }
        /// Friend allocator used by soap_new_ns1__RetrieveGetDataRequest(struct soap*, int)
        friend SOAP_FMAC1 ns1__RetrieveGetDataRequest * SOAP_FMAC2 soap_instantiate_ns1__RetrieveGetDataRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:302 */
#ifndef SOAP_TYPE_ns1__SubmitGetHistoryRequest
#define SOAP_TYPE_ns1__SubmitGetHistoryRequest (79)
/* complex XML schema type 'ns1:SubmitGetHistoryRequest': */
class SOAP_CMAC ns1__SubmitGetHistoryRequest {
      public:
        /// Required element 'ns1:headers' of XML schema type 'ns1:GetHistoryHeaders'
        ns1__GetHistoryHeaders *headers;
        /// Required element 'ns1:fields' of XML schema type 'ns1:Fields'
        ns1__Fields *fields;
        /// Required element 'ns1:instruments' of XML schema type 'ns1:Instruments'
        ns1__Instruments *instruments;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SubmitGetHistoryRequest
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__SubmitGetHistoryRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SubmitGetHistoryRequest, default initialized and not managed by a soap context
        virtual ns1__SubmitGetHistoryRequest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__SubmitGetHistoryRequest); }
      public:
        /// Constructor with default initializations
        ns1__SubmitGetHistoryRequest() : headers(), fields(), instruments(), soap() { }
        virtual ~ns1__SubmitGetHistoryRequest() { }
        /// Friend allocator used by soap_new_ns1__SubmitGetHistoryRequest(struct soap*, int)
        friend SOAP_FMAC1 ns1__SubmitGetHistoryRequest * SOAP_FMAC2 soap_instantiate_ns1__SubmitGetHistoryRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:306 */
#ifndef SOAP_TYPE_ns1__RetrieveGetHistoryRequest
#define SOAP_TYPE_ns1__RetrieveGetHistoryRequest (81)
/* complex XML schema type 'ns1:RetrieveGetHistoryRequest': */
class SOAP_CMAC ns1__RetrieveGetHistoryRequest {
      public:
        /// Required element 'ns1:responseId' of XML schema type 'xsd:string'
        std::string responseId;
        /// Optional element 'ns1:responseDate' of XML schema type 'xsd:date'
        std::string *responseDate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RetrieveGetHistoryRequest
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__RetrieveGetHistoryRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RetrieveGetHistoryRequest, default initialized and not managed by a soap context
        virtual ns1__RetrieveGetHistoryRequest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__RetrieveGetHistoryRequest); }
      public:
        /// Constructor with default initializations
        ns1__RetrieveGetHistoryRequest() : responseId(), responseDate(), soap() { }
        virtual ~ns1__RetrieveGetHistoryRequest() { }
        /// Friend allocator used by soap_new_ns1__RetrieveGetHistoryRequest(struct soap*, int)
        friend SOAP_FMAC1 ns1__RetrieveGetHistoryRequest * SOAP_FMAC2 soap_instantiate_ns1__RetrieveGetHistoryRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:310 */
#ifndef SOAP_TYPE_ns1__SubmitCancelRequest
#define SOAP_TYPE_ns1__SubmitCancelRequest (83)
/* complex XML schema type 'ns1:SubmitCancelRequest': */
class SOAP_CMAC ns1__SubmitCancelRequest {
      public:
        /// Required element 'ns1:responseId' of XML schema type 'xsd:string'
        std::vector<std::string> responseId;
        /// Required element 'ns1:headers' of XML schema type 'ns1:CancelHeaders'
        ns1__CancelHeaders *headers;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SubmitCancelRequest
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__SubmitCancelRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SubmitCancelRequest, default initialized and not managed by a soap context
        virtual ns1__SubmitCancelRequest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__SubmitCancelRequest); }
      public:
        /// Constructor with default initializations
        ns1__SubmitCancelRequest() : responseId(), headers(), soap() { }
        virtual ~ns1__SubmitCancelRequest() { }
        /// Friend allocator used by soap_new_ns1__SubmitCancelRequest(struct soap*, int)
        friend SOAP_FMAC1 ns1__SubmitCancelRequest * SOAP_FMAC2 soap_instantiate_ns1__SubmitCancelRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:314 */
#ifndef SOAP_TYPE_ns1__RetrieveCancelRequest
#define SOAP_TYPE_ns1__RetrieveCancelRequest (85)
/* complex XML schema type 'ns1:RetrieveCancelRequest': */
class SOAP_CMAC ns1__RetrieveCancelRequest {
      public:
        /// Required element 'ns1:responseId' of XML schema type 'xsd:string'
        std::string responseId;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RetrieveCancelRequest
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__RetrieveCancelRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RetrieveCancelRequest, default initialized and not managed by a soap context
        virtual ns1__RetrieveCancelRequest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__RetrieveCancelRequest); }
      public:
        /// Constructor with default initializations
        ns1__RetrieveCancelRequest() : responseId(), soap() { }
        virtual ~ns1__RetrieveCancelRequest() { }
        /// Friend allocator used by soap_new_ns1__RetrieveCancelRequest(struct soap*, int)
        friend SOAP_FMAC1 ns1__RetrieveCancelRequest * SOAP_FMAC2 soap_instantiate_ns1__RetrieveCancelRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:318 */
#ifndef SOAP_TYPE_ns1__GetCorrectionsRequest
#define SOAP_TYPE_ns1__GetCorrectionsRequest (87)
/* complex XML schema type 'ns1:GetCorrectionsRequest': */
class SOAP_CMAC ns1__GetCorrectionsRequest {
      public:
        /// Optional element 'ns1:responseDate' of XML schema type 'xsd:date'
        std::string *responseDate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GetCorrectionsRequest
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__GetCorrectionsRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GetCorrectionsRequest, default initialized and not managed by a soap context
        virtual ns1__GetCorrectionsRequest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__GetCorrectionsRequest); }
      public:
        /// Constructor with default initializations
        ns1__GetCorrectionsRequest() : responseDate(), soap() { }
        virtual ~ns1__GetCorrectionsRequest() { }
        /// Friend allocator used by soap_new_ns1__GetCorrectionsRequest(struct soap*, int)
        friend SOAP_FMAC1 ns1__GetCorrectionsRequest * SOAP_FMAC2 soap_instantiate_ns1__GetCorrectionsRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:322 */
#ifndef SOAP_TYPE_ns1__SubmitScheduledRequest
#define SOAP_TYPE_ns1__SubmitScheduledRequest (89)
/* complex XML schema type 'ns1:SubmitScheduledRequest': */
class SOAP_CMAC ns1__SubmitScheduledRequest {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SubmitScheduledRequest
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__SubmitScheduledRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SubmitScheduledRequest, default initialized and not managed by a soap context
        virtual ns1__SubmitScheduledRequest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__SubmitScheduledRequest); }
      public:
        /// Constructor with default initializations
        ns1__SubmitScheduledRequest() : soap() { }
        virtual ~ns1__SubmitScheduledRequest() { }
        /// Friend allocator used by soap_new_ns1__SubmitScheduledRequest(struct soap*, int)
        friend SOAP_FMAC1 ns1__SubmitScheduledRequest * SOAP_FMAC2 soap_instantiate_ns1__SubmitScheduledRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:326 */
#ifndef SOAP_TYPE_ns1__RetrieveScheduledRequest
#define SOAP_TYPE_ns1__RetrieveScheduledRequest (91)
/* complex XML schema type 'ns1:RetrieveScheduledRequest': */
class SOAP_CMAC ns1__RetrieveScheduledRequest {
      public:
        /// Required element 'ns1:responseId' of XML schema type 'xsd:string'
        std::string responseId;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RetrieveScheduledRequest
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__RetrieveScheduledRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RetrieveScheduledRequest, default initialized and not managed by a soap context
        virtual ns1__RetrieveScheduledRequest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__RetrieveScheduledRequest); }
      public:
        /// Constructor with default initializations
        ns1__RetrieveScheduledRequest() : responseId(), soap() { }
        virtual ~ns1__RetrieveScheduledRequest() { }
        /// Friend allocator used by soap_new_ns1__RetrieveScheduledRequest(struct soap*, int)
        friend SOAP_FMAC1 ns1__RetrieveScheduledRequest * SOAP_FMAC2 soap_instantiate_ns1__RetrieveScheduledRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:328 */
#ifndef SOAP_TYPE_ns1__ScheduledResponses
#define SOAP_TYPE_ns1__ScheduledResponses (92)
/* complex XML schema type 'ns1:ScheduledResponses': */
class SOAP_CMAC ns1__ScheduledResponses {
      public:
        /// Optional element 'ns1:fileData' of XML schema type 'ns1:ScheduledResponse'
        std::vector<ns1__ScheduledResponse *> fileData;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ScheduledResponses
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ScheduledResponses; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ScheduledResponses, default initialized and not managed by a soap context
        virtual ns1__ScheduledResponses *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ScheduledResponses); }
      public:
        /// Constructor with default initializations
        ns1__ScheduledResponses() : fileData(), soap() { }
        virtual ~ns1__ScheduledResponses() { }
        /// Friend allocator used by soap_new_ns1__ScheduledResponses(struct soap*, int)
        friend SOAP_FMAC1 ns1__ScheduledResponses * SOAP_FMAC2 soap_instantiate_ns1__ScheduledResponses(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:330 */
#ifndef SOAP_TYPE_ns1__ScheduledResponse
#define SOAP_TYPE_ns1__ScheduledResponse (93)
/* complex XML schema type 'ns1:ScheduledResponse': */
class SOAP_CMAC ns1__ScheduledResponse {
      public:
        /// Optional element 'ns1:headers' of XML schema type 'ns1:ScheduledHeaders'
        ns1__ScheduledHeaders *headers;
        /// Optional element 'ns1:fields' of XML schema type 'ns1:Fields'
        ns1__Fields *fields;
        /// Optional element 'ns1:bvalfieldsets' of XML schema type 'ns1:BvalFieldSets'
        ns1__BvalFieldSets *bvalfieldsets;
        /// Optional element 'ns1:fieldsets' of XML schema type 'ns1:FieldSets'
        ns1__FieldSets *fieldsets;
        /// Optional element 'ns1:instruments' of XML schema type 'ns1:Instruments'
        ns1__Instruments *instruments;
        /// Optional element 'ns1:responseId' of XML schema type 'xsd:string'
        std::string *responseId;
        /// Optional element 'ns1:time' of XML schema type 'xsd:time'
        std::string *time;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ScheduledResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ScheduledResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ScheduledResponse, default initialized and not managed by a soap context
        virtual ns1__ScheduledResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ScheduledResponse); }
      public:
        /// Constructor with default initializations
        ns1__ScheduledResponse() : headers(), fields(), bvalfieldsets(), fieldsets(), instruments(), responseId(), time(), soap() { }
        virtual ~ns1__ScheduledResponse() { }
        /// Friend allocator used by soap_new_ns1__ScheduledResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__ScheduledResponse * SOAP_FMAC2 soap_instantiate_ns1__ScheduledResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:334 */
#ifndef SOAP_TYPE_ns1__SubmitGetFundamentalsRequest
#define SOAP_TYPE_ns1__SubmitGetFundamentalsRequest (95)
/* complex XML schema type 'ns1:SubmitGetFundamentalsRequest': */
class SOAP_CMAC ns1__SubmitGetFundamentalsRequest {
      public:
        /// Required element 'ns1:headers' of XML schema type 'ns1:GetFundamentalsHeaders'
        ns1__GetFundamentalsHeaders *headers;
        /// Required element 'ns1:fields' of XML schema type 'ns1:Fields'
        ns1__Fields *fields;
        /// Required element 'ns1:instruments' of XML schema type 'ns1:FundInstruments'
        ns1__FundInstruments *instruments;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SubmitGetFundamentalsRequest
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__SubmitGetFundamentalsRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SubmitGetFundamentalsRequest, default initialized and not managed by a soap context
        virtual ns1__SubmitGetFundamentalsRequest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__SubmitGetFundamentalsRequest); }
      public:
        /// Constructor with default initializations
        ns1__SubmitGetFundamentalsRequest() : headers(), fields(), instruments(), soap() { }
        virtual ~ns1__SubmitGetFundamentalsRequest() { }
        /// Friend allocator used by soap_new_ns1__SubmitGetFundamentalsRequest(struct soap*, int)
        friend SOAP_FMAC1 ns1__SubmitGetFundamentalsRequest * SOAP_FMAC2 soap_instantiate_ns1__SubmitGetFundamentalsRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:338 */
#ifndef SOAP_TYPE_ns1__RetrieveGetFundamentalsRequest
#define SOAP_TYPE_ns1__RetrieveGetFundamentalsRequest (97)
/* complex XML schema type 'ns1:RetrieveGetFundamentalsRequest': */
class SOAP_CMAC ns1__RetrieveGetFundamentalsRequest {
      public:
        /// Required element 'ns1:responseId' of XML schema type 'xsd:string'
        std::string responseId;
        /// Optional element 'ns1:responseDate' of XML schema type 'xsd:date'
        std::string *responseDate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RetrieveGetFundamentalsRequest
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__RetrieveGetFundamentalsRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RetrieveGetFundamentalsRequest, default initialized and not managed by a soap context
        virtual ns1__RetrieveGetFundamentalsRequest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__RetrieveGetFundamentalsRequest); }
      public:
        /// Constructor with default initializations
        ns1__RetrieveGetFundamentalsRequest() : responseId(), responseDate(), soap() { }
        virtual ~ns1__RetrieveGetFundamentalsRequest() { }
        /// Friend allocator used by soap_new_ns1__RetrieveGetFundamentalsRequest(struct soap*, int)
        friend SOAP_FMAC1 ns1__RetrieveGetFundamentalsRequest * SOAP_FMAC2 soap_instantiate_ns1__RetrieveGetFundamentalsRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:342 */
#ifndef SOAP_TYPE_ns1__SubmitGetCompanyRequest
#define SOAP_TYPE_ns1__SubmitGetCompanyRequest (99)
/* complex XML schema type 'ns1:SubmitGetCompanyRequest': */
class SOAP_CMAC ns1__SubmitGetCompanyRequest {
      public:
        /// Required element 'ns1:headers' of XML schema type 'ns1:GetCompanyHeaders'
        ns1__GetCompanyHeaders *headers;
        /// Optional element 'ns1:fieldset' of XML schema type 'ns1:FieldSet'
        ns1__FieldSet *fieldset;
        /// Optional element 'ns1:fields' of XML schema type 'ns1:Fields'
        ns1__Fields *fields;
        /// Required element 'ns1:instruments' of XML schema type 'ns1:Instruments'
        ns1__Instruments *instruments;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SubmitGetCompanyRequest
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__SubmitGetCompanyRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SubmitGetCompanyRequest, default initialized and not managed by a soap context
        virtual ns1__SubmitGetCompanyRequest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__SubmitGetCompanyRequest); }
      public:
        /// Constructor with default initializations
        ns1__SubmitGetCompanyRequest() : headers(), fieldset(), fields(), instruments(), soap() { }
        virtual ~ns1__SubmitGetCompanyRequest() { }
        /// Friend allocator used by soap_new_ns1__SubmitGetCompanyRequest(struct soap*, int)
        friend SOAP_FMAC1 ns1__SubmitGetCompanyRequest * SOAP_FMAC2 soap_instantiate_ns1__SubmitGetCompanyRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:346 */
#ifndef SOAP_TYPE_ns1__RetrieveGetCompanyRequest
#define SOAP_TYPE_ns1__RetrieveGetCompanyRequest (101)
/* complex XML schema type 'ns1:RetrieveGetCompanyRequest': */
class SOAP_CMAC ns1__RetrieveGetCompanyRequest {
      public:
        /// Required element 'ns1:responseId' of XML schema type 'xsd:string'
        std::string responseId;
        /// Optional element 'ns1:responseDate' of XML schema type 'xsd:date'
        std::string *responseDate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RetrieveGetCompanyRequest
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__RetrieveGetCompanyRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RetrieveGetCompanyRequest, default initialized and not managed by a soap context
        virtual ns1__RetrieveGetCompanyRequest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__RetrieveGetCompanyRequest); }
      public:
        /// Constructor with default initializations
        ns1__RetrieveGetCompanyRequest() : responseId(), responseDate(), soap() { }
        virtual ~ns1__RetrieveGetCompanyRequest() { }
        /// Friend allocator used by soap_new_ns1__RetrieveGetCompanyRequest(struct soap*, int)
        friend SOAP_FMAC1 ns1__RetrieveGetCompanyRequest * SOAP_FMAC2 soap_instantiate_ns1__RetrieveGetCompanyRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:350 */
#ifndef SOAP_TYPE_ns1__GetPortfolioValidationRequest
#define SOAP_TYPE_ns1__GetPortfolioValidationRequest (103)
/* complex XML schema type 'ns1:GetPortfolioValidationRequest': */
class SOAP_CMAC ns1__GetPortfolioValidationRequest {
      public:
        /// Required element 'ns1:responseId' of XML schema type 'xsd:string'
        std::string responseId;
        /// Optional element 'ns1:responseDate' of XML schema type 'xsd:date'
        std::string *responseDate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GetPortfolioValidationRequest
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__GetPortfolioValidationRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GetPortfolioValidationRequest, default initialized and not managed by a soap context
        virtual ns1__GetPortfolioValidationRequest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__GetPortfolioValidationRequest); }
      public:
        /// Constructor with default initializations
        ns1__GetPortfolioValidationRequest() : responseId(), responseDate(), soap() { }
        virtual ~ns1__GetPortfolioValidationRequest() { }
        /// Friend allocator used by soap_new_ns1__GetPortfolioValidationRequest(struct soap*, int)
        friend SOAP_FMAC1 ns1__GetPortfolioValidationRequest * SOAP_FMAC2 soap_instantiate_ns1__GetPortfolioValidationRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:354 */
#ifndef SOAP_TYPE_ns1__SubmitGetActionsRequest
#define SOAP_TYPE_ns1__SubmitGetActionsRequest (105)
/* complex XML schema type 'ns1:SubmitGetActionsRequest': */
class SOAP_CMAC ns1__SubmitGetActionsRequest {
      public:
        /// Required element 'ns1:headers' of XML schema type 'ns1:GetActionsHeaders'
        ns1__GetActionsHeaders *headers;
        /// Required element 'ns1:instruments' of XML schema type 'ns1:Instruments'
        ns1__Instruments *instruments;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SubmitGetActionsRequest
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__SubmitGetActionsRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SubmitGetActionsRequest, default initialized and not managed by a soap context
        virtual ns1__SubmitGetActionsRequest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__SubmitGetActionsRequest); }
      public:
        /// Constructor with default initializations
        ns1__SubmitGetActionsRequest() : headers(), instruments(), soap() { }
        virtual ~ns1__SubmitGetActionsRequest() { }
        /// Friend allocator used by soap_new_ns1__SubmitGetActionsRequest(struct soap*, int)
        friend SOAP_FMAC1 ns1__SubmitGetActionsRequest * SOAP_FMAC2 soap_instantiate_ns1__SubmitGetActionsRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:358 */
#ifndef SOAP_TYPE_ns1__RetrieveGetActionsRequest
#define SOAP_TYPE_ns1__RetrieveGetActionsRequest (107)
/* complex XML schema type 'ns1:RetrieveGetActionsRequest': */
class SOAP_CMAC ns1__RetrieveGetActionsRequest {
      public:
        /// Required element 'ns1:responseId' of XML schema type 'xsd:string'
        std::string responseId;
        /// Optional element 'ns1:responseDate' of XML schema type 'xsd:date'
        std::string *responseDate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RetrieveGetActionsRequest
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__RetrieveGetActionsRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RetrieveGetActionsRequest, default initialized and not managed by a soap context
        virtual ns1__RetrieveGetActionsRequest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__RetrieveGetActionsRequest); }
      public:
        /// Constructor with default initializations
        ns1__RetrieveGetActionsRequest() : responseId(), responseDate(), soap() { }
        virtual ~ns1__RetrieveGetActionsRequest() { }
        /// Friend allocator used by soap_new_ns1__RetrieveGetActionsRequest(struct soap*, int)
        friend SOAP_FMAC1 ns1__RetrieveGetActionsRequest * SOAP_FMAC2 soap_instantiate_ns1__RetrieveGetActionsRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:362 */
#ifndef SOAP_TYPE_ns1__SubmitGetQuotesRequest
#define SOAP_TYPE_ns1__SubmitGetQuotesRequest (109)
/* complex XML schema type 'ns1:SubmitGetQuotesRequest': */
class SOAP_CMAC ns1__SubmitGetQuotesRequest {
      public:
        /// Required element 'ns1:headers' of XML schema type 'ns1:QuotesHeaders'
        ns1__QuotesHeaders *headers;
        /// Required element 'ns1:instruments' of XML schema type 'ns1:Instruments'
        ns1__Instruments *instruments;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SubmitGetQuotesRequest
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__SubmitGetQuotesRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SubmitGetQuotesRequest, default initialized and not managed by a soap context
        virtual ns1__SubmitGetQuotesRequest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__SubmitGetQuotesRequest); }
      public:
        /// Constructor with default initializations
        ns1__SubmitGetQuotesRequest() : headers(), instruments(), soap() { }
        virtual ~ns1__SubmitGetQuotesRequest() { }
        /// Friend allocator used by soap_new_ns1__SubmitGetQuotesRequest(struct soap*, int)
        friend SOAP_FMAC1 ns1__SubmitGetQuotesRequest * SOAP_FMAC2 soap_instantiate_ns1__SubmitGetQuotesRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:366 */
#ifndef SOAP_TYPE_ns1__RetrieveGetQuotesRequest
#define SOAP_TYPE_ns1__RetrieveGetQuotesRequest (111)
/* complex XML schema type 'ns1:RetrieveGetQuotesRequest': */
class SOAP_CMAC ns1__RetrieveGetQuotesRequest {
      public:
        /// Required element 'ns1:responseId' of XML schema type 'xsd:string'
        std::string responseId;
        /// Optional element 'ns1:responseDate' of XML schema type 'xsd:date'
        std::string *responseDate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RetrieveGetQuotesRequest
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__RetrieveGetQuotesRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RetrieveGetQuotesRequest, default initialized and not managed by a soap context
        virtual ns1__RetrieveGetQuotesRequest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__RetrieveGetQuotesRequest); }
      public:
        /// Constructor with default initializations
        ns1__RetrieveGetQuotesRequest() : responseId(), responseDate(), soap() { }
        virtual ~ns1__RetrieveGetQuotesRequest() { }
        /// Friend allocator used by soap_new_ns1__RetrieveGetQuotesRequest(struct soap*, int)
        friend SOAP_FMAC1 ns1__RetrieveGetQuotesRequest * SOAP_FMAC2 soap_instantiate_ns1__RetrieveGetQuotesRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:370 */
#ifndef SOAP_TYPE_ns1__SubmitGetAllQuotesRequest
#define SOAP_TYPE_ns1__SubmitGetAllQuotesRequest (113)
/* complex XML schema type 'ns1:SubmitGetAllQuotesRequest': */
class SOAP_CMAC ns1__SubmitGetAllQuotesRequest {
      public:
        /// Required element 'ns1:headers' of XML schema type 'ns1:QuotesHeaders'
        ns1__QuotesHeaders *headers;
        /// Required element 'ns1:instruments' of XML schema type 'ns1:Instruments'
        ns1__Instruments *instruments;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SubmitGetAllQuotesRequest
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__SubmitGetAllQuotesRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SubmitGetAllQuotesRequest, default initialized and not managed by a soap context
        virtual ns1__SubmitGetAllQuotesRequest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__SubmitGetAllQuotesRequest); }
      public:
        /// Constructor with default initializations
        ns1__SubmitGetAllQuotesRequest() : headers(), instruments(), soap() { }
        virtual ~ns1__SubmitGetAllQuotesRequest() { }
        /// Friend allocator used by soap_new_ns1__SubmitGetAllQuotesRequest(struct soap*, int)
        friend SOAP_FMAC1 ns1__SubmitGetAllQuotesRequest * SOAP_FMAC2 soap_instantiate_ns1__SubmitGetAllQuotesRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:374 */
#ifndef SOAP_TYPE_ns1__RetrieveGetAllQuotesRequest
#define SOAP_TYPE_ns1__RetrieveGetAllQuotesRequest (115)
/* complex XML schema type 'ns1:RetrieveGetAllQuotesRequest': */
class SOAP_CMAC ns1__RetrieveGetAllQuotesRequest {
      public:
        /// Required element 'ns1:responseId' of XML schema type 'xsd:string'
        std::string responseId;
        /// Optional element 'ns1:responseDate' of XML schema type 'xsd:date'
        std::string *responseDate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RetrieveGetAllQuotesRequest
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__RetrieveGetAllQuotesRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RetrieveGetAllQuotesRequest, default initialized and not managed by a soap context
        virtual ns1__RetrieveGetAllQuotesRequest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__RetrieveGetAllQuotesRequest); }
      public:
        /// Constructor with default initializations
        ns1__RetrieveGetAllQuotesRequest() : responseId(), responseDate(), soap() { }
        virtual ~ns1__RetrieveGetAllQuotesRequest() { }
        /// Friend allocator used by soap_new_ns1__RetrieveGetAllQuotesRequest(struct soap*, int)
        friend SOAP_FMAC1 ns1__RetrieveGetAllQuotesRequest * SOAP_FMAC2 soap_instantiate_ns1__RetrieveGetAllQuotesRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:378 */
#ifndef SOAP_TYPE_ns1__SubmitOtcbvalUploadRequest
#define SOAP_TYPE_ns1__SubmitOtcbvalUploadRequest (117)
/* complex XML schema type 'ns1:SubmitOtcbvalUploadRequest': */
class SOAP_CMAC ns1__SubmitOtcbvalUploadRequest {
      public:
        /// Required element 'ns1:usernumber' of XML schema type 'xsd:int'
        int usernumber;
        /// Required element 'ns1:otcBvalHeaders' of XML schema type 'ns1:OtcBvalHeaders'
        ns1__OtcBvalHeaders *otcBvalHeaders;
        /// Required element 'ns1:fileContent' of XML schema type 'xsd:string'
        std::string fileContent;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SubmitOtcbvalUploadRequest
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__SubmitOtcbvalUploadRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SubmitOtcbvalUploadRequest, default initialized and not managed by a soap context
        virtual ns1__SubmitOtcbvalUploadRequest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__SubmitOtcbvalUploadRequest); }
      public:
        /// Constructor with default initializations
        ns1__SubmitOtcbvalUploadRequest() : usernumber(), otcBvalHeaders(), fileContent(), soap() { }
        virtual ~ns1__SubmitOtcbvalUploadRequest() { }
        /// Friend allocator used by soap_new_ns1__SubmitOtcbvalUploadRequest(struct soap*, int)
        friend SOAP_FMAC1 ns1__SubmitOtcbvalUploadRequest * SOAP_FMAC2 soap_instantiate_ns1__SubmitOtcbvalUploadRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:382 */
#ifndef SOAP_TYPE_ns1__RetrieveOtcbvalUploadRequest
#define SOAP_TYPE_ns1__RetrieveOtcbvalUploadRequest (119)
/* complex XML schema type 'ns1:RetrieveOtcbvalUploadRequest': */
class SOAP_CMAC ns1__RetrieveOtcbvalUploadRequest {
      public:
        /// Required element 'ns1:responseId' of XML schema type 'xsd:string'
        std::string responseId;
        /// Optional element 'ns1:responseDate' of XML schema type 'xsd:date'
        std::string *responseDate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RetrieveOtcbvalUploadRequest
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__RetrieveOtcbvalUploadRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RetrieveOtcbvalUploadRequest, default initialized and not managed by a soap context
        virtual ns1__RetrieveOtcbvalUploadRequest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__RetrieveOtcbvalUploadRequest); }
      public:
        /// Constructor with default initializations
        ns1__RetrieveOtcbvalUploadRequest() : responseId(), responseDate(), soap() { }
        virtual ~ns1__RetrieveOtcbvalUploadRequest() { }
        /// Friend allocator used by soap_new_ns1__RetrieveOtcbvalUploadRequest(struct soap*, int)
        friend SOAP_FMAC1 ns1__RetrieveOtcbvalUploadRequest * SOAP_FMAC2 soap_instantiate_ns1__RetrieveOtcbvalUploadRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:386 */
#ifndef SOAP_TYPE_ns1__SubmitOtcBvalDealsUploadRequest
#define SOAP_TYPE_ns1__SubmitOtcBvalDealsUploadRequest (121)
/* complex XML schema type 'ns1:SubmitOtcBvalDealsUploadRequest': */
class SOAP_CMAC ns1__SubmitOtcBvalDealsUploadRequest {
      public:
        /// Required element 'ns1:usernumber' of XML schema type 'xsd:int'
        int usernumber;
        /// Required element 'ns1:otcBvalHeaders' of XML schema type 'ns1:OtcBvalHeaders'
        ns1__OtcBvalHeaders *otcBvalHeaders;
        /// Required element 'ns1:fileContent' of XML schema type 'xsd:string'
        std::string fileContent;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SubmitOtcBvalDealsUploadRequest
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__SubmitOtcBvalDealsUploadRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SubmitOtcBvalDealsUploadRequest, default initialized and not managed by a soap context
        virtual ns1__SubmitOtcBvalDealsUploadRequest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__SubmitOtcBvalDealsUploadRequest); }
      public:
        /// Constructor with default initializations
        ns1__SubmitOtcBvalDealsUploadRequest() : usernumber(), otcBvalHeaders(), fileContent(), soap() { }
        virtual ~ns1__SubmitOtcBvalDealsUploadRequest() { }
        /// Friend allocator used by soap_new_ns1__SubmitOtcBvalDealsUploadRequest(struct soap*, int)
        friend SOAP_FMAC1 ns1__SubmitOtcBvalDealsUploadRequest * SOAP_FMAC2 soap_instantiate_ns1__SubmitOtcBvalDealsUploadRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:390 */
#ifndef SOAP_TYPE_ns1__RetrieveOtcBvalDealsUploadRequest
#define SOAP_TYPE_ns1__RetrieveOtcBvalDealsUploadRequest (123)
/* complex XML schema type 'ns1:RetrieveOtcBvalDealsUploadRequest': */
class SOAP_CMAC ns1__RetrieveOtcBvalDealsUploadRequest {
      public:
        /// Required element 'ns1:responseId' of XML schema type 'xsd:string'
        std::string responseId;
        /// Optional element 'ns1:responseDate' of XML schema type 'xsd:date'
        std::string *responseDate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RetrieveOtcBvalDealsUploadRequest
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__RetrieveOtcBvalDealsUploadRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RetrieveOtcBvalDealsUploadRequest, default initialized and not managed by a soap context
        virtual ns1__RetrieveOtcBvalDealsUploadRequest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__RetrieveOtcBvalDealsUploadRequest); }
      public:
        /// Constructor with default initializations
        ns1__RetrieveOtcBvalDealsUploadRequest() : responseId(), responseDate(), soap() { }
        virtual ~ns1__RetrieveOtcBvalDealsUploadRequest() { }
        /// Friend allocator used by soap_new_ns1__RetrieveOtcBvalDealsUploadRequest(struct soap*, int)
        friend SOAP_FMAC1 ns1__RetrieveOtcBvalDealsUploadRequest * SOAP_FMAC2 soap_instantiate_ns1__RetrieveOtcBvalDealsUploadRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:394 */
#ifndef SOAP_TYPE_ns1__GetFieldsRequest
#define SOAP_TYPE_ns1__GetFieldsRequest (125)
/* complex XML schema type 'ns1:GetFieldsRequest': */
class SOAP_CMAC ns1__GetFieldsRequest {
      public:
        /// Required element 'ns1:criteria' of XML schema type 'ns1:FieldSearchCriteria'
        ns1__FieldSearchCriteria *criteria;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GetFieldsRequest
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__GetFieldsRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GetFieldsRequest, default initialized and not managed by a soap context
        virtual ns1__GetFieldsRequest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__GetFieldsRequest); }
      public:
        /// Constructor with default initializations
        ns1__GetFieldsRequest() : criteria(), soap() { }
        virtual ~ns1__GetFieldsRequest() { }
        /// Friend allocator used by soap_new_ns1__GetFieldsRequest(struct soap*, int)
        friend SOAP_FMAC1 ns1__GetFieldsRequest * SOAP_FMAC2 soap_instantiate_ns1__GetFieldsRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:398 */
#ifndef SOAP_TYPE_ns1__MmktBvalHeaders
#define SOAP_TYPE_ns1__MmktBvalHeaders (127)
/* complex XML schema type 'ns1:MmktBvalHeaders': */
class SOAP_CMAC ns1__MmktBvalHeaders {
      public:
        /// Required element 'ns1:contentType' of XML schema type 'xsd:string'
        std::string contentType;
        /// Required element 'ns1:mimeVersion' of XML schema type 'xsd:string'
        std::string mimeVersion;
        /// Required element 'ns1:contentEncoding' of XML schema type 'xsd:string'
        std::string contentEncoding;
        /// Required element 'ns1:contentDisposition' of XML schema type 'xsd:string'
        std::string contentDisposition;
        /// Required element 'ns1:fileName' of XML schema type 'xsd:string'
        std::string fileName;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MmktBvalHeaders
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__MmktBvalHeaders; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MmktBvalHeaders, default initialized and not managed by a soap context
        virtual ns1__MmktBvalHeaders *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__MmktBvalHeaders); }
      public:
        /// Constructor with default initializations
        ns1__MmktBvalHeaders() : contentType(), mimeVersion(), contentEncoding(), contentDisposition(), fileName(), soap() { }
        virtual ~ns1__MmktBvalHeaders() { }
        /// Friend allocator used by soap_new_ns1__MmktBvalHeaders(struct soap*, int)
        friend SOAP_FMAC1 ns1__MmktBvalHeaders * SOAP_FMAC2 soap_instantiate_ns1__MmktBvalHeaders(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:400 */
#ifndef SOAP_TYPE_ns1__SubmitMmktBvalDealsUploadRequest
#define SOAP_TYPE_ns1__SubmitMmktBvalDealsUploadRequest (128)
/* complex XML schema type 'ns1:SubmitMmktBvalDealsUploadRequest': */
class SOAP_CMAC ns1__SubmitMmktBvalDealsUploadRequest {
      public:
        /// Required element 'ns1:usernumber' of XML schema type 'xsd:int'
        int usernumber;
        /// Required element 'ns1:mmktBvalHeaders' of XML schema type 'ns1:MmktBvalHeaders'
        ns1__MmktBvalHeaders *mmktBvalHeaders;
        /// Required element 'ns1:fileContent' of XML schema type 'xsd:string'
        std::string fileContent;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SubmitMmktBvalDealsUploadRequest
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__SubmitMmktBvalDealsUploadRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SubmitMmktBvalDealsUploadRequest, default initialized and not managed by a soap context
        virtual ns1__SubmitMmktBvalDealsUploadRequest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__SubmitMmktBvalDealsUploadRequest); }
      public:
        /// Constructor with default initializations
        ns1__SubmitMmktBvalDealsUploadRequest() : usernumber(), mmktBvalHeaders(), fileContent(), soap() { }
        virtual ~ns1__SubmitMmktBvalDealsUploadRequest() { }
        /// Friend allocator used by soap_new_ns1__SubmitMmktBvalDealsUploadRequest(struct soap*, int)
        friend SOAP_FMAC1 ns1__SubmitMmktBvalDealsUploadRequest * SOAP_FMAC2 soap_instantiate_ns1__SubmitMmktBvalDealsUploadRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:404 */
#ifndef SOAP_TYPE_ns1__RetrieveMmktBvalDealsUploadRequest
#define SOAP_TYPE_ns1__RetrieveMmktBvalDealsUploadRequest (130)
/* complex XML schema type 'ns1:RetrieveMmktBvalDealsUploadRequest': */
class SOAP_CMAC ns1__RetrieveMmktBvalDealsUploadRequest {
      public:
        /// Required element 'ns1:responseId' of XML schema type 'xsd:string'
        std::string responseId;
        /// Optional element 'ns1:responseDate' of XML schema type 'xsd:date'
        std::string *responseDate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RetrieveMmktBvalDealsUploadRequest
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__RetrieveMmktBvalDealsUploadRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RetrieveMmktBvalDealsUploadRequest, default initialized and not managed by a soap context
        virtual ns1__RetrieveMmktBvalDealsUploadRequest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__RetrieveMmktBvalDealsUploadRequest); }
      public:
        /// Constructor with default initializations
        ns1__RetrieveMmktBvalDealsUploadRequest() : responseId(), responseDate(), soap() { }
        virtual ~ns1__RetrieveMmktBvalDealsUploadRequest() { }
        /// Friend allocator used by soap_new_ns1__RetrieveMmktBvalDealsUploadRequest(struct soap*, int)
        friend SOAP_FMAC1 ns1__RetrieveMmktBvalDealsUploadRequest * SOAP_FMAC2 soap_instantiate_ns1__RetrieveMmktBvalDealsUploadRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:406 */
#ifndef SOAP_TYPE_ns1__MmktBvalDealInformation
#define SOAP_TYPE_ns1__MmktBvalDealInformation (131)
/* complex XML schema type 'ns1:MmktBvalDealInformation': */
class SOAP_CMAC ns1__MmktBvalDealInformation {
      public:
        /// Required element 'ns1:statusCode' of XML schema type 'ns1:ResponseStatus'
        ns1__ResponseStatus *statusCode;
        /// Optional element 'ns1:clientDealId' of XML schema type 'xsd:string'
        std::string *clientDealId;
        /// Optional element 'ns1:bbDealId' of XML schema type 'xsd:string'
        std::string *bbDealId;
        /// Optional element 'ns1:dtcCusip' of XML schema type 'xsd:string'
        std::string *dtcCusip;
        /// Optional element 'ns1:ticker' of XML schema type 'xsd:string'
        std::string *ticker;
        /// Optional element 'ns1:programType' of XML schema type 'xsd:string'
        std::string *programType;
        /// Optional element 'ns1:currency' of XML schema type 'xsd:string'
        std::string *currency;
        /// Optional element 'ns1:maturity' of XML schema type 'xsd:date'
        std::string *maturity;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MmktBvalDealInformation
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__MmktBvalDealInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MmktBvalDealInformation, default initialized and not managed by a soap context
        virtual ns1__MmktBvalDealInformation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__MmktBvalDealInformation); }
      public:
        /// Constructor with default initializations
        ns1__MmktBvalDealInformation() : statusCode(), clientDealId(), bbDealId(), dtcCusip(), ticker(), programType(), currency(), maturity(), soap() { }
        virtual ~ns1__MmktBvalDealInformation() { }
        /// Friend allocator used by soap_new_ns1__MmktBvalDealInformation(struct soap*, int)
        friend SOAP_FMAC1 ns1__MmktBvalDealInformation * SOAP_FMAC2 soap_instantiate_ns1__MmktBvalDealInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:408 */
#ifndef SOAP_TYPE_ns1__MmktBvalDealInfos
#define SOAP_TYPE_ns1__MmktBvalDealInfos (132)
/* complex XML schema type 'ns1:MmktBvalDealInfos': */
class SOAP_CMAC ns1__MmktBvalDealInfos {
      public:
        /// Optional element 'ns1:deal' of XML schema type 'ns1:MmktBvalDealInformation'
        std::vector<ns1__MmktBvalDealInformation *> deal;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MmktBvalDealInfos
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__MmktBvalDealInfos; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MmktBvalDealInfos, default initialized and not managed by a soap context
        virtual ns1__MmktBvalDealInfos *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__MmktBvalDealInfos); }
      public:
        /// Constructor with default initializations
        ns1__MmktBvalDealInfos() : deal(), soap() { }
        virtual ~ns1__MmktBvalDealInfos() { }
        /// Friend allocator used by soap_new_ns1__MmktBvalDealInfos(struct soap*, int)
        friend SOAP_FMAC1 ns1__MmktBvalDealInfos * SOAP_FMAC2 soap_instantiate_ns1__MmktBvalDealInfos(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:296 */
#ifndef SOAP_TYPE_ns1__SubmitGetDataResponse
#define SOAP_TYPE_ns1__SubmitGetDataResponse (76)
/* complex XML schema type 'ns1:SubmitGetDataResponse': */
class SOAP_CMAC ns1__SubmitGetDataResponse : public ns1__PerSecurityResponse {
      public:
        /// Required element 'ns1:responseId' of XML schema type 'xsd:string'
        std::string responseId;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SubmitGetDataResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__SubmitGetDataResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SubmitGetDataResponse, default initialized and not managed by a soap context
        virtual ns1__SubmitGetDataResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__SubmitGetDataResponse); }
      public:
        /// Constructor with default initializations
        ns1__SubmitGetDataResponse() : responseId() { }
        virtual ~ns1__SubmitGetDataResponse() { }
        /// Friend allocator used by soap_new_ns1__SubmitGetDataResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__SubmitGetDataResponse * SOAP_FMAC2 soap_instantiate_ns1__SubmitGetDataResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:300 */
#ifndef SOAP_TYPE_ns1__RetrieveGetDataResponse
#define SOAP_TYPE_ns1__RetrieveGetDataResponse (78)
/* complex XML schema type 'ns1:RetrieveGetDataResponse': */
class SOAP_CMAC ns1__RetrieveGetDataResponse : public ns1__PerSecurityResponse {
      public:
        /// Required element 'ns1:responseId' of XML schema type 'xsd:string'
        std::string responseId;
        /// Optional element 'ns1:headers' of XML schema type 'ns1:GetDataHeaders'
        ns1__GetDataHeaders *headers;
        /// Optional element 'ns1:fields' of XML schema type 'ns1:Fields'
        ns1__Fields *fields;
        /// Optional element 'ns1:timestarted' of XML schema type 'xsd:dateTime'
        time_t *timestarted;
        /// Optional element 'ns1:instrumentDatas' of XML schema type 'ns1:InstrumentDatas'
        ns1__InstrumentDatas *instrumentDatas;
        /// Optional element 'ns1:timefinished' of XML schema type 'xsd:dateTime'
        time_t *timefinished;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RetrieveGetDataResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__RetrieveGetDataResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RetrieveGetDataResponse, default initialized and not managed by a soap context
        virtual ns1__RetrieveGetDataResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__RetrieveGetDataResponse); }
      public:
        /// Constructor with default initializations
        ns1__RetrieveGetDataResponse() : responseId(), headers(), fields(), timestarted(), instrumentDatas(), timefinished() { }
        virtual ~ns1__RetrieveGetDataResponse() { }
        /// Friend allocator used by soap_new_ns1__RetrieveGetDataResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__RetrieveGetDataResponse * SOAP_FMAC2 soap_instantiate_ns1__RetrieveGetDataResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:304 */
#ifndef SOAP_TYPE_ns1__SubmitGetHistoryResponse
#define SOAP_TYPE_ns1__SubmitGetHistoryResponse (80)
/* complex XML schema type 'ns1:SubmitGetHistoryResponse': */
class SOAP_CMAC ns1__SubmitGetHistoryResponse : public ns1__PerSecurityResponse {
      public:
        /// Required element 'ns1:responseId' of XML schema type 'xsd:string'
        std::string responseId;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SubmitGetHistoryResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__SubmitGetHistoryResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SubmitGetHistoryResponse, default initialized and not managed by a soap context
        virtual ns1__SubmitGetHistoryResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__SubmitGetHistoryResponse); }
      public:
        /// Constructor with default initializations
        ns1__SubmitGetHistoryResponse() : responseId() { }
        virtual ~ns1__SubmitGetHistoryResponse() { }
        /// Friend allocator used by soap_new_ns1__SubmitGetHistoryResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__SubmitGetHistoryResponse * SOAP_FMAC2 soap_instantiate_ns1__SubmitGetHistoryResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:308 */
#ifndef SOAP_TYPE_ns1__RetrieveGetHistoryResponse
#define SOAP_TYPE_ns1__RetrieveGetHistoryResponse (82)
/* complex XML schema type 'ns1:RetrieveGetHistoryResponse': */
class SOAP_CMAC ns1__RetrieveGetHistoryResponse : public ns1__PerSecurityResponse {
      public:
        /// Required element 'ns1:responseId' of XML schema type 'xsd:string'
        std::string responseId;
        /// Optional element 'ns1:headers' of XML schema type 'ns1:GetHistoryHeaders'
        ns1__GetHistoryHeaders *headers;
        /// Optional element 'ns1:fields' of XML schema type 'ns1:Fields'
        ns1__Fields *fields;
        /// Optional element 'ns1:timestarted' of XML schema type 'xsd:dateTime'
        time_t *timestarted;
        /// Optional element 'ns1:instrumentDatas' of XML schema type 'ns1:HistInstrumentDatas'
        ns1__HistInstrumentDatas *instrumentDatas;
        /// Optional element 'ns1:timefinished' of XML schema type 'xsd:dateTime'
        time_t *timefinished;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RetrieveGetHistoryResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__RetrieveGetHistoryResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RetrieveGetHistoryResponse, default initialized and not managed by a soap context
        virtual ns1__RetrieveGetHistoryResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__RetrieveGetHistoryResponse); }
      public:
        /// Constructor with default initializations
        ns1__RetrieveGetHistoryResponse() : responseId(), headers(), fields(), timestarted(), instrumentDatas(), timefinished() { }
        virtual ~ns1__RetrieveGetHistoryResponse() { }
        /// Friend allocator used by soap_new_ns1__RetrieveGetHistoryResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__RetrieveGetHistoryResponse * SOAP_FMAC2 soap_instantiate_ns1__RetrieveGetHistoryResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:312 */
#ifndef SOAP_TYPE_ns1__SubmitCancelResponse
#define SOAP_TYPE_ns1__SubmitCancelResponse (84)
/* complex XML schema type 'ns1:SubmitCancelResponse': */
class SOAP_CMAC ns1__SubmitCancelResponse : public ns1__PerSecurityResponse {
      public:
        /// Required element 'ns1:responseId' of XML schema type 'xsd:string'
        std::string responseId;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SubmitCancelResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__SubmitCancelResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SubmitCancelResponse, default initialized and not managed by a soap context
        virtual ns1__SubmitCancelResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__SubmitCancelResponse); }
      public:
        /// Constructor with default initializations
        ns1__SubmitCancelResponse() : responseId() { }
        virtual ~ns1__SubmitCancelResponse() { }
        /// Friend allocator used by soap_new_ns1__SubmitCancelResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__SubmitCancelResponse * SOAP_FMAC2 soap_instantiate_ns1__SubmitCancelResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:316 */
#ifndef SOAP_TYPE_ns1__RetrieveCancelResponse
#define SOAP_TYPE_ns1__RetrieveCancelResponse (86)
/* complex XML schema type 'ns1:RetrieveCancelResponse': */
class SOAP_CMAC ns1__RetrieveCancelResponse : public ns1__PerSecurityResponse {
      public:
        /// Optional element 'ns1:headers' of XML schema type 'ns1:CancelHeaders'
        ns1__CancelHeaders *headers;
        /// Required element 'ns1:cancelResponseStatus' of XML schema type 'ns1:CancelResponseStatus'
        std::vector<ns1__CancelResponseStatus *> cancelResponseStatus;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RetrieveCancelResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__RetrieveCancelResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RetrieveCancelResponse, default initialized and not managed by a soap context
        virtual ns1__RetrieveCancelResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__RetrieveCancelResponse); }
      public:
        /// Constructor with default initializations
        ns1__RetrieveCancelResponse() : headers(), cancelResponseStatus() { }
        virtual ~ns1__RetrieveCancelResponse() { }
        /// Friend allocator used by soap_new_ns1__RetrieveCancelResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__RetrieveCancelResponse * SOAP_FMAC2 soap_instantiate_ns1__RetrieveCancelResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:320 */
#ifndef SOAP_TYPE_ns1__GetCorrectionsResponse
#define SOAP_TYPE_ns1__GetCorrectionsResponse (88)
/* complex XML schema type 'ns1:GetCorrectionsResponse': */
class SOAP_CMAC ns1__GetCorrectionsResponse : public ns1__PerSecurityResponse {
      public:
        /// Optional element 'ns1:headers' of XML schema type 'ns1:GetCorrectionsHeaders'
        ns1__GetCorrectionsHeaders *headers;
        /// Optional element 'ns1:timestarted' of XML schema type 'xsd:dateTime'
        time_t *timestarted;
        /// Optional element 'ns1:correctionRecords' of XML schema type 'ns1:CorrectionRecords'
        ns1__CorrectionRecords *correctionRecords;
        /// Optional element 'ns1:timefinished' of XML schema type 'xsd:dateTime'
        time_t *timefinished;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GetCorrectionsResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__GetCorrectionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GetCorrectionsResponse, default initialized and not managed by a soap context
        virtual ns1__GetCorrectionsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__GetCorrectionsResponse); }
      public:
        /// Constructor with default initializations
        ns1__GetCorrectionsResponse() : headers(), timestarted(), correctionRecords(), timefinished() { }
        virtual ~ns1__GetCorrectionsResponse() { }
        /// Friend allocator used by soap_new_ns1__GetCorrectionsResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__GetCorrectionsResponse * SOAP_FMAC2 soap_instantiate_ns1__GetCorrectionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:324 */
#ifndef SOAP_TYPE_ns1__SubmitScheduledResponse
#define SOAP_TYPE_ns1__SubmitScheduledResponse (90)
/* complex XML schema type 'ns1:SubmitScheduledResponse': */
class SOAP_CMAC ns1__SubmitScheduledResponse : public ns1__PerSecurityResponse {
      public:
        /// Required element 'ns1:responseId' of XML schema type 'xsd:string'
        std::string responseId;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SubmitScheduledResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__SubmitScheduledResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SubmitScheduledResponse, default initialized and not managed by a soap context
        virtual ns1__SubmitScheduledResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__SubmitScheduledResponse); }
      public:
        /// Constructor with default initializations
        ns1__SubmitScheduledResponse() : responseId() { }
        virtual ~ns1__SubmitScheduledResponse() { }
        /// Friend allocator used by soap_new_ns1__SubmitScheduledResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__SubmitScheduledResponse * SOAP_FMAC2 soap_instantiate_ns1__SubmitScheduledResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:332 */
#ifndef SOAP_TYPE_ns1__RetrieveScheduledResponse
#define SOAP_TYPE_ns1__RetrieveScheduledResponse (94)
/* complex XML schema type 'ns1:RetrieveScheduledResponse': */
class SOAP_CMAC ns1__RetrieveScheduledResponse : public ns1__PerSecurityResponse {
      public:
        /// Required element 'ns1:responseId' of XML schema type 'xsd:string'
        std::string responseId;
        /// Optional element 'ns1:fileDatas' of XML schema type 'ns1:ScheduledResponses'
        ns1__ScheduledResponses *fileDatas;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RetrieveScheduledResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__RetrieveScheduledResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RetrieveScheduledResponse, default initialized and not managed by a soap context
        virtual ns1__RetrieveScheduledResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__RetrieveScheduledResponse); }
      public:
        /// Constructor with default initializations
        ns1__RetrieveScheduledResponse() : responseId(), fileDatas() { }
        virtual ~ns1__RetrieveScheduledResponse() { }
        /// Friend allocator used by soap_new_ns1__RetrieveScheduledResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__RetrieveScheduledResponse * SOAP_FMAC2 soap_instantiate_ns1__RetrieveScheduledResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:336 */
#ifndef SOAP_TYPE_ns1__SubmitGetFundamentalsResponse
#define SOAP_TYPE_ns1__SubmitGetFundamentalsResponse (96)
/* complex XML schema type 'ns1:SubmitGetFundamentalsResponse': */
class SOAP_CMAC ns1__SubmitGetFundamentalsResponse : public ns1__PerSecurityResponse {
      public:
        /// Required element 'ns1:responseId' of XML schema type 'xsd:string'
        std::string responseId;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SubmitGetFundamentalsResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__SubmitGetFundamentalsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SubmitGetFundamentalsResponse, default initialized and not managed by a soap context
        virtual ns1__SubmitGetFundamentalsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__SubmitGetFundamentalsResponse); }
      public:
        /// Constructor with default initializations
        ns1__SubmitGetFundamentalsResponse() : responseId() { }
        virtual ~ns1__SubmitGetFundamentalsResponse() { }
        /// Friend allocator used by soap_new_ns1__SubmitGetFundamentalsResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__SubmitGetFundamentalsResponse * SOAP_FMAC2 soap_instantiate_ns1__SubmitGetFundamentalsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:340 */
#ifndef SOAP_TYPE_ns1__RetrieveGetFundamentalsResponse
#define SOAP_TYPE_ns1__RetrieveGetFundamentalsResponse (98)
/* complex XML schema type 'ns1:RetrieveGetFundamentalsResponse': */
class SOAP_CMAC ns1__RetrieveGetFundamentalsResponse : public ns1__PerSecurityResponse {
      public:
        /// Required element 'ns1:responseId' of XML schema type 'xsd:string'
        std::string responseId;
        /// Optional element 'ns1:headers' of XML schema type 'ns1:GetFundamentalsHeaders'
        ns1__GetFundamentalsHeaders *headers;
        /// Optional element 'ns1:fields' of XML schema type 'ns1:Fields'
        ns1__Fields *fields;
        /// Optional element 'ns1:timestarted' of XML schema type 'xsd:dateTime'
        time_t *timestarted;
        /// Optional element 'ns1:instrumentDatas' of XML schema type 'ns1:FundInstrumentDatas'
        ns1__FundInstrumentDatas *instrumentDatas;
        /// Optional element 'ns1:timefinished' of XML schema type 'xsd:dateTime'
        time_t *timefinished;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RetrieveGetFundamentalsResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__RetrieveGetFundamentalsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RetrieveGetFundamentalsResponse, default initialized and not managed by a soap context
        virtual ns1__RetrieveGetFundamentalsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__RetrieveGetFundamentalsResponse); }
      public:
        /// Constructor with default initializations
        ns1__RetrieveGetFundamentalsResponse() : responseId(), headers(), fields(), timestarted(), instrumentDatas(), timefinished() { }
        virtual ~ns1__RetrieveGetFundamentalsResponse() { }
        /// Friend allocator used by soap_new_ns1__RetrieveGetFundamentalsResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__RetrieveGetFundamentalsResponse * SOAP_FMAC2 soap_instantiate_ns1__RetrieveGetFundamentalsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:344 */
#ifndef SOAP_TYPE_ns1__SubmitGetCompanyResponse
#define SOAP_TYPE_ns1__SubmitGetCompanyResponse (100)
/* complex XML schema type 'ns1:SubmitGetCompanyResponse': */
class SOAP_CMAC ns1__SubmitGetCompanyResponse : public ns1__PerSecurityResponse {
      public:
        /// Required element 'ns1:responseId' of XML schema type 'xsd:string'
        std::string responseId;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SubmitGetCompanyResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__SubmitGetCompanyResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SubmitGetCompanyResponse, default initialized and not managed by a soap context
        virtual ns1__SubmitGetCompanyResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__SubmitGetCompanyResponse); }
      public:
        /// Constructor with default initializations
        ns1__SubmitGetCompanyResponse() : responseId() { }
        virtual ~ns1__SubmitGetCompanyResponse() { }
        /// Friend allocator used by soap_new_ns1__SubmitGetCompanyResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__SubmitGetCompanyResponse * SOAP_FMAC2 soap_instantiate_ns1__SubmitGetCompanyResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:348 */
#ifndef SOAP_TYPE_ns1__RetrieveGetCompanyResponse
#define SOAP_TYPE_ns1__RetrieveGetCompanyResponse (102)
/* complex XML schema type 'ns1:RetrieveGetCompanyResponse': */
class SOAP_CMAC ns1__RetrieveGetCompanyResponse : public ns1__PerSecurityResponse {
      public:
        /// Required element 'ns1:responseId' of XML schema type 'xsd:string'
        std::string responseId;
        /// Optional element 'ns1:headers' of XML schema type 'ns1:GetCompanyHeaders'
        ns1__GetCompanyHeaders *headers;
        /// Optional element 'ns1:fields' of XML schema type 'ns1:Fields'
        ns1__Fields *fields;
        /// Optional element 'ns1:timestarted' of XML schema type 'xsd:dateTime'
        time_t *timestarted;
        /// Optional element 'ns1:instrumentDatas' of XML schema type 'ns1:InstrumentDatas'
        ns1__InstrumentDatas *instrumentDatas;
        /// Optional element 'ns1:timefinished' of XML schema type 'xsd:dateTime'
        time_t *timefinished;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RetrieveGetCompanyResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__RetrieveGetCompanyResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RetrieveGetCompanyResponse, default initialized and not managed by a soap context
        virtual ns1__RetrieveGetCompanyResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__RetrieveGetCompanyResponse); }
      public:
        /// Constructor with default initializations
        ns1__RetrieveGetCompanyResponse() : responseId(), headers(), fields(), timestarted(), instrumentDatas(), timefinished() { }
        virtual ~ns1__RetrieveGetCompanyResponse() { }
        /// Friend allocator used by soap_new_ns1__RetrieveGetCompanyResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__RetrieveGetCompanyResponse * SOAP_FMAC2 soap_instantiate_ns1__RetrieveGetCompanyResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:352 */
#ifndef SOAP_TYPE_ns1__GetPortfolioValidationResponse
#define SOAP_TYPE_ns1__GetPortfolioValidationResponse (104)
/* complex XML schema type 'ns1:GetPortfolioValidationResponse': */
class SOAP_CMAC ns1__GetPortfolioValidationResponse : public ns1__PerSecurityResponse {
      public:
        /// Required element 'ns1:responseId' of XML schema type 'xsd:string'
        std::string responseId;
        /// Optional element 'ns1:headers' of XML schema type 'ns1:GetPortfolioValidationHeaders'
        ns1__GetPortfolioValidationHeaders *headers;
        /// Optional element 'ns1:fields' of XML schema type 'ns1:Fields'
        ns1__Fields *fields;
        /// Optional element 'ns1:timestarted' of XML schema type 'xsd:dateTime'
        time_t *timestarted;
        /// Optional element 'ns1:instrumentDatas' of XML schema type 'ns1:InstrumentDatas'
        ns1__InstrumentDatas *instrumentDatas;
        /// Optional element 'ns1:timefinished' of XML schema type 'xsd:dateTime'
        time_t *timefinished;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GetPortfolioValidationResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__GetPortfolioValidationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GetPortfolioValidationResponse, default initialized and not managed by a soap context
        virtual ns1__GetPortfolioValidationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__GetPortfolioValidationResponse); }
      public:
        /// Constructor with default initializations
        ns1__GetPortfolioValidationResponse() : responseId(), headers(), fields(), timestarted(), instrumentDatas(), timefinished() { }
        virtual ~ns1__GetPortfolioValidationResponse() { }
        /// Friend allocator used by soap_new_ns1__GetPortfolioValidationResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__GetPortfolioValidationResponse * SOAP_FMAC2 soap_instantiate_ns1__GetPortfolioValidationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:356 */
#ifndef SOAP_TYPE_ns1__SubmitGetActionsResponse
#define SOAP_TYPE_ns1__SubmitGetActionsResponse (106)
/* complex XML schema type 'ns1:SubmitGetActionsResponse': */
class SOAP_CMAC ns1__SubmitGetActionsResponse : public ns1__PerSecurityResponse {
      public:
        /// Required element 'ns1:responseId' of XML schema type 'xsd:string'
        std::string responseId;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SubmitGetActionsResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__SubmitGetActionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SubmitGetActionsResponse, default initialized and not managed by a soap context
        virtual ns1__SubmitGetActionsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__SubmitGetActionsResponse); }
      public:
        /// Constructor with default initializations
        ns1__SubmitGetActionsResponse() : responseId() { }
        virtual ~ns1__SubmitGetActionsResponse() { }
        /// Friend allocator used by soap_new_ns1__SubmitGetActionsResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__SubmitGetActionsResponse * SOAP_FMAC2 soap_instantiate_ns1__SubmitGetActionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:360 */
#ifndef SOAP_TYPE_ns1__RetrieveGetActionsResponse
#define SOAP_TYPE_ns1__RetrieveGetActionsResponse (108)
/* complex XML schema type 'ns1:RetrieveGetActionsResponse': */
class SOAP_CMAC ns1__RetrieveGetActionsResponse : public ns1__PerSecurityResponse {
      public:
        /// Required element 'ns1:responseId' of XML schema type 'xsd:string'
        std::string responseId;
        /// Optional element 'ns1:headers' of XML schema type 'ns1:GetActionsHeaders'
        ns1__GetActionsHeaders *headers;
        /// Optional element 'ns1:timestarted' of XML schema type 'xsd:dateTime'
        time_t *timestarted;
        /// Optional element 'ns1:instrumentDatas' of XML schema type 'ns1:ActionsInstrumentDatas'
        ns1__ActionsInstrumentDatas *instrumentDatas;
        /// Optional element 'ns1:timefinished' of XML schema type 'xsd:dateTime'
        time_t *timefinished;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RetrieveGetActionsResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__RetrieveGetActionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RetrieveGetActionsResponse, default initialized and not managed by a soap context
        virtual ns1__RetrieveGetActionsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__RetrieveGetActionsResponse); }
      public:
        /// Constructor with default initializations
        ns1__RetrieveGetActionsResponse() : responseId(), headers(), timestarted(), instrumentDatas(), timefinished() { }
        virtual ~ns1__RetrieveGetActionsResponse() { }
        /// Friend allocator used by soap_new_ns1__RetrieveGetActionsResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__RetrieveGetActionsResponse * SOAP_FMAC2 soap_instantiate_ns1__RetrieveGetActionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:364 */
#ifndef SOAP_TYPE_ns1__SubmitGetQuotesResponse
#define SOAP_TYPE_ns1__SubmitGetQuotesResponse (110)
/* complex XML schema type 'ns1:SubmitGetQuotesResponse': */
class SOAP_CMAC ns1__SubmitGetQuotesResponse : public ns1__PerSecurityResponse {
      public:
        /// Required element 'ns1:responseId' of XML schema type 'xsd:string'
        std::string responseId;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SubmitGetQuotesResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__SubmitGetQuotesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SubmitGetQuotesResponse, default initialized and not managed by a soap context
        virtual ns1__SubmitGetQuotesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__SubmitGetQuotesResponse); }
      public:
        /// Constructor with default initializations
        ns1__SubmitGetQuotesResponse() : responseId() { }
        virtual ~ns1__SubmitGetQuotesResponse() { }
        /// Friend allocator used by soap_new_ns1__SubmitGetQuotesResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__SubmitGetQuotesResponse * SOAP_FMAC2 soap_instantiate_ns1__SubmitGetQuotesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:368 */
#ifndef SOAP_TYPE_ns1__RetrieveGetQuotesResponse
#define SOAP_TYPE_ns1__RetrieveGetQuotesResponse (112)
/* complex XML schema type 'ns1:RetrieveGetQuotesResponse': */
class SOAP_CMAC ns1__RetrieveGetQuotesResponse : public ns1__PerSecurityResponse {
      public:
        /// Required element 'ns1:responseId' of XML schema type 'xsd:string'
        std::string responseId;
        /// Optional element 'ns1:headers' of XML schema type 'ns1:QuotesHeaders'
        ns1__QuotesHeaders *headers;
        /// Optional element 'ns1:timestarted' of XML schema type 'xsd:dateTime'
        time_t *timestarted;
        /// Optional element 'ns1:instrumentDatas' of XML schema type 'ns1:QuotesInstrumentDatas'
        ns1__QuotesInstrumentDatas *instrumentDatas;
        /// Optional element 'ns1:timefinished' of XML schema type 'xsd:dateTime'
        time_t *timefinished;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RetrieveGetQuotesResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__RetrieveGetQuotesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RetrieveGetQuotesResponse, default initialized and not managed by a soap context
        virtual ns1__RetrieveGetQuotesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__RetrieveGetQuotesResponse); }
      public:
        /// Constructor with default initializations
        ns1__RetrieveGetQuotesResponse() : responseId(), headers(), timestarted(), instrumentDatas(), timefinished() { }
        virtual ~ns1__RetrieveGetQuotesResponse() { }
        /// Friend allocator used by soap_new_ns1__RetrieveGetQuotesResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__RetrieveGetQuotesResponse * SOAP_FMAC2 soap_instantiate_ns1__RetrieveGetQuotesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:372 */
#ifndef SOAP_TYPE_ns1__SubmitGetAllQuotesResponse
#define SOAP_TYPE_ns1__SubmitGetAllQuotesResponse (114)
/* complex XML schema type 'ns1:SubmitGetAllQuotesResponse': */
class SOAP_CMAC ns1__SubmitGetAllQuotesResponse : public ns1__PerSecurityResponse {
      public:
        /// Required element 'ns1:responseId' of XML schema type 'xsd:string'
        std::string responseId;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SubmitGetAllQuotesResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__SubmitGetAllQuotesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SubmitGetAllQuotesResponse, default initialized and not managed by a soap context
        virtual ns1__SubmitGetAllQuotesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__SubmitGetAllQuotesResponse); }
      public:
        /// Constructor with default initializations
        ns1__SubmitGetAllQuotesResponse() : responseId() { }
        virtual ~ns1__SubmitGetAllQuotesResponse() { }
        /// Friend allocator used by soap_new_ns1__SubmitGetAllQuotesResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__SubmitGetAllQuotesResponse * SOAP_FMAC2 soap_instantiate_ns1__SubmitGetAllQuotesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:376 */
#ifndef SOAP_TYPE_ns1__RetrieveGetAllQuotesResponse
#define SOAP_TYPE_ns1__RetrieveGetAllQuotesResponse (116)
/* complex XML schema type 'ns1:RetrieveGetAllQuotesResponse': */
class SOAP_CMAC ns1__RetrieveGetAllQuotesResponse : public ns1__PerSecurityResponse {
      public:
        /// Required element 'ns1:responseId' of XML schema type 'xsd:string'
        std::string responseId;
        /// Optional element 'ns1:headers' of XML schema type 'ns1:QuotesHeaders'
        ns1__QuotesHeaders *headers;
        /// Optional element 'ns1:timestarted' of XML schema type 'xsd:dateTime'
        time_t *timestarted;
        /// Optional element 'ns1:instrumentDatas' of XML schema type 'ns1:AllQuotesInstrumentDatas'
        ns1__AllQuotesInstrumentDatas *instrumentDatas;
        /// Optional element 'ns1:timefinished' of XML schema type 'xsd:dateTime'
        time_t *timefinished;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RetrieveGetAllQuotesResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__RetrieveGetAllQuotesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RetrieveGetAllQuotesResponse, default initialized and not managed by a soap context
        virtual ns1__RetrieveGetAllQuotesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__RetrieveGetAllQuotesResponse); }
      public:
        /// Constructor with default initializations
        ns1__RetrieveGetAllQuotesResponse() : responseId(), headers(), timestarted(), instrumentDatas(), timefinished() { }
        virtual ~ns1__RetrieveGetAllQuotesResponse() { }
        /// Friend allocator used by soap_new_ns1__RetrieveGetAllQuotesResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__RetrieveGetAllQuotesResponse * SOAP_FMAC2 soap_instantiate_ns1__RetrieveGetAllQuotesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:380 */
#ifndef SOAP_TYPE_ns1__SubmitOtcbvalUploadResponse
#define SOAP_TYPE_ns1__SubmitOtcbvalUploadResponse (118)
/* complex XML schema type 'ns1:SubmitOtcbvalUploadResponse': */
class SOAP_CMAC ns1__SubmitOtcbvalUploadResponse : public ns1__PerSecurityResponse {
      public:
        /// Required element 'ns1:responseId' of XML schema type 'xsd:string'
        std::string responseId;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SubmitOtcbvalUploadResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__SubmitOtcbvalUploadResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SubmitOtcbvalUploadResponse, default initialized and not managed by a soap context
        virtual ns1__SubmitOtcbvalUploadResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__SubmitOtcbvalUploadResponse); }
      public:
        /// Constructor with default initializations
        ns1__SubmitOtcbvalUploadResponse() : responseId() { }
        virtual ~ns1__SubmitOtcbvalUploadResponse() { }
        /// Friend allocator used by soap_new_ns1__SubmitOtcbvalUploadResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__SubmitOtcbvalUploadResponse * SOAP_FMAC2 soap_instantiate_ns1__SubmitOtcbvalUploadResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:384 */
#ifndef SOAP_TYPE_ns1__RetrieveOtcbvalUploadResponse
#define SOAP_TYPE_ns1__RetrieveOtcbvalUploadResponse (120)
/* complex XML schema type 'ns1:RetrieveOtcbvalUploadResponse': */
class SOAP_CMAC ns1__RetrieveOtcbvalUploadResponse : public ns1__PerSecurityResponse {
      public:
        /// Required element 'ns1:responseId' of XML schema type 'xsd:string'
        std::string responseId;
        /// Optional element 'ns1:response' of XML schema type 'xsd:string'
        std::string *response;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RetrieveOtcbvalUploadResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__RetrieveOtcbvalUploadResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RetrieveOtcbvalUploadResponse, default initialized and not managed by a soap context
        virtual ns1__RetrieveOtcbvalUploadResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__RetrieveOtcbvalUploadResponse); }
      public:
        /// Constructor with default initializations
        ns1__RetrieveOtcbvalUploadResponse() : responseId(), response() { }
        virtual ~ns1__RetrieveOtcbvalUploadResponse() { }
        /// Friend allocator used by soap_new_ns1__RetrieveOtcbvalUploadResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__RetrieveOtcbvalUploadResponse * SOAP_FMAC2 soap_instantiate_ns1__RetrieveOtcbvalUploadResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:388 */
#ifndef SOAP_TYPE_ns1__SubmitOtcBvalDealsUploadResponse
#define SOAP_TYPE_ns1__SubmitOtcBvalDealsUploadResponse (122)
/* complex XML schema type 'ns1:SubmitOtcBvalDealsUploadResponse': */
class SOAP_CMAC ns1__SubmitOtcBvalDealsUploadResponse : public ns1__PerSecurityResponse {
      public:
        /// Required element 'ns1:responseId' of XML schema type 'xsd:string'
        std::string responseId;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SubmitOtcBvalDealsUploadResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__SubmitOtcBvalDealsUploadResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SubmitOtcBvalDealsUploadResponse, default initialized and not managed by a soap context
        virtual ns1__SubmitOtcBvalDealsUploadResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__SubmitOtcBvalDealsUploadResponse); }
      public:
        /// Constructor with default initializations
        ns1__SubmitOtcBvalDealsUploadResponse() : responseId() { }
        virtual ~ns1__SubmitOtcBvalDealsUploadResponse() { }
        /// Friend allocator used by soap_new_ns1__SubmitOtcBvalDealsUploadResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__SubmitOtcBvalDealsUploadResponse * SOAP_FMAC2 soap_instantiate_ns1__SubmitOtcBvalDealsUploadResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:392 */
#ifndef SOAP_TYPE_ns1__RetrieveOtcBvalDealsUploadResponse
#define SOAP_TYPE_ns1__RetrieveOtcBvalDealsUploadResponse (124)
/* complex XML schema type 'ns1:RetrieveOtcBvalDealsUploadResponse': */
class SOAP_CMAC ns1__RetrieveOtcBvalDealsUploadResponse : public ns1__PerSecurityResponse {
      public:
        /// Required element 'ns1:responseId' of XML schema type 'xsd:string'
        std::string responseId;
        /// Optional element 'ns1:timestarted' of XML schema type 'xsd:dateTime'
        time_t *timestarted;
        /// Optional element 'ns1:deals' of XML schema type 'ns1:OtcDealInfos'
        ns1__OtcDealInfos *deals;
        /// Optional element 'ns1:timefinished' of XML schema type 'xsd:dateTime'
        time_t *timefinished;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RetrieveOtcBvalDealsUploadResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__RetrieveOtcBvalDealsUploadResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RetrieveOtcBvalDealsUploadResponse, default initialized and not managed by a soap context
        virtual ns1__RetrieveOtcBvalDealsUploadResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__RetrieveOtcBvalDealsUploadResponse); }
      public:
        /// Constructor with default initializations
        ns1__RetrieveOtcBvalDealsUploadResponse() : responseId(), timestarted(), deals(), timefinished() { }
        virtual ~ns1__RetrieveOtcBvalDealsUploadResponse() { }
        /// Friend allocator used by soap_new_ns1__RetrieveOtcBvalDealsUploadResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__RetrieveOtcBvalDealsUploadResponse * SOAP_FMAC2 soap_instantiate_ns1__RetrieveOtcBvalDealsUploadResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:396 */
#ifndef SOAP_TYPE_ns1__GetFieldsResponse
#define SOAP_TYPE_ns1__GetFieldsResponse (126)
/* complex XML schema type 'ns1:GetFieldsResponse': */
class SOAP_CMAC ns1__GetFieldsResponse : public ns1__PerSecurityResponse {
      public:
        /// Optional element 'ns1:fields' of XML schema type 'ns1:FieldInfos'
        ns1__FieldInfos *fields;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GetFieldsResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__GetFieldsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GetFieldsResponse, default initialized and not managed by a soap context
        virtual ns1__GetFieldsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__GetFieldsResponse); }
      public:
        /// Constructor with default initializations
        ns1__GetFieldsResponse() : fields() { }
        virtual ~ns1__GetFieldsResponse() { }
        /// Friend allocator used by soap_new_ns1__GetFieldsResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__GetFieldsResponse * SOAP_FMAC2 soap_instantiate_ns1__GetFieldsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:402 */
#ifndef SOAP_TYPE_ns1__SubmitMmktBvalDealsUploadResponse
#define SOAP_TYPE_ns1__SubmitMmktBvalDealsUploadResponse (129)
/* complex XML schema type 'ns1:SubmitMmktBvalDealsUploadResponse': */
class SOAP_CMAC ns1__SubmitMmktBvalDealsUploadResponse : public ns1__PerSecurityResponse {
      public:
        /// Required element 'ns1:responseId' of XML schema type 'xsd:string'
        std::string responseId;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SubmitMmktBvalDealsUploadResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__SubmitMmktBvalDealsUploadResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SubmitMmktBvalDealsUploadResponse, default initialized and not managed by a soap context
        virtual ns1__SubmitMmktBvalDealsUploadResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__SubmitMmktBvalDealsUploadResponse); }
      public:
        /// Constructor with default initializations
        ns1__SubmitMmktBvalDealsUploadResponse() : responseId() { }
        virtual ~ns1__SubmitMmktBvalDealsUploadResponse() { }
        /// Friend allocator used by soap_new_ns1__SubmitMmktBvalDealsUploadResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__SubmitMmktBvalDealsUploadResponse * SOAP_FMAC2 soap_instantiate_ns1__SubmitMmktBvalDealsUploadResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:410 */
#ifndef SOAP_TYPE_ns1__RetrieveMmktBvalDealsUploadResponse
#define SOAP_TYPE_ns1__RetrieveMmktBvalDealsUploadResponse (133)
/* complex XML schema type 'ns1:RetrieveMmktBvalDealsUploadResponse': */
class SOAP_CMAC ns1__RetrieveMmktBvalDealsUploadResponse : public ns1__PerSecurityResponse {
      public:
        /// Required element 'ns1:responseId' of XML schema type 'xsd:string'
        std::string responseId;
        /// Optional element 'ns1:timestarted' of XML schema type 'xsd:dateTime'
        time_t *timestarted;
        /// Optional element 'ns1:deals' of XML schema type 'ns1:MmktBvalDealInfos'
        ns1__MmktBvalDealInfos *deals;
        /// Optional element 'ns1:timefinished' of XML schema type 'xsd:dateTime'
        time_t *timefinished;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RetrieveMmktBvalDealsUploadResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__RetrieveMmktBvalDealsUploadResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RetrieveMmktBvalDealsUploadResponse, default initialized and not managed by a soap context
        virtual ns1__RetrieveMmktBvalDealsUploadResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__RetrieveMmktBvalDealsUploadResponse); }
      public:
        /// Constructor with default initializations
        ns1__RetrieveMmktBvalDealsUploadResponse() : responseId(), timestarted(), deals(), timefinished() { }
        virtual ~ns1__RetrieveMmktBvalDealsUploadResponse() { }
        /// Friend allocator used by soap_new_ns1__RetrieveMmktBvalDealsUploadResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__RetrieveMmktBvalDealsUploadResponse * SOAP_FMAC2 soap_instantiate_ns1__RetrieveMmktBvalDealsUploadResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:4733 */
#ifndef SOAP_TYPE___ns1__submitGetDataRequest
#define SOAP_TYPE___ns1__submitGetDataRequest (289)
/* Wrapper: */
struct SOAP_CMAC __ns1__submitGetDataRequest {
      public:
        /** Optional element 'ns1:submitGetDataRequest' of XML schema type 'ns1:SubmitGetDataRequest' */
        ns1__SubmitGetDataRequest *ns1__submitGetDataRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__submitGetDataRequest */
        long soap_type() const { return SOAP_TYPE___ns1__submitGetDataRequest; }
        /** Constructor with member initializations */
        __ns1__submitGetDataRequest() : ns1__submitGetDataRequest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__submitGetDataRequest * SOAP_FMAC2 soap_instantiate___ns1__submitGetDataRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:4803 */
#ifndef SOAP_TYPE___ns1__retrieveGetDataResponse
#define SOAP_TYPE___ns1__retrieveGetDataResponse (293)
/* Wrapper: */
struct SOAP_CMAC __ns1__retrieveGetDataResponse {
      public:
        /** Optional element 'ns1:retrieveGetDataRequest' of XML schema type 'ns1:RetrieveGetDataRequest' */
        ns1__RetrieveGetDataRequest *ns1__retrieveGetDataRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__retrieveGetDataResponse */
        long soap_type() const { return SOAP_TYPE___ns1__retrieveGetDataResponse; }
        /** Constructor with member initializations */
        __ns1__retrieveGetDataResponse() : ns1__retrieveGetDataRequest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__retrieveGetDataResponse * SOAP_FMAC2 soap_instantiate___ns1__retrieveGetDataResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:4873 */
#ifndef SOAP_TYPE___ns1__submitGetHistoryRequest
#define SOAP_TYPE___ns1__submitGetHistoryRequest (297)
/* Wrapper: */
struct SOAP_CMAC __ns1__submitGetHistoryRequest {
      public:
        /** Optional element 'ns1:submitGetHistoryRequest' of XML schema type 'ns1:SubmitGetHistoryRequest' */
        ns1__SubmitGetHistoryRequest *ns1__submitGetHistoryRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__submitGetHistoryRequest */
        long soap_type() const { return SOAP_TYPE___ns1__submitGetHistoryRequest; }
        /** Constructor with member initializations */
        __ns1__submitGetHistoryRequest() : ns1__submitGetHistoryRequest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__submitGetHistoryRequest * SOAP_FMAC2 soap_instantiate___ns1__submitGetHistoryRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:4943 */
#ifndef SOAP_TYPE___ns1__retrieveGetHistoryResponse
#define SOAP_TYPE___ns1__retrieveGetHistoryResponse (301)
/* Wrapper: */
struct SOAP_CMAC __ns1__retrieveGetHistoryResponse {
      public:
        /** Optional element 'ns1:retrieveGetHistoryRequest' of XML schema type 'ns1:RetrieveGetHistoryRequest' */
        ns1__RetrieveGetHistoryRequest *ns1__retrieveGetHistoryRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__retrieveGetHistoryResponse */
        long soap_type() const { return SOAP_TYPE___ns1__retrieveGetHistoryResponse; }
        /** Constructor with member initializations */
        __ns1__retrieveGetHistoryResponse() : ns1__retrieveGetHistoryRequest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__retrieveGetHistoryResponse * SOAP_FMAC2 soap_instantiate___ns1__retrieveGetHistoryResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:5013 */
#ifndef SOAP_TYPE___ns1__submitScheduledRequest
#define SOAP_TYPE___ns1__submitScheduledRequest (305)
/* Wrapper: */
struct SOAP_CMAC __ns1__submitScheduledRequest {
      public:
        /** Optional element 'ns1:submitScheduledRequest' of XML schema type 'ns1:SubmitScheduledRequest' */
        ns1__SubmitScheduledRequest *ns1__submitScheduledRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__submitScheduledRequest */
        long soap_type() const { return SOAP_TYPE___ns1__submitScheduledRequest; }
        /** Constructor with member initializations */
        __ns1__submitScheduledRequest() : ns1__submitScheduledRequest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__submitScheduledRequest * SOAP_FMAC2 soap_instantiate___ns1__submitScheduledRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:5083 */
#ifndef SOAP_TYPE___ns1__retrieveScheduledResponse
#define SOAP_TYPE___ns1__retrieveScheduledResponse (309)
/* Wrapper: */
struct SOAP_CMAC __ns1__retrieveScheduledResponse {
      public:
        /** Optional element 'ns1:retrieveScheduledRequest' of XML schema type 'ns1:RetrieveScheduledRequest' */
        ns1__RetrieveScheduledRequest *ns1__retrieveScheduledRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__retrieveScheduledResponse */
        long soap_type() const { return SOAP_TYPE___ns1__retrieveScheduledResponse; }
        /** Constructor with member initializations */
        __ns1__retrieveScheduledResponse() : ns1__retrieveScheduledRequest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__retrieveScheduledResponse * SOAP_FMAC2 soap_instantiate___ns1__retrieveScheduledResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:5153 */
#ifndef SOAP_TYPE___ns1__submitCancelRequest
#define SOAP_TYPE___ns1__submitCancelRequest (313)
/* Wrapper: */
struct SOAP_CMAC __ns1__submitCancelRequest {
      public:
        /** Optional element 'ns1:submitCancelRequest' of XML schema type 'ns1:SubmitCancelRequest' */
        ns1__SubmitCancelRequest *ns1__submitCancelRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__submitCancelRequest */
        long soap_type() const { return SOAP_TYPE___ns1__submitCancelRequest; }
        /** Constructor with member initializations */
        __ns1__submitCancelRequest() : ns1__submitCancelRequest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__submitCancelRequest * SOAP_FMAC2 soap_instantiate___ns1__submitCancelRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:5223 */
#ifndef SOAP_TYPE___ns1__retrieveCancelResponse
#define SOAP_TYPE___ns1__retrieveCancelResponse (317)
/* Wrapper: */
struct SOAP_CMAC __ns1__retrieveCancelResponse {
      public:
        /** Optional element 'ns1:retrieveCancelRequest' of XML schema type 'ns1:RetrieveCancelRequest' */
        ns1__RetrieveCancelRequest *ns1__retrieveCancelRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__retrieveCancelResponse */
        long soap_type() const { return SOAP_TYPE___ns1__retrieveCancelResponse; }
        /** Constructor with member initializations */
        __ns1__retrieveCancelResponse() : ns1__retrieveCancelRequest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__retrieveCancelResponse * SOAP_FMAC2 soap_instantiate___ns1__retrieveCancelResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:5293 */
#ifndef SOAP_TYPE___ns1__getCorrections
#define SOAP_TYPE___ns1__getCorrections (321)
/* Wrapper: */
struct SOAP_CMAC __ns1__getCorrections {
      public:
        /** Optional element 'ns1:getCorrectionsRequest' of XML schema type 'ns1:GetCorrectionsRequest' */
        ns1__GetCorrectionsRequest *ns1__getCorrectionsRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getCorrections */
        long soap_type() const { return SOAP_TYPE___ns1__getCorrections; }
        /** Constructor with member initializations */
        __ns1__getCorrections() : ns1__getCorrectionsRequest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getCorrections * SOAP_FMAC2 soap_instantiate___ns1__getCorrections(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:5363 */
#ifndef SOAP_TYPE___ns1__submitGetFundamentalsRequest
#define SOAP_TYPE___ns1__submitGetFundamentalsRequest (325)
/* Wrapper: */
struct SOAP_CMAC __ns1__submitGetFundamentalsRequest {
      public:
        /** Optional element 'ns1:submitGetFundamentalsRequest' of XML schema type 'ns1:SubmitGetFundamentalsRequest' */
        ns1__SubmitGetFundamentalsRequest *ns1__submitGetFundamentalsRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__submitGetFundamentalsRequest */
        long soap_type() const { return SOAP_TYPE___ns1__submitGetFundamentalsRequest; }
        /** Constructor with member initializations */
        __ns1__submitGetFundamentalsRequest() : ns1__submitGetFundamentalsRequest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__submitGetFundamentalsRequest * SOAP_FMAC2 soap_instantiate___ns1__submitGetFundamentalsRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:5433 */
#ifndef SOAP_TYPE___ns1__retrieveGetFundamentalsResponse
#define SOAP_TYPE___ns1__retrieveGetFundamentalsResponse (329)
/* Wrapper: */
struct SOAP_CMAC __ns1__retrieveGetFundamentalsResponse {
      public:
        /** Optional element 'ns1:retrieveGetFundamentalsRequest' of XML schema type 'ns1:RetrieveGetFundamentalsRequest' */
        ns1__RetrieveGetFundamentalsRequest *ns1__retrieveGetFundamentalsRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__retrieveGetFundamentalsResponse */
        long soap_type() const { return SOAP_TYPE___ns1__retrieveGetFundamentalsResponse; }
        /** Constructor with member initializations */
        __ns1__retrieveGetFundamentalsResponse() : ns1__retrieveGetFundamentalsRequest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__retrieveGetFundamentalsResponse * SOAP_FMAC2 soap_instantiate___ns1__retrieveGetFundamentalsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:5503 */
#ifndef SOAP_TYPE___ns1__submitGetCompanyRequest
#define SOAP_TYPE___ns1__submitGetCompanyRequest (333)
/* Wrapper: */
struct SOAP_CMAC __ns1__submitGetCompanyRequest {
      public:
        /** Optional element 'ns1:submitGetCompanyRequest' of XML schema type 'ns1:SubmitGetCompanyRequest' */
        ns1__SubmitGetCompanyRequest *ns1__submitGetCompanyRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__submitGetCompanyRequest */
        long soap_type() const { return SOAP_TYPE___ns1__submitGetCompanyRequest; }
        /** Constructor with member initializations */
        __ns1__submitGetCompanyRequest() : ns1__submitGetCompanyRequest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__submitGetCompanyRequest * SOAP_FMAC2 soap_instantiate___ns1__submitGetCompanyRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:5573 */
#ifndef SOAP_TYPE___ns1__retrieveGetCompanyResponse
#define SOAP_TYPE___ns1__retrieveGetCompanyResponse (337)
/* Wrapper: */
struct SOAP_CMAC __ns1__retrieveGetCompanyResponse {
      public:
        /** Optional element 'ns1:retrieveGetCompanyRequest' of XML schema type 'ns1:RetrieveGetCompanyRequest' */
        ns1__RetrieveGetCompanyRequest *ns1__retrieveGetCompanyRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__retrieveGetCompanyResponse */
        long soap_type() const { return SOAP_TYPE___ns1__retrieveGetCompanyResponse; }
        /** Constructor with member initializations */
        __ns1__retrieveGetCompanyResponse() : ns1__retrieveGetCompanyRequest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__retrieveGetCompanyResponse * SOAP_FMAC2 soap_instantiate___ns1__retrieveGetCompanyResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:5643 */
#ifndef SOAP_TYPE___ns1__submitGetActionsRequest
#define SOAP_TYPE___ns1__submitGetActionsRequest (341)
/* Wrapper: */
struct SOAP_CMAC __ns1__submitGetActionsRequest {
      public:
        /** Optional element 'ns1:submitGetActionsRequest' of XML schema type 'ns1:SubmitGetActionsRequest' */
        ns1__SubmitGetActionsRequest *ns1__submitGetActionsRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__submitGetActionsRequest */
        long soap_type() const { return SOAP_TYPE___ns1__submitGetActionsRequest; }
        /** Constructor with member initializations */
        __ns1__submitGetActionsRequest() : ns1__submitGetActionsRequest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__submitGetActionsRequest * SOAP_FMAC2 soap_instantiate___ns1__submitGetActionsRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:5713 */
#ifndef SOAP_TYPE___ns1__retrieveGetActionsResponse
#define SOAP_TYPE___ns1__retrieveGetActionsResponse (345)
/* Wrapper: */
struct SOAP_CMAC __ns1__retrieveGetActionsResponse {
      public:
        /** Optional element 'ns1:retrieveGetActionsRequest' of XML schema type 'ns1:RetrieveGetActionsRequest' */
        ns1__RetrieveGetActionsRequest *ns1__retrieveGetActionsRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__retrieveGetActionsResponse */
        long soap_type() const { return SOAP_TYPE___ns1__retrieveGetActionsResponse; }
        /** Constructor with member initializations */
        __ns1__retrieveGetActionsResponse() : ns1__retrieveGetActionsRequest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__retrieveGetActionsResponse * SOAP_FMAC2 soap_instantiate___ns1__retrieveGetActionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:5783 */
#ifndef SOAP_TYPE___ns1__getPortfolioValidation
#define SOAP_TYPE___ns1__getPortfolioValidation (349)
/* Wrapper: */
struct SOAP_CMAC __ns1__getPortfolioValidation {
      public:
        /** Optional element 'ns1:getPortfolioValidationRequest' of XML schema type 'ns1:GetPortfolioValidationRequest' */
        ns1__GetPortfolioValidationRequest *ns1__getPortfolioValidationRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getPortfolioValidation */
        long soap_type() const { return SOAP_TYPE___ns1__getPortfolioValidation; }
        /** Constructor with member initializations */
        __ns1__getPortfolioValidation() : ns1__getPortfolioValidationRequest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getPortfolioValidation * SOAP_FMAC2 soap_instantiate___ns1__getPortfolioValidation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:5853 */
#ifndef SOAP_TYPE___ns1__submitGetQuotesRequest
#define SOAP_TYPE___ns1__submitGetQuotesRequest (353)
/* Wrapper: */
struct SOAP_CMAC __ns1__submitGetQuotesRequest {
      public:
        /** Optional element 'ns1:submitGetQuotesRequest' of XML schema type 'ns1:SubmitGetQuotesRequest' */
        ns1__SubmitGetQuotesRequest *ns1__submitGetQuotesRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__submitGetQuotesRequest */
        long soap_type() const { return SOAP_TYPE___ns1__submitGetQuotesRequest; }
        /** Constructor with member initializations */
        __ns1__submitGetQuotesRequest() : ns1__submitGetQuotesRequest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__submitGetQuotesRequest * SOAP_FMAC2 soap_instantiate___ns1__submitGetQuotesRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:5923 */
#ifndef SOAP_TYPE___ns1__retrieveGetQuotesResponse
#define SOAP_TYPE___ns1__retrieveGetQuotesResponse (357)
/* Wrapper: */
struct SOAP_CMAC __ns1__retrieveGetQuotesResponse {
      public:
        /** Optional element 'ns1:retrieveGetQuotesRequest' of XML schema type 'ns1:RetrieveGetQuotesRequest' */
        ns1__RetrieveGetQuotesRequest *ns1__retrieveGetQuotesRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__retrieveGetQuotesResponse */
        long soap_type() const { return SOAP_TYPE___ns1__retrieveGetQuotesResponse; }
        /** Constructor with member initializations */
        __ns1__retrieveGetQuotesResponse() : ns1__retrieveGetQuotesRequest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__retrieveGetQuotesResponse * SOAP_FMAC2 soap_instantiate___ns1__retrieveGetQuotesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:5993 */
#ifndef SOAP_TYPE___ns1__submitGetAllQuotesRequest
#define SOAP_TYPE___ns1__submitGetAllQuotesRequest (361)
/* Wrapper: */
struct SOAP_CMAC __ns1__submitGetAllQuotesRequest {
      public:
        /** Optional element 'ns1:submitGetAllQuotesRequest' of XML schema type 'ns1:SubmitGetAllQuotesRequest' */
        ns1__SubmitGetAllQuotesRequest *ns1__submitGetAllQuotesRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__submitGetAllQuotesRequest */
        long soap_type() const { return SOAP_TYPE___ns1__submitGetAllQuotesRequest; }
        /** Constructor with member initializations */
        __ns1__submitGetAllQuotesRequest() : ns1__submitGetAllQuotesRequest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__submitGetAllQuotesRequest * SOAP_FMAC2 soap_instantiate___ns1__submitGetAllQuotesRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:6063 */
#ifndef SOAP_TYPE___ns1__retrieveGetAllQuotesResponse
#define SOAP_TYPE___ns1__retrieveGetAllQuotesResponse (365)
/* Wrapper: */
struct SOAP_CMAC __ns1__retrieveGetAllQuotesResponse {
      public:
        /** Optional element 'ns1:retrieveGetAllQuotesRequest' of XML schema type 'ns1:RetrieveGetAllQuotesRequest' */
        ns1__RetrieveGetAllQuotesRequest *ns1__retrieveGetAllQuotesRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__retrieveGetAllQuotesResponse */
        long soap_type() const { return SOAP_TYPE___ns1__retrieveGetAllQuotesResponse; }
        /** Constructor with member initializations */
        __ns1__retrieveGetAllQuotesResponse() : ns1__retrieveGetAllQuotesRequest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__retrieveGetAllQuotesResponse * SOAP_FMAC2 soap_instantiate___ns1__retrieveGetAllQuotesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:6133 */
#ifndef SOAP_TYPE___ns1__submitOtcbvalUploadRequest
#define SOAP_TYPE___ns1__submitOtcbvalUploadRequest (369)
/* Wrapper: */
struct SOAP_CMAC __ns1__submitOtcbvalUploadRequest {
      public:
        /** Optional element 'ns1:submitOtcbvalUploadRequest' of XML schema type 'ns1:SubmitOtcbvalUploadRequest' */
        ns1__SubmitOtcbvalUploadRequest *ns1__submitOtcbvalUploadRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__submitOtcbvalUploadRequest */
        long soap_type() const { return SOAP_TYPE___ns1__submitOtcbvalUploadRequest; }
        /** Constructor with member initializations */
        __ns1__submitOtcbvalUploadRequest() : ns1__submitOtcbvalUploadRequest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__submitOtcbvalUploadRequest * SOAP_FMAC2 soap_instantiate___ns1__submitOtcbvalUploadRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:6203 */
#ifndef SOAP_TYPE___ns1__retrieveOtcbvalUploadResponse
#define SOAP_TYPE___ns1__retrieveOtcbvalUploadResponse (373)
/* Wrapper: */
struct SOAP_CMAC __ns1__retrieveOtcbvalUploadResponse {
      public:
        /** Optional element 'ns1:retrieveOtcbvalUploadRequest' of XML schema type 'ns1:RetrieveOtcbvalUploadRequest' */
        ns1__RetrieveOtcbvalUploadRequest *ns1__retrieveOtcbvalUploadRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__retrieveOtcbvalUploadResponse */
        long soap_type() const { return SOAP_TYPE___ns1__retrieveOtcbvalUploadResponse; }
        /** Constructor with member initializations */
        __ns1__retrieveOtcbvalUploadResponse() : ns1__retrieveOtcbvalUploadRequest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__retrieveOtcbvalUploadResponse * SOAP_FMAC2 soap_instantiate___ns1__retrieveOtcbvalUploadResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:6273 */
#ifndef SOAP_TYPE___ns1__submitOtcBvalDealsUploadRequest
#define SOAP_TYPE___ns1__submitOtcBvalDealsUploadRequest (377)
/* Wrapper: */
struct SOAP_CMAC __ns1__submitOtcBvalDealsUploadRequest {
      public:
        /** Optional element 'ns1:submitOtcBvalDealsUploadRequest' of XML schema type 'ns1:SubmitOtcBvalDealsUploadRequest' */
        ns1__SubmitOtcBvalDealsUploadRequest *ns1__submitOtcBvalDealsUploadRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__submitOtcBvalDealsUploadRequest */
        long soap_type() const { return SOAP_TYPE___ns1__submitOtcBvalDealsUploadRequest; }
        /** Constructor with member initializations */
        __ns1__submitOtcBvalDealsUploadRequest() : ns1__submitOtcBvalDealsUploadRequest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__submitOtcBvalDealsUploadRequest * SOAP_FMAC2 soap_instantiate___ns1__submitOtcBvalDealsUploadRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:6343 */
#ifndef SOAP_TYPE___ns1__retrieveOtcBvalDealsUploadResponse
#define SOAP_TYPE___ns1__retrieveOtcBvalDealsUploadResponse (381)
/* Wrapper: */
struct SOAP_CMAC __ns1__retrieveOtcBvalDealsUploadResponse {
      public:
        /** Optional element 'ns1:retrieveOtcBvalDealsUploadRequest' of XML schema type 'ns1:RetrieveOtcBvalDealsUploadRequest' */
        ns1__RetrieveOtcBvalDealsUploadRequest *ns1__retrieveOtcBvalDealsUploadRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__retrieveOtcBvalDealsUploadResponse */
        long soap_type() const { return SOAP_TYPE___ns1__retrieveOtcBvalDealsUploadResponse; }
        /** Constructor with member initializations */
        __ns1__retrieveOtcBvalDealsUploadResponse() : ns1__retrieveOtcBvalDealsUploadRequest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__retrieveOtcBvalDealsUploadResponse * SOAP_FMAC2 soap_instantiate___ns1__retrieveOtcBvalDealsUploadResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:6413 */
#ifndef SOAP_TYPE___ns1__getFields
#define SOAP_TYPE___ns1__getFields (385)
/* Wrapper: */
struct SOAP_CMAC __ns1__getFields {
      public:
        /** Optional element 'ns1:getFieldsRequest' of XML schema type 'ns1:GetFieldsRequest' */
        ns1__GetFieldsRequest *ns1__getFieldsRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getFields */
        long soap_type() const { return SOAP_TYPE___ns1__getFields; }
        /** Constructor with member initializations */
        __ns1__getFields() : ns1__getFieldsRequest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getFields * SOAP_FMAC2 soap_instantiate___ns1__getFields(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:6483 */
#ifndef SOAP_TYPE___ns1__submitMmktBvalDealsUploadRequest
#define SOAP_TYPE___ns1__submitMmktBvalDealsUploadRequest (389)
/* Wrapper: */
struct SOAP_CMAC __ns1__submitMmktBvalDealsUploadRequest {
      public:
        /** Optional element 'ns1:submitMmktBvalDealsUploadRequest' of XML schema type 'ns1:SubmitMmktBvalDealsUploadRequest' */
        ns1__SubmitMmktBvalDealsUploadRequest *ns1__submitMmktBvalDealsUploadRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__submitMmktBvalDealsUploadRequest */
        long soap_type() const { return SOAP_TYPE___ns1__submitMmktBvalDealsUploadRequest; }
        /** Constructor with member initializations */
        __ns1__submitMmktBvalDealsUploadRequest() : ns1__submitMmktBvalDealsUploadRequest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__submitMmktBvalDealsUploadRequest * SOAP_FMAC2 soap_instantiate___ns1__submitMmktBvalDealsUploadRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:6553 */
#ifndef SOAP_TYPE___ns1__retrieveMmktBvalDealsUploadResponse
#define SOAP_TYPE___ns1__retrieveMmktBvalDealsUploadResponse (393)
/* Wrapper: */
struct SOAP_CMAC __ns1__retrieveMmktBvalDealsUploadResponse {
      public:
        /** Optional element 'ns1:retrieveMmktBvalDealsUploadRequest' of XML schema type 'ns1:RetrieveMmktBvalDealsUploadRequest' */
        ns1__RetrieveMmktBvalDealsUploadRequest *ns1__retrieveMmktBvalDealsUploadRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__retrieveMmktBvalDealsUploadResponse */
        long soap_type() const { return SOAP_TYPE___ns1__retrieveMmktBvalDealsUploadResponse; }
        /** Constructor with member initializations */
        __ns1__retrieveMmktBvalDealsUploadResponse() : ns1__retrieveMmktBvalDealsUploadRequest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__retrieveMmktBvalDealsUploadResponse * SOAP_FMAC2 soap_instantiate___ns1__retrieveMmktBvalDealsUploadResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bloomberg_dl_soap.h:6722 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (394)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* bloomberg_dl_soap.h:6722 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (395)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XML schema type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code() : SOAP_ENV__Value(), SOAP_ENV__Subcode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* bloomberg_dl_soap.h:6722 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (397)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_<typename> assigned to __type */
        /** Do not create a cyclic data structure through this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : __any(), __type(), fault() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* bloomberg_dl_soap.h:6722 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (400)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason() : SOAP_ENV__Text() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* bloomberg_dl_soap.h:6722 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (401)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XML schema type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XML schema type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XML schema type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XML schema type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* (built-in):0 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
typedef char *_XML;
#endif

/* (built-in):0 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
typedef char *_QName;
#endif

/* bloomberg_dl_soap.h:153 */
#ifndef SOAP_TYPE_xsd__date
#define SOAP_TYPE_xsd__date (9)
typedef std::string xsd__date;
#endif

/* bloomberg_dl_soap.h:156 */
#ifndef SOAP_TYPE_xsd__time
#define SOAP_TYPE_xsd__time (10)
typedef std::string xsd__time;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* time_t has binding name 'dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_dateTime
#define SOAP_TYPE_dateTime (187)
#endif

/* bool has binding name 'bool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_bool
#define SOAP_TYPE_bool (162)
#endif

/* enum ns1__DLCategory2 has binding name 'ns1__DLCategory2' for type 'ns1:DLCategory2' */
#ifndef SOAP_TYPE_ns1__DLCategory2
#define SOAP_TYPE_ns1__DLCategory2 (159)
#endif

/* enum ns1__DLCategory has binding name 'ns1__DLCategory' for type 'ns1:DLCategory' */
#ifndef SOAP_TYPE_ns1__DLCategory
#define SOAP_TYPE_ns1__DLCategory (158)
#endif

/* enum ns1__BvalFieldMacro has binding name 'ns1__BvalFieldMacro' for type 'ns1:BvalFieldMacro' */
#ifndef SOAP_TYPE_ns1__BvalFieldMacro
#define SOAP_TYPE_ns1__BvalFieldMacro (157)
#endif

/* enum ns1__FieldMacro has binding name 'ns1__FieldMacro' for type 'ns1:FieldMacro' */
#ifndef SOAP_TYPE_ns1__FieldMacro
#define SOAP_TYPE_ns1__FieldMacro (156)
#endif

/* enum ns1__RegSolvency has binding name 'ns1__RegSolvency' for type 'ns1:RegSolvency' */
#ifndef SOAP_TYPE_ns1__RegSolvency
#define SOAP_TYPE_ns1__RegSolvency (155)
#endif

/* enum ns1__OtcBvalAction has binding name 'ns1__OtcBvalAction' for type 'ns1:OtcBvalAction' */
#ifndef SOAP_TYPE_ns1__OtcBvalAction
#define SOAP_TYPE_ns1__OtcBvalAction (154)
#endif

/* enum ns1__ActionsDate has binding name 'ns1__ActionsDate' for type 'ns1:ActionsDate' */
#ifndef SOAP_TYPE_ns1__ActionsDate
#define SOAP_TYPE_ns1__ActionsDate (153)
#endif

/* enum ns1__PortSecDes has binding name 'ns1__PortSecDes' for type 'ns1:PortSecDes' */
#ifndef SOAP_TYPE_ns1__PortSecDes
#define SOAP_TYPE_ns1__PortSecDes (152)
#endif

/* enum ns1__CancelStatus has binding name 'ns1__CancelStatus' for type 'ns1:CancelStatus' */
#ifndef SOAP_TYPE_ns1__CancelStatus
#define SOAP_TYPE_ns1__CancelStatus (151)
#endif

/* enum ns1__BvalSnapshot has binding name 'ns1__BvalSnapshot' for type 'ns1:BvalSnapshot' */
#ifndef SOAP_TYPE_ns1__BvalSnapshot
#define SOAP_TYPE_ns1__BvalSnapshot (150)
#endif

/* enum ns1__BvalTier has binding name 'ns1__BvalTier' for type 'ns1:BvalTier' */
#ifndef SOAP_TYPE_ns1__BvalTier
#define SOAP_TYPE_ns1__BvalTier (149)
#endif

/* enum ns1__Periodicity has binding name 'ns1__Periodicity' for type 'ns1:Periodicity' */
#ifndef SOAP_TYPE_ns1__Periodicity
#define SOAP_TYPE_ns1__Periodicity (148)
#endif

/* enum ns1__FilingStatus has binding name 'ns1__FilingStatus' for type 'ns1:FilingStatus' */
#ifndef SOAP_TYPE_ns1__FilingStatus
#define SOAP_TYPE_ns1__FilingStatus (147)
#endif

/* enum ns1__HistOption has binding name 'ns1__HistOption' for type 'ns1:HistOption' */
#ifndef SOAP_TYPE_ns1__HistOption
#define SOAP_TYPE_ns1__HistOption (146)
#endif

/* enum ns1__HistPeriod has binding name 'ns1__HistPeriod' for type 'ns1:HistPeriod' */
#ifndef SOAP_TYPE_ns1__HistPeriod
#define SOAP_TYPE_ns1__HistPeriod (145)
#endif

/* enum ns1__FieldType has binding name 'ns1__FieldType' for type 'ns1:FieldType' */
#ifndef SOAP_TYPE_ns1__FieldType
#define SOAP_TYPE_ns1__FieldType (144)
#endif

/* enum ns1__DateFormat has binding name 'ns1__DateFormat' for type 'ns1:DateFormat' */
#ifndef SOAP_TYPE_ns1__DateFormat
#define SOAP_TYPE_ns1__DateFormat (143)
#endif

/* enum ns1__DiffFlag has binding name 'ns1__DiffFlag' for type 'ns1:DiffFlag' */
#ifndef SOAP_TYPE_ns1__DiffFlag
#define SOAP_TYPE_ns1__DiffFlag (142)
#endif

/* enum ns1__Version has binding name 'ns1__Version' for type 'ns1:Version' */
#ifndef SOAP_TYPE_ns1__Version
#define SOAP_TYPE_ns1__Version (141)
#endif

/* enum ns1__ProgramFlag has binding name 'ns1__ProgramFlag' for type 'ns1:ProgramFlag' */
#ifndef SOAP_TYPE_ns1__ProgramFlag
#define SOAP_TYPE_ns1__ProgramFlag (140)
#endif

/* enum ns1__SpecialChar has binding name 'ns1__SpecialChar' for type 'ns1:SpecialChar' */
#ifndef SOAP_TYPE_ns1__SpecialChar
#define SOAP_TYPE_ns1__SpecialChar (139)
#endif

/* enum ns1__InstrumentType has binding name 'ns1__InstrumentType' for type 'ns1:InstrumentType' */
#ifndef SOAP_TYPE_ns1__InstrumentType
#define SOAP_TYPE_ns1__InstrumentType (138)
#endif

/* enum ns1__SecondaryQualifierType has binding name 'ns1__SecondaryQualifierType' for type 'ns1:SecondaryQualifierType' */
#ifndef SOAP_TYPE_ns1__SecondaryQualifierType
#define SOAP_TYPE_ns1__SecondaryQualifierType (137)
#endif

/* enum ns1__SecondaryQualifierOperator has binding name 'ns1__SecondaryQualifierOperator' for type 'ns1:SecondaryQualifierOperator' */
#ifndef SOAP_TYPE_ns1__SecondaryQualifierOperator
#define SOAP_TYPE_ns1__SecondaryQualifierOperator (136)
#endif

/* enum ns1__MacroType has binding name 'ns1__MacroType' for type 'ns1:MacroType' */
#ifndef SOAP_TYPE_ns1__MacroType
#define SOAP_TYPE_ns1__MacroType (135)
#endif

/* enum ns1__MarketSector has binding name 'ns1__MarketSector' for type 'ns1:MarketSector' */
#ifndef SOAP_TYPE_ns1__MarketSector
#define SOAP_TYPE_ns1__MarketSector (134)
#endif

/* ns1__RetrieveMmktBvalDealsUploadResponse has binding name 'ns1__RetrieveMmktBvalDealsUploadResponse' for type 'ns1:RetrieveMmktBvalDealsUploadResponse' */
#ifndef SOAP_TYPE_ns1__RetrieveMmktBvalDealsUploadResponse
#define SOAP_TYPE_ns1__RetrieveMmktBvalDealsUploadResponse (133)
#endif

/* ns1__MmktBvalDealInfos has binding name 'ns1__MmktBvalDealInfos' for type 'ns1:MmktBvalDealInfos' */
#ifndef SOAP_TYPE_ns1__MmktBvalDealInfos
#define SOAP_TYPE_ns1__MmktBvalDealInfos (132)
#endif

/* ns1__MmktBvalDealInformation has binding name 'ns1__MmktBvalDealInformation' for type 'ns1:MmktBvalDealInformation' */
#ifndef SOAP_TYPE_ns1__MmktBvalDealInformation
#define SOAP_TYPE_ns1__MmktBvalDealInformation (131)
#endif

/* ns1__RetrieveMmktBvalDealsUploadRequest has binding name 'ns1__RetrieveMmktBvalDealsUploadRequest' for type 'ns1:RetrieveMmktBvalDealsUploadRequest' */
#ifndef SOAP_TYPE_ns1__RetrieveMmktBvalDealsUploadRequest
#define SOAP_TYPE_ns1__RetrieveMmktBvalDealsUploadRequest (130)
#endif

/* ns1__SubmitMmktBvalDealsUploadResponse has binding name 'ns1__SubmitMmktBvalDealsUploadResponse' for type 'ns1:SubmitMmktBvalDealsUploadResponse' */
#ifndef SOAP_TYPE_ns1__SubmitMmktBvalDealsUploadResponse
#define SOAP_TYPE_ns1__SubmitMmktBvalDealsUploadResponse (129)
#endif

/* ns1__SubmitMmktBvalDealsUploadRequest has binding name 'ns1__SubmitMmktBvalDealsUploadRequest' for type 'ns1:SubmitMmktBvalDealsUploadRequest' */
#ifndef SOAP_TYPE_ns1__SubmitMmktBvalDealsUploadRequest
#define SOAP_TYPE_ns1__SubmitMmktBvalDealsUploadRequest (128)
#endif

/* ns1__MmktBvalHeaders has binding name 'ns1__MmktBvalHeaders' for type 'ns1:MmktBvalHeaders' */
#ifndef SOAP_TYPE_ns1__MmktBvalHeaders
#define SOAP_TYPE_ns1__MmktBvalHeaders (127)
#endif

/* ns1__GetFieldsResponse has binding name 'ns1__GetFieldsResponse' for type 'ns1:GetFieldsResponse' */
#ifndef SOAP_TYPE_ns1__GetFieldsResponse
#define SOAP_TYPE_ns1__GetFieldsResponse (126)
#endif

/* ns1__GetFieldsRequest has binding name 'ns1__GetFieldsRequest' for type 'ns1:GetFieldsRequest' */
#ifndef SOAP_TYPE_ns1__GetFieldsRequest
#define SOAP_TYPE_ns1__GetFieldsRequest (125)
#endif

/* ns1__RetrieveOtcBvalDealsUploadResponse has binding name 'ns1__RetrieveOtcBvalDealsUploadResponse' for type 'ns1:RetrieveOtcBvalDealsUploadResponse' */
#ifndef SOAP_TYPE_ns1__RetrieveOtcBvalDealsUploadResponse
#define SOAP_TYPE_ns1__RetrieveOtcBvalDealsUploadResponse (124)
#endif

/* ns1__RetrieveOtcBvalDealsUploadRequest has binding name 'ns1__RetrieveOtcBvalDealsUploadRequest' for type 'ns1:RetrieveOtcBvalDealsUploadRequest' */
#ifndef SOAP_TYPE_ns1__RetrieveOtcBvalDealsUploadRequest
#define SOAP_TYPE_ns1__RetrieveOtcBvalDealsUploadRequest (123)
#endif

/* ns1__SubmitOtcBvalDealsUploadResponse has binding name 'ns1__SubmitOtcBvalDealsUploadResponse' for type 'ns1:SubmitOtcBvalDealsUploadResponse' */
#ifndef SOAP_TYPE_ns1__SubmitOtcBvalDealsUploadResponse
#define SOAP_TYPE_ns1__SubmitOtcBvalDealsUploadResponse (122)
#endif

/* ns1__SubmitOtcBvalDealsUploadRequest has binding name 'ns1__SubmitOtcBvalDealsUploadRequest' for type 'ns1:SubmitOtcBvalDealsUploadRequest' */
#ifndef SOAP_TYPE_ns1__SubmitOtcBvalDealsUploadRequest
#define SOAP_TYPE_ns1__SubmitOtcBvalDealsUploadRequest (121)
#endif

/* ns1__RetrieveOtcbvalUploadResponse has binding name 'ns1__RetrieveOtcbvalUploadResponse' for type 'ns1:RetrieveOtcbvalUploadResponse' */
#ifndef SOAP_TYPE_ns1__RetrieveOtcbvalUploadResponse
#define SOAP_TYPE_ns1__RetrieveOtcbvalUploadResponse (120)
#endif

/* ns1__RetrieveOtcbvalUploadRequest has binding name 'ns1__RetrieveOtcbvalUploadRequest' for type 'ns1:RetrieveOtcbvalUploadRequest' */
#ifndef SOAP_TYPE_ns1__RetrieveOtcbvalUploadRequest
#define SOAP_TYPE_ns1__RetrieveOtcbvalUploadRequest (119)
#endif

/* ns1__SubmitOtcbvalUploadResponse has binding name 'ns1__SubmitOtcbvalUploadResponse' for type 'ns1:SubmitOtcbvalUploadResponse' */
#ifndef SOAP_TYPE_ns1__SubmitOtcbvalUploadResponse
#define SOAP_TYPE_ns1__SubmitOtcbvalUploadResponse (118)
#endif

/* ns1__SubmitOtcbvalUploadRequest has binding name 'ns1__SubmitOtcbvalUploadRequest' for type 'ns1:SubmitOtcbvalUploadRequest' */
#ifndef SOAP_TYPE_ns1__SubmitOtcbvalUploadRequest
#define SOAP_TYPE_ns1__SubmitOtcbvalUploadRequest (117)
#endif

/* ns1__RetrieveGetAllQuotesResponse has binding name 'ns1__RetrieveGetAllQuotesResponse' for type 'ns1:RetrieveGetAllQuotesResponse' */
#ifndef SOAP_TYPE_ns1__RetrieveGetAllQuotesResponse
#define SOAP_TYPE_ns1__RetrieveGetAllQuotesResponse (116)
#endif

/* ns1__RetrieveGetAllQuotesRequest has binding name 'ns1__RetrieveGetAllQuotesRequest' for type 'ns1:RetrieveGetAllQuotesRequest' */
#ifndef SOAP_TYPE_ns1__RetrieveGetAllQuotesRequest
#define SOAP_TYPE_ns1__RetrieveGetAllQuotesRequest (115)
#endif

/* ns1__SubmitGetAllQuotesResponse has binding name 'ns1__SubmitGetAllQuotesResponse' for type 'ns1:SubmitGetAllQuotesResponse' */
#ifndef SOAP_TYPE_ns1__SubmitGetAllQuotesResponse
#define SOAP_TYPE_ns1__SubmitGetAllQuotesResponse (114)
#endif

/* ns1__SubmitGetAllQuotesRequest has binding name 'ns1__SubmitGetAllQuotesRequest' for type 'ns1:SubmitGetAllQuotesRequest' */
#ifndef SOAP_TYPE_ns1__SubmitGetAllQuotesRequest
#define SOAP_TYPE_ns1__SubmitGetAllQuotesRequest (113)
#endif

/* ns1__RetrieveGetQuotesResponse has binding name 'ns1__RetrieveGetQuotesResponse' for type 'ns1:RetrieveGetQuotesResponse' */
#ifndef SOAP_TYPE_ns1__RetrieveGetQuotesResponse
#define SOAP_TYPE_ns1__RetrieveGetQuotesResponse (112)
#endif

/* ns1__RetrieveGetQuotesRequest has binding name 'ns1__RetrieveGetQuotesRequest' for type 'ns1:RetrieveGetQuotesRequest' */
#ifndef SOAP_TYPE_ns1__RetrieveGetQuotesRequest
#define SOAP_TYPE_ns1__RetrieveGetQuotesRequest (111)
#endif

/* ns1__SubmitGetQuotesResponse has binding name 'ns1__SubmitGetQuotesResponse' for type 'ns1:SubmitGetQuotesResponse' */
#ifndef SOAP_TYPE_ns1__SubmitGetQuotesResponse
#define SOAP_TYPE_ns1__SubmitGetQuotesResponse (110)
#endif

/* ns1__SubmitGetQuotesRequest has binding name 'ns1__SubmitGetQuotesRequest' for type 'ns1:SubmitGetQuotesRequest' */
#ifndef SOAP_TYPE_ns1__SubmitGetQuotesRequest
#define SOAP_TYPE_ns1__SubmitGetQuotesRequest (109)
#endif

/* ns1__RetrieveGetActionsResponse has binding name 'ns1__RetrieveGetActionsResponse' for type 'ns1:RetrieveGetActionsResponse' */
#ifndef SOAP_TYPE_ns1__RetrieveGetActionsResponse
#define SOAP_TYPE_ns1__RetrieveGetActionsResponse (108)
#endif

/* ns1__RetrieveGetActionsRequest has binding name 'ns1__RetrieveGetActionsRequest' for type 'ns1:RetrieveGetActionsRequest' */
#ifndef SOAP_TYPE_ns1__RetrieveGetActionsRequest
#define SOAP_TYPE_ns1__RetrieveGetActionsRequest (107)
#endif

/* ns1__SubmitGetActionsResponse has binding name 'ns1__SubmitGetActionsResponse' for type 'ns1:SubmitGetActionsResponse' */
#ifndef SOAP_TYPE_ns1__SubmitGetActionsResponse
#define SOAP_TYPE_ns1__SubmitGetActionsResponse (106)
#endif

/* ns1__SubmitGetActionsRequest has binding name 'ns1__SubmitGetActionsRequest' for type 'ns1:SubmitGetActionsRequest' */
#ifndef SOAP_TYPE_ns1__SubmitGetActionsRequest
#define SOAP_TYPE_ns1__SubmitGetActionsRequest (105)
#endif

/* ns1__GetPortfolioValidationResponse has binding name 'ns1__GetPortfolioValidationResponse' for type 'ns1:GetPortfolioValidationResponse' */
#ifndef SOAP_TYPE_ns1__GetPortfolioValidationResponse
#define SOAP_TYPE_ns1__GetPortfolioValidationResponse (104)
#endif

/* ns1__GetPortfolioValidationRequest has binding name 'ns1__GetPortfolioValidationRequest' for type 'ns1:GetPortfolioValidationRequest' */
#ifndef SOAP_TYPE_ns1__GetPortfolioValidationRequest
#define SOAP_TYPE_ns1__GetPortfolioValidationRequest (103)
#endif

/* ns1__RetrieveGetCompanyResponse has binding name 'ns1__RetrieveGetCompanyResponse' for type 'ns1:RetrieveGetCompanyResponse' */
#ifndef SOAP_TYPE_ns1__RetrieveGetCompanyResponse
#define SOAP_TYPE_ns1__RetrieveGetCompanyResponse (102)
#endif

/* ns1__RetrieveGetCompanyRequest has binding name 'ns1__RetrieveGetCompanyRequest' for type 'ns1:RetrieveGetCompanyRequest' */
#ifndef SOAP_TYPE_ns1__RetrieveGetCompanyRequest
#define SOAP_TYPE_ns1__RetrieveGetCompanyRequest (101)
#endif

/* ns1__SubmitGetCompanyResponse has binding name 'ns1__SubmitGetCompanyResponse' for type 'ns1:SubmitGetCompanyResponse' */
#ifndef SOAP_TYPE_ns1__SubmitGetCompanyResponse
#define SOAP_TYPE_ns1__SubmitGetCompanyResponse (100)
#endif

/* ns1__SubmitGetCompanyRequest has binding name 'ns1__SubmitGetCompanyRequest' for type 'ns1:SubmitGetCompanyRequest' */
#ifndef SOAP_TYPE_ns1__SubmitGetCompanyRequest
#define SOAP_TYPE_ns1__SubmitGetCompanyRequest (99)
#endif

/* ns1__RetrieveGetFundamentalsResponse has binding name 'ns1__RetrieveGetFundamentalsResponse' for type 'ns1:RetrieveGetFundamentalsResponse' */
#ifndef SOAP_TYPE_ns1__RetrieveGetFundamentalsResponse
#define SOAP_TYPE_ns1__RetrieveGetFundamentalsResponse (98)
#endif

/* ns1__RetrieveGetFundamentalsRequest has binding name 'ns1__RetrieveGetFundamentalsRequest' for type 'ns1:RetrieveGetFundamentalsRequest' */
#ifndef SOAP_TYPE_ns1__RetrieveGetFundamentalsRequest
#define SOAP_TYPE_ns1__RetrieveGetFundamentalsRequest (97)
#endif

/* ns1__SubmitGetFundamentalsResponse has binding name 'ns1__SubmitGetFundamentalsResponse' for type 'ns1:SubmitGetFundamentalsResponse' */
#ifndef SOAP_TYPE_ns1__SubmitGetFundamentalsResponse
#define SOAP_TYPE_ns1__SubmitGetFundamentalsResponse (96)
#endif

/* ns1__SubmitGetFundamentalsRequest has binding name 'ns1__SubmitGetFundamentalsRequest' for type 'ns1:SubmitGetFundamentalsRequest' */
#ifndef SOAP_TYPE_ns1__SubmitGetFundamentalsRequest
#define SOAP_TYPE_ns1__SubmitGetFundamentalsRequest (95)
#endif

/* ns1__RetrieveScheduledResponse has binding name 'ns1__RetrieveScheduledResponse' for type 'ns1:RetrieveScheduledResponse' */
#ifndef SOAP_TYPE_ns1__RetrieveScheduledResponse
#define SOAP_TYPE_ns1__RetrieveScheduledResponse (94)
#endif

/* ns1__ScheduledResponse has binding name 'ns1__ScheduledResponse' for type 'ns1:ScheduledResponse' */
#ifndef SOAP_TYPE_ns1__ScheduledResponse
#define SOAP_TYPE_ns1__ScheduledResponse (93)
#endif

/* ns1__ScheduledResponses has binding name 'ns1__ScheduledResponses' for type 'ns1:ScheduledResponses' */
#ifndef SOAP_TYPE_ns1__ScheduledResponses
#define SOAP_TYPE_ns1__ScheduledResponses (92)
#endif

/* ns1__RetrieveScheduledRequest has binding name 'ns1__RetrieveScheduledRequest' for type 'ns1:RetrieveScheduledRequest' */
#ifndef SOAP_TYPE_ns1__RetrieveScheduledRequest
#define SOAP_TYPE_ns1__RetrieveScheduledRequest (91)
#endif

/* ns1__SubmitScheduledResponse has binding name 'ns1__SubmitScheduledResponse' for type 'ns1:SubmitScheduledResponse' */
#ifndef SOAP_TYPE_ns1__SubmitScheduledResponse
#define SOAP_TYPE_ns1__SubmitScheduledResponse (90)
#endif

/* ns1__SubmitScheduledRequest has binding name 'ns1__SubmitScheduledRequest' for type 'ns1:SubmitScheduledRequest' */
#ifndef SOAP_TYPE_ns1__SubmitScheduledRequest
#define SOAP_TYPE_ns1__SubmitScheduledRequest (89)
#endif

/* ns1__GetCorrectionsResponse has binding name 'ns1__GetCorrectionsResponse' for type 'ns1:GetCorrectionsResponse' */
#ifndef SOAP_TYPE_ns1__GetCorrectionsResponse
#define SOAP_TYPE_ns1__GetCorrectionsResponse (88)
#endif

/* ns1__GetCorrectionsRequest has binding name 'ns1__GetCorrectionsRequest' for type 'ns1:GetCorrectionsRequest' */
#ifndef SOAP_TYPE_ns1__GetCorrectionsRequest
#define SOAP_TYPE_ns1__GetCorrectionsRequest (87)
#endif

/* ns1__RetrieveCancelResponse has binding name 'ns1__RetrieveCancelResponse' for type 'ns1:RetrieveCancelResponse' */
#ifndef SOAP_TYPE_ns1__RetrieveCancelResponse
#define SOAP_TYPE_ns1__RetrieveCancelResponse (86)
#endif

/* ns1__RetrieveCancelRequest has binding name 'ns1__RetrieveCancelRequest' for type 'ns1:RetrieveCancelRequest' */
#ifndef SOAP_TYPE_ns1__RetrieveCancelRequest
#define SOAP_TYPE_ns1__RetrieveCancelRequest (85)
#endif

/* ns1__SubmitCancelResponse has binding name 'ns1__SubmitCancelResponse' for type 'ns1:SubmitCancelResponse' */
#ifndef SOAP_TYPE_ns1__SubmitCancelResponse
#define SOAP_TYPE_ns1__SubmitCancelResponse (84)
#endif

/* ns1__SubmitCancelRequest has binding name 'ns1__SubmitCancelRequest' for type 'ns1:SubmitCancelRequest' */
#ifndef SOAP_TYPE_ns1__SubmitCancelRequest
#define SOAP_TYPE_ns1__SubmitCancelRequest (83)
#endif

/* ns1__RetrieveGetHistoryResponse has binding name 'ns1__RetrieveGetHistoryResponse' for type 'ns1:RetrieveGetHistoryResponse' */
#ifndef SOAP_TYPE_ns1__RetrieveGetHistoryResponse
#define SOAP_TYPE_ns1__RetrieveGetHistoryResponse (82)
#endif

/* ns1__RetrieveGetHistoryRequest has binding name 'ns1__RetrieveGetHistoryRequest' for type 'ns1:RetrieveGetHistoryRequest' */
#ifndef SOAP_TYPE_ns1__RetrieveGetHistoryRequest
#define SOAP_TYPE_ns1__RetrieveGetHistoryRequest (81)
#endif

/* ns1__SubmitGetHistoryResponse has binding name 'ns1__SubmitGetHistoryResponse' for type 'ns1:SubmitGetHistoryResponse' */
#ifndef SOAP_TYPE_ns1__SubmitGetHistoryResponse
#define SOAP_TYPE_ns1__SubmitGetHistoryResponse (80)
#endif

/* ns1__SubmitGetHistoryRequest has binding name 'ns1__SubmitGetHistoryRequest' for type 'ns1:SubmitGetHistoryRequest' */
#ifndef SOAP_TYPE_ns1__SubmitGetHistoryRequest
#define SOAP_TYPE_ns1__SubmitGetHistoryRequest (79)
#endif

/* ns1__RetrieveGetDataResponse has binding name 'ns1__RetrieveGetDataResponse' for type 'ns1:RetrieveGetDataResponse' */
#ifndef SOAP_TYPE_ns1__RetrieveGetDataResponse
#define SOAP_TYPE_ns1__RetrieveGetDataResponse (78)
#endif

/* ns1__RetrieveGetDataRequest has binding name 'ns1__RetrieveGetDataRequest' for type 'ns1:RetrieveGetDataRequest' */
#ifndef SOAP_TYPE_ns1__RetrieveGetDataRequest
#define SOAP_TYPE_ns1__RetrieveGetDataRequest (77)
#endif

/* ns1__SubmitGetDataResponse has binding name 'ns1__SubmitGetDataResponse' for type 'ns1:SubmitGetDataResponse' */
#ifndef SOAP_TYPE_ns1__SubmitGetDataResponse
#define SOAP_TYPE_ns1__SubmitGetDataResponse (76)
#endif

/* ns1__SubmitGetDataRequest has binding name 'ns1__SubmitGetDataRequest' for type 'ns1:SubmitGetDataRequest' */
#ifndef SOAP_TYPE_ns1__SubmitGetDataRequest
#define SOAP_TYPE_ns1__SubmitGetDataRequest (75)
#endif

/* ns1__PerSecurityResponse has binding name 'ns1__PerSecurityResponse' for type 'ns1:PerSecurityResponse' */
#ifndef SOAP_TYPE_ns1__PerSecurityResponse
#define SOAP_TYPE_ns1__PerSecurityResponse (74)
#endif

/* ns1__OtcDealInfos has binding name 'ns1__OtcDealInfos' for type 'ns1:OtcDealInfos' */
#ifndef SOAP_TYPE_ns1__OtcDealInfos
#define SOAP_TYPE_ns1__OtcDealInfos (73)
#endif

/* ns1__OtcDealInformation has binding name 'ns1__OtcDealInformation' for type 'ns1:OtcDealInformation' */
#ifndef SOAP_TYPE_ns1__OtcDealInformation
#define SOAP_TYPE_ns1__OtcDealInformation (72)
#endif

/* ns1__OtcBvalHeaders has binding name 'ns1__OtcBvalHeaders' for type 'ns1:OtcBvalHeaders' */
#ifndef SOAP_TYPE_ns1__OtcBvalHeaders
#define SOAP_TYPE_ns1__OtcBvalHeaders (71)
#endif

/* ns1__FieldInfo has binding name 'ns1__FieldInfo' for type 'ns1:FieldInfo' */
#ifndef SOAP_TYPE_ns1__FieldInfo
#define SOAP_TYPE_ns1__FieldInfo (70)
#endif

/* ns1__FieldInfos has binding name 'ns1__FieldInfos' for type 'ns1:FieldInfos' */
#ifndef SOAP_TYPE_ns1__FieldInfos
#define SOAP_TYPE_ns1__FieldInfos (69)
#endif

/* ns1__FieldSearchCriteria has binding name 'ns1__FieldSearchCriteria' for type 'ns1:FieldSearchCriteria' */
#ifndef SOAP_TYPE_ns1__FieldSearchCriteria
#define SOAP_TYPE_ns1__FieldSearchCriteria (68)
#endif

/* ns1__CancelResponseStatus has binding name 'ns1__CancelResponseStatus' for type 'ns1:CancelResponseStatus' */
#ifndef SOAP_TYPE_ns1__CancelResponseStatus
#define SOAP_TYPE_ns1__CancelResponseStatus (67)
#endif

/* ns1__ResponseStatus has binding name 'ns1__ResponseStatus' for type 'ns1:ResponseStatus' */
#ifndef SOAP_TYPE_ns1__ResponseStatus
#define SOAP_TYPE_ns1__ResponseStatus (66)
#endif

/* ns1__BulkArrayEntry has binding name 'ns1__BulkArrayEntry' for type 'ns1:BulkArrayEntry' */
#ifndef SOAP_TYPE_ns1__BulkArrayEntry
#define SOAP_TYPE_ns1__BulkArrayEntry (65)
#endif

/* ns1__BulkArray has binding name 'ns1__BulkArray' for type 'ns1:BulkArray' */
#ifndef SOAP_TYPE_ns1__BulkArray
#define SOAP_TYPE_ns1__BulkArray (64)
#endif

/* ns1__ActionStandardFields has binding name 'ns1__ActionStandardFields' for type 'ns1:ActionStandardFields' */
#ifndef SOAP_TYPE_ns1__ActionStandardFields
#define SOAP_TYPE_ns1__ActionStandardFields (63)
#endif

/* ns1__HistData has binding name 'ns1__HistData' for type 'ns1:HistData' */
#ifndef SOAP_TYPE_ns1__HistData
#define SOAP_TYPE_ns1__HistData (62)
#endif

/* ns1__QRMQuote has binding name 'ns1__QRMQuote' for type 'ns1:QRMQuote' */
#ifndef SOAP_TYPE_ns1__QRMQuote
#define SOAP_TYPE_ns1__QRMQuote (61)
#endif

/* ns1__QRMQuoteData has binding name 'ns1__QRMQuoteData' for type 'ns1:QRMQuoteData' */
#ifndef SOAP_TYPE_ns1__QRMQuoteData
#define SOAP_TYPE_ns1__QRMQuoteData (60)
#endif

/* ns1__QRQuote has binding name 'ns1__QRQuote' for type 'ns1:QRQuote' */
#ifndef SOAP_TYPE_ns1__QRQuote
#define SOAP_TYPE_ns1__QRQuote (59)
#endif

/* ns1__QRMQuotes has binding name 'ns1__QRMQuotes' for type 'ns1:QRMQuotes' */
#ifndef SOAP_TYPE_ns1__QRMQuotes
#define SOAP_TYPE_ns1__QRMQuotes (58)
#endif

/* ns1__QRQuotes has binding name 'ns1__QRQuotes' for type 'ns1:QRQuotes' */
#ifndef SOAP_TYPE_ns1__QRQuotes
#define SOAP_TYPE_ns1__QRQuotes (57)
#endif

/* ns1__Data has binding name 'ns1__Data' for type 'ns1:Data' */
#ifndef SOAP_TYPE_ns1__Data
#define SOAP_TYPE_ns1__Data (56)
#endif

/* ns1__CorrectionRecord has binding name 'ns1__CorrectionRecord' for type 'ns1:CorrectionRecord' */
#ifndef SOAP_TYPE_ns1__CorrectionRecord
#define SOAP_TYPE_ns1__CorrectionRecord (55)
#endif

/* ns1__ActionsInstrumentData has binding name 'ns1__ActionsInstrumentData' for type 'ns1:ActionsInstrumentData' */
#ifndef SOAP_TYPE_ns1__ActionsInstrumentData
#define SOAP_TYPE_ns1__ActionsInstrumentData (54)
#endif

/* ns1__AllQuotesInstrumentData has binding name 'ns1__AllQuotesInstrumentData' for type 'ns1:AllQuotesInstrumentData' */
#ifndef SOAP_TYPE_ns1__AllQuotesInstrumentData
#define SOAP_TYPE_ns1__AllQuotesInstrumentData (53)
#endif

/* ns1__QuotesInstrumentData has binding name 'ns1__QuotesInstrumentData' for type 'ns1:QuotesInstrumentData' */
#ifndef SOAP_TYPE_ns1__QuotesInstrumentData
#define SOAP_TYPE_ns1__QuotesInstrumentData (52)
#endif

/* ns1__FundInstrumentData has binding name 'ns1__FundInstrumentData' for type 'ns1:FundInstrumentData' */
#ifndef SOAP_TYPE_ns1__FundInstrumentData
#define SOAP_TYPE_ns1__FundInstrumentData (51)
#endif

/* ns1__HistInstrumentData has binding name 'ns1__HistInstrumentData' for type 'ns1:HistInstrumentData' */
#ifndef SOAP_TYPE_ns1__HistInstrumentData
#define SOAP_TYPE_ns1__HistInstrumentData (50)
#endif

/* ns1__InstrumentData has binding name 'ns1__InstrumentData' for type 'ns1:InstrumentData' */
#ifndef SOAP_TYPE_ns1__InstrumentData
#define SOAP_TYPE_ns1__InstrumentData (49)
#endif

/* ns1__DataItem has binding name 'ns1__DataItem' for type 'ns1:DataItem' */
#ifndef SOAP_TYPE_ns1__DataItem
#define SOAP_TYPE_ns1__DataItem (48)
#endif

/* ns1__Actions has binding name 'ns1__Actions' for type 'ns1:Actions' */
#ifndef SOAP_TYPE_ns1__Actions
#define SOAP_TYPE_ns1__Actions (47)
#endif

/* ns1__Override has binding name 'ns1__Override' for type 'ns1:Override' */
#ifndef SOAP_TYPE_ns1__Override
#define SOAP_TYPE_ns1__Override (46)
#endif

/* ns1__SecondaryQualifier has binding name 'ns1__SecondaryQualifier' for type 'ns1:SecondaryQualifier' */
#ifndef SOAP_TYPE_ns1__SecondaryQualifier
#define SOAP_TYPE_ns1__SecondaryQualifier (45)
#endif

/* ns1__PrimaryQualifier has binding name 'ns1__PrimaryQualifier' for type 'ns1:PrimaryQualifier' */
#ifndef SOAP_TYPE_ns1__PrimaryQualifier
#define SOAP_TYPE_ns1__PrimaryQualifier (44)
#endif

/* ns1__Macro has binding name 'ns1__Macro' for type 'ns1:Macro' */
#ifndef SOAP_TYPE_ns1__Macro
#define SOAP_TYPE_ns1__Macro (43)
#endif

/* ns1__FundInstrument has binding name 'ns1__FundInstrument' for type 'ns1:FundInstrument' */
#ifndef SOAP_TYPE_ns1__FundInstrument
#define SOAP_TYPE_ns1__FundInstrument (42)
#endif

/* ns1__Instrument has binding name 'ns1__Instrument' for type 'ns1:Instrument' */
#ifndef SOAP_TYPE_ns1__Instrument
#define SOAP_TYPE_ns1__Instrument (41)
#endif

/* ns1__AllQuotesInstrumentDatas has binding name 'ns1__AllQuotesInstrumentDatas' for type 'ns1:AllQuotesInstrumentDatas' */
#ifndef SOAP_TYPE_ns1__AllQuotesInstrumentDatas
#define SOAP_TYPE_ns1__AllQuotesInstrumentDatas (40)
#endif

/* ns1__QuotesInstrumentDatas has binding name 'ns1__QuotesInstrumentDatas' for type 'ns1:QuotesInstrumentDatas' */
#ifndef SOAP_TYPE_ns1__QuotesInstrumentDatas
#define SOAP_TYPE_ns1__QuotesInstrumentDatas (39)
#endif

/* ns1__CorrectionRecords has binding name 'ns1__CorrectionRecords' for type 'ns1:CorrectionRecords' */
#ifndef SOAP_TYPE_ns1__CorrectionRecords
#define SOAP_TYPE_ns1__CorrectionRecords (38)
#endif

/* ns1__ActionsInstrumentDatas has binding name 'ns1__ActionsInstrumentDatas' for type 'ns1:ActionsInstrumentDatas' */
#ifndef SOAP_TYPE_ns1__ActionsInstrumentDatas
#define SOAP_TYPE_ns1__ActionsInstrumentDatas (37)
#endif

/* ns1__FundInstrumentDatas has binding name 'ns1__FundInstrumentDatas' for type 'ns1:FundInstrumentDatas' */
#ifndef SOAP_TYPE_ns1__FundInstrumentDatas
#define SOAP_TYPE_ns1__FundInstrumentDatas (36)
#endif

/* ns1__HistInstrumentDatas has binding name 'ns1__HistInstrumentDatas' for type 'ns1:HistInstrumentDatas' */
#ifndef SOAP_TYPE_ns1__HistInstrumentDatas
#define SOAP_TYPE_ns1__HistInstrumentDatas (35)
#endif

/* ns1__InstrumentDatas has binding name 'ns1__InstrumentDatas' for type 'ns1:InstrumentDatas' */
#ifndef SOAP_TYPE_ns1__InstrumentDatas
#define SOAP_TYPE_ns1__InstrumentDatas (34)
#endif

/* ns1__FundInstruments has binding name 'ns1__FundInstruments' for type 'ns1:FundInstruments' */
#ifndef SOAP_TYPE_ns1__FundInstruments
#define SOAP_TYPE_ns1__FundInstruments (33)
#endif

/* ns1__Instruments has binding name 'ns1__Instruments' for type 'ns1:Instruments' */
#ifndef SOAP_TYPE_ns1__Instruments
#define SOAP_TYPE_ns1__Instruments (32)
#endif

/* ns1__Overrides has binding name 'ns1__Overrides' for type 'ns1:Overrides' */
#ifndef SOAP_TYPE_ns1__Overrides
#define SOAP_TYPE_ns1__Overrides (31)
#endif

/* ns1__Fields has binding name 'ns1__Fields' for type 'ns1:Fields' */
#ifndef SOAP_TYPE_ns1__Fields
#define SOAP_TYPE_ns1__Fields (30)
#endif

/* ns1__ScheduledHeaders has binding name 'ns1__ScheduledHeaders' for type 'ns1:ScheduledHeaders' */
#ifndef SOAP_TYPE_ns1__ScheduledHeaders
#define SOAP_TYPE_ns1__ScheduledHeaders (29)
#endif

/* ns1__BvalFieldSet has binding name 'ns1__BvalFieldSet' for type 'ns1:BvalFieldSet' */
#ifndef SOAP_TYPE_ns1__BvalFieldSet
#define SOAP_TYPE_ns1__BvalFieldSet (28)
#endif

/* ns1__BvalFieldSets has binding name 'ns1__BvalFieldSets' for type 'ns1:BvalFieldSets' */
#ifndef SOAP_TYPE_ns1__BvalFieldSets
#define SOAP_TYPE_ns1__BvalFieldSets (27)
#endif

/* ns1__FieldSet has binding name 'ns1__FieldSet' for type 'ns1:FieldSet' */
#ifndef SOAP_TYPE_ns1__FieldSet
#define SOAP_TYPE_ns1__FieldSet (26)
#endif

/* ns1__FieldSets has binding name 'ns1__FieldSets' for type 'ns1:FieldSets' */
#ifndef SOAP_TYPE_ns1__FieldSets
#define SOAP_TYPE_ns1__FieldSets (25)
#endif

/* ns1__TickOutputTz has binding name 'ns1__TickOutputTz' for type 'ns1:TickOutputTz' */
#ifndef SOAP_TYPE_ns1__TickOutputTz
#define SOAP_TYPE_ns1__TickOutputTz (24)
#endif

/* ns1__DateTimeRange has binding name 'ns1__DateTimeRange' for type 'ns1:DateTimeRange' */
#ifndef SOAP_TYPE_ns1__DateTimeRange
#define SOAP_TYPE_ns1__DateTimeRange (23)
#endif

/* ns1__QuotesHeaders has binding name 'ns1__QuotesHeaders' for type 'ns1:QuotesHeaders' */
#ifndef SOAP_TYPE_ns1__QuotesHeaders
#define SOAP_TYPE_ns1__QuotesHeaders (22)
#endif

/* ns1__GetPortfolioValidationHeaders has binding name 'ns1__GetPortfolioValidationHeaders' for type 'ns1:GetPortfolioValidationHeaders' */
#ifndef SOAP_TYPE_ns1__GetPortfolioValidationHeaders
#define SOAP_TYPE_ns1__GetPortfolioValidationHeaders (21)
#endif

/* ns1__GetActionsHeaders has binding name 'ns1__GetActionsHeaders' for type 'ns1:GetActionsHeaders' */
#ifndef SOAP_TYPE_ns1__GetActionsHeaders
#define SOAP_TYPE_ns1__GetActionsHeaders (20)
#endif

/* ns1__GetCompanyHeaders has binding name 'ns1__GetCompanyHeaders' for type 'ns1:GetCompanyHeaders' */
#ifndef SOAP_TYPE_ns1__GetCompanyHeaders
#define SOAP_TYPE_ns1__GetCompanyHeaders (19)
#endif

/* ns1__GetFundamentalsHeaders has binding name 'ns1__GetFundamentalsHeaders' for type 'ns1:GetFundamentalsHeaders' */
#ifndef SOAP_TYPE_ns1__GetFundamentalsHeaders
#define SOAP_TYPE_ns1__GetFundamentalsHeaders (18)
#endif

/* ns1__GetHistoryHeaders has binding name 'ns1__GetHistoryHeaders' for type 'ns1:GetHistoryHeaders' */
#ifndef SOAP_TYPE_ns1__GetHistoryHeaders
#define SOAP_TYPE_ns1__GetHistoryHeaders (17)
#endif

/* ns1__DateRange has binding name 'ns1__DateRange' for type 'ns1:DateRange' */
#ifndef SOAP_TYPE_ns1__DateRange
#define SOAP_TYPE_ns1__DateRange (16)
#endif

/* ns1__Duration has binding name 'ns1__Duration' for type 'ns1:Duration' */
#ifndef SOAP_TYPE_ns1__Duration
#define SOAP_TYPE_ns1__Duration (15)
#endif

/* ns1__Period has binding name 'ns1__Period' for type 'ns1:Period' */
#ifndef SOAP_TYPE_ns1__Period
#define SOAP_TYPE_ns1__Period (14)
#endif

/* ns1__GetDataHeaders has binding name 'ns1__GetDataHeaders' for type 'ns1:GetDataHeaders' */
#ifndef SOAP_TYPE_ns1__GetDataHeaders
#define SOAP_TYPE_ns1__GetDataHeaders (13)
#endif

/* ns1__GetCorrectionsHeaders has binding name 'ns1__GetCorrectionsHeaders' for type 'ns1:GetCorrectionsHeaders' */
#ifndef SOAP_TYPE_ns1__GetCorrectionsHeaders
#define SOAP_TYPE_ns1__GetCorrectionsHeaders (12)
#endif

/* ns1__CancelHeaders has binding name 'ns1__CancelHeaders' for type 'ns1:CancelHeaders' */
#ifndef SOAP_TYPE_ns1__CancelHeaders
#define SOAP_TYPE_ns1__CancelHeaders (11)
#endif

/* xsd__time has binding name 'xsd__time' for type 'xsd:time' */
#ifndef SOAP_TYPE_xsd__time
#define SOAP_TYPE_xsd__time (10)
#endif

/* xsd__date has binding name 'xsd__date' for type 'xsd:date' */
#ifndef SOAP_TYPE_xsd__date
#define SOAP_TYPE_xsd__date (9)
#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__string
#define SOAP_TYPE_std__string (8)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (401)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (400)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (397)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (395)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (394)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (403)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (402)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (396)
#endif

/* ns1__RetrieveMmktBvalDealsUploadRequest * has binding name 'PointerTons1__RetrieveMmktBvalDealsUploadRequest' for type 'ns1:RetrieveMmktBvalDealsUploadRequest' */
#ifndef SOAP_TYPE_PointerTons1__RetrieveMmktBvalDealsUploadRequest
#define SOAP_TYPE_PointerTons1__RetrieveMmktBvalDealsUploadRequest (390)
#endif

/* ns1__SubmitMmktBvalDealsUploadRequest * has binding name 'PointerTons1__SubmitMmktBvalDealsUploadRequest' for type 'ns1:SubmitMmktBvalDealsUploadRequest' */
#ifndef SOAP_TYPE_PointerTons1__SubmitMmktBvalDealsUploadRequest
#define SOAP_TYPE_PointerTons1__SubmitMmktBvalDealsUploadRequest (386)
#endif

/* ns1__GetFieldsRequest * has binding name 'PointerTons1__GetFieldsRequest' for type 'ns1:GetFieldsRequest' */
#ifndef SOAP_TYPE_PointerTons1__GetFieldsRequest
#define SOAP_TYPE_PointerTons1__GetFieldsRequest (382)
#endif

/* ns1__RetrieveOtcBvalDealsUploadRequest * has binding name 'PointerTons1__RetrieveOtcBvalDealsUploadRequest' for type 'ns1:RetrieveOtcBvalDealsUploadRequest' */
#ifndef SOAP_TYPE_PointerTons1__RetrieveOtcBvalDealsUploadRequest
#define SOAP_TYPE_PointerTons1__RetrieveOtcBvalDealsUploadRequest (378)
#endif

/* ns1__SubmitOtcBvalDealsUploadRequest * has binding name 'PointerTons1__SubmitOtcBvalDealsUploadRequest' for type 'ns1:SubmitOtcBvalDealsUploadRequest' */
#ifndef SOAP_TYPE_PointerTons1__SubmitOtcBvalDealsUploadRequest
#define SOAP_TYPE_PointerTons1__SubmitOtcBvalDealsUploadRequest (374)
#endif

/* ns1__RetrieveOtcbvalUploadRequest * has binding name 'PointerTons1__RetrieveOtcbvalUploadRequest' for type 'ns1:RetrieveOtcbvalUploadRequest' */
#ifndef SOAP_TYPE_PointerTons1__RetrieveOtcbvalUploadRequest
#define SOAP_TYPE_PointerTons1__RetrieveOtcbvalUploadRequest (370)
#endif

/* ns1__SubmitOtcbvalUploadRequest * has binding name 'PointerTons1__SubmitOtcbvalUploadRequest' for type 'ns1:SubmitOtcbvalUploadRequest' */
#ifndef SOAP_TYPE_PointerTons1__SubmitOtcbvalUploadRequest
#define SOAP_TYPE_PointerTons1__SubmitOtcbvalUploadRequest (366)
#endif

/* ns1__RetrieveGetAllQuotesRequest * has binding name 'PointerTons1__RetrieveGetAllQuotesRequest' for type 'ns1:RetrieveGetAllQuotesRequest' */
#ifndef SOAP_TYPE_PointerTons1__RetrieveGetAllQuotesRequest
#define SOAP_TYPE_PointerTons1__RetrieveGetAllQuotesRequest (362)
#endif

/* ns1__SubmitGetAllQuotesRequest * has binding name 'PointerTons1__SubmitGetAllQuotesRequest' for type 'ns1:SubmitGetAllQuotesRequest' */
#ifndef SOAP_TYPE_PointerTons1__SubmitGetAllQuotesRequest
#define SOAP_TYPE_PointerTons1__SubmitGetAllQuotesRequest (358)
#endif

/* ns1__RetrieveGetQuotesRequest * has binding name 'PointerTons1__RetrieveGetQuotesRequest' for type 'ns1:RetrieveGetQuotesRequest' */
#ifndef SOAP_TYPE_PointerTons1__RetrieveGetQuotesRequest
#define SOAP_TYPE_PointerTons1__RetrieveGetQuotesRequest (354)
#endif

/* ns1__SubmitGetQuotesRequest * has binding name 'PointerTons1__SubmitGetQuotesRequest' for type 'ns1:SubmitGetQuotesRequest' */
#ifndef SOAP_TYPE_PointerTons1__SubmitGetQuotesRequest
#define SOAP_TYPE_PointerTons1__SubmitGetQuotesRequest (350)
#endif

/* ns1__GetPortfolioValidationRequest * has binding name 'PointerTons1__GetPortfolioValidationRequest' for type 'ns1:GetPortfolioValidationRequest' */
#ifndef SOAP_TYPE_PointerTons1__GetPortfolioValidationRequest
#define SOAP_TYPE_PointerTons1__GetPortfolioValidationRequest (346)
#endif

/* ns1__RetrieveGetActionsRequest * has binding name 'PointerTons1__RetrieveGetActionsRequest' for type 'ns1:RetrieveGetActionsRequest' */
#ifndef SOAP_TYPE_PointerTons1__RetrieveGetActionsRequest
#define SOAP_TYPE_PointerTons1__RetrieveGetActionsRequest (342)
#endif

/* ns1__SubmitGetActionsRequest * has binding name 'PointerTons1__SubmitGetActionsRequest' for type 'ns1:SubmitGetActionsRequest' */
#ifndef SOAP_TYPE_PointerTons1__SubmitGetActionsRequest
#define SOAP_TYPE_PointerTons1__SubmitGetActionsRequest (338)
#endif

/* ns1__RetrieveGetCompanyRequest * has binding name 'PointerTons1__RetrieveGetCompanyRequest' for type 'ns1:RetrieveGetCompanyRequest' */
#ifndef SOAP_TYPE_PointerTons1__RetrieveGetCompanyRequest
#define SOAP_TYPE_PointerTons1__RetrieveGetCompanyRequest (334)
#endif

/* ns1__SubmitGetCompanyRequest * has binding name 'PointerTons1__SubmitGetCompanyRequest' for type 'ns1:SubmitGetCompanyRequest' */
#ifndef SOAP_TYPE_PointerTons1__SubmitGetCompanyRequest
#define SOAP_TYPE_PointerTons1__SubmitGetCompanyRequest (330)
#endif

/* ns1__RetrieveGetFundamentalsRequest * has binding name 'PointerTons1__RetrieveGetFundamentalsRequest' for type 'ns1:RetrieveGetFundamentalsRequest' */
#ifndef SOAP_TYPE_PointerTons1__RetrieveGetFundamentalsRequest
#define SOAP_TYPE_PointerTons1__RetrieveGetFundamentalsRequest (326)
#endif

/* ns1__SubmitGetFundamentalsRequest * has binding name 'PointerTons1__SubmitGetFundamentalsRequest' for type 'ns1:SubmitGetFundamentalsRequest' */
#ifndef SOAP_TYPE_PointerTons1__SubmitGetFundamentalsRequest
#define SOAP_TYPE_PointerTons1__SubmitGetFundamentalsRequest (322)
#endif

/* ns1__GetCorrectionsRequest * has binding name 'PointerTons1__GetCorrectionsRequest' for type 'ns1:GetCorrectionsRequest' */
#ifndef SOAP_TYPE_PointerTons1__GetCorrectionsRequest
#define SOAP_TYPE_PointerTons1__GetCorrectionsRequest (318)
#endif

/* ns1__RetrieveCancelRequest * has binding name 'PointerTons1__RetrieveCancelRequest' for type 'ns1:RetrieveCancelRequest' */
#ifndef SOAP_TYPE_PointerTons1__RetrieveCancelRequest
#define SOAP_TYPE_PointerTons1__RetrieveCancelRequest (314)
#endif

/* ns1__SubmitCancelRequest * has binding name 'PointerTons1__SubmitCancelRequest' for type 'ns1:SubmitCancelRequest' */
#ifndef SOAP_TYPE_PointerTons1__SubmitCancelRequest
#define SOAP_TYPE_PointerTons1__SubmitCancelRequest (310)
#endif

/* ns1__RetrieveScheduledRequest * has binding name 'PointerTons1__RetrieveScheduledRequest' for type 'ns1:RetrieveScheduledRequest' */
#ifndef SOAP_TYPE_PointerTons1__RetrieveScheduledRequest
#define SOAP_TYPE_PointerTons1__RetrieveScheduledRequest (306)
#endif

/* ns1__SubmitScheduledRequest * has binding name 'PointerTons1__SubmitScheduledRequest' for type 'ns1:SubmitScheduledRequest' */
#ifndef SOAP_TYPE_PointerTons1__SubmitScheduledRequest
#define SOAP_TYPE_PointerTons1__SubmitScheduledRequest (302)
#endif

/* ns1__RetrieveGetHistoryRequest * has binding name 'PointerTons1__RetrieveGetHistoryRequest' for type 'ns1:RetrieveGetHistoryRequest' */
#ifndef SOAP_TYPE_PointerTons1__RetrieveGetHistoryRequest
#define SOAP_TYPE_PointerTons1__RetrieveGetHistoryRequest (298)
#endif

/* ns1__SubmitGetHistoryRequest * has binding name 'PointerTons1__SubmitGetHistoryRequest' for type 'ns1:SubmitGetHistoryRequest' */
#ifndef SOAP_TYPE_PointerTons1__SubmitGetHistoryRequest
#define SOAP_TYPE_PointerTons1__SubmitGetHistoryRequest (294)
#endif

/* ns1__RetrieveGetDataRequest * has binding name 'PointerTons1__RetrieveGetDataRequest' for type 'ns1:RetrieveGetDataRequest' */
#ifndef SOAP_TYPE_PointerTons1__RetrieveGetDataRequest
#define SOAP_TYPE_PointerTons1__RetrieveGetDataRequest (290)
#endif

/* ns1__SubmitGetDataRequest * has binding name 'PointerTons1__SubmitGetDataRequest' for type 'ns1:SubmitGetDataRequest' */
#ifndef SOAP_TYPE_PointerTons1__SubmitGetDataRequest
#define SOAP_TYPE_PointerTons1__SubmitGetDataRequest (286)
#endif

/* ns1__MmktBvalDealInfos * has binding name 'PointerTons1__MmktBvalDealInfos' for type 'ns1:MmktBvalDealInfos' */
#ifndef SOAP_TYPE_PointerTons1__MmktBvalDealInfos
#define SOAP_TYPE_PointerTons1__MmktBvalDealInfos (285)
#endif

/* ns1__FieldInfos * has binding name 'PointerTons1__FieldInfos' for type 'ns1:FieldInfos' */
#ifndef SOAP_TYPE_PointerTons1__FieldInfos
#define SOAP_TYPE_PointerTons1__FieldInfos (284)
#endif

/* ns1__OtcDealInfos * has binding name 'PointerTons1__OtcDealInfos' for type 'ns1:OtcDealInfos' */
#ifndef SOAP_TYPE_PointerTons1__OtcDealInfos
#define SOAP_TYPE_PointerTons1__OtcDealInfos (283)
#endif

/* ns1__AllQuotesInstrumentDatas * has binding name 'PointerTons1__AllQuotesInstrumentDatas' for type 'ns1:AllQuotesInstrumentDatas' */
#ifndef SOAP_TYPE_PointerTons1__AllQuotesInstrumentDatas
#define SOAP_TYPE_PointerTons1__AllQuotesInstrumentDatas (282)
#endif

/* ns1__QuotesInstrumentDatas * has binding name 'PointerTons1__QuotesInstrumentDatas' for type 'ns1:QuotesInstrumentDatas' */
#ifndef SOAP_TYPE_PointerTons1__QuotesInstrumentDatas
#define SOAP_TYPE_PointerTons1__QuotesInstrumentDatas (281)
#endif

/* ns1__ActionsInstrumentDatas * has binding name 'PointerTons1__ActionsInstrumentDatas' for type 'ns1:ActionsInstrumentDatas' */
#ifndef SOAP_TYPE_PointerTons1__ActionsInstrumentDatas
#define SOAP_TYPE_PointerTons1__ActionsInstrumentDatas (280)
#endif

/* ns1__GetPortfolioValidationHeaders * has binding name 'PointerTons1__GetPortfolioValidationHeaders' for type 'ns1:GetPortfolioValidationHeaders' */
#ifndef SOAP_TYPE_PointerTons1__GetPortfolioValidationHeaders
#define SOAP_TYPE_PointerTons1__GetPortfolioValidationHeaders (279)
#endif

/* ns1__FundInstrumentDatas * has binding name 'PointerTons1__FundInstrumentDatas' for type 'ns1:FundInstrumentDatas' */
#ifndef SOAP_TYPE_PointerTons1__FundInstrumentDatas
#define SOAP_TYPE_PointerTons1__FundInstrumentDatas (278)
#endif

/* ns1__ScheduledResponses * has binding name 'PointerTons1__ScheduledResponses' for type 'ns1:ScheduledResponses' */
#ifndef SOAP_TYPE_PointerTons1__ScheduledResponses
#define SOAP_TYPE_PointerTons1__ScheduledResponses (277)
#endif

/* ns1__CorrectionRecords * has binding name 'PointerTons1__CorrectionRecords' for type 'ns1:CorrectionRecords' */
#ifndef SOAP_TYPE_PointerTons1__CorrectionRecords
#define SOAP_TYPE_PointerTons1__CorrectionRecords (276)
#endif

/* ns1__GetCorrectionsHeaders * has binding name 'PointerTons1__GetCorrectionsHeaders' for type 'ns1:GetCorrectionsHeaders' */
#ifndef SOAP_TYPE_PointerTons1__GetCorrectionsHeaders
#define SOAP_TYPE_PointerTons1__GetCorrectionsHeaders (275)
#endif

/* ns1__CancelResponseStatus * has binding name 'PointerTons1__CancelResponseStatus' for type 'ns1:CancelResponseStatus' */
#ifndef SOAP_TYPE_PointerTons1__CancelResponseStatus
#define SOAP_TYPE_PointerTons1__CancelResponseStatus (273)
#endif

/* ns1__HistInstrumentDatas * has binding name 'PointerTons1__HistInstrumentDatas' for type 'ns1:HistInstrumentDatas' */
#ifndef SOAP_TYPE_PointerTons1__HistInstrumentDatas
#define SOAP_TYPE_PointerTons1__HistInstrumentDatas (272)
#endif

/* ns1__InstrumentDatas * has binding name 'PointerTons1__InstrumentDatas' for type 'ns1:InstrumentDatas' */
#ifndef SOAP_TYPE_PointerTons1__InstrumentDatas
#define SOAP_TYPE_PointerTons1__InstrumentDatas (271)
#endif

/* ns1__MmktBvalDealInformation * has binding name 'PointerTons1__MmktBvalDealInformation' for type 'ns1:MmktBvalDealInformation' */
#ifndef SOAP_TYPE_PointerTons1__MmktBvalDealInformation
#define SOAP_TYPE_PointerTons1__MmktBvalDealInformation (269)
#endif

/* ns1__MmktBvalHeaders * has binding name 'PointerTons1__MmktBvalHeaders' for type 'ns1:MmktBvalHeaders' */
#ifndef SOAP_TYPE_PointerTons1__MmktBvalHeaders
#define SOAP_TYPE_PointerTons1__MmktBvalHeaders (268)
#endif

/* ns1__FieldSearchCriteria * has binding name 'PointerTons1__FieldSearchCriteria' for type 'ns1:FieldSearchCriteria' */
#ifndef SOAP_TYPE_PointerTons1__FieldSearchCriteria
#define SOAP_TYPE_PointerTons1__FieldSearchCriteria (267)
#endif

/* ns1__OtcBvalHeaders * has binding name 'PointerTons1__OtcBvalHeaders' for type 'ns1:OtcBvalHeaders' */
#ifndef SOAP_TYPE_PointerTons1__OtcBvalHeaders
#define SOAP_TYPE_PointerTons1__OtcBvalHeaders (266)
#endif

/* ns1__FundInstruments * has binding name 'PointerTons1__FundInstruments' for type 'ns1:FundInstruments' */
#ifndef SOAP_TYPE_PointerTons1__FundInstruments
#define SOAP_TYPE_PointerTons1__FundInstruments (265)
#endif

/* std::string * has binding name 'PointerToxsd__time' for type 'xsd:time' */
#ifndef SOAP_TYPE_PointerToxsd__time
#define SOAP_TYPE_PointerToxsd__time (264)
#endif

/* ns1__FieldSets * has binding name 'PointerTons1__FieldSets' for type 'ns1:FieldSets' */
#ifndef SOAP_TYPE_PointerTons1__FieldSets
#define SOAP_TYPE_PointerTons1__FieldSets (263)
#endif

/* ns1__ScheduledHeaders * has binding name 'PointerTons1__ScheduledHeaders' for type 'ns1:ScheduledHeaders' */
#ifndef SOAP_TYPE_PointerTons1__ScheduledHeaders
#define SOAP_TYPE_PointerTons1__ScheduledHeaders (262)
#endif

/* ns1__ScheduledResponse * has binding name 'PointerTons1__ScheduledResponse' for type 'ns1:ScheduledResponse' */
#ifndef SOAP_TYPE_PointerTons1__ScheduledResponse
#define SOAP_TYPE_PointerTons1__ScheduledResponse (260)
#endif

/* ns1__CancelHeaders * has binding name 'PointerTons1__CancelHeaders' for type 'ns1:CancelHeaders' */
#ifndef SOAP_TYPE_PointerTons1__CancelHeaders
#define SOAP_TYPE_PointerTons1__CancelHeaders (259)
#endif

/* ns1__Instruments * has binding name 'PointerTons1__Instruments' for type 'ns1:Instruments' */
#ifndef SOAP_TYPE_PointerTons1__Instruments
#define SOAP_TYPE_PointerTons1__Instruments (258)
#endif

/* ns1__Fields * has binding name 'PointerTons1__Fields' for type 'ns1:Fields' */
#ifndef SOAP_TYPE_PointerTons1__Fields
#define SOAP_TYPE_PointerTons1__Fields (257)
#endif

/* ns1__BvalFieldSets * has binding name 'PointerTons1__BvalFieldSets' for type 'ns1:BvalFieldSets' */
#ifndef SOAP_TYPE_PointerTons1__BvalFieldSets
#define SOAP_TYPE_PointerTons1__BvalFieldSets (256)
#endif

/* ns1__OtcDealInformation * has binding name 'PointerTons1__OtcDealInformation' for type 'ns1:OtcDealInformation' */
#ifndef SOAP_TYPE_PointerTons1__OtcDealInformation
#define SOAP_TYPE_PointerTons1__OtcDealInformation (254)
#endif

/* enum ns1__OtcBvalAction * has binding name 'PointerTons1__OtcBvalAction' for type 'ns1:OtcBvalAction' */
#ifndef SOAP_TYPE_PointerTons1__OtcBvalAction
#define SOAP_TYPE_PointerTons1__OtcBvalAction (253)
#endif

/* ns1__ResponseStatus * has binding name 'PointerTons1__ResponseStatus' for type 'ns1:ResponseStatus' */
#ifndef SOAP_TYPE_PointerTons1__ResponseStatus
#define SOAP_TYPE_PointerTons1__ResponseStatus (252)
#endif

/* enum ns1__DLCategory2 * has binding name 'PointerTons1__DLCategory2' for type 'ns1:DLCategory2' */
#ifndef SOAP_TYPE_PointerTons1__DLCategory2
#define SOAP_TYPE_PointerTons1__DLCategory2 (251)
#endif

/* enum ns1__DLCategory * has binding name 'PointerTons1__DLCategory' for type 'ns1:DLCategory' */
#ifndef SOAP_TYPE_PointerTons1__DLCategory
#define SOAP_TYPE_PointerTons1__DLCategory (250)
#endif

/* ns1__FieldInfo * has binding name 'PointerTons1__FieldInfo' for type 'ns1:FieldInfo' */
#ifndef SOAP_TYPE_PointerTons1__FieldInfo
#define SOAP_TYPE_PointerTons1__FieldInfo (248)
#endif

/* enum ns1__FieldType * has binding name 'PointerTons1__FieldType' for type 'ns1:FieldType' */
#ifndef SOAP_TYPE_PointerTons1__FieldType
#define SOAP_TYPE_PointerTons1__FieldType (244)
#endif

/* ns1__BulkArrayEntry * has binding name 'PointerTons1__BulkArrayEntry' for type 'ns1:BulkArrayEntry' */
#ifndef SOAP_TYPE_PointerTons1__BulkArrayEntry
#define SOAP_TYPE_PointerTons1__BulkArrayEntry (242)
#endif

/* ns1__QRMQuoteData * has binding name 'PointerTons1__QRMQuoteData' for type 'ns1:QRMQuoteData' */
#ifndef SOAP_TYPE_PointerTons1__QRMQuoteData
#define SOAP_TYPE_PointerTons1__QRMQuoteData (240)
#endif

/* time_t * has binding name 'PointerTodateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_PointerTodateTime
#define SOAP_TYPE_PointerTodateTime (239)
#endif

/* ns1__QRMQuote * has binding name 'PointerTons1__QRMQuote' for type 'ns1:QRMQuote' */
#ifndef SOAP_TYPE_PointerTons1__QRMQuote
#define SOAP_TYPE_PointerTons1__QRMQuote (237)
#endif

/* ns1__QRQuote * has binding name 'PointerTons1__QRQuote' for type 'ns1:QRQuote' */
#ifndef SOAP_TYPE_PointerTons1__QRQuote
#define SOAP_TYPE_PointerTons1__QRQuote (235)
#endif

/* ns1__BulkArray * has binding name 'PointerTons1__BulkArray' for type 'ns1:BulkArray' */
#ifndef SOAP_TYPE_PointerTons1__BulkArray
#define SOAP_TYPE_PointerTons1__BulkArray (233)
#endif

/* ns1__ActionStandardFields * has binding name 'PointerTons1__ActionStandardFields' for type 'ns1:ActionStandardFields' */
#ifndef SOAP_TYPE_PointerTons1__ActionStandardFields
#define SOAP_TYPE_PointerTons1__ActionStandardFields (232)
#endif

/* ns1__QRMQuotes * has binding name 'PointerTons1__QRMQuotes' for type 'ns1:QRMQuotes' */
#ifndef SOAP_TYPE_PointerTons1__QRMQuotes
#define SOAP_TYPE_PointerTons1__QRMQuotes (231)
#endif

/* ns1__QRQuotes * has binding name 'PointerTons1__QRQuotes' for type 'ns1:QRQuotes' */
#ifndef SOAP_TYPE_PointerTons1__QRQuotes
#define SOAP_TYPE_PointerTons1__QRQuotes (230)
#endif

/* ns1__HistData * has binding name 'PointerTons1__HistData' for type 'ns1:HistData' */
#ifndef SOAP_TYPE_PointerTons1__HistData
#define SOAP_TYPE_PointerTons1__HistData (228)
#endif

/* ns1__Data * has binding name 'PointerTons1__Data' for type 'ns1:Data' */
#ifndef SOAP_TYPE_PointerTons1__Data
#define SOAP_TYPE_PointerTons1__Data (226)
#endif

/* ns1__SecondaryQualifier * has binding name 'PointerTons1__SecondaryQualifier' for type 'ns1:SecondaryQualifier' */
#ifndef SOAP_TYPE_PointerTons1__SecondaryQualifier
#define SOAP_TYPE_PointerTons1__SecondaryQualifier (224)
#endif

/* ns1__PrimaryQualifier * has binding name 'PointerTons1__PrimaryQualifier' for type 'ns1:PrimaryQualifier' */
#ifndef SOAP_TYPE_PointerTons1__PrimaryQualifier
#define SOAP_TYPE_PointerTons1__PrimaryQualifier (223)
#endif

/* ns1__Overrides * has binding name 'PointerTons1__Overrides' for type 'ns1:Overrides' */
#ifndef SOAP_TYPE_PointerTons1__Overrides
#define SOAP_TYPE_PointerTons1__Overrides (222)
#endif

/* ns1__AllQuotesInstrumentData * has binding name 'PointerTons1__AllQuotesInstrumentData' for type 'ns1:AllQuotesInstrumentData' */
#ifndef SOAP_TYPE_PointerTons1__AllQuotesInstrumentData
#define SOAP_TYPE_PointerTons1__AllQuotesInstrumentData (220)
#endif

/* ns1__QuotesInstrumentData * has binding name 'PointerTons1__QuotesInstrumentData' for type 'ns1:QuotesInstrumentData' */
#ifndef SOAP_TYPE_PointerTons1__QuotesInstrumentData
#define SOAP_TYPE_PointerTons1__QuotesInstrumentData (218)
#endif

/* ns1__CorrectionRecord * has binding name 'PointerTons1__CorrectionRecord' for type 'ns1:CorrectionRecord' */
#ifndef SOAP_TYPE_PointerTons1__CorrectionRecord
#define SOAP_TYPE_PointerTons1__CorrectionRecord (216)
#endif

/* ns1__ActionsInstrumentData * has binding name 'PointerTons1__ActionsInstrumentData' for type 'ns1:ActionsInstrumentData' */
#ifndef SOAP_TYPE_PointerTons1__ActionsInstrumentData
#define SOAP_TYPE_PointerTons1__ActionsInstrumentData (214)
#endif

/* ns1__FundInstrumentData * has binding name 'PointerTons1__FundInstrumentData' for type 'ns1:FundInstrumentData' */
#ifndef SOAP_TYPE_PointerTons1__FundInstrumentData
#define SOAP_TYPE_PointerTons1__FundInstrumentData (212)
#endif

/* ns1__HistInstrumentData * has binding name 'PointerTons1__HistInstrumentData' for type 'ns1:HistInstrumentData' */
#ifndef SOAP_TYPE_PointerTons1__HistInstrumentData
#define SOAP_TYPE_PointerTons1__HistInstrumentData (210)
#endif

/* ns1__InstrumentData * has binding name 'PointerTons1__InstrumentData' for type 'ns1:InstrumentData' */
#ifndef SOAP_TYPE_PointerTons1__InstrumentData
#define SOAP_TYPE_PointerTons1__InstrumentData (208)
#endif

/* ns1__FundInstrument * has binding name 'PointerTons1__FundInstrument' for type 'ns1:FundInstrument' */
#ifndef SOAP_TYPE_PointerTons1__FundInstrument
#define SOAP_TYPE_PointerTons1__FundInstrument (206)
#endif

/* ns1__Macro * has binding name 'PointerTons1__Macro' for type 'ns1:Macro' */
#ifndef SOAP_TYPE_PointerTons1__Macro
#define SOAP_TYPE_PointerTons1__Macro (204)
#endif

/* ns1__Instrument * has binding name 'PointerTons1__Instrument' for type 'ns1:Instrument' */
#ifndef SOAP_TYPE_PointerTons1__Instrument
#define SOAP_TYPE_PointerTons1__Instrument (202)
#endif

/* ns1__Override * has binding name 'PointerTons1__Override' for type 'ns1:Override' */
#ifndef SOAP_TYPE_PointerTons1__Override
#define SOAP_TYPE_PointerTons1__Override (200)
#endif

/* ns1__QuotesHeaders * has binding name 'PointerTons1__QuotesHeaders' for type 'ns1:QuotesHeaders' */
#ifndef SOAP_TYPE_PointerTons1__QuotesHeaders
#define SOAP_TYPE_PointerTons1__QuotesHeaders (198)
#endif

/* ns1__GetActionsHeaders * has binding name 'PointerTons1__GetActionsHeaders' for type 'ns1:GetActionsHeaders' */
#ifndef SOAP_TYPE_PointerTons1__GetActionsHeaders
#define SOAP_TYPE_PointerTons1__GetActionsHeaders (197)
#endif

/* ns1__GetCompanyHeaders * has binding name 'PointerTons1__GetCompanyHeaders' for type 'ns1:GetCompanyHeaders' */
#ifndef SOAP_TYPE_PointerTons1__GetCompanyHeaders
#define SOAP_TYPE_PointerTons1__GetCompanyHeaders (196)
#endif

/* ns1__GetFundamentalsHeaders * has binding name 'PointerTons1__GetFundamentalsHeaders' for type 'ns1:GetFundamentalsHeaders' */
#ifndef SOAP_TYPE_PointerTons1__GetFundamentalsHeaders
#define SOAP_TYPE_PointerTons1__GetFundamentalsHeaders (195)
#endif

/* ns1__GetHistoryHeaders * has binding name 'PointerTons1__GetHistoryHeaders' for type 'ns1:GetHistoryHeaders' */
#ifndef SOAP_TYPE_PointerTons1__GetHistoryHeaders
#define SOAP_TYPE_PointerTons1__GetHistoryHeaders (194)
#endif

/* ns1__GetDataHeaders * has binding name 'PointerTons1__GetDataHeaders' for type 'ns1:GetDataHeaders' */
#ifndef SOAP_TYPE_PointerTons1__GetDataHeaders
#define SOAP_TYPE_PointerTons1__GetDataHeaders (193)
#endif

/* ns1__BvalFieldSet * has binding name 'PointerTons1__BvalFieldSet' for type 'ns1:BvalFieldSet' */
#ifndef SOAP_TYPE_PointerTons1__BvalFieldSet
#define SOAP_TYPE_PointerTons1__BvalFieldSet (191)
#endif

/* std::string * has binding name 'PointerToxsd__date' for type 'xsd:date' */
#ifndef SOAP_TYPE_PointerToxsd__date
#define SOAP_TYPE_PointerToxsd__date (190)
#endif

/* ns1__FieldSet * has binding name 'PointerTons1__FieldSet' for type 'ns1:FieldSet' */
#ifndef SOAP_TYPE_PointerTons1__FieldSet
#define SOAP_TYPE_PointerTons1__FieldSet (188)
#endif

/* ns1__TickOutputTz * has binding name 'PointerTons1__TickOutputTz' for type 'ns1:TickOutputTz' */
#ifndef SOAP_TYPE_PointerTons1__TickOutputTz
#define SOAP_TYPE_PointerTons1__TickOutputTz (186)
#endif

/* ns1__DateTimeRange * has binding name 'PointerTons1__DateTimeRange' for type 'ns1:DateTimeRange' */
#ifndef SOAP_TYPE_PointerTons1__DateTimeRange
#define SOAP_TYPE_PointerTons1__DateTimeRange (185)
#endif

/* enum ns1__ActionsDate * has binding name 'PointerTons1__ActionsDate' for type 'ns1:ActionsDate' */
#ifndef SOAP_TYPE_PointerTons1__ActionsDate
#define SOAP_TYPE_PointerTons1__ActionsDate (184)
#endif

/* ns1__Actions * has binding name 'PointerTons1__Actions' for type 'ns1:Actions' */
#ifndef SOAP_TYPE_PointerTons1__Actions
#define SOAP_TYPE_PointerTons1__Actions (183)
#endif

/* enum ns1__Periodicity * has binding name 'PointerTons1__Periodicity' for type 'ns1:Periodicity' */
#ifndef SOAP_TYPE_PointerTons1__Periodicity
#define SOAP_TYPE_PointerTons1__Periodicity (182)
#endif

/* enum ns1__FilingStatus * has binding name 'PointerTons1__FilingStatus' for type 'ns1:FilingStatus' */
#ifndef SOAP_TYPE_PointerTons1__FilingStatus
#define SOAP_TYPE_PointerTons1__FilingStatus (181)
#endif

/* enum ns1__HistOption * has binding name 'PointerTons1__HistOption' for type 'ns1:HistOption' */
#ifndef SOAP_TYPE_PointerTons1__HistOption
#define SOAP_TYPE_PointerTons1__HistOption (180)
#endif

/* enum ns1__HistPeriod * has binding name 'PointerTons1__HistPeriod' for type 'ns1:HistPeriod' */
#ifndef SOAP_TYPE_PointerTons1__HistPeriod
#define SOAP_TYPE_PointerTons1__HistPeriod (179)
#endif

/* ns1__DateRange * has binding name 'PointerTons1__DateRange' for type 'ns1:DateRange' */
#ifndef SOAP_TYPE_PointerTons1__DateRange
#define SOAP_TYPE_PointerTons1__DateRange (178)
#endif

/* ns1__Duration * has binding name 'PointerTons1__Duration' for type 'ns1:Duration' */
#ifndef SOAP_TYPE_PointerTons1__Duration
#define SOAP_TYPE_PointerTons1__Duration (177)
#endif

/* ns1__Period * has binding name 'PointerTons1__Period' for type 'ns1:Period' */
#ifndef SOAP_TYPE_PointerTons1__Period
#define SOAP_TYPE_PointerTons1__Period (176)
#endif

/* enum ns1__RegSolvency * has binding name 'PointerTons1__RegSolvency' for type 'ns1:RegSolvency' */
#ifndef SOAP_TYPE_PointerTons1__RegSolvency
#define SOAP_TYPE_PointerTons1__RegSolvency (175)
#endif

/* enum ns1__PortSecDes * has binding name 'PointerTons1__PortSecDes' for type 'ns1:PortSecDes' */
#ifndef SOAP_TYPE_PointerTons1__PortSecDes
#define SOAP_TYPE_PointerTons1__PortSecDes (174)
#endif

/* enum ns1__BvalSnapshot * has binding name 'PointerTons1__BvalSnapshot' for type 'ns1:BvalSnapshot' */
#ifndef SOAP_TYPE_PointerTons1__BvalSnapshot
#define SOAP_TYPE_PointerTons1__BvalSnapshot (173)
#endif

/* enum ns1__BvalTier * has binding name 'PointerTons1__BvalTier' for type 'ns1:BvalTier' */
#ifndef SOAP_TYPE_PointerTons1__BvalTier
#define SOAP_TYPE_PointerTons1__BvalTier (172)
#endif

/* enum ns1__MarketSector * has binding name 'PointerTons1__MarketSector' for type 'ns1:MarketSector' */
#ifndef SOAP_TYPE_PointerTons1__MarketSector
#define SOAP_TYPE_PointerTons1__MarketSector (171)
#endif

/* enum ns1__Version * has binding name 'PointerTons1__Version' for type 'ns1:Version' */
#ifndef SOAP_TYPE_PointerTons1__Version
#define SOAP_TYPE_PointerTons1__Version (170)
#endif

/* enum ns1__SpecialChar * has binding name 'PointerTons1__SpecialChar' for type 'ns1:SpecialChar' */
#ifndef SOAP_TYPE_PointerTons1__SpecialChar
#define SOAP_TYPE_PointerTons1__SpecialChar (169)
#endif

/* int * has binding name 'PointerToint' for type 'xsd:int' */
#ifndef SOAP_TYPE_PointerToint
#define SOAP_TYPE_PointerToint (168)
#endif

/* enum ns1__InstrumentType * has binding name 'PointerTons1__InstrumentType' for type 'ns1:InstrumentType' */
#ifndef SOAP_TYPE_PointerTons1__InstrumentType
#define SOAP_TYPE_PointerTons1__InstrumentType (167)
#endif

/* enum ns1__ProgramFlag * has binding name 'PointerTons1__ProgramFlag' for type 'ns1:ProgramFlag' */
#ifndef SOAP_TYPE_PointerTons1__ProgramFlag
#define SOAP_TYPE_PointerTons1__ProgramFlag (166)
#endif

/* std::string * has binding name 'PointerTostd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_PointerTostd__string
#define SOAP_TYPE_PointerTostd__string (165)
#endif

/* enum ns1__DiffFlag * has binding name 'PointerTons1__DiffFlag' for type 'ns1:DiffFlag' */
#ifndef SOAP_TYPE_PointerTons1__DiffFlag
#define SOAP_TYPE_PointerTons1__DiffFlag (164)
#endif

/* bool * has binding name 'PointerTobool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_PointerTobool
#define SOAP_TYPE_PointerTobool (163)
#endif

/* enum ns1__DateFormat * has binding name 'PointerTons1__DateFormat' for type 'ns1:DateFormat' */
#ifndef SOAP_TYPE_PointerTons1__DateFormat
#define SOAP_TYPE_PointerTons1__DateFormat (161)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/* std::vector<ns1__CancelResponseStatus *>  has binding name 'std__vectorTemplateOfPointerTons1__CancelResponseStatus' for type 'ns1:CancelResponseStatus' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__CancelResponseStatus
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__CancelResponseStatus (274)
#endif

/* std::vector<ns1__MmktBvalDealInformation *>  has binding name 'std__vectorTemplateOfPointerTons1__MmktBvalDealInformation' for type 'ns1:MmktBvalDealInformation' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__MmktBvalDealInformation
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__MmktBvalDealInformation (270)
#endif

/* std::vector<ns1__ScheduledResponse *>  has binding name 'std__vectorTemplateOfPointerTons1__ScheduledResponse' for type 'ns1:ScheduledResponse' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__ScheduledResponse
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__ScheduledResponse (261)
#endif

/* std::vector<ns1__OtcDealInformation *>  has binding name 'std__vectorTemplateOfPointerTons1__OtcDealInformation' for type 'ns1:OtcDealInformation' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__OtcDealInformation
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__OtcDealInformation (255)
#endif

/* std::vector<ns1__FieldInfo *>  has binding name 'std__vectorTemplateOfPointerTons1__FieldInfo' for type 'ns1:FieldInfo' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__FieldInfo
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__FieldInfo (249)
#endif

/* std::vector<enum ns1__DLCategory2>  has binding name 'std__vectorTemplateOfns1__DLCategory2' for type 'ns1:DLCategory2' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns1__DLCategory2
#define SOAP_TYPE_std__vectorTemplateOfns1__DLCategory2 (247)
#endif

/* std::vector<enum ns1__MarketSector>  has binding name 'std__vectorTemplateOfns1__MarketSector' for type 'ns1:MarketSector' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns1__MarketSector
#define SOAP_TYPE_std__vectorTemplateOfns1__MarketSector (246)
#endif

/* std::vector<enum ns1__DLCategory>  has binding name 'std__vectorTemplateOfns1__DLCategory' for type 'ns1:DLCategory' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns1__DLCategory
#define SOAP_TYPE_std__vectorTemplateOfns1__DLCategory (245)
#endif

/* std::vector<ns1__BulkArrayEntry *>  has binding name 'std__vectorTemplateOfPointerTons1__BulkArrayEntry' for type 'ns1:BulkArrayEntry' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__BulkArrayEntry
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__BulkArrayEntry (243)
#endif

/* std::vector<ns1__QRMQuoteData *>  has binding name 'std__vectorTemplateOfPointerTons1__QRMQuoteData' for type 'ns1:QRMQuoteData' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__QRMQuoteData
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__QRMQuoteData (241)
#endif

/* std::vector<ns1__QRMQuote *>  has binding name 'std__vectorTemplateOfPointerTons1__QRMQuote' for type 'ns1:QRMQuote' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__QRMQuote
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__QRMQuote (238)
#endif

/* std::vector<ns1__QRQuote *>  has binding name 'std__vectorTemplateOfPointerTons1__QRQuote' for type 'ns1:QRQuote' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__QRQuote
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__QRQuote (236)
#endif

/* std::vector<ns1__BulkArray *>  has binding name 'std__vectorTemplateOfPointerTons1__BulkArray' for type 'ns1:BulkArray' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__BulkArray
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__BulkArray (234)
#endif

/* std::vector<ns1__HistData *>  has binding name 'std__vectorTemplateOfPointerTons1__HistData' for type 'ns1:HistData' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__HistData
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__HistData (229)
#endif

/* std::vector<ns1__Data *>  has binding name 'std__vectorTemplateOfPointerTons1__Data' for type 'ns1:Data' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__Data
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__Data (227)
#endif

/* std::vector<ns1__SecondaryQualifier *>  has binding name 'std__vectorTemplateOfPointerTons1__SecondaryQualifier' for type 'ns1:SecondaryQualifier' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__SecondaryQualifier
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__SecondaryQualifier (225)
#endif

/* std::vector<ns1__AllQuotesInstrumentData *>  has binding name 'std__vectorTemplateOfPointerTons1__AllQuotesInstrumentData' for type 'ns1:AllQuotesInstrumentData' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__AllQuotesInstrumentData
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__AllQuotesInstrumentData (221)
#endif

/* std::vector<ns1__QuotesInstrumentData *>  has binding name 'std__vectorTemplateOfPointerTons1__QuotesInstrumentData' for type 'ns1:QuotesInstrumentData' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__QuotesInstrumentData
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__QuotesInstrumentData (219)
#endif

/* std::vector<ns1__CorrectionRecord *>  has binding name 'std__vectorTemplateOfPointerTons1__CorrectionRecord' for type 'ns1:CorrectionRecord' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__CorrectionRecord
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__CorrectionRecord (217)
#endif

/* std::vector<ns1__ActionsInstrumentData *>  has binding name 'std__vectorTemplateOfPointerTons1__ActionsInstrumentData' for type 'ns1:ActionsInstrumentData' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__ActionsInstrumentData
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__ActionsInstrumentData (215)
#endif

/* std::vector<ns1__FundInstrumentData *>  has binding name 'std__vectorTemplateOfPointerTons1__FundInstrumentData' for type 'ns1:FundInstrumentData' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__FundInstrumentData
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__FundInstrumentData (213)
#endif

/* std::vector<ns1__HistInstrumentData *>  has binding name 'std__vectorTemplateOfPointerTons1__HistInstrumentData' for type 'ns1:HistInstrumentData' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__HistInstrumentData
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__HistInstrumentData (211)
#endif

/* std::vector<ns1__InstrumentData *>  has binding name 'std__vectorTemplateOfPointerTons1__InstrumentData' for type 'ns1:InstrumentData' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__InstrumentData
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__InstrumentData (209)
#endif

/* std::vector<ns1__FundInstrument *>  has binding name 'std__vectorTemplateOfPointerTons1__FundInstrument' for type 'ns1:FundInstrument' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__FundInstrument
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__FundInstrument (207)
#endif

/* std::vector<ns1__Macro *>  has binding name 'std__vectorTemplateOfPointerTons1__Macro' for type 'ns1:Macro' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__Macro
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__Macro (205)
#endif

/* std::vector<ns1__Instrument *>  has binding name 'std__vectorTemplateOfPointerTons1__Instrument' for type 'ns1:Instrument' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__Instrument
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__Instrument (203)
#endif

/* std::vector<ns1__Override *>  has binding name 'std__vectorTemplateOfPointerTons1__Override' for type 'ns1:Override' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__Override
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__Override (201)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfstd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__vectorTemplateOfstd__string
#define SOAP_TYPE_std__vectorTemplateOfstd__string (199)
#endif

/* std::vector<ns1__BvalFieldSet *>  has binding name 'std__vectorTemplateOfPointerTons1__BvalFieldSet' for type 'ns1:BvalFieldSet' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__BvalFieldSet
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__BvalFieldSet (192)
#endif

/* std::vector<ns1__FieldSet *>  has binding name 'std__vectorTemplateOfPointerTons1__FieldSet' for type 'ns1:FieldSet' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__FieldSet
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__FieldSet (189)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
