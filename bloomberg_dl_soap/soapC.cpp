/* soapC.cpp
   Generated by gSOAP 2.8.112 for bloombreg_dl.h

gSOAP XML Web services tools
Copyright (C) 2000-2021, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.112 2021-04-12 22:01:51 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
	}
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code == NULL)
		soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Reason == NULL)
		soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
				return NULL;
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_subcode(struct soap *soap)
{
	const char **s = soap_faultsubcode(soap);
	return s ? *s : NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Reason)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_string(struct soap *soap)
{
	const char **s = soap_faultstring(soap);
	return s ? *s : NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
			soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
		soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_detail(struct soap *soap)
{
	const char **s = soap_faultdetail(soap);
	return s ? *s : NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, NULL, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, const char *tag, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, tag, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, tag, NULL, "xsd:int");
	case SOAP_TYPE_dateTime:
		return soap_in_dateTime(soap, tag, NULL, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, tag, NULL, "xsd:boolean");
	case SOAP_TYPE_ns1__DLCategory2:
		return soap_in_ns1__DLCategory2(soap, tag, NULL, "ns1:DLCategory2");
	case SOAP_TYPE_ns1__DLCategory:
		return soap_in_ns1__DLCategory(soap, tag, NULL, "ns1:DLCategory");
	case SOAP_TYPE_ns1__BvalFieldMacro:
		return soap_in_ns1__BvalFieldMacro(soap, tag, NULL, "ns1:BvalFieldMacro");
	case SOAP_TYPE_ns1__FieldMacro:
		return soap_in_ns1__FieldMacro(soap, tag, NULL, "ns1:FieldMacro");
	case SOAP_TYPE_ns1__RegSolvency:
		return soap_in_ns1__RegSolvency(soap, tag, NULL, "ns1:RegSolvency");
	case SOAP_TYPE_ns1__OtcBvalAction:
		return soap_in_ns1__OtcBvalAction(soap, tag, NULL, "ns1:OtcBvalAction");
	case SOAP_TYPE_ns1__ActionsDate:
		return soap_in_ns1__ActionsDate(soap, tag, NULL, "ns1:ActionsDate");
	case SOAP_TYPE_ns1__PortSecDes:
		return soap_in_ns1__PortSecDes(soap, tag, NULL, "ns1:PortSecDes");
	case SOAP_TYPE_ns1__CancelStatus:
		return soap_in_ns1__CancelStatus(soap, tag, NULL, "ns1:CancelStatus");
	case SOAP_TYPE_ns1__BvalSnapshot:
		return soap_in_ns1__BvalSnapshot(soap, tag, NULL, "ns1:BvalSnapshot");
	case SOAP_TYPE_ns1__BvalTier:
		return soap_in_ns1__BvalTier(soap, tag, NULL, "ns1:BvalTier");
	case SOAP_TYPE_ns1__Periodicity:
		return soap_in_ns1__Periodicity(soap, tag, NULL, "ns1:Periodicity");
	case SOAP_TYPE_ns1__FilingStatus:
		return soap_in_ns1__FilingStatus(soap, tag, NULL, "ns1:FilingStatus");
	case SOAP_TYPE_ns1__HistOption:
		return soap_in_ns1__HistOption(soap, tag, NULL, "ns1:HistOption");
	case SOAP_TYPE_ns1__HistPeriod:
		return soap_in_ns1__HistPeriod(soap, tag, NULL, "ns1:HistPeriod");
	case SOAP_TYPE_ns1__FieldType:
		return soap_in_ns1__FieldType(soap, tag, NULL, "ns1:FieldType");
	case SOAP_TYPE_ns1__DateFormat:
		return soap_in_ns1__DateFormat(soap, tag, NULL, "ns1:DateFormat");
	case SOAP_TYPE_ns1__DiffFlag:
		return soap_in_ns1__DiffFlag(soap, tag, NULL, "ns1:DiffFlag");
	case SOAP_TYPE_ns1__Version:
		return soap_in_ns1__Version(soap, tag, NULL, "ns1:Version");
	case SOAP_TYPE_ns1__ProgramFlag:
		return soap_in_ns1__ProgramFlag(soap, tag, NULL, "ns1:ProgramFlag");
	case SOAP_TYPE_ns1__SpecialChar:
		return soap_in_ns1__SpecialChar(soap, tag, NULL, "ns1:SpecialChar");
	case SOAP_TYPE_ns1__InstrumentType:
		return soap_in_ns1__InstrumentType(soap, tag, NULL, "ns1:InstrumentType");
	case SOAP_TYPE_ns1__SecondaryQualifierType:
		return soap_in_ns1__SecondaryQualifierType(soap, tag, NULL, "ns1:SecondaryQualifierType");
	case SOAP_TYPE_ns1__SecondaryQualifierOperator:
		return soap_in_ns1__SecondaryQualifierOperator(soap, tag, NULL, "ns1:SecondaryQualifierOperator");
	case SOAP_TYPE_ns1__MacroType:
		return soap_in_ns1__MacroType(soap, tag, NULL, "ns1:MacroType");
	case SOAP_TYPE_ns1__MarketSector:
		return soap_in_ns1__MarketSector(soap, tag, NULL, "ns1:MarketSector");
	case SOAP_TYPE_ns1__RetrieveMmktBvalDealsUploadResponse:
		return soap_in_ns1__RetrieveMmktBvalDealsUploadResponse(soap, tag, NULL, "ns1:RetrieveMmktBvalDealsUploadResponse");
	case SOAP_TYPE_ns1__MmktBvalDealInfos:
		return soap_in_ns1__MmktBvalDealInfos(soap, tag, NULL, "ns1:MmktBvalDealInfos");
	case SOAP_TYPE_ns1__MmktBvalDealInformation:
		return soap_in_ns1__MmktBvalDealInformation(soap, tag, NULL, "ns1:MmktBvalDealInformation");
	case SOAP_TYPE_ns1__RetrieveMmktBvalDealsUploadRequest:
		return soap_in_ns1__RetrieveMmktBvalDealsUploadRequest(soap, tag, NULL, "ns1:RetrieveMmktBvalDealsUploadRequest");
	case SOAP_TYPE_ns1__SubmitMmktBvalDealsUploadResponse:
		return soap_in_ns1__SubmitMmktBvalDealsUploadResponse(soap, tag, NULL, "ns1:SubmitMmktBvalDealsUploadResponse");
	case SOAP_TYPE_ns1__SubmitMmktBvalDealsUploadRequest:
		return soap_in_ns1__SubmitMmktBvalDealsUploadRequest(soap, tag, NULL, "ns1:SubmitMmktBvalDealsUploadRequest");
	case SOAP_TYPE_ns1__MmktBvalHeaders:
		return soap_in_ns1__MmktBvalHeaders(soap, tag, NULL, "ns1:MmktBvalHeaders");
	case SOAP_TYPE_ns1__GetFieldsResponse:
		return soap_in_ns1__GetFieldsResponse(soap, tag, NULL, "ns1:GetFieldsResponse");
	case SOAP_TYPE_ns1__GetFieldsRequest:
		return soap_in_ns1__GetFieldsRequest(soap, tag, NULL, "ns1:GetFieldsRequest");
	case SOAP_TYPE_ns1__RetrieveOtcBvalDealsUploadResponse:
		return soap_in_ns1__RetrieveOtcBvalDealsUploadResponse(soap, tag, NULL, "ns1:RetrieveOtcBvalDealsUploadResponse");
	case SOAP_TYPE_ns1__RetrieveOtcBvalDealsUploadRequest:
		return soap_in_ns1__RetrieveOtcBvalDealsUploadRequest(soap, tag, NULL, "ns1:RetrieveOtcBvalDealsUploadRequest");
	case SOAP_TYPE_ns1__SubmitOtcBvalDealsUploadResponse:
		return soap_in_ns1__SubmitOtcBvalDealsUploadResponse(soap, tag, NULL, "ns1:SubmitOtcBvalDealsUploadResponse");
	case SOAP_TYPE_ns1__SubmitOtcBvalDealsUploadRequest:
		return soap_in_ns1__SubmitOtcBvalDealsUploadRequest(soap, tag, NULL, "ns1:SubmitOtcBvalDealsUploadRequest");
	case SOAP_TYPE_ns1__RetrieveOtcbvalUploadResponse:
		return soap_in_ns1__RetrieveOtcbvalUploadResponse(soap, tag, NULL, "ns1:RetrieveOtcbvalUploadResponse");
	case SOAP_TYPE_ns1__RetrieveOtcbvalUploadRequest:
		return soap_in_ns1__RetrieveOtcbvalUploadRequest(soap, tag, NULL, "ns1:RetrieveOtcbvalUploadRequest");
	case SOAP_TYPE_ns1__SubmitOtcbvalUploadResponse:
		return soap_in_ns1__SubmitOtcbvalUploadResponse(soap, tag, NULL, "ns1:SubmitOtcbvalUploadResponse");
	case SOAP_TYPE_ns1__SubmitOtcbvalUploadRequest:
		return soap_in_ns1__SubmitOtcbvalUploadRequest(soap, tag, NULL, "ns1:SubmitOtcbvalUploadRequest");
	case SOAP_TYPE_ns1__RetrieveGetAllQuotesResponse:
		return soap_in_ns1__RetrieveGetAllQuotesResponse(soap, tag, NULL, "ns1:RetrieveGetAllQuotesResponse");
	case SOAP_TYPE_ns1__RetrieveGetAllQuotesRequest:
		return soap_in_ns1__RetrieveGetAllQuotesRequest(soap, tag, NULL, "ns1:RetrieveGetAllQuotesRequest");
	case SOAP_TYPE_ns1__SubmitGetAllQuotesResponse:
		return soap_in_ns1__SubmitGetAllQuotesResponse(soap, tag, NULL, "ns1:SubmitGetAllQuotesResponse");
	case SOAP_TYPE_ns1__SubmitGetAllQuotesRequest:
		return soap_in_ns1__SubmitGetAllQuotesRequest(soap, tag, NULL, "ns1:SubmitGetAllQuotesRequest");
	case SOAP_TYPE_ns1__RetrieveGetQuotesResponse:
		return soap_in_ns1__RetrieveGetQuotesResponse(soap, tag, NULL, "ns1:RetrieveGetQuotesResponse");
	case SOAP_TYPE_ns1__RetrieveGetQuotesRequest:
		return soap_in_ns1__RetrieveGetQuotesRequest(soap, tag, NULL, "ns1:RetrieveGetQuotesRequest");
	case SOAP_TYPE_ns1__SubmitGetQuotesResponse:
		return soap_in_ns1__SubmitGetQuotesResponse(soap, tag, NULL, "ns1:SubmitGetQuotesResponse");
	case SOAP_TYPE_ns1__SubmitGetQuotesRequest:
		return soap_in_ns1__SubmitGetQuotesRequest(soap, tag, NULL, "ns1:SubmitGetQuotesRequest");
	case SOAP_TYPE_ns1__RetrieveGetActionsResponse:
		return soap_in_ns1__RetrieveGetActionsResponse(soap, tag, NULL, "ns1:RetrieveGetActionsResponse");
	case SOAP_TYPE_ns1__RetrieveGetActionsRequest:
		return soap_in_ns1__RetrieveGetActionsRequest(soap, tag, NULL, "ns1:RetrieveGetActionsRequest");
	case SOAP_TYPE_ns1__SubmitGetActionsResponse:
		return soap_in_ns1__SubmitGetActionsResponse(soap, tag, NULL, "ns1:SubmitGetActionsResponse");
	case SOAP_TYPE_ns1__SubmitGetActionsRequest:
		return soap_in_ns1__SubmitGetActionsRequest(soap, tag, NULL, "ns1:SubmitGetActionsRequest");
	case SOAP_TYPE_ns1__GetPortfolioValidationResponse:
		return soap_in_ns1__GetPortfolioValidationResponse(soap, tag, NULL, "ns1:GetPortfolioValidationResponse");
	case SOAP_TYPE_ns1__GetPortfolioValidationRequest:
		return soap_in_ns1__GetPortfolioValidationRequest(soap, tag, NULL, "ns1:GetPortfolioValidationRequest");
	case SOAP_TYPE_ns1__RetrieveGetCompanyResponse:
		return soap_in_ns1__RetrieveGetCompanyResponse(soap, tag, NULL, "ns1:RetrieveGetCompanyResponse");
	case SOAP_TYPE_ns1__RetrieveGetCompanyRequest:
		return soap_in_ns1__RetrieveGetCompanyRequest(soap, tag, NULL, "ns1:RetrieveGetCompanyRequest");
	case SOAP_TYPE_ns1__SubmitGetCompanyResponse:
		return soap_in_ns1__SubmitGetCompanyResponse(soap, tag, NULL, "ns1:SubmitGetCompanyResponse");
	case SOAP_TYPE_ns1__SubmitGetCompanyRequest:
		return soap_in_ns1__SubmitGetCompanyRequest(soap, tag, NULL, "ns1:SubmitGetCompanyRequest");
	case SOAP_TYPE_ns1__RetrieveGetFundamentalsResponse:
		return soap_in_ns1__RetrieveGetFundamentalsResponse(soap, tag, NULL, "ns1:RetrieveGetFundamentalsResponse");
	case SOAP_TYPE_ns1__RetrieveGetFundamentalsRequest:
		return soap_in_ns1__RetrieveGetFundamentalsRequest(soap, tag, NULL, "ns1:RetrieveGetFundamentalsRequest");
	case SOAP_TYPE_ns1__SubmitGetFundamentalsResponse:
		return soap_in_ns1__SubmitGetFundamentalsResponse(soap, tag, NULL, "ns1:SubmitGetFundamentalsResponse");
	case SOAP_TYPE_ns1__SubmitGetFundamentalsRequest:
		return soap_in_ns1__SubmitGetFundamentalsRequest(soap, tag, NULL, "ns1:SubmitGetFundamentalsRequest");
	case SOAP_TYPE_ns1__RetrieveScheduledResponse:
		return soap_in_ns1__RetrieveScheduledResponse(soap, tag, NULL, "ns1:RetrieveScheduledResponse");
	case SOAP_TYPE_ns1__ScheduledResponse:
		return soap_in_ns1__ScheduledResponse(soap, tag, NULL, "ns1:ScheduledResponse");
	case SOAP_TYPE_ns1__ScheduledResponses:
		return soap_in_ns1__ScheduledResponses(soap, tag, NULL, "ns1:ScheduledResponses");
	case SOAP_TYPE_ns1__RetrieveScheduledRequest:
		return soap_in_ns1__RetrieveScheduledRequest(soap, tag, NULL, "ns1:RetrieveScheduledRequest");
	case SOAP_TYPE_ns1__SubmitScheduledResponse:
		return soap_in_ns1__SubmitScheduledResponse(soap, tag, NULL, "ns1:SubmitScheduledResponse");
	case SOAP_TYPE_ns1__SubmitScheduledRequest:
		return soap_in_ns1__SubmitScheduledRequest(soap, tag, NULL, "ns1:SubmitScheduledRequest");
	case SOAP_TYPE_ns1__GetCorrectionsResponse:
		return soap_in_ns1__GetCorrectionsResponse(soap, tag, NULL, "ns1:GetCorrectionsResponse");
	case SOAP_TYPE_ns1__GetCorrectionsRequest:
		return soap_in_ns1__GetCorrectionsRequest(soap, tag, NULL, "ns1:GetCorrectionsRequest");
	case SOAP_TYPE_ns1__RetrieveCancelResponse:
		return soap_in_ns1__RetrieveCancelResponse(soap, tag, NULL, "ns1:RetrieveCancelResponse");
	case SOAP_TYPE_ns1__RetrieveCancelRequest:
		return soap_in_ns1__RetrieveCancelRequest(soap, tag, NULL, "ns1:RetrieveCancelRequest");
	case SOAP_TYPE_ns1__SubmitCancelResponse:
		return soap_in_ns1__SubmitCancelResponse(soap, tag, NULL, "ns1:SubmitCancelResponse");
	case SOAP_TYPE_ns1__SubmitCancelRequest:
		return soap_in_ns1__SubmitCancelRequest(soap, tag, NULL, "ns1:SubmitCancelRequest");
	case SOAP_TYPE_ns1__RetrieveGetHistoryResponse:
		return soap_in_ns1__RetrieveGetHistoryResponse(soap, tag, NULL, "ns1:RetrieveGetHistoryResponse");
	case SOAP_TYPE_ns1__RetrieveGetHistoryRequest:
		return soap_in_ns1__RetrieveGetHistoryRequest(soap, tag, NULL, "ns1:RetrieveGetHistoryRequest");
	case SOAP_TYPE_ns1__SubmitGetHistoryResponse:
		return soap_in_ns1__SubmitGetHistoryResponse(soap, tag, NULL, "ns1:SubmitGetHistoryResponse");
	case SOAP_TYPE_ns1__SubmitGetHistoryRequest:
		return soap_in_ns1__SubmitGetHistoryRequest(soap, tag, NULL, "ns1:SubmitGetHistoryRequest");
	case SOAP_TYPE_ns1__RetrieveGetDataResponse:
		return soap_in_ns1__RetrieveGetDataResponse(soap, tag, NULL, "ns1:RetrieveGetDataResponse");
	case SOAP_TYPE_ns1__RetrieveGetDataRequest:
		return soap_in_ns1__RetrieveGetDataRequest(soap, tag, NULL, "ns1:RetrieveGetDataRequest");
	case SOAP_TYPE_ns1__SubmitGetDataResponse:
		return soap_in_ns1__SubmitGetDataResponse(soap, tag, NULL, "ns1:SubmitGetDataResponse");
	case SOAP_TYPE_ns1__SubmitGetDataRequest:
		return soap_in_ns1__SubmitGetDataRequest(soap, tag, NULL, "ns1:SubmitGetDataRequest");
	case SOAP_TYPE_ns1__PerSecurityResponse:
		return soap_in_ns1__PerSecurityResponse(soap, tag, NULL, "ns1:PerSecurityResponse");
	case SOAP_TYPE_ns1__OtcDealInfos:
		return soap_in_ns1__OtcDealInfos(soap, tag, NULL, "ns1:OtcDealInfos");
	case SOAP_TYPE_ns1__OtcDealInformation:
		return soap_in_ns1__OtcDealInformation(soap, tag, NULL, "ns1:OtcDealInformation");
	case SOAP_TYPE_ns1__OtcBvalHeaders:
		return soap_in_ns1__OtcBvalHeaders(soap, tag, NULL, "ns1:OtcBvalHeaders");
	case SOAP_TYPE_ns1__FieldInfo:
		return soap_in_ns1__FieldInfo(soap, tag, NULL, "ns1:FieldInfo");
	case SOAP_TYPE_ns1__FieldInfos:
		return soap_in_ns1__FieldInfos(soap, tag, NULL, "ns1:FieldInfos");
	case SOAP_TYPE_ns1__FieldSearchCriteria:
		return soap_in_ns1__FieldSearchCriteria(soap, tag, NULL, "ns1:FieldSearchCriteria");
	case SOAP_TYPE_ns1__CancelResponseStatus:
		return soap_in_ns1__CancelResponseStatus(soap, tag, NULL, "ns1:CancelResponseStatus");
	case SOAP_TYPE_ns1__ResponseStatus:
		return soap_in_ns1__ResponseStatus(soap, tag, NULL, "ns1:ResponseStatus");
	case SOAP_TYPE_ns1__BulkArrayEntry:
		return soap_in_ns1__BulkArrayEntry(soap, tag, NULL, "ns1:BulkArrayEntry");
	case SOAP_TYPE_ns1__BulkArray:
		return soap_in_ns1__BulkArray(soap, tag, NULL, "ns1:BulkArray");
	case SOAP_TYPE_ns1__ActionStandardFields:
		return soap_in_ns1__ActionStandardFields(soap, tag, NULL, "ns1:ActionStandardFields");
	case SOAP_TYPE_ns1__HistData:
		return soap_in_ns1__HistData(soap, tag, NULL, "ns1:HistData");
	case SOAP_TYPE_ns1__QRMQuote:
		return soap_in_ns1__QRMQuote(soap, tag, NULL, "ns1:QRMQuote");
	case SOAP_TYPE_ns1__QRMQuoteData:
		return soap_in_ns1__QRMQuoteData(soap, tag, NULL, "ns1:QRMQuoteData");
	case SOAP_TYPE_ns1__QRQuote:
		return soap_in_ns1__QRQuote(soap, tag, NULL, "ns1:QRQuote");
	case SOAP_TYPE_ns1__QRMQuotes:
		return soap_in_ns1__QRMQuotes(soap, tag, NULL, "ns1:QRMQuotes");
	case SOAP_TYPE_ns1__QRQuotes:
		return soap_in_ns1__QRQuotes(soap, tag, NULL, "ns1:QRQuotes");
	case SOAP_TYPE_ns1__Data:
		return soap_in_ns1__Data(soap, tag, NULL, "ns1:Data");
	case SOAP_TYPE_ns1__CorrectionRecord:
		return soap_in_ns1__CorrectionRecord(soap, tag, NULL, "ns1:CorrectionRecord");
	case SOAP_TYPE_ns1__ActionsInstrumentData:
		return soap_in_ns1__ActionsInstrumentData(soap, tag, NULL, "ns1:ActionsInstrumentData");
	case SOAP_TYPE_ns1__AllQuotesInstrumentData:
		return soap_in_ns1__AllQuotesInstrumentData(soap, tag, NULL, "ns1:AllQuotesInstrumentData");
	case SOAP_TYPE_ns1__QuotesInstrumentData:
		return soap_in_ns1__QuotesInstrumentData(soap, tag, NULL, "ns1:QuotesInstrumentData");
	case SOAP_TYPE_ns1__FundInstrumentData:
		return soap_in_ns1__FundInstrumentData(soap, tag, NULL, "ns1:FundInstrumentData");
	case SOAP_TYPE_ns1__HistInstrumentData:
		return soap_in_ns1__HistInstrumentData(soap, tag, NULL, "ns1:HistInstrumentData");
	case SOAP_TYPE_ns1__InstrumentData:
		return soap_in_ns1__InstrumentData(soap, tag, NULL, "ns1:InstrumentData");
	case SOAP_TYPE_ns1__DataItem:
		return soap_in_ns1__DataItem(soap, tag, NULL, "ns1:DataItem");
	case SOAP_TYPE_ns1__Actions:
		return soap_in_ns1__Actions(soap, tag, NULL, "ns1:Actions");
	case SOAP_TYPE_ns1__Override:
		return soap_in_ns1__Override(soap, tag, NULL, "ns1:Override");
	case SOAP_TYPE_ns1__SecondaryQualifier:
		return soap_in_ns1__SecondaryQualifier(soap, tag, NULL, "ns1:SecondaryQualifier");
	case SOAP_TYPE_ns1__PrimaryQualifier:
		return soap_in_ns1__PrimaryQualifier(soap, tag, NULL, "ns1:PrimaryQualifier");
	case SOAP_TYPE_ns1__Macro:
		return soap_in_ns1__Macro(soap, tag, NULL, "ns1:Macro");
	case SOAP_TYPE_ns1__FundInstrument:
		return soap_in_ns1__FundInstrument(soap, tag, NULL, "ns1:FundInstrument");
	case SOAP_TYPE_ns1__Instrument:
		return soap_in_ns1__Instrument(soap, tag, NULL, "ns1:Instrument");
	case SOAP_TYPE_ns1__AllQuotesInstrumentDatas:
		return soap_in_ns1__AllQuotesInstrumentDatas(soap, tag, NULL, "ns1:AllQuotesInstrumentDatas");
	case SOAP_TYPE_ns1__QuotesInstrumentDatas:
		return soap_in_ns1__QuotesInstrumentDatas(soap, tag, NULL, "ns1:QuotesInstrumentDatas");
	case SOAP_TYPE_ns1__CorrectionRecords:
		return soap_in_ns1__CorrectionRecords(soap, tag, NULL, "ns1:CorrectionRecords");
	case SOAP_TYPE_ns1__ActionsInstrumentDatas:
		return soap_in_ns1__ActionsInstrumentDatas(soap, tag, NULL, "ns1:ActionsInstrumentDatas");
	case SOAP_TYPE_ns1__FundInstrumentDatas:
		return soap_in_ns1__FundInstrumentDatas(soap, tag, NULL, "ns1:FundInstrumentDatas");
	case SOAP_TYPE_ns1__HistInstrumentDatas:
		return soap_in_ns1__HistInstrumentDatas(soap, tag, NULL, "ns1:HistInstrumentDatas");
	case SOAP_TYPE_ns1__InstrumentDatas:
		return soap_in_ns1__InstrumentDatas(soap, tag, NULL, "ns1:InstrumentDatas");
	case SOAP_TYPE_ns1__FundInstruments:
		return soap_in_ns1__FundInstruments(soap, tag, NULL, "ns1:FundInstruments");
	case SOAP_TYPE_ns1__Instruments:
		return soap_in_ns1__Instruments(soap, tag, NULL, "ns1:Instruments");
	case SOAP_TYPE_ns1__Overrides:
		return soap_in_ns1__Overrides(soap, tag, NULL, "ns1:Overrides");
	case SOAP_TYPE_ns1__Fields:
		return soap_in_ns1__Fields(soap, tag, NULL, "ns1:Fields");
	case SOAP_TYPE_ns1__ScheduledHeaders:
		return soap_in_ns1__ScheduledHeaders(soap, tag, NULL, "ns1:ScheduledHeaders");
	case SOAP_TYPE_ns1__BvalFieldSet:
		return soap_in_ns1__BvalFieldSet(soap, tag, NULL, "ns1:BvalFieldSet");
	case SOAP_TYPE_ns1__BvalFieldSets:
		return soap_in_ns1__BvalFieldSets(soap, tag, NULL, "ns1:BvalFieldSets");
	case SOAP_TYPE_ns1__FieldSet:
		return soap_in_ns1__FieldSet(soap, tag, NULL, "ns1:FieldSet");
	case SOAP_TYPE_ns1__FieldSets:
		return soap_in_ns1__FieldSets(soap, tag, NULL, "ns1:FieldSets");
	case SOAP_TYPE_ns1__TickOutputTz:
		return soap_in_ns1__TickOutputTz(soap, tag, NULL, "ns1:TickOutputTz");
	case SOAP_TYPE_ns1__DateTimeRange:
		return soap_in_ns1__DateTimeRange(soap, tag, NULL, "ns1:DateTimeRange");
	case SOAP_TYPE_ns1__QuotesHeaders:
		return soap_in_ns1__QuotesHeaders(soap, tag, NULL, "ns1:QuotesHeaders");
	case SOAP_TYPE_ns1__GetPortfolioValidationHeaders:
		return soap_in_ns1__GetPortfolioValidationHeaders(soap, tag, NULL, "ns1:GetPortfolioValidationHeaders");
	case SOAP_TYPE_ns1__GetActionsHeaders:
		return soap_in_ns1__GetActionsHeaders(soap, tag, NULL, "ns1:GetActionsHeaders");
	case SOAP_TYPE_ns1__GetCompanyHeaders:
		return soap_in_ns1__GetCompanyHeaders(soap, tag, NULL, "ns1:GetCompanyHeaders");
	case SOAP_TYPE_ns1__GetFundamentalsHeaders:
		return soap_in_ns1__GetFundamentalsHeaders(soap, tag, NULL, "ns1:GetFundamentalsHeaders");
	case SOAP_TYPE_ns1__GetHistoryHeaders:
		return soap_in_ns1__GetHistoryHeaders(soap, tag, NULL, "ns1:GetHistoryHeaders");
	case SOAP_TYPE_ns1__DateRange:
		return soap_in_ns1__DateRange(soap, tag, NULL, "ns1:DateRange");
	case SOAP_TYPE_ns1__Duration:
		return soap_in_ns1__Duration(soap, tag, NULL, "ns1:Duration");
	case SOAP_TYPE_ns1__Period:
		return soap_in_ns1__Period(soap, tag, NULL, "ns1:Period");
	case SOAP_TYPE_ns1__GetDataHeaders:
		return soap_in_ns1__GetDataHeaders(soap, tag, NULL, "ns1:GetDataHeaders");
	case SOAP_TYPE_ns1__GetCorrectionsHeaders:
		return soap_in_ns1__GetCorrectionsHeaders(soap, tag, NULL, "ns1:GetCorrectionsHeaders");
	case SOAP_TYPE_ns1__CancelHeaders:
		return soap_in_ns1__CancelHeaders(soap, tag, NULL, "ns1:CancelHeaders");
	case SOAP_TYPE_xsd__time:
		return soap_in_xsd__time(soap, tag, NULL, "xsd:time");
	case SOAP_TYPE_xsd__date:
		return soap_in_xsd__date(soap, tag, NULL, "xsd:date");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, tag, NULL, "xsd:string");
	case SOAP_TYPE_PointerTons1__RetrieveMmktBvalDealsUploadRequest:
		return soap_in_PointerTons1__RetrieveMmktBvalDealsUploadRequest(soap, tag, NULL, "ns1:RetrieveMmktBvalDealsUploadRequest");
	case SOAP_TYPE_PointerTons1__SubmitMmktBvalDealsUploadRequest:
		return soap_in_PointerTons1__SubmitMmktBvalDealsUploadRequest(soap, tag, NULL, "ns1:SubmitMmktBvalDealsUploadRequest");
	case SOAP_TYPE_PointerTons1__GetFieldsRequest:
		return soap_in_PointerTons1__GetFieldsRequest(soap, tag, NULL, "ns1:GetFieldsRequest");
	case SOAP_TYPE_PointerTons1__RetrieveOtcBvalDealsUploadRequest:
		return soap_in_PointerTons1__RetrieveOtcBvalDealsUploadRequest(soap, tag, NULL, "ns1:RetrieveOtcBvalDealsUploadRequest");
	case SOAP_TYPE_PointerTons1__SubmitOtcBvalDealsUploadRequest:
		return soap_in_PointerTons1__SubmitOtcBvalDealsUploadRequest(soap, tag, NULL, "ns1:SubmitOtcBvalDealsUploadRequest");
	case SOAP_TYPE_PointerTons1__RetrieveOtcbvalUploadRequest:
		return soap_in_PointerTons1__RetrieveOtcbvalUploadRequest(soap, tag, NULL, "ns1:RetrieveOtcbvalUploadRequest");
	case SOAP_TYPE_PointerTons1__SubmitOtcbvalUploadRequest:
		return soap_in_PointerTons1__SubmitOtcbvalUploadRequest(soap, tag, NULL, "ns1:SubmitOtcbvalUploadRequest");
	case SOAP_TYPE_PointerTons1__RetrieveGetAllQuotesRequest:
		return soap_in_PointerTons1__RetrieveGetAllQuotesRequest(soap, tag, NULL, "ns1:RetrieveGetAllQuotesRequest");
	case SOAP_TYPE_PointerTons1__SubmitGetAllQuotesRequest:
		return soap_in_PointerTons1__SubmitGetAllQuotesRequest(soap, tag, NULL, "ns1:SubmitGetAllQuotesRequest");
	case SOAP_TYPE_PointerTons1__RetrieveGetQuotesRequest:
		return soap_in_PointerTons1__RetrieveGetQuotesRequest(soap, tag, NULL, "ns1:RetrieveGetQuotesRequest");
	case SOAP_TYPE_PointerTons1__SubmitGetQuotesRequest:
		return soap_in_PointerTons1__SubmitGetQuotesRequest(soap, tag, NULL, "ns1:SubmitGetQuotesRequest");
	case SOAP_TYPE_PointerTons1__GetPortfolioValidationRequest:
		return soap_in_PointerTons1__GetPortfolioValidationRequest(soap, tag, NULL, "ns1:GetPortfolioValidationRequest");
	case SOAP_TYPE_PointerTons1__RetrieveGetActionsRequest:
		return soap_in_PointerTons1__RetrieveGetActionsRequest(soap, tag, NULL, "ns1:RetrieveGetActionsRequest");
	case SOAP_TYPE_PointerTons1__SubmitGetActionsRequest:
		return soap_in_PointerTons1__SubmitGetActionsRequest(soap, tag, NULL, "ns1:SubmitGetActionsRequest");
	case SOAP_TYPE_PointerTons1__RetrieveGetCompanyRequest:
		return soap_in_PointerTons1__RetrieveGetCompanyRequest(soap, tag, NULL, "ns1:RetrieveGetCompanyRequest");
	case SOAP_TYPE_PointerTons1__SubmitGetCompanyRequest:
		return soap_in_PointerTons1__SubmitGetCompanyRequest(soap, tag, NULL, "ns1:SubmitGetCompanyRequest");
	case SOAP_TYPE_PointerTons1__RetrieveGetFundamentalsRequest:
		return soap_in_PointerTons1__RetrieveGetFundamentalsRequest(soap, tag, NULL, "ns1:RetrieveGetFundamentalsRequest");
	case SOAP_TYPE_PointerTons1__SubmitGetFundamentalsRequest:
		return soap_in_PointerTons1__SubmitGetFundamentalsRequest(soap, tag, NULL, "ns1:SubmitGetFundamentalsRequest");
	case SOAP_TYPE_PointerTons1__GetCorrectionsRequest:
		return soap_in_PointerTons1__GetCorrectionsRequest(soap, tag, NULL, "ns1:GetCorrectionsRequest");
	case SOAP_TYPE_PointerTons1__RetrieveCancelRequest:
		return soap_in_PointerTons1__RetrieveCancelRequest(soap, tag, NULL, "ns1:RetrieveCancelRequest");
	case SOAP_TYPE_PointerTons1__SubmitCancelRequest:
		return soap_in_PointerTons1__SubmitCancelRequest(soap, tag, NULL, "ns1:SubmitCancelRequest");
	case SOAP_TYPE_PointerTons1__RetrieveScheduledRequest:
		return soap_in_PointerTons1__RetrieveScheduledRequest(soap, tag, NULL, "ns1:RetrieveScheduledRequest");
	case SOAP_TYPE_PointerTons1__SubmitScheduledRequest:
		return soap_in_PointerTons1__SubmitScheduledRequest(soap, tag, NULL, "ns1:SubmitScheduledRequest");
	case SOAP_TYPE_PointerTons1__RetrieveGetHistoryRequest:
		return soap_in_PointerTons1__RetrieveGetHistoryRequest(soap, tag, NULL, "ns1:RetrieveGetHistoryRequest");
	case SOAP_TYPE_PointerTons1__SubmitGetHistoryRequest:
		return soap_in_PointerTons1__SubmitGetHistoryRequest(soap, tag, NULL, "ns1:SubmitGetHistoryRequest");
	case SOAP_TYPE_PointerTons1__RetrieveGetDataRequest:
		return soap_in_PointerTons1__RetrieveGetDataRequest(soap, tag, NULL, "ns1:RetrieveGetDataRequest");
	case SOAP_TYPE_PointerTons1__SubmitGetDataRequest:
		return soap_in_PointerTons1__SubmitGetDataRequest(soap, tag, NULL, "ns1:SubmitGetDataRequest");
	case SOAP_TYPE_PointerTons1__MmktBvalDealInfos:
		return soap_in_PointerTons1__MmktBvalDealInfos(soap, tag, NULL, "ns1:MmktBvalDealInfos");
	case SOAP_TYPE_PointerTons1__FieldInfos:
		return soap_in_PointerTons1__FieldInfos(soap, tag, NULL, "ns1:FieldInfos");
	case SOAP_TYPE_PointerTons1__OtcDealInfos:
		return soap_in_PointerTons1__OtcDealInfos(soap, tag, NULL, "ns1:OtcDealInfos");
	case SOAP_TYPE_PointerTons1__AllQuotesInstrumentDatas:
		return soap_in_PointerTons1__AllQuotesInstrumentDatas(soap, tag, NULL, "ns1:AllQuotesInstrumentDatas");
	case SOAP_TYPE_PointerTons1__QuotesInstrumentDatas:
		return soap_in_PointerTons1__QuotesInstrumentDatas(soap, tag, NULL, "ns1:QuotesInstrumentDatas");
	case SOAP_TYPE_PointerTons1__ActionsInstrumentDatas:
		return soap_in_PointerTons1__ActionsInstrumentDatas(soap, tag, NULL, "ns1:ActionsInstrumentDatas");
	case SOAP_TYPE_PointerTons1__GetPortfolioValidationHeaders:
		return soap_in_PointerTons1__GetPortfolioValidationHeaders(soap, tag, NULL, "ns1:GetPortfolioValidationHeaders");
	case SOAP_TYPE_PointerTons1__FundInstrumentDatas:
		return soap_in_PointerTons1__FundInstrumentDatas(soap, tag, NULL, "ns1:FundInstrumentDatas");
	case SOAP_TYPE_PointerTons1__ScheduledResponses:
		return soap_in_PointerTons1__ScheduledResponses(soap, tag, NULL, "ns1:ScheduledResponses");
	case SOAP_TYPE_PointerTons1__CorrectionRecords:
		return soap_in_PointerTons1__CorrectionRecords(soap, tag, NULL, "ns1:CorrectionRecords");
	case SOAP_TYPE_PointerTons1__GetCorrectionsHeaders:
		return soap_in_PointerTons1__GetCorrectionsHeaders(soap, tag, NULL, "ns1:GetCorrectionsHeaders");
	case SOAP_TYPE_PointerTons1__CancelResponseStatus:
		return soap_in_PointerTons1__CancelResponseStatus(soap, tag, NULL, "ns1:CancelResponseStatus");
	case SOAP_TYPE_PointerTons1__HistInstrumentDatas:
		return soap_in_PointerTons1__HistInstrumentDatas(soap, tag, NULL, "ns1:HistInstrumentDatas");
	case SOAP_TYPE_PointerTons1__InstrumentDatas:
		return soap_in_PointerTons1__InstrumentDatas(soap, tag, NULL, "ns1:InstrumentDatas");
	case SOAP_TYPE_PointerTons1__MmktBvalDealInformation:
		return soap_in_PointerTons1__MmktBvalDealInformation(soap, tag, NULL, "ns1:MmktBvalDealInformation");
	case SOAP_TYPE_PointerTons1__MmktBvalHeaders:
		return soap_in_PointerTons1__MmktBvalHeaders(soap, tag, NULL, "ns1:MmktBvalHeaders");
	case SOAP_TYPE_PointerTons1__FieldSearchCriteria:
		return soap_in_PointerTons1__FieldSearchCriteria(soap, tag, NULL, "ns1:FieldSearchCriteria");
	case SOAP_TYPE_PointerTons1__OtcBvalHeaders:
		return soap_in_PointerTons1__OtcBvalHeaders(soap, tag, NULL, "ns1:OtcBvalHeaders");
	case SOAP_TYPE_PointerTons1__FundInstruments:
		return soap_in_PointerTons1__FundInstruments(soap, tag, NULL, "ns1:FundInstruments");
	case SOAP_TYPE_PointerToxsd__time:
		return soap_in_PointerToxsd__time(soap, tag, NULL, "xsd:time");
	case SOAP_TYPE_PointerTons1__FieldSets:
		return soap_in_PointerTons1__FieldSets(soap, tag, NULL, "ns1:FieldSets");
	case SOAP_TYPE_PointerTons1__ScheduledHeaders:
		return soap_in_PointerTons1__ScheduledHeaders(soap, tag, NULL, "ns1:ScheduledHeaders");
	case SOAP_TYPE_PointerTons1__ScheduledResponse:
		return soap_in_PointerTons1__ScheduledResponse(soap, tag, NULL, "ns1:ScheduledResponse");
	case SOAP_TYPE_PointerTons1__CancelHeaders:
		return soap_in_PointerTons1__CancelHeaders(soap, tag, NULL, "ns1:CancelHeaders");
	case SOAP_TYPE_PointerTons1__Instruments:
		return soap_in_PointerTons1__Instruments(soap, tag, NULL, "ns1:Instruments");
	case SOAP_TYPE_PointerTons1__Fields:
		return soap_in_PointerTons1__Fields(soap, tag, NULL, "ns1:Fields");
	case SOAP_TYPE_PointerTons1__BvalFieldSets:
		return soap_in_PointerTons1__BvalFieldSets(soap, tag, NULL, "ns1:BvalFieldSets");
	case SOAP_TYPE_PointerTons1__OtcDealInformation:
		return soap_in_PointerTons1__OtcDealInformation(soap, tag, NULL, "ns1:OtcDealInformation");
	case SOAP_TYPE_PointerTons1__OtcBvalAction:
		return soap_in_PointerTons1__OtcBvalAction(soap, tag, NULL, "ns1:OtcBvalAction");
	case SOAP_TYPE_PointerTons1__ResponseStatus:
		return soap_in_PointerTons1__ResponseStatus(soap, tag, NULL, "ns1:ResponseStatus");
	case SOAP_TYPE_PointerTons1__DLCategory2:
		return soap_in_PointerTons1__DLCategory2(soap, tag, NULL, "ns1:DLCategory2");
	case SOAP_TYPE_PointerTons1__DLCategory:
		return soap_in_PointerTons1__DLCategory(soap, tag, NULL, "ns1:DLCategory");
	case SOAP_TYPE_PointerTons1__FieldInfo:
		return soap_in_PointerTons1__FieldInfo(soap, tag, NULL, "ns1:FieldInfo");
	case SOAP_TYPE_PointerTons1__FieldType:
		return soap_in_PointerTons1__FieldType(soap, tag, NULL, "ns1:FieldType");
	case SOAP_TYPE_PointerTons1__BulkArrayEntry:
		return soap_in_PointerTons1__BulkArrayEntry(soap, tag, NULL, "ns1:BulkArrayEntry");
	case SOAP_TYPE_PointerTons1__QRMQuoteData:
		return soap_in_PointerTons1__QRMQuoteData(soap, tag, NULL, "ns1:QRMQuoteData");
	case SOAP_TYPE_PointerTodateTime:
		return soap_in_PointerTodateTime(soap, tag, NULL, "xsd:dateTime");
	case SOAP_TYPE_PointerTons1__QRMQuote:
		return soap_in_PointerTons1__QRMQuote(soap, tag, NULL, "ns1:QRMQuote");
	case SOAP_TYPE_PointerTons1__QRQuote:
		return soap_in_PointerTons1__QRQuote(soap, tag, NULL, "ns1:QRQuote");
	case SOAP_TYPE_PointerTons1__BulkArray:
		return soap_in_PointerTons1__BulkArray(soap, tag, NULL, "ns1:BulkArray");
	case SOAP_TYPE_PointerTons1__ActionStandardFields:
		return soap_in_PointerTons1__ActionStandardFields(soap, tag, NULL, "ns1:ActionStandardFields");
	case SOAP_TYPE_PointerTons1__QRMQuotes:
		return soap_in_PointerTons1__QRMQuotes(soap, tag, NULL, "ns1:QRMQuotes");
	case SOAP_TYPE_PointerTons1__QRQuotes:
		return soap_in_PointerTons1__QRQuotes(soap, tag, NULL, "ns1:QRQuotes");
	case SOAP_TYPE_PointerTons1__HistData:
		return soap_in_PointerTons1__HistData(soap, tag, NULL, "ns1:HistData");
	case SOAP_TYPE_PointerTons1__Data:
		return soap_in_PointerTons1__Data(soap, tag, NULL, "ns1:Data");
	case SOAP_TYPE_PointerTons1__SecondaryQualifier:
		return soap_in_PointerTons1__SecondaryQualifier(soap, tag, NULL, "ns1:SecondaryQualifier");
	case SOAP_TYPE_PointerTons1__PrimaryQualifier:
		return soap_in_PointerTons1__PrimaryQualifier(soap, tag, NULL, "ns1:PrimaryQualifier");
	case SOAP_TYPE_PointerTons1__Overrides:
		return soap_in_PointerTons1__Overrides(soap, tag, NULL, "ns1:Overrides");
	case SOAP_TYPE_PointerTons1__AllQuotesInstrumentData:
		return soap_in_PointerTons1__AllQuotesInstrumentData(soap, tag, NULL, "ns1:AllQuotesInstrumentData");
	case SOAP_TYPE_PointerTons1__QuotesInstrumentData:
		return soap_in_PointerTons1__QuotesInstrumentData(soap, tag, NULL, "ns1:QuotesInstrumentData");
	case SOAP_TYPE_PointerTons1__CorrectionRecord:
		return soap_in_PointerTons1__CorrectionRecord(soap, tag, NULL, "ns1:CorrectionRecord");
	case SOAP_TYPE_PointerTons1__ActionsInstrumentData:
		return soap_in_PointerTons1__ActionsInstrumentData(soap, tag, NULL, "ns1:ActionsInstrumentData");
	case SOAP_TYPE_PointerTons1__FundInstrumentData:
		return soap_in_PointerTons1__FundInstrumentData(soap, tag, NULL, "ns1:FundInstrumentData");
	case SOAP_TYPE_PointerTons1__HistInstrumentData:
		return soap_in_PointerTons1__HistInstrumentData(soap, tag, NULL, "ns1:HistInstrumentData");
	case SOAP_TYPE_PointerTons1__InstrumentData:
		return soap_in_PointerTons1__InstrumentData(soap, tag, NULL, "ns1:InstrumentData");
	case SOAP_TYPE_PointerTons1__FundInstrument:
		return soap_in_PointerTons1__FundInstrument(soap, tag, NULL, "ns1:FundInstrument");
	case SOAP_TYPE_PointerTons1__Macro:
		return soap_in_PointerTons1__Macro(soap, tag, NULL, "ns1:Macro");
	case SOAP_TYPE_PointerTons1__Instrument:
		return soap_in_PointerTons1__Instrument(soap, tag, NULL, "ns1:Instrument");
	case SOAP_TYPE_PointerTons1__Override:
		return soap_in_PointerTons1__Override(soap, tag, NULL, "ns1:Override");
	case SOAP_TYPE_PointerTons1__QuotesHeaders:
		return soap_in_PointerTons1__QuotesHeaders(soap, tag, NULL, "ns1:QuotesHeaders");
	case SOAP_TYPE_PointerTons1__GetActionsHeaders:
		return soap_in_PointerTons1__GetActionsHeaders(soap, tag, NULL, "ns1:GetActionsHeaders");
	case SOAP_TYPE_PointerTons1__GetCompanyHeaders:
		return soap_in_PointerTons1__GetCompanyHeaders(soap, tag, NULL, "ns1:GetCompanyHeaders");
	case SOAP_TYPE_PointerTons1__GetFundamentalsHeaders:
		return soap_in_PointerTons1__GetFundamentalsHeaders(soap, tag, NULL, "ns1:GetFundamentalsHeaders");
	case SOAP_TYPE_PointerTons1__GetHistoryHeaders:
		return soap_in_PointerTons1__GetHistoryHeaders(soap, tag, NULL, "ns1:GetHistoryHeaders");
	case SOAP_TYPE_PointerTons1__GetDataHeaders:
		return soap_in_PointerTons1__GetDataHeaders(soap, tag, NULL, "ns1:GetDataHeaders");
	case SOAP_TYPE_PointerTons1__BvalFieldSet:
		return soap_in_PointerTons1__BvalFieldSet(soap, tag, NULL, "ns1:BvalFieldSet");
	case SOAP_TYPE_PointerToxsd__date:
		return soap_in_PointerToxsd__date(soap, tag, NULL, "xsd:date");
	case SOAP_TYPE_PointerTons1__FieldSet:
		return soap_in_PointerTons1__FieldSet(soap, tag, NULL, "ns1:FieldSet");
	case SOAP_TYPE_PointerTons1__TickOutputTz:
		return soap_in_PointerTons1__TickOutputTz(soap, tag, NULL, "ns1:TickOutputTz");
	case SOAP_TYPE_PointerTons1__DateTimeRange:
		return soap_in_PointerTons1__DateTimeRange(soap, tag, NULL, "ns1:DateTimeRange");
	case SOAP_TYPE_PointerTons1__ActionsDate:
		return soap_in_PointerTons1__ActionsDate(soap, tag, NULL, "ns1:ActionsDate");
	case SOAP_TYPE_PointerTons1__Actions:
		return soap_in_PointerTons1__Actions(soap, tag, NULL, "ns1:Actions");
	case SOAP_TYPE_PointerTons1__Periodicity:
		return soap_in_PointerTons1__Periodicity(soap, tag, NULL, "ns1:Periodicity");
	case SOAP_TYPE_PointerTons1__FilingStatus:
		return soap_in_PointerTons1__FilingStatus(soap, tag, NULL, "ns1:FilingStatus");
	case SOAP_TYPE_PointerTons1__HistOption:
		return soap_in_PointerTons1__HistOption(soap, tag, NULL, "ns1:HistOption");
	case SOAP_TYPE_PointerTons1__HistPeriod:
		return soap_in_PointerTons1__HistPeriod(soap, tag, NULL, "ns1:HistPeriod");
	case SOAP_TYPE_PointerTons1__DateRange:
		return soap_in_PointerTons1__DateRange(soap, tag, NULL, "ns1:DateRange");
	case SOAP_TYPE_PointerTons1__Duration:
		return soap_in_PointerTons1__Duration(soap, tag, NULL, "ns1:Duration");
	case SOAP_TYPE_PointerTons1__Period:
		return soap_in_PointerTons1__Period(soap, tag, NULL, "ns1:Period");
	case SOAP_TYPE_PointerTons1__RegSolvency:
		return soap_in_PointerTons1__RegSolvency(soap, tag, NULL, "ns1:RegSolvency");
	case SOAP_TYPE_PointerTons1__PortSecDes:
		return soap_in_PointerTons1__PortSecDes(soap, tag, NULL, "ns1:PortSecDes");
	case SOAP_TYPE_PointerTons1__BvalSnapshot:
		return soap_in_PointerTons1__BvalSnapshot(soap, tag, NULL, "ns1:BvalSnapshot");
	case SOAP_TYPE_PointerTons1__BvalTier:
		return soap_in_PointerTons1__BvalTier(soap, tag, NULL, "ns1:BvalTier");
	case SOAP_TYPE_PointerTons1__MarketSector:
		return soap_in_PointerTons1__MarketSector(soap, tag, NULL, "ns1:MarketSector");
	case SOAP_TYPE_PointerTons1__Version:
		return soap_in_PointerTons1__Version(soap, tag, NULL, "ns1:Version");
	case SOAP_TYPE_PointerTons1__SpecialChar:
		return soap_in_PointerTons1__SpecialChar(soap, tag, NULL, "ns1:SpecialChar");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, tag, NULL, "xsd:int");
	case SOAP_TYPE_PointerTons1__InstrumentType:
		return soap_in_PointerTons1__InstrumentType(soap, tag, NULL, "ns1:InstrumentType");
	case SOAP_TYPE_PointerTons1__ProgramFlag:
		return soap_in_PointerTons1__ProgramFlag(soap, tag, NULL, "ns1:ProgramFlag");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, tag, NULL, "xsd:string");
	case SOAP_TYPE_PointerTons1__DiffFlag:
		return soap_in_PointerTons1__DiffFlag(soap, tag, NULL, "ns1:DiffFlag");
	case SOAP_TYPE_PointerTobool:
		return soap_in_PointerTobool(soap, tag, NULL, "xsd:boolean");
	case SOAP_TYPE_PointerTons1__DateFormat:
		return soap_in_PointerTons1__DateFormat(soap, tag, NULL, "ns1:DateFormat");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, tag, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, tag, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:RetrieveMmktBvalDealsUploadResponse"))
		{	*type = SOAP_TYPE_ns1__RetrieveMmktBvalDealsUploadResponse;
			return soap_in_ns1__RetrieveMmktBvalDealsUploadResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MmktBvalDealInfos"))
		{	*type = SOAP_TYPE_ns1__MmktBvalDealInfos;
			return soap_in_ns1__MmktBvalDealInfos(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MmktBvalDealInformation"))
		{	*type = SOAP_TYPE_ns1__MmktBvalDealInformation;
			return soap_in_ns1__MmktBvalDealInformation(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RetrieveMmktBvalDealsUploadRequest"))
		{	*type = SOAP_TYPE_ns1__RetrieveMmktBvalDealsUploadRequest;
			return soap_in_ns1__RetrieveMmktBvalDealsUploadRequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SubmitMmktBvalDealsUploadResponse"))
		{	*type = SOAP_TYPE_ns1__SubmitMmktBvalDealsUploadResponse;
			return soap_in_ns1__SubmitMmktBvalDealsUploadResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SubmitMmktBvalDealsUploadRequest"))
		{	*type = SOAP_TYPE_ns1__SubmitMmktBvalDealsUploadRequest;
			return soap_in_ns1__SubmitMmktBvalDealsUploadRequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MmktBvalHeaders"))
		{	*type = SOAP_TYPE_ns1__MmktBvalHeaders;
			return soap_in_ns1__MmktBvalHeaders(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetFieldsResponse"))
		{	*type = SOAP_TYPE_ns1__GetFieldsResponse;
			return soap_in_ns1__GetFieldsResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetFieldsRequest"))
		{	*type = SOAP_TYPE_ns1__GetFieldsRequest;
			return soap_in_ns1__GetFieldsRequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RetrieveOtcBvalDealsUploadResponse"))
		{	*type = SOAP_TYPE_ns1__RetrieveOtcBvalDealsUploadResponse;
			return soap_in_ns1__RetrieveOtcBvalDealsUploadResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RetrieveOtcBvalDealsUploadRequest"))
		{	*type = SOAP_TYPE_ns1__RetrieveOtcBvalDealsUploadRequest;
			return soap_in_ns1__RetrieveOtcBvalDealsUploadRequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SubmitOtcBvalDealsUploadResponse"))
		{	*type = SOAP_TYPE_ns1__SubmitOtcBvalDealsUploadResponse;
			return soap_in_ns1__SubmitOtcBvalDealsUploadResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SubmitOtcBvalDealsUploadRequest"))
		{	*type = SOAP_TYPE_ns1__SubmitOtcBvalDealsUploadRequest;
			return soap_in_ns1__SubmitOtcBvalDealsUploadRequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RetrieveOtcbvalUploadResponse"))
		{	*type = SOAP_TYPE_ns1__RetrieveOtcbvalUploadResponse;
			return soap_in_ns1__RetrieveOtcbvalUploadResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RetrieveOtcbvalUploadRequest"))
		{	*type = SOAP_TYPE_ns1__RetrieveOtcbvalUploadRequest;
			return soap_in_ns1__RetrieveOtcbvalUploadRequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SubmitOtcbvalUploadResponse"))
		{	*type = SOAP_TYPE_ns1__SubmitOtcbvalUploadResponse;
			return soap_in_ns1__SubmitOtcbvalUploadResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SubmitOtcbvalUploadRequest"))
		{	*type = SOAP_TYPE_ns1__SubmitOtcbvalUploadRequest;
			return soap_in_ns1__SubmitOtcbvalUploadRequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RetrieveGetAllQuotesResponse"))
		{	*type = SOAP_TYPE_ns1__RetrieveGetAllQuotesResponse;
			return soap_in_ns1__RetrieveGetAllQuotesResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RetrieveGetAllQuotesRequest"))
		{	*type = SOAP_TYPE_ns1__RetrieveGetAllQuotesRequest;
			return soap_in_ns1__RetrieveGetAllQuotesRequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SubmitGetAllQuotesResponse"))
		{	*type = SOAP_TYPE_ns1__SubmitGetAllQuotesResponse;
			return soap_in_ns1__SubmitGetAllQuotesResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SubmitGetAllQuotesRequest"))
		{	*type = SOAP_TYPE_ns1__SubmitGetAllQuotesRequest;
			return soap_in_ns1__SubmitGetAllQuotesRequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RetrieveGetQuotesResponse"))
		{	*type = SOAP_TYPE_ns1__RetrieveGetQuotesResponse;
			return soap_in_ns1__RetrieveGetQuotesResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RetrieveGetQuotesRequest"))
		{	*type = SOAP_TYPE_ns1__RetrieveGetQuotesRequest;
			return soap_in_ns1__RetrieveGetQuotesRequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SubmitGetQuotesResponse"))
		{	*type = SOAP_TYPE_ns1__SubmitGetQuotesResponse;
			return soap_in_ns1__SubmitGetQuotesResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SubmitGetQuotesRequest"))
		{	*type = SOAP_TYPE_ns1__SubmitGetQuotesRequest;
			return soap_in_ns1__SubmitGetQuotesRequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RetrieveGetActionsResponse"))
		{	*type = SOAP_TYPE_ns1__RetrieveGetActionsResponse;
			return soap_in_ns1__RetrieveGetActionsResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RetrieveGetActionsRequest"))
		{	*type = SOAP_TYPE_ns1__RetrieveGetActionsRequest;
			return soap_in_ns1__RetrieveGetActionsRequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SubmitGetActionsResponse"))
		{	*type = SOAP_TYPE_ns1__SubmitGetActionsResponse;
			return soap_in_ns1__SubmitGetActionsResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SubmitGetActionsRequest"))
		{	*type = SOAP_TYPE_ns1__SubmitGetActionsRequest;
			return soap_in_ns1__SubmitGetActionsRequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPortfolioValidationResponse"))
		{	*type = SOAP_TYPE_ns1__GetPortfolioValidationResponse;
			return soap_in_ns1__GetPortfolioValidationResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPortfolioValidationRequest"))
		{	*type = SOAP_TYPE_ns1__GetPortfolioValidationRequest;
			return soap_in_ns1__GetPortfolioValidationRequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RetrieveGetCompanyResponse"))
		{	*type = SOAP_TYPE_ns1__RetrieveGetCompanyResponse;
			return soap_in_ns1__RetrieveGetCompanyResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RetrieveGetCompanyRequest"))
		{	*type = SOAP_TYPE_ns1__RetrieveGetCompanyRequest;
			return soap_in_ns1__RetrieveGetCompanyRequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SubmitGetCompanyResponse"))
		{	*type = SOAP_TYPE_ns1__SubmitGetCompanyResponse;
			return soap_in_ns1__SubmitGetCompanyResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SubmitGetCompanyRequest"))
		{	*type = SOAP_TYPE_ns1__SubmitGetCompanyRequest;
			return soap_in_ns1__SubmitGetCompanyRequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RetrieveGetFundamentalsResponse"))
		{	*type = SOAP_TYPE_ns1__RetrieveGetFundamentalsResponse;
			return soap_in_ns1__RetrieveGetFundamentalsResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RetrieveGetFundamentalsRequest"))
		{	*type = SOAP_TYPE_ns1__RetrieveGetFundamentalsRequest;
			return soap_in_ns1__RetrieveGetFundamentalsRequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SubmitGetFundamentalsResponse"))
		{	*type = SOAP_TYPE_ns1__SubmitGetFundamentalsResponse;
			return soap_in_ns1__SubmitGetFundamentalsResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SubmitGetFundamentalsRequest"))
		{	*type = SOAP_TYPE_ns1__SubmitGetFundamentalsRequest;
			return soap_in_ns1__SubmitGetFundamentalsRequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RetrieveScheduledResponse"))
		{	*type = SOAP_TYPE_ns1__RetrieveScheduledResponse;
			return soap_in_ns1__RetrieveScheduledResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ScheduledResponse"))
		{	*type = SOAP_TYPE_ns1__ScheduledResponse;
			return soap_in_ns1__ScheduledResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ScheduledResponses"))
		{	*type = SOAP_TYPE_ns1__ScheduledResponses;
			return soap_in_ns1__ScheduledResponses(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RetrieveScheduledRequest"))
		{	*type = SOAP_TYPE_ns1__RetrieveScheduledRequest;
			return soap_in_ns1__RetrieveScheduledRequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SubmitScheduledResponse"))
		{	*type = SOAP_TYPE_ns1__SubmitScheduledResponse;
			return soap_in_ns1__SubmitScheduledResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SubmitScheduledRequest"))
		{	*type = SOAP_TYPE_ns1__SubmitScheduledRequest;
			return soap_in_ns1__SubmitScheduledRequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetCorrectionsResponse"))
		{	*type = SOAP_TYPE_ns1__GetCorrectionsResponse;
			return soap_in_ns1__GetCorrectionsResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetCorrectionsRequest"))
		{	*type = SOAP_TYPE_ns1__GetCorrectionsRequest;
			return soap_in_ns1__GetCorrectionsRequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RetrieveCancelResponse"))
		{	*type = SOAP_TYPE_ns1__RetrieveCancelResponse;
			return soap_in_ns1__RetrieveCancelResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RetrieveCancelRequest"))
		{	*type = SOAP_TYPE_ns1__RetrieveCancelRequest;
			return soap_in_ns1__RetrieveCancelRequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SubmitCancelResponse"))
		{	*type = SOAP_TYPE_ns1__SubmitCancelResponse;
			return soap_in_ns1__SubmitCancelResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SubmitCancelRequest"))
		{	*type = SOAP_TYPE_ns1__SubmitCancelRequest;
			return soap_in_ns1__SubmitCancelRequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RetrieveGetHistoryResponse"))
		{	*type = SOAP_TYPE_ns1__RetrieveGetHistoryResponse;
			return soap_in_ns1__RetrieveGetHistoryResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RetrieveGetHistoryRequest"))
		{	*type = SOAP_TYPE_ns1__RetrieveGetHistoryRequest;
			return soap_in_ns1__RetrieveGetHistoryRequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SubmitGetHistoryResponse"))
		{	*type = SOAP_TYPE_ns1__SubmitGetHistoryResponse;
			return soap_in_ns1__SubmitGetHistoryResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SubmitGetHistoryRequest"))
		{	*type = SOAP_TYPE_ns1__SubmitGetHistoryRequest;
			return soap_in_ns1__SubmitGetHistoryRequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RetrieveGetDataResponse"))
		{	*type = SOAP_TYPE_ns1__RetrieveGetDataResponse;
			return soap_in_ns1__RetrieveGetDataResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RetrieveGetDataRequest"))
		{	*type = SOAP_TYPE_ns1__RetrieveGetDataRequest;
			return soap_in_ns1__RetrieveGetDataRequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SubmitGetDataResponse"))
		{	*type = SOAP_TYPE_ns1__SubmitGetDataResponse;
			return soap_in_ns1__SubmitGetDataResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SubmitGetDataRequest"))
		{	*type = SOAP_TYPE_ns1__SubmitGetDataRequest;
			return soap_in_ns1__SubmitGetDataRequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PerSecurityResponse"))
		{	*type = SOAP_TYPE_ns1__PerSecurityResponse;
			return soap_in_ns1__PerSecurityResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OtcDealInfos"))
		{	*type = SOAP_TYPE_ns1__OtcDealInfos;
			return soap_in_ns1__OtcDealInfos(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OtcDealInformation"))
		{	*type = SOAP_TYPE_ns1__OtcDealInformation;
			return soap_in_ns1__OtcDealInformation(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OtcBvalHeaders"))
		{	*type = SOAP_TYPE_ns1__OtcBvalHeaders;
			return soap_in_ns1__OtcBvalHeaders(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FieldInfo"))
		{	*type = SOAP_TYPE_ns1__FieldInfo;
			return soap_in_ns1__FieldInfo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FieldInfos"))
		{	*type = SOAP_TYPE_ns1__FieldInfos;
			return soap_in_ns1__FieldInfos(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FieldSearchCriteria"))
		{	*type = SOAP_TYPE_ns1__FieldSearchCriteria;
			return soap_in_ns1__FieldSearchCriteria(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CancelResponseStatus"))
		{	*type = SOAP_TYPE_ns1__CancelResponseStatus;
			return soap_in_ns1__CancelResponseStatus(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ResponseStatus"))
		{	*type = SOAP_TYPE_ns1__ResponseStatus;
			return soap_in_ns1__ResponseStatus(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BulkArrayEntry"))
		{	*type = SOAP_TYPE_ns1__BulkArrayEntry;
			return soap_in_ns1__BulkArrayEntry(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BulkArray"))
		{	*type = SOAP_TYPE_ns1__BulkArray;
			return soap_in_ns1__BulkArray(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ActionStandardFields"))
		{	*type = SOAP_TYPE_ns1__ActionStandardFields;
			return soap_in_ns1__ActionStandardFields(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:HistData"))
		{	*type = SOAP_TYPE_ns1__HistData;
			return soap_in_ns1__HistData(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:QRMQuote"))
		{	*type = SOAP_TYPE_ns1__QRMQuote;
			return soap_in_ns1__QRMQuote(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:QRMQuoteData"))
		{	*type = SOAP_TYPE_ns1__QRMQuoteData;
			return soap_in_ns1__QRMQuoteData(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:QRQuote"))
		{	*type = SOAP_TYPE_ns1__QRQuote;
			return soap_in_ns1__QRQuote(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:QRMQuotes"))
		{	*type = SOAP_TYPE_ns1__QRMQuotes;
			return soap_in_ns1__QRMQuotes(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:QRQuotes"))
		{	*type = SOAP_TYPE_ns1__QRQuotes;
			return soap_in_ns1__QRQuotes(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Data"))
		{	*type = SOAP_TYPE_ns1__Data;
			return soap_in_ns1__Data(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CorrectionRecord"))
		{	*type = SOAP_TYPE_ns1__CorrectionRecord;
			return soap_in_ns1__CorrectionRecord(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ActionsInstrumentData"))
		{	*type = SOAP_TYPE_ns1__ActionsInstrumentData;
			return soap_in_ns1__ActionsInstrumentData(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AllQuotesInstrumentData"))
		{	*type = SOAP_TYPE_ns1__AllQuotesInstrumentData;
			return soap_in_ns1__AllQuotesInstrumentData(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:QuotesInstrumentData"))
		{	*type = SOAP_TYPE_ns1__QuotesInstrumentData;
			return soap_in_ns1__QuotesInstrumentData(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FundInstrumentData"))
		{	*type = SOAP_TYPE_ns1__FundInstrumentData;
			return soap_in_ns1__FundInstrumentData(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:HistInstrumentData"))
		{	*type = SOAP_TYPE_ns1__HistInstrumentData;
			return soap_in_ns1__HistInstrumentData(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InstrumentData"))
		{	*type = SOAP_TYPE_ns1__InstrumentData;
			return soap_in_ns1__InstrumentData(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DataItem"))
		{	*type = SOAP_TYPE_ns1__DataItem;
			return soap_in_ns1__DataItem(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Actions"))
		{	*type = SOAP_TYPE_ns1__Actions;
			return soap_in_ns1__Actions(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Override"))
		{	*type = SOAP_TYPE_ns1__Override;
			return soap_in_ns1__Override(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SecondaryQualifier"))
		{	*type = SOAP_TYPE_ns1__SecondaryQualifier;
			return soap_in_ns1__SecondaryQualifier(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PrimaryQualifier"))
		{	*type = SOAP_TYPE_ns1__PrimaryQualifier;
			return soap_in_ns1__PrimaryQualifier(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Macro"))
		{	*type = SOAP_TYPE_ns1__Macro;
			return soap_in_ns1__Macro(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FundInstrument"))
		{	*type = SOAP_TYPE_ns1__FundInstrument;
			return soap_in_ns1__FundInstrument(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Instrument"))
		{	*type = SOAP_TYPE_ns1__Instrument;
			return soap_in_ns1__Instrument(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AllQuotesInstrumentDatas"))
		{	*type = SOAP_TYPE_ns1__AllQuotesInstrumentDatas;
			return soap_in_ns1__AllQuotesInstrumentDatas(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:QuotesInstrumentDatas"))
		{	*type = SOAP_TYPE_ns1__QuotesInstrumentDatas;
			return soap_in_ns1__QuotesInstrumentDatas(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CorrectionRecords"))
		{	*type = SOAP_TYPE_ns1__CorrectionRecords;
			return soap_in_ns1__CorrectionRecords(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ActionsInstrumentDatas"))
		{	*type = SOAP_TYPE_ns1__ActionsInstrumentDatas;
			return soap_in_ns1__ActionsInstrumentDatas(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FundInstrumentDatas"))
		{	*type = SOAP_TYPE_ns1__FundInstrumentDatas;
			return soap_in_ns1__FundInstrumentDatas(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:HistInstrumentDatas"))
		{	*type = SOAP_TYPE_ns1__HistInstrumentDatas;
			return soap_in_ns1__HistInstrumentDatas(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InstrumentDatas"))
		{	*type = SOAP_TYPE_ns1__InstrumentDatas;
			return soap_in_ns1__InstrumentDatas(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FundInstruments"))
		{	*type = SOAP_TYPE_ns1__FundInstruments;
			return soap_in_ns1__FundInstruments(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Instruments"))
		{	*type = SOAP_TYPE_ns1__Instruments;
			return soap_in_ns1__Instruments(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Overrides"))
		{	*type = SOAP_TYPE_ns1__Overrides;
			return soap_in_ns1__Overrides(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Fields"))
		{	*type = SOAP_TYPE_ns1__Fields;
			return soap_in_ns1__Fields(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ScheduledHeaders"))
		{	*type = SOAP_TYPE_ns1__ScheduledHeaders;
			return soap_in_ns1__ScheduledHeaders(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BvalFieldSet"))
		{	*type = SOAP_TYPE_ns1__BvalFieldSet;
			return soap_in_ns1__BvalFieldSet(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BvalFieldSets"))
		{	*type = SOAP_TYPE_ns1__BvalFieldSets;
			return soap_in_ns1__BvalFieldSets(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FieldSet"))
		{	*type = SOAP_TYPE_ns1__FieldSet;
			return soap_in_ns1__FieldSet(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FieldSets"))
		{	*type = SOAP_TYPE_ns1__FieldSets;
			return soap_in_ns1__FieldSets(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TickOutputTz"))
		{	*type = SOAP_TYPE_ns1__TickOutputTz;
			return soap_in_ns1__TickOutputTz(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DateTimeRange"))
		{	*type = SOAP_TYPE_ns1__DateTimeRange;
			return soap_in_ns1__DateTimeRange(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:QuotesHeaders"))
		{	*type = SOAP_TYPE_ns1__QuotesHeaders;
			return soap_in_ns1__QuotesHeaders(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPortfolioValidationHeaders"))
		{	*type = SOAP_TYPE_ns1__GetPortfolioValidationHeaders;
			return soap_in_ns1__GetPortfolioValidationHeaders(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetActionsHeaders"))
		{	*type = SOAP_TYPE_ns1__GetActionsHeaders;
			return soap_in_ns1__GetActionsHeaders(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetCompanyHeaders"))
		{	*type = SOAP_TYPE_ns1__GetCompanyHeaders;
			return soap_in_ns1__GetCompanyHeaders(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetFundamentalsHeaders"))
		{	*type = SOAP_TYPE_ns1__GetFundamentalsHeaders;
			return soap_in_ns1__GetFundamentalsHeaders(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetHistoryHeaders"))
		{	*type = SOAP_TYPE_ns1__GetHistoryHeaders;
			return soap_in_ns1__GetHistoryHeaders(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DateRange"))
		{	*type = SOAP_TYPE_ns1__DateRange;
			return soap_in_ns1__DateRange(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Duration"))
		{	*type = SOAP_TYPE_ns1__Duration;
			return soap_in_ns1__Duration(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Period"))
		{	*type = SOAP_TYPE_ns1__Period;
			return soap_in_ns1__Period(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetDataHeaders"))
		{	*type = SOAP_TYPE_ns1__GetDataHeaders;
			return soap_in_ns1__GetDataHeaders(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetCorrectionsHeaders"))
		{	*type = SOAP_TYPE_ns1__GetCorrectionsHeaders;
			return soap_in_ns1__GetCorrectionsHeaders(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CancelHeaders"))
		{	*type = SOAP_TYPE_ns1__CancelHeaders;
			return soap_in_ns1__CancelHeaders(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:time"))
		{	*type = SOAP_TYPE_xsd__time;
			return soap_in_xsd__time(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:date"))
		{	*type = SOAP_TYPE_xsd__date;
			return soap_in_xsd__date(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_dateTime;
			return soap_in_dateTime(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DLCategory2"))
		{	*type = SOAP_TYPE_ns1__DLCategory2;
			return soap_in_ns1__DLCategory2(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DLCategory"))
		{	*type = SOAP_TYPE_ns1__DLCategory;
			return soap_in_ns1__DLCategory(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BvalFieldMacro"))
		{	*type = SOAP_TYPE_ns1__BvalFieldMacro;
			return soap_in_ns1__BvalFieldMacro(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FieldMacro"))
		{	*type = SOAP_TYPE_ns1__FieldMacro;
			return soap_in_ns1__FieldMacro(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RegSolvency"))
		{	*type = SOAP_TYPE_ns1__RegSolvency;
			return soap_in_ns1__RegSolvency(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OtcBvalAction"))
		{	*type = SOAP_TYPE_ns1__OtcBvalAction;
			return soap_in_ns1__OtcBvalAction(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ActionsDate"))
		{	*type = SOAP_TYPE_ns1__ActionsDate;
			return soap_in_ns1__ActionsDate(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PortSecDes"))
		{	*type = SOAP_TYPE_ns1__PortSecDes;
			return soap_in_ns1__PortSecDes(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CancelStatus"))
		{	*type = SOAP_TYPE_ns1__CancelStatus;
			return soap_in_ns1__CancelStatus(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BvalSnapshot"))
		{	*type = SOAP_TYPE_ns1__BvalSnapshot;
			return soap_in_ns1__BvalSnapshot(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BvalTier"))
		{	*type = SOAP_TYPE_ns1__BvalTier;
			return soap_in_ns1__BvalTier(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Periodicity"))
		{	*type = SOAP_TYPE_ns1__Periodicity;
			return soap_in_ns1__Periodicity(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FilingStatus"))
		{	*type = SOAP_TYPE_ns1__FilingStatus;
			return soap_in_ns1__FilingStatus(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:HistOption"))
		{	*type = SOAP_TYPE_ns1__HistOption;
			return soap_in_ns1__HistOption(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:HistPeriod"))
		{	*type = SOAP_TYPE_ns1__HistPeriod;
			return soap_in_ns1__HistPeriod(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FieldType"))
		{	*type = SOAP_TYPE_ns1__FieldType;
			return soap_in_ns1__FieldType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DateFormat"))
		{	*type = SOAP_TYPE_ns1__DateFormat;
			return soap_in_ns1__DateFormat(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DiffFlag"))
		{	*type = SOAP_TYPE_ns1__DiffFlag;
			return soap_in_ns1__DiffFlag(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Version"))
		{	*type = SOAP_TYPE_ns1__Version;
			return soap_in_ns1__Version(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ProgramFlag"))
		{	*type = SOAP_TYPE_ns1__ProgramFlag;
			return soap_in_ns1__ProgramFlag(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SpecialChar"))
		{	*type = SOAP_TYPE_ns1__SpecialChar;
			return soap_in_ns1__SpecialChar(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InstrumentType"))
		{	*type = SOAP_TYPE_ns1__InstrumentType;
			return soap_in_ns1__InstrumentType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SecondaryQualifierType"))
		{	*type = SOAP_TYPE_ns1__SecondaryQualifierType;
			return soap_in_ns1__SecondaryQualifierType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SecondaryQualifierOperator"))
		{	*type = SOAP_TYPE_ns1__SecondaryQualifierOperator;
			return soap_in_ns1__SecondaryQualifierOperator(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MacroType"))
		{	*type = SOAP_TYPE_ns1__MacroType;
			return soap_in_ns1__MacroType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MarketSector"))
		{	*type = SOAP_TYPE_ns1__MarketSector;
			return soap_in_ns1__MarketSector(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input at level = %u body = %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && !soap->fignore && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, NULL, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body && soap_ignore(soap))
				return soap->error;
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_dateTime:
		return soap_out_dateTime(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_ns1__DLCategory2:
		return soap_out_ns1__DLCategory2(soap, tag, id, (const enum ns1__DLCategory2 *)ptr, "ns1:DLCategory2");
	case SOAP_TYPE_ns1__DLCategory:
		return soap_out_ns1__DLCategory(soap, tag, id, (const enum ns1__DLCategory *)ptr, "ns1:DLCategory");
	case SOAP_TYPE_ns1__BvalFieldMacro:
		return soap_out_ns1__BvalFieldMacro(soap, tag, id, (const enum ns1__BvalFieldMacro *)ptr, "ns1:BvalFieldMacro");
	case SOAP_TYPE_ns1__FieldMacro:
		return soap_out_ns1__FieldMacro(soap, tag, id, (const enum ns1__FieldMacro *)ptr, "ns1:FieldMacro");
	case SOAP_TYPE_ns1__RegSolvency:
		return soap_out_ns1__RegSolvency(soap, tag, id, (const enum ns1__RegSolvency *)ptr, "ns1:RegSolvency");
	case SOAP_TYPE_ns1__OtcBvalAction:
		return soap_out_ns1__OtcBvalAction(soap, tag, id, (const enum ns1__OtcBvalAction *)ptr, "ns1:OtcBvalAction");
	case SOAP_TYPE_ns1__ActionsDate:
		return soap_out_ns1__ActionsDate(soap, tag, id, (const enum ns1__ActionsDate *)ptr, "ns1:ActionsDate");
	case SOAP_TYPE_ns1__PortSecDes:
		return soap_out_ns1__PortSecDes(soap, tag, id, (const enum ns1__PortSecDes *)ptr, "ns1:PortSecDes");
	case SOAP_TYPE_ns1__CancelStatus:
		return soap_out_ns1__CancelStatus(soap, tag, id, (const enum ns1__CancelStatus *)ptr, "ns1:CancelStatus");
	case SOAP_TYPE_ns1__BvalSnapshot:
		return soap_out_ns1__BvalSnapshot(soap, tag, id, (const enum ns1__BvalSnapshot *)ptr, "ns1:BvalSnapshot");
	case SOAP_TYPE_ns1__BvalTier:
		return soap_out_ns1__BvalTier(soap, tag, id, (const enum ns1__BvalTier *)ptr, "ns1:BvalTier");
	case SOAP_TYPE_ns1__Periodicity:
		return soap_out_ns1__Periodicity(soap, tag, id, (const enum ns1__Periodicity *)ptr, "ns1:Periodicity");
	case SOAP_TYPE_ns1__FilingStatus:
		return soap_out_ns1__FilingStatus(soap, tag, id, (const enum ns1__FilingStatus *)ptr, "ns1:FilingStatus");
	case SOAP_TYPE_ns1__HistOption:
		return soap_out_ns1__HistOption(soap, tag, id, (const enum ns1__HistOption *)ptr, "ns1:HistOption");
	case SOAP_TYPE_ns1__HistPeriod:
		return soap_out_ns1__HistPeriod(soap, tag, id, (const enum ns1__HistPeriod *)ptr, "ns1:HistPeriod");
	case SOAP_TYPE_ns1__FieldType:
		return soap_out_ns1__FieldType(soap, tag, id, (const enum ns1__FieldType *)ptr, "ns1:FieldType");
	case SOAP_TYPE_ns1__DateFormat:
		return soap_out_ns1__DateFormat(soap, tag, id, (const enum ns1__DateFormat *)ptr, "ns1:DateFormat");
	case SOAP_TYPE_ns1__DiffFlag:
		return soap_out_ns1__DiffFlag(soap, tag, id, (const enum ns1__DiffFlag *)ptr, "ns1:DiffFlag");
	case SOAP_TYPE_ns1__Version:
		return soap_out_ns1__Version(soap, tag, id, (const enum ns1__Version *)ptr, "ns1:Version");
	case SOAP_TYPE_ns1__ProgramFlag:
		return soap_out_ns1__ProgramFlag(soap, tag, id, (const enum ns1__ProgramFlag *)ptr, "ns1:ProgramFlag");
	case SOAP_TYPE_ns1__SpecialChar:
		return soap_out_ns1__SpecialChar(soap, tag, id, (const enum ns1__SpecialChar *)ptr, "ns1:SpecialChar");
	case SOAP_TYPE_ns1__InstrumentType:
		return soap_out_ns1__InstrumentType(soap, tag, id, (const enum ns1__InstrumentType *)ptr, "ns1:InstrumentType");
	case SOAP_TYPE_ns1__SecondaryQualifierType:
		return soap_out_ns1__SecondaryQualifierType(soap, tag, id, (const enum ns1__SecondaryQualifierType *)ptr, "ns1:SecondaryQualifierType");
	case SOAP_TYPE_ns1__SecondaryQualifierOperator:
		return soap_out_ns1__SecondaryQualifierOperator(soap, tag, id, (const enum ns1__SecondaryQualifierOperator *)ptr, "ns1:SecondaryQualifierOperator");
	case SOAP_TYPE_ns1__MacroType:
		return soap_out_ns1__MacroType(soap, tag, id, (const enum ns1__MacroType *)ptr, "ns1:MacroType");
	case SOAP_TYPE_ns1__MarketSector:
		return soap_out_ns1__MarketSector(soap, tag, id, (const enum ns1__MarketSector *)ptr, "ns1:MarketSector");
	case SOAP_TYPE_ns1__RetrieveMmktBvalDealsUploadResponse:
		return ((ns1__RetrieveMmktBvalDealsUploadResponse *)ptr)->soap_out(soap, tag, id, "ns1:RetrieveMmktBvalDealsUploadResponse");
	case SOAP_TYPE_ns1__MmktBvalDealInfos:
		return ((ns1__MmktBvalDealInfos *)ptr)->soap_out(soap, tag, id, "ns1:MmktBvalDealInfos");
	case SOAP_TYPE_ns1__MmktBvalDealInformation:
		return ((ns1__MmktBvalDealInformation *)ptr)->soap_out(soap, tag, id, "ns1:MmktBvalDealInformation");
	case SOAP_TYPE_ns1__RetrieveMmktBvalDealsUploadRequest:
		return ((ns1__RetrieveMmktBvalDealsUploadRequest *)ptr)->soap_out(soap, tag, id, "ns1:RetrieveMmktBvalDealsUploadRequest");
	case SOAP_TYPE_ns1__SubmitMmktBvalDealsUploadResponse:
		return ((ns1__SubmitMmktBvalDealsUploadResponse *)ptr)->soap_out(soap, tag, id, "ns1:SubmitMmktBvalDealsUploadResponse");
	case SOAP_TYPE_ns1__SubmitMmktBvalDealsUploadRequest:
		return ((ns1__SubmitMmktBvalDealsUploadRequest *)ptr)->soap_out(soap, tag, id, "ns1:SubmitMmktBvalDealsUploadRequest");
	case SOAP_TYPE_ns1__MmktBvalHeaders:
		return ((ns1__MmktBvalHeaders *)ptr)->soap_out(soap, tag, id, "ns1:MmktBvalHeaders");
	case SOAP_TYPE_ns1__GetFieldsResponse:
		return ((ns1__GetFieldsResponse *)ptr)->soap_out(soap, tag, id, "ns1:GetFieldsResponse");
	case SOAP_TYPE_ns1__GetFieldsRequest:
		return ((ns1__GetFieldsRequest *)ptr)->soap_out(soap, tag, id, "ns1:GetFieldsRequest");
	case SOAP_TYPE_ns1__RetrieveOtcBvalDealsUploadResponse:
		return ((ns1__RetrieveOtcBvalDealsUploadResponse *)ptr)->soap_out(soap, tag, id, "ns1:RetrieveOtcBvalDealsUploadResponse");
	case SOAP_TYPE_ns1__RetrieveOtcBvalDealsUploadRequest:
		return ((ns1__RetrieveOtcBvalDealsUploadRequest *)ptr)->soap_out(soap, tag, id, "ns1:RetrieveOtcBvalDealsUploadRequest");
	case SOAP_TYPE_ns1__SubmitOtcBvalDealsUploadResponse:
		return ((ns1__SubmitOtcBvalDealsUploadResponse *)ptr)->soap_out(soap, tag, id, "ns1:SubmitOtcBvalDealsUploadResponse");
	case SOAP_TYPE_ns1__SubmitOtcBvalDealsUploadRequest:
		return ((ns1__SubmitOtcBvalDealsUploadRequest *)ptr)->soap_out(soap, tag, id, "ns1:SubmitOtcBvalDealsUploadRequest");
	case SOAP_TYPE_ns1__RetrieveOtcbvalUploadResponse:
		return ((ns1__RetrieveOtcbvalUploadResponse *)ptr)->soap_out(soap, tag, id, "ns1:RetrieveOtcbvalUploadResponse");
	case SOAP_TYPE_ns1__RetrieveOtcbvalUploadRequest:
		return ((ns1__RetrieveOtcbvalUploadRequest *)ptr)->soap_out(soap, tag, id, "ns1:RetrieveOtcbvalUploadRequest");
	case SOAP_TYPE_ns1__SubmitOtcbvalUploadResponse:
		return ((ns1__SubmitOtcbvalUploadResponse *)ptr)->soap_out(soap, tag, id, "ns1:SubmitOtcbvalUploadResponse");
	case SOAP_TYPE_ns1__SubmitOtcbvalUploadRequest:
		return ((ns1__SubmitOtcbvalUploadRequest *)ptr)->soap_out(soap, tag, id, "ns1:SubmitOtcbvalUploadRequest");
	case SOAP_TYPE_ns1__RetrieveGetAllQuotesResponse:
		return ((ns1__RetrieveGetAllQuotesResponse *)ptr)->soap_out(soap, tag, id, "ns1:RetrieveGetAllQuotesResponse");
	case SOAP_TYPE_ns1__RetrieveGetAllQuotesRequest:
		return ((ns1__RetrieveGetAllQuotesRequest *)ptr)->soap_out(soap, tag, id, "ns1:RetrieveGetAllQuotesRequest");
	case SOAP_TYPE_ns1__SubmitGetAllQuotesResponse:
		return ((ns1__SubmitGetAllQuotesResponse *)ptr)->soap_out(soap, tag, id, "ns1:SubmitGetAllQuotesResponse");
	case SOAP_TYPE_ns1__SubmitGetAllQuotesRequest:
		return ((ns1__SubmitGetAllQuotesRequest *)ptr)->soap_out(soap, tag, id, "ns1:SubmitGetAllQuotesRequest");
	case SOAP_TYPE_ns1__RetrieveGetQuotesResponse:
		return ((ns1__RetrieveGetQuotesResponse *)ptr)->soap_out(soap, tag, id, "ns1:RetrieveGetQuotesResponse");
	case SOAP_TYPE_ns1__RetrieveGetQuotesRequest:
		return ((ns1__RetrieveGetQuotesRequest *)ptr)->soap_out(soap, tag, id, "ns1:RetrieveGetQuotesRequest");
	case SOAP_TYPE_ns1__SubmitGetQuotesResponse:
		return ((ns1__SubmitGetQuotesResponse *)ptr)->soap_out(soap, tag, id, "ns1:SubmitGetQuotesResponse");
	case SOAP_TYPE_ns1__SubmitGetQuotesRequest:
		return ((ns1__SubmitGetQuotesRequest *)ptr)->soap_out(soap, tag, id, "ns1:SubmitGetQuotesRequest");
	case SOAP_TYPE_ns1__RetrieveGetActionsResponse:
		return ((ns1__RetrieveGetActionsResponse *)ptr)->soap_out(soap, tag, id, "ns1:RetrieveGetActionsResponse");
	case SOAP_TYPE_ns1__RetrieveGetActionsRequest:
		return ((ns1__RetrieveGetActionsRequest *)ptr)->soap_out(soap, tag, id, "ns1:RetrieveGetActionsRequest");
	case SOAP_TYPE_ns1__SubmitGetActionsResponse:
		return ((ns1__SubmitGetActionsResponse *)ptr)->soap_out(soap, tag, id, "ns1:SubmitGetActionsResponse");
	case SOAP_TYPE_ns1__SubmitGetActionsRequest:
		return ((ns1__SubmitGetActionsRequest *)ptr)->soap_out(soap, tag, id, "ns1:SubmitGetActionsRequest");
	case SOAP_TYPE_ns1__GetPortfolioValidationResponse:
		return ((ns1__GetPortfolioValidationResponse *)ptr)->soap_out(soap, tag, id, "ns1:GetPortfolioValidationResponse");
	case SOAP_TYPE_ns1__GetPortfolioValidationRequest:
		return ((ns1__GetPortfolioValidationRequest *)ptr)->soap_out(soap, tag, id, "ns1:GetPortfolioValidationRequest");
	case SOAP_TYPE_ns1__RetrieveGetCompanyResponse:
		return ((ns1__RetrieveGetCompanyResponse *)ptr)->soap_out(soap, tag, id, "ns1:RetrieveGetCompanyResponse");
	case SOAP_TYPE_ns1__RetrieveGetCompanyRequest:
		return ((ns1__RetrieveGetCompanyRequest *)ptr)->soap_out(soap, tag, id, "ns1:RetrieveGetCompanyRequest");
	case SOAP_TYPE_ns1__SubmitGetCompanyResponse:
		return ((ns1__SubmitGetCompanyResponse *)ptr)->soap_out(soap, tag, id, "ns1:SubmitGetCompanyResponse");
	case SOAP_TYPE_ns1__SubmitGetCompanyRequest:
		return ((ns1__SubmitGetCompanyRequest *)ptr)->soap_out(soap, tag, id, "ns1:SubmitGetCompanyRequest");
	case SOAP_TYPE_ns1__RetrieveGetFundamentalsResponse:
		return ((ns1__RetrieveGetFundamentalsResponse *)ptr)->soap_out(soap, tag, id, "ns1:RetrieveGetFundamentalsResponse");
	case SOAP_TYPE_ns1__RetrieveGetFundamentalsRequest:
		return ((ns1__RetrieveGetFundamentalsRequest *)ptr)->soap_out(soap, tag, id, "ns1:RetrieveGetFundamentalsRequest");
	case SOAP_TYPE_ns1__SubmitGetFundamentalsResponse:
		return ((ns1__SubmitGetFundamentalsResponse *)ptr)->soap_out(soap, tag, id, "ns1:SubmitGetFundamentalsResponse");
	case SOAP_TYPE_ns1__SubmitGetFundamentalsRequest:
		return ((ns1__SubmitGetFundamentalsRequest *)ptr)->soap_out(soap, tag, id, "ns1:SubmitGetFundamentalsRequest");
	case SOAP_TYPE_ns1__RetrieveScheduledResponse:
		return ((ns1__RetrieveScheduledResponse *)ptr)->soap_out(soap, tag, id, "ns1:RetrieveScheduledResponse");
	case SOAP_TYPE_ns1__ScheduledResponse:
		return ((ns1__ScheduledResponse *)ptr)->soap_out(soap, tag, id, "ns1:ScheduledResponse");
	case SOAP_TYPE_ns1__ScheduledResponses:
		return ((ns1__ScheduledResponses *)ptr)->soap_out(soap, tag, id, "ns1:ScheduledResponses");
	case SOAP_TYPE_ns1__RetrieveScheduledRequest:
		return ((ns1__RetrieveScheduledRequest *)ptr)->soap_out(soap, tag, id, "ns1:RetrieveScheduledRequest");
	case SOAP_TYPE_ns1__SubmitScheduledResponse:
		return ((ns1__SubmitScheduledResponse *)ptr)->soap_out(soap, tag, id, "ns1:SubmitScheduledResponse");
	case SOAP_TYPE_ns1__SubmitScheduledRequest:
		return ((ns1__SubmitScheduledRequest *)ptr)->soap_out(soap, tag, id, "ns1:SubmitScheduledRequest");
	case SOAP_TYPE_ns1__GetCorrectionsResponse:
		return ((ns1__GetCorrectionsResponse *)ptr)->soap_out(soap, tag, id, "ns1:GetCorrectionsResponse");
	case SOAP_TYPE_ns1__GetCorrectionsRequest:
		return ((ns1__GetCorrectionsRequest *)ptr)->soap_out(soap, tag, id, "ns1:GetCorrectionsRequest");
	case SOAP_TYPE_ns1__RetrieveCancelResponse:
		return ((ns1__RetrieveCancelResponse *)ptr)->soap_out(soap, tag, id, "ns1:RetrieveCancelResponse");
	case SOAP_TYPE_ns1__RetrieveCancelRequest:
		return ((ns1__RetrieveCancelRequest *)ptr)->soap_out(soap, tag, id, "ns1:RetrieveCancelRequest");
	case SOAP_TYPE_ns1__SubmitCancelResponse:
		return ((ns1__SubmitCancelResponse *)ptr)->soap_out(soap, tag, id, "ns1:SubmitCancelResponse");
	case SOAP_TYPE_ns1__SubmitCancelRequest:
		return ((ns1__SubmitCancelRequest *)ptr)->soap_out(soap, tag, id, "ns1:SubmitCancelRequest");
	case SOAP_TYPE_ns1__RetrieveGetHistoryResponse:
		return ((ns1__RetrieveGetHistoryResponse *)ptr)->soap_out(soap, tag, id, "ns1:RetrieveGetHistoryResponse");
	case SOAP_TYPE_ns1__RetrieveGetHistoryRequest:
		return ((ns1__RetrieveGetHistoryRequest *)ptr)->soap_out(soap, tag, id, "ns1:RetrieveGetHistoryRequest");
	case SOAP_TYPE_ns1__SubmitGetHistoryResponse:
		return ((ns1__SubmitGetHistoryResponse *)ptr)->soap_out(soap, tag, id, "ns1:SubmitGetHistoryResponse");
	case SOAP_TYPE_ns1__SubmitGetHistoryRequest:
		return ((ns1__SubmitGetHistoryRequest *)ptr)->soap_out(soap, tag, id, "ns1:SubmitGetHistoryRequest");
	case SOAP_TYPE_ns1__RetrieveGetDataResponse:
		return ((ns1__RetrieveGetDataResponse *)ptr)->soap_out(soap, tag, id, "ns1:RetrieveGetDataResponse");
	case SOAP_TYPE_ns1__RetrieveGetDataRequest:
		return ((ns1__RetrieveGetDataRequest *)ptr)->soap_out(soap, tag, id, "ns1:RetrieveGetDataRequest");
	case SOAP_TYPE_ns1__SubmitGetDataResponse:
		return ((ns1__SubmitGetDataResponse *)ptr)->soap_out(soap, tag, id, "ns1:SubmitGetDataResponse");
	case SOAP_TYPE_ns1__SubmitGetDataRequest:
		return ((ns1__SubmitGetDataRequest *)ptr)->soap_out(soap, tag, id, "ns1:SubmitGetDataRequest");
	case SOAP_TYPE_ns1__PerSecurityResponse:
		return ((ns1__PerSecurityResponse *)ptr)->soap_out(soap, tag, id, "ns1:PerSecurityResponse");
	case SOAP_TYPE_ns1__OtcDealInfos:
		return ((ns1__OtcDealInfos *)ptr)->soap_out(soap, tag, id, "ns1:OtcDealInfos");
	case SOAP_TYPE_ns1__OtcDealInformation:
		return ((ns1__OtcDealInformation *)ptr)->soap_out(soap, tag, id, "ns1:OtcDealInformation");
	case SOAP_TYPE_ns1__OtcBvalHeaders:
		return ((ns1__OtcBvalHeaders *)ptr)->soap_out(soap, tag, id, "ns1:OtcBvalHeaders");
	case SOAP_TYPE_ns1__FieldInfo:
		return ((ns1__FieldInfo *)ptr)->soap_out(soap, tag, id, "ns1:FieldInfo");
	case SOAP_TYPE_ns1__FieldInfos:
		return ((ns1__FieldInfos *)ptr)->soap_out(soap, tag, id, "ns1:FieldInfos");
	case SOAP_TYPE_ns1__FieldSearchCriteria:
		return ((ns1__FieldSearchCriteria *)ptr)->soap_out(soap, tag, id, "ns1:FieldSearchCriteria");
	case SOAP_TYPE_ns1__CancelResponseStatus:
		return ((ns1__CancelResponseStatus *)ptr)->soap_out(soap, tag, id, "ns1:CancelResponseStatus");
	case SOAP_TYPE_ns1__ResponseStatus:
		return ((ns1__ResponseStatus *)ptr)->soap_out(soap, tag, id, "ns1:ResponseStatus");
	case SOAP_TYPE_ns1__BulkArrayEntry:
		return ((ns1__BulkArrayEntry *)ptr)->soap_out(soap, tag, id, "ns1:BulkArrayEntry");
	case SOAP_TYPE_ns1__BulkArray:
		return ((ns1__BulkArray *)ptr)->soap_out(soap, tag, id, "ns1:BulkArray");
	case SOAP_TYPE_ns1__ActionStandardFields:
		return ((ns1__ActionStandardFields *)ptr)->soap_out(soap, tag, id, "ns1:ActionStandardFields");
	case SOAP_TYPE_ns1__HistData:
		return ((ns1__HistData *)ptr)->soap_out(soap, tag, id, "ns1:HistData");
	case SOAP_TYPE_ns1__QRMQuote:
		return ((ns1__QRMQuote *)ptr)->soap_out(soap, tag, id, "ns1:QRMQuote");
	case SOAP_TYPE_ns1__QRMQuoteData:
		return ((ns1__QRMQuoteData *)ptr)->soap_out(soap, tag, id, "ns1:QRMQuoteData");
	case SOAP_TYPE_ns1__QRQuote:
		return ((ns1__QRQuote *)ptr)->soap_out(soap, tag, id, "ns1:QRQuote");
	case SOAP_TYPE_ns1__QRMQuotes:
		return ((ns1__QRMQuotes *)ptr)->soap_out(soap, tag, id, "ns1:QRMQuotes");
	case SOAP_TYPE_ns1__QRQuotes:
		return ((ns1__QRQuotes *)ptr)->soap_out(soap, tag, id, "ns1:QRQuotes");
	case SOAP_TYPE_ns1__Data:
		return ((ns1__Data *)ptr)->soap_out(soap, tag, id, "ns1:Data");
	case SOAP_TYPE_ns1__CorrectionRecord:
		return ((ns1__CorrectionRecord *)ptr)->soap_out(soap, tag, id, "ns1:CorrectionRecord");
	case SOAP_TYPE_ns1__ActionsInstrumentData:
		return ((ns1__ActionsInstrumentData *)ptr)->soap_out(soap, tag, id, "ns1:ActionsInstrumentData");
	case SOAP_TYPE_ns1__AllQuotesInstrumentData:
		return ((ns1__AllQuotesInstrumentData *)ptr)->soap_out(soap, tag, id, "ns1:AllQuotesInstrumentData");
	case SOAP_TYPE_ns1__QuotesInstrumentData:
		return ((ns1__QuotesInstrumentData *)ptr)->soap_out(soap, tag, id, "ns1:QuotesInstrumentData");
	case SOAP_TYPE_ns1__FundInstrumentData:
		return ((ns1__FundInstrumentData *)ptr)->soap_out(soap, tag, id, "ns1:FundInstrumentData");
	case SOAP_TYPE_ns1__HistInstrumentData:
		return ((ns1__HistInstrumentData *)ptr)->soap_out(soap, tag, id, "ns1:HistInstrumentData");
	case SOAP_TYPE_ns1__InstrumentData:
		return ((ns1__InstrumentData *)ptr)->soap_out(soap, tag, id, "ns1:InstrumentData");
	case SOAP_TYPE_ns1__DataItem:
		return ((ns1__DataItem *)ptr)->soap_out(soap, tag, id, "ns1:DataItem");
	case SOAP_TYPE_ns1__Actions:
		return ((ns1__Actions *)ptr)->soap_out(soap, tag, id, "ns1:Actions");
	case SOAP_TYPE_ns1__Override:
		return ((ns1__Override *)ptr)->soap_out(soap, tag, id, "ns1:Override");
	case SOAP_TYPE_ns1__SecondaryQualifier:
		return ((ns1__SecondaryQualifier *)ptr)->soap_out(soap, tag, id, "ns1:SecondaryQualifier");
	case SOAP_TYPE_ns1__PrimaryQualifier:
		return ((ns1__PrimaryQualifier *)ptr)->soap_out(soap, tag, id, "ns1:PrimaryQualifier");
	case SOAP_TYPE_ns1__Macro:
		return ((ns1__Macro *)ptr)->soap_out(soap, tag, id, "ns1:Macro");
	case SOAP_TYPE_ns1__FundInstrument:
		return ((ns1__FundInstrument *)ptr)->soap_out(soap, tag, id, "ns1:FundInstrument");
	case SOAP_TYPE_ns1__Instrument:
		return ((ns1__Instrument *)ptr)->soap_out(soap, tag, id, "ns1:Instrument");
	case SOAP_TYPE_ns1__AllQuotesInstrumentDatas:
		return ((ns1__AllQuotesInstrumentDatas *)ptr)->soap_out(soap, tag, id, "ns1:AllQuotesInstrumentDatas");
	case SOAP_TYPE_ns1__QuotesInstrumentDatas:
		return ((ns1__QuotesInstrumentDatas *)ptr)->soap_out(soap, tag, id, "ns1:QuotesInstrumentDatas");
	case SOAP_TYPE_ns1__CorrectionRecords:
		return ((ns1__CorrectionRecords *)ptr)->soap_out(soap, tag, id, "ns1:CorrectionRecords");
	case SOAP_TYPE_ns1__ActionsInstrumentDatas:
		return ((ns1__ActionsInstrumentDatas *)ptr)->soap_out(soap, tag, id, "ns1:ActionsInstrumentDatas");
	case SOAP_TYPE_ns1__FundInstrumentDatas:
		return ((ns1__FundInstrumentDatas *)ptr)->soap_out(soap, tag, id, "ns1:FundInstrumentDatas");
	case SOAP_TYPE_ns1__HistInstrumentDatas:
		return ((ns1__HistInstrumentDatas *)ptr)->soap_out(soap, tag, id, "ns1:HistInstrumentDatas");
	case SOAP_TYPE_ns1__InstrumentDatas:
		return ((ns1__InstrumentDatas *)ptr)->soap_out(soap, tag, id, "ns1:InstrumentDatas");
	case SOAP_TYPE_ns1__FundInstruments:
		return ((ns1__FundInstruments *)ptr)->soap_out(soap, tag, id, "ns1:FundInstruments");
	case SOAP_TYPE_ns1__Instruments:
		return ((ns1__Instruments *)ptr)->soap_out(soap, tag, id, "ns1:Instruments");
	case SOAP_TYPE_ns1__Overrides:
		return ((ns1__Overrides *)ptr)->soap_out(soap, tag, id, "ns1:Overrides");
	case SOAP_TYPE_ns1__Fields:
		return ((ns1__Fields *)ptr)->soap_out(soap, tag, id, "ns1:Fields");
	case SOAP_TYPE_ns1__ScheduledHeaders:
		return ((ns1__ScheduledHeaders *)ptr)->soap_out(soap, tag, id, "ns1:ScheduledHeaders");
	case SOAP_TYPE_ns1__BvalFieldSet:
		return ((ns1__BvalFieldSet *)ptr)->soap_out(soap, tag, id, "ns1:BvalFieldSet");
	case SOAP_TYPE_ns1__BvalFieldSets:
		return ((ns1__BvalFieldSets *)ptr)->soap_out(soap, tag, id, "ns1:BvalFieldSets");
	case SOAP_TYPE_ns1__FieldSet:
		return ((ns1__FieldSet *)ptr)->soap_out(soap, tag, id, "ns1:FieldSet");
	case SOAP_TYPE_ns1__FieldSets:
		return ((ns1__FieldSets *)ptr)->soap_out(soap, tag, id, "ns1:FieldSets");
	case SOAP_TYPE_ns1__TickOutputTz:
		return ((ns1__TickOutputTz *)ptr)->soap_out(soap, tag, id, "ns1:TickOutputTz");
	case SOAP_TYPE_ns1__DateTimeRange:
		return ((ns1__DateTimeRange *)ptr)->soap_out(soap, tag, id, "ns1:DateTimeRange");
	case SOAP_TYPE_ns1__QuotesHeaders:
		return ((ns1__QuotesHeaders *)ptr)->soap_out(soap, tag, id, "ns1:QuotesHeaders");
	case SOAP_TYPE_ns1__GetPortfolioValidationHeaders:
		return ((ns1__GetPortfolioValidationHeaders *)ptr)->soap_out(soap, tag, id, "ns1:GetPortfolioValidationHeaders");
	case SOAP_TYPE_ns1__GetActionsHeaders:
		return ((ns1__GetActionsHeaders *)ptr)->soap_out(soap, tag, id, "ns1:GetActionsHeaders");
	case SOAP_TYPE_ns1__GetCompanyHeaders:
		return ((ns1__GetCompanyHeaders *)ptr)->soap_out(soap, tag, id, "ns1:GetCompanyHeaders");
	case SOAP_TYPE_ns1__GetFundamentalsHeaders:
		return ((ns1__GetFundamentalsHeaders *)ptr)->soap_out(soap, tag, id, "ns1:GetFundamentalsHeaders");
	case SOAP_TYPE_ns1__GetHistoryHeaders:
		return ((ns1__GetHistoryHeaders *)ptr)->soap_out(soap, tag, id, "ns1:GetHistoryHeaders");
	case SOAP_TYPE_ns1__DateRange:
		return ((ns1__DateRange *)ptr)->soap_out(soap, tag, id, "ns1:DateRange");
	case SOAP_TYPE_ns1__Duration:
		return ((ns1__Duration *)ptr)->soap_out(soap, tag, id, "ns1:Duration");
	case SOAP_TYPE_ns1__Period:
		return ((ns1__Period *)ptr)->soap_out(soap, tag, id, "ns1:Period");
	case SOAP_TYPE_ns1__GetDataHeaders:
		return ((ns1__GetDataHeaders *)ptr)->soap_out(soap, tag, id, "ns1:GetDataHeaders");
	case SOAP_TYPE_ns1__GetCorrectionsHeaders:
		return ((ns1__GetCorrectionsHeaders *)ptr)->soap_out(soap, tag, id, "ns1:GetCorrectionsHeaders");
	case SOAP_TYPE_ns1__CancelHeaders:
		return ((ns1__CancelHeaders *)ptr)->soap_out(soap, tag, id, "ns1:CancelHeaders");
	case SOAP_TYPE_xsd__time:
		return soap_out_xsd__time(soap, tag, id, (const std::string *)ptr, "xsd:time");
	case SOAP_TYPE_xsd__date:
		return soap_out_xsd__date(soap, tag, id, (const std::string *)ptr, "xsd:date");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_PointerTons1__RetrieveMmktBvalDealsUploadRequest:
		return soap_out_PointerTons1__RetrieveMmktBvalDealsUploadRequest(soap, tag, id, (ns1__RetrieveMmktBvalDealsUploadRequest *const*)ptr, "ns1:RetrieveMmktBvalDealsUploadRequest");
	case SOAP_TYPE_PointerTons1__SubmitMmktBvalDealsUploadRequest:
		return soap_out_PointerTons1__SubmitMmktBvalDealsUploadRequest(soap, tag, id, (ns1__SubmitMmktBvalDealsUploadRequest *const*)ptr, "ns1:SubmitMmktBvalDealsUploadRequest");
	case SOAP_TYPE_PointerTons1__GetFieldsRequest:
		return soap_out_PointerTons1__GetFieldsRequest(soap, tag, id, (ns1__GetFieldsRequest *const*)ptr, "ns1:GetFieldsRequest");
	case SOAP_TYPE_PointerTons1__RetrieveOtcBvalDealsUploadRequest:
		return soap_out_PointerTons1__RetrieveOtcBvalDealsUploadRequest(soap, tag, id, (ns1__RetrieveOtcBvalDealsUploadRequest *const*)ptr, "ns1:RetrieveOtcBvalDealsUploadRequest");
	case SOAP_TYPE_PointerTons1__SubmitOtcBvalDealsUploadRequest:
		return soap_out_PointerTons1__SubmitOtcBvalDealsUploadRequest(soap, tag, id, (ns1__SubmitOtcBvalDealsUploadRequest *const*)ptr, "ns1:SubmitOtcBvalDealsUploadRequest");
	case SOAP_TYPE_PointerTons1__RetrieveOtcbvalUploadRequest:
		return soap_out_PointerTons1__RetrieveOtcbvalUploadRequest(soap, tag, id, (ns1__RetrieveOtcbvalUploadRequest *const*)ptr, "ns1:RetrieveOtcbvalUploadRequest");
	case SOAP_TYPE_PointerTons1__SubmitOtcbvalUploadRequest:
		return soap_out_PointerTons1__SubmitOtcbvalUploadRequest(soap, tag, id, (ns1__SubmitOtcbvalUploadRequest *const*)ptr, "ns1:SubmitOtcbvalUploadRequest");
	case SOAP_TYPE_PointerTons1__RetrieveGetAllQuotesRequest:
		return soap_out_PointerTons1__RetrieveGetAllQuotesRequest(soap, tag, id, (ns1__RetrieveGetAllQuotesRequest *const*)ptr, "ns1:RetrieveGetAllQuotesRequest");
	case SOAP_TYPE_PointerTons1__SubmitGetAllQuotesRequest:
		return soap_out_PointerTons1__SubmitGetAllQuotesRequest(soap, tag, id, (ns1__SubmitGetAllQuotesRequest *const*)ptr, "ns1:SubmitGetAllQuotesRequest");
	case SOAP_TYPE_PointerTons1__RetrieveGetQuotesRequest:
		return soap_out_PointerTons1__RetrieveGetQuotesRequest(soap, tag, id, (ns1__RetrieveGetQuotesRequest *const*)ptr, "ns1:RetrieveGetQuotesRequest");
	case SOAP_TYPE_PointerTons1__SubmitGetQuotesRequest:
		return soap_out_PointerTons1__SubmitGetQuotesRequest(soap, tag, id, (ns1__SubmitGetQuotesRequest *const*)ptr, "ns1:SubmitGetQuotesRequest");
	case SOAP_TYPE_PointerTons1__GetPortfolioValidationRequest:
		return soap_out_PointerTons1__GetPortfolioValidationRequest(soap, tag, id, (ns1__GetPortfolioValidationRequest *const*)ptr, "ns1:GetPortfolioValidationRequest");
	case SOAP_TYPE_PointerTons1__RetrieveGetActionsRequest:
		return soap_out_PointerTons1__RetrieveGetActionsRequest(soap, tag, id, (ns1__RetrieveGetActionsRequest *const*)ptr, "ns1:RetrieveGetActionsRequest");
	case SOAP_TYPE_PointerTons1__SubmitGetActionsRequest:
		return soap_out_PointerTons1__SubmitGetActionsRequest(soap, tag, id, (ns1__SubmitGetActionsRequest *const*)ptr, "ns1:SubmitGetActionsRequest");
	case SOAP_TYPE_PointerTons1__RetrieveGetCompanyRequest:
		return soap_out_PointerTons1__RetrieveGetCompanyRequest(soap, tag, id, (ns1__RetrieveGetCompanyRequest *const*)ptr, "ns1:RetrieveGetCompanyRequest");
	case SOAP_TYPE_PointerTons1__SubmitGetCompanyRequest:
		return soap_out_PointerTons1__SubmitGetCompanyRequest(soap, tag, id, (ns1__SubmitGetCompanyRequest *const*)ptr, "ns1:SubmitGetCompanyRequest");
	case SOAP_TYPE_PointerTons1__RetrieveGetFundamentalsRequest:
		return soap_out_PointerTons1__RetrieveGetFundamentalsRequest(soap, tag, id, (ns1__RetrieveGetFundamentalsRequest *const*)ptr, "ns1:RetrieveGetFundamentalsRequest");
	case SOAP_TYPE_PointerTons1__SubmitGetFundamentalsRequest:
		return soap_out_PointerTons1__SubmitGetFundamentalsRequest(soap, tag, id, (ns1__SubmitGetFundamentalsRequest *const*)ptr, "ns1:SubmitGetFundamentalsRequest");
	case SOAP_TYPE_PointerTons1__GetCorrectionsRequest:
		return soap_out_PointerTons1__GetCorrectionsRequest(soap, tag, id, (ns1__GetCorrectionsRequest *const*)ptr, "ns1:GetCorrectionsRequest");
	case SOAP_TYPE_PointerTons1__RetrieveCancelRequest:
		return soap_out_PointerTons1__RetrieveCancelRequest(soap, tag, id, (ns1__RetrieveCancelRequest *const*)ptr, "ns1:RetrieveCancelRequest");
	case SOAP_TYPE_PointerTons1__SubmitCancelRequest:
		return soap_out_PointerTons1__SubmitCancelRequest(soap, tag, id, (ns1__SubmitCancelRequest *const*)ptr, "ns1:SubmitCancelRequest");
	case SOAP_TYPE_PointerTons1__RetrieveScheduledRequest:
		return soap_out_PointerTons1__RetrieveScheduledRequest(soap, tag, id, (ns1__RetrieveScheduledRequest *const*)ptr, "ns1:RetrieveScheduledRequest");
	case SOAP_TYPE_PointerTons1__SubmitScheduledRequest:
		return soap_out_PointerTons1__SubmitScheduledRequest(soap, tag, id, (ns1__SubmitScheduledRequest *const*)ptr, "ns1:SubmitScheduledRequest");
	case SOAP_TYPE_PointerTons1__RetrieveGetHistoryRequest:
		return soap_out_PointerTons1__RetrieveGetHistoryRequest(soap, tag, id, (ns1__RetrieveGetHistoryRequest *const*)ptr, "ns1:RetrieveGetHistoryRequest");
	case SOAP_TYPE_PointerTons1__SubmitGetHistoryRequest:
		return soap_out_PointerTons1__SubmitGetHistoryRequest(soap, tag, id, (ns1__SubmitGetHistoryRequest *const*)ptr, "ns1:SubmitGetHistoryRequest");
	case SOAP_TYPE_PointerTons1__RetrieveGetDataRequest:
		return soap_out_PointerTons1__RetrieveGetDataRequest(soap, tag, id, (ns1__RetrieveGetDataRequest *const*)ptr, "ns1:RetrieveGetDataRequest");
	case SOAP_TYPE_PointerTons1__SubmitGetDataRequest:
		return soap_out_PointerTons1__SubmitGetDataRequest(soap, tag, id, (ns1__SubmitGetDataRequest *const*)ptr, "ns1:SubmitGetDataRequest");
	case SOAP_TYPE_PointerTons1__MmktBvalDealInfos:
		return soap_out_PointerTons1__MmktBvalDealInfos(soap, tag, id, (ns1__MmktBvalDealInfos *const*)ptr, "ns1:MmktBvalDealInfos");
	case SOAP_TYPE_PointerTons1__FieldInfos:
		return soap_out_PointerTons1__FieldInfos(soap, tag, id, (ns1__FieldInfos *const*)ptr, "ns1:FieldInfos");
	case SOAP_TYPE_PointerTons1__OtcDealInfos:
		return soap_out_PointerTons1__OtcDealInfos(soap, tag, id, (ns1__OtcDealInfos *const*)ptr, "ns1:OtcDealInfos");
	case SOAP_TYPE_PointerTons1__AllQuotesInstrumentDatas:
		return soap_out_PointerTons1__AllQuotesInstrumentDatas(soap, tag, id, (ns1__AllQuotesInstrumentDatas *const*)ptr, "ns1:AllQuotesInstrumentDatas");
	case SOAP_TYPE_PointerTons1__QuotesInstrumentDatas:
		return soap_out_PointerTons1__QuotesInstrumentDatas(soap, tag, id, (ns1__QuotesInstrumentDatas *const*)ptr, "ns1:QuotesInstrumentDatas");
	case SOAP_TYPE_PointerTons1__ActionsInstrumentDatas:
		return soap_out_PointerTons1__ActionsInstrumentDatas(soap, tag, id, (ns1__ActionsInstrumentDatas *const*)ptr, "ns1:ActionsInstrumentDatas");
	case SOAP_TYPE_PointerTons1__GetPortfolioValidationHeaders:
		return soap_out_PointerTons1__GetPortfolioValidationHeaders(soap, tag, id, (ns1__GetPortfolioValidationHeaders *const*)ptr, "ns1:GetPortfolioValidationHeaders");
	case SOAP_TYPE_PointerTons1__FundInstrumentDatas:
		return soap_out_PointerTons1__FundInstrumentDatas(soap, tag, id, (ns1__FundInstrumentDatas *const*)ptr, "ns1:FundInstrumentDatas");
	case SOAP_TYPE_PointerTons1__ScheduledResponses:
		return soap_out_PointerTons1__ScheduledResponses(soap, tag, id, (ns1__ScheduledResponses *const*)ptr, "ns1:ScheduledResponses");
	case SOAP_TYPE_PointerTons1__CorrectionRecords:
		return soap_out_PointerTons1__CorrectionRecords(soap, tag, id, (ns1__CorrectionRecords *const*)ptr, "ns1:CorrectionRecords");
	case SOAP_TYPE_PointerTons1__GetCorrectionsHeaders:
		return soap_out_PointerTons1__GetCorrectionsHeaders(soap, tag, id, (ns1__GetCorrectionsHeaders *const*)ptr, "ns1:GetCorrectionsHeaders");
	case SOAP_TYPE_PointerTons1__CancelResponseStatus:
		return soap_out_PointerTons1__CancelResponseStatus(soap, tag, id, (ns1__CancelResponseStatus *const*)ptr, "ns1:CancelResponseStatus");
	case SOAP_TYPE_PointerTons1__HistInstrumentDatas:
		return soap_out_PointerTons1__HistInstrumentDatas(soap, tag, id, (ns1__HistInstrumentDatas *const*)ptr, "ns1:HistInstrumentDatas");
	case SOAP_TYPE_PointerTons1__InstrumentDatas:
		return soap_out_PointerTons1__InstrumentDatas(soap, tag, id, (ns1__InstrumentDatas *const*)ptr, "ns1:InstrumentDatas");
	case SOAP_TYPE_PointerTons1__MmktBvalDealInformation:
		return soap_out_PointerTons1__MmktBvalDealInformation(soap, tag, id, (ns1__MmktBvalDealInformation *const*)ptr, "ns1:MmktBvalDealInformation");
	case SOAP_TYPE_PointerTons1__MmktBvalHeaders:
		return soap_out_PointerTons1__MmktBvalHeaders(soap, tag, id, (ns1__MmktBvalHeaders *const*)ptr, "ns1:MmktBvalHeaders");
	case SOAP_TYPE_PointerTons1__FieldSearchCriteria:
		return soap_out_PointerTons1__FieldSearchCriteria(soap, tag, id, (ns1__FieldSearchCriteria *const*)ptr, "ns1:FieldSearchCriteria");
	case SOAP_TYPE_PointerTons1__OtcBvalHeaders:
		return soap_out_PointerTons1__OtcBvalHeaders(soap, tag, id, (ns1__OtcBvalHeaders *const*)ptr, "ns1:OtcBvalHeaders");
	case SOAP_TYPE_PointerTons1__FundInstruments:
		return soap_out_PointerTons1__FundInstruments(soap, tag, id, (ns1__FundInstruments *const*)ptr, "ns1:FundInstruments");
	case SOAP_TYPE_PointerToxsd__time:
		return soap_out_PointerToxsd__time(soap, tag, id, (std::string *const*)ptr, "xsd:time");
	case SOAP_TYPE_PointerTons1__FieldSets:
		return soap_out_PointerTons1__FieldSets(soap, tag, id, (ns1__FieldSets *const*)ptr, "ns1:FieldSets");
	case SOAP_TYPE_PointerTons1__ScheduledHeaders:
		return soap_out_PointerTons1__ScheduledHeaders(soap, tag, id, (ns1__ScheduledHeaders *const*)ptr, "ns1:ScheduledHeaders");
	case SOAP_TYPE_PointerTons1__ScheduledResponse:
		return soap_out_PointerTons1__ScheduledResponse(soap, tag, id, (ns1__ScheduledResponse *const*)ptr, "ns1:ScheduledResponse");
	case SOAP_TYPE_PointerTons1__CancelHeaders:
		return soap_out_PointerTons1__CancelHeaders(soap, tag, id, (ns1__CancelHeaders *const*)ptr, "ns1:CancelHeaders");
	case SOAP_TYPE_PointerTons1__Instruments:
		return soap_out_PointerTons1__Instruments(soap, tag, id, (ns1__Instruments *const*)ptr, "ns1:Instruments");
	case SOAP_TYPE_PointerTons1__Fields:
		return soap_out_PointerTons1__Fields(soap, tag, id, (ns1__Fields *const*)ptr, "ns1:Fields");
	case SOAP_TYPE_PointerTons1__BvalFieldSets:
		return soap_out_PointerTons1__BvalFieldSets(soap, tag, id, (ns1__BvalFieldSets *const*)ptr, "ns1:BvalFieldSets");
	case SOAP_TYPE_PointerTons1__OtcDealInformation:
		return soap_out_PointerTons1__OtcDealInformation(soap, tag, id, (ns1__OtcDealInformation *const*)ptr, "ns1:OtcDealInformation");
	case SOAP_TYPE_PointerTons1__OtcBvalAction:
		return soap_out_PointerTons1__OtcBvalAction(soap, tag, id, (enum ns1__OtcBvalAction *const*)ptr, "ns1:OtcBvalAction");
	case SOAP_TYPE_PointerTons1__ResponseStatus:
		return soap_out_PointerTons1__ResponseStatus(soap, tag, id, (ns1__ResponseStatus *const*)ptr, "ns1:ResponseStatus");
	case SOAP_TYPE_PointerTons1__DLCategory2:
		return soap_out_PointerTons1__DLCategory2(soap, tag, id, (enum ns1__DLCategory2 *const*)ptr, "ns1:DLCategory2");
	case SOAP_TYPE_PointerTons1__DLCategory:
		return soap_out_PointerTons1__DLCategory(soap, tag, id, (enum ns1__DLCategory *const*)ptr, "ns1:DLCategory");
	case SOAP_TYPE_PointerTons1__FieldInfo:
		return soap_out_PointerTons1__FieldInfo(soap, tag, id, (ns1__FieldInfo *const*)ptr, "ns1:FieldInfo");
	case SOAP_TYPE_PointerTons1__FieldType:
		return soap_out_PointerTons1__FieldType(soap, tag, id, (enum ns1__FieldType *const*)ptr, "ns1:FieldType");
	case SOAP_TYPE_PointerTons1__BulkArrayEntry:
		return soap_out_PointerTons1__BulkArrayEntry(soap, tag, id, (ns1__BulkArrayEntry *const*)ptr, "ns1:BulkArrayEntry");
	case SOAP_TYPE_PointerTons1__QRMQuoteData:
		return soap_out_PointerTons1__QRMQuoteData(soap, tag, id, (ns1__QRMQuoteData *const*)ptr, "ns1:QRMQuoteData");
	case SOAP_TYPE_PointerTodateTime:
		return soap_out_PointerTodateTime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerTons1__QRMQuote:
		return soap_out_PointerTons1__QRMQuote(soap, tag, id, (ns1__QRMQuote *const*)ptr, "ns1:QRMQuote");
	case SOAP_TYPE_PointerTons1__QRQuote:
		return soap_out_PointerTons1__QRQuote(soap, tag, id, (ns1__QRQuote *const*)ptr, "ns1:QRQuote");
	case SOAP_TYPE_PointerTons1__BulkArray:
		return soap_out_PointerTons1__BulkArray(soap, tag, id, (ns1__BulkArray *const*)ptr, "ns1:BulkArray");
	case SOAP_TYPE_PointerTons1__ActionStandardFields:
		return soap_out_PointerTons1__ActionStandardFields(soap, tag, id, (ns1__ActionStandardFields *const*)ptr, "ns1:ActionStandardFields");
	case SOAP_TYPE_PointerTons1__QRMQuotes:
		return soap_out_PointerTons1__QRMQuotes(soap, tag, id, (ns1__QRMQuotes *const*)ptr, "ns1:QRMQuotes");
	case SOAP_TYPE_PointerTons1__QRQuotes:
		return soap_out_PointerTons1__QRQuotes(soap, tag, id, (ns1__QRQuotes *const*)ptr, "ns1:QRQuotes");
	case SOAP_TYPE_PointerTons1__HistData:
		return soap_out_PointerTons1__HistData(soap, tag, id, (ns1__HistData *const*)ptr, "ns1:HistData");
	case SOAP_TYPE_PointerTons1__Data:
		return soap_out_PointerTons1__Data(soap, tag, id, (ns1__Data *const*)ptr, "ns1:Data");
	case SOAP_TYPE_PointerTons1__SecondaryQualifier:
		return soap_out_PointerTons1__SecondaryQualifier(soap, tag, id, (ns1__SecondaryQualifier *const*)ptr, "ns1:SecondaryQualifier");
	case SOAP_TYPE_PointerTons1__PrimaryQualifier:
		return soap_out_PointerTons1__PrimaryQualifier(soap, tag, id, (ns1__PrimaryQualifier *const*)ptr, "ns1:PrimaryQualifier");
	case SOAP_TYPE_PointerTons1__Overrides:
		return soap_out_PointerTons1__Overrides(soap, tag, id, (ns1__Overrides *const*)ptr, "ns1:Overrides");
	case SOAP_TYPE_PointerTons1__AllQuotesInstrumentData:
		return soap_out_PointerTons1__AllQuotesInstrumentData(soap, tag, id, (ns1__AllQuotesInstrumentData *const*)ptr, "ns1:AllQuotesInstrumentData");
	case SOAP_TYPE_PointerTons1__QuotesInstrumentData:
		return soap_out_PointerTons1__QuotesInstrumentData(soap, tag, id, (ns1__QuotesInstrumentData *const*)ptr, "ns1:QuotesInstrumentData");
	case SOAP_TYPE_PointerTons1__CorrectionRecord:
		return soap_out_PointerTons1__CorrectionRecord(soap, tag, id, (ns1__CorrectionRecord *const*)ptr, "ns1:CorrectionRecord");
	case SOAP_TYPE_PointerTons1__ActionsInstrumentData:
		return soap_out_PointerTons1__ActionsInstrumentData(soap, tag, id, (ns1__ActionsInstrumentData *const*)ptr, "ns1:ActionsInstrumentData");
	case SOAP_TYPE_PointerTons1__FundInstrumentData:
		return soap_out_PointerTons1__FundInstrumentData(soap, tag, id, (ns1__FundInstrumentData *const*)ptr, "ns1:FundInstrumentData");
	case SOAP_TYPE_PointerTons1__HistInstrumentData:
		return soap_out_PointerTons1__HistInstrumentData(soap, tag, id, (ns1__HistInstrumentData *const*)ptr, "ns1:HistInstrumentData");
	case SOAP_TYPE_PointerTons1__InstrumentData:
		return soap_out_PointerTons1__InstrumentData(soap, tag, id, (ns1__InstrumentData *const*)ptr, "ns1:InstrumentData");
	case SOAP_TYPE_PointerTons1__FundInstrument:
		return soap_out_PointerTons1__FundInstrument(soap, tag, id, (ns1__FundInstrument *const*)ptr, "ns1:FundInstrument");
	case SOAP_TYPE_PointerTons1__Macro:
		return soap_out_PointerTons1__Macro(soap, tag, id, (ns1__Macro *const*)ptr, "ns1:Macro");
	case SOAP_TYPE_PointerTons1__Instrument:
		return soap_out_PointerTons1__Instrument(soap, tag, id, (ns1__Instrument *const*)ptr, "ns1:Instrument");
	case SOAP_TYPE_PointerTons1__Override:
		return soap_out_PointerTons1__Override(soap, tag, id, (ns1__Override *const*)ptr, "ns1:Override");
	case SOAP_TYPE_PointerTons1__QuotesHeaders:
		return soap_out_PointerTons1__QuotesHeaders(soap, tag, id, (ns1__QuotesHeaders *const*)ptr, "ns1:QuotesHeaders");
	case SOAP_TYPE_PointerTons1__GetActionsHeaders:
		return soap_out_PointerTons1__GetActionsHeaders(soap, tag, id, (ns1__GetActionsHeaders *const*)ptr, "ns1:GetActionsHeaders");
	case SOAP_TYPE_PointerTons1__GetCompanyHeaders:
		return soap_out_PointerTons1__GetCompanyHeaders(soap, tag, id, (ns1__GetCompanyHeaders *const*)ptr, "ns1:GetCompanyHeaders");
	case SOAP_TYPE_PointerTons1__GetFundamentalsHeaders:
		return soap_out_PointerTons1__GetFundamentalsHeaders(soap, tag, id, (ns1__GetFundamentalsHeaders *const*)ptr, "ns1:GetFundamentalsHeaders");
	case SOAP_TYPE_PointerTons1__GetHistoryHeaders:
		return soap_out_PointerTons1__GetHistoryHeaders(soap, tag, id, (ns1__GetHistoryHeaders *const*)ptr, "ns1:GetHistoryHeaders");
	case SOAP_TYPE_PointerTons1__GetDataHeaders:
		return soap_out_PointerTons1__GetDataHeaders(soap, tag, id, (ns1__GetDataHeaders *const*)ptr, "ns1:GetDataHeaders");
	case SOAP_TYPE_PointerTons1__BvalFieldSet:
		return soap_out_PointerTons1__BvalFieldSet(soap, tag, id, (ns1__BvalFieldSet *const*)ptr, "ns1:BvalFieldSet");
	case SOAP_TYPE_PointerToxsd__date:
		return soap_out_PointerToxsd__date(soap, tag, id, (std::string *const*)ptr, "xsd:date");
	case SOAP_TYPE_PointerTons1__FieldSet:
		return soap_out_PointerTons1__FieldSet(soap, tag, id, (ns1__FieldSet *const*)ptr, "ns1:FieldSet");
	case SOAP_TYPE_PointerTons1__TickOutputTz:
		return soap_out_PointerTons1__TickOutputTz(soap, tag, id, (ns1__TickOutputTz *const*)ptr, "ns1:TickOutputTz");
	case SOAP_TYPE_PointerTons1__DateTimeRange:
		return soap_out_PointerTons1__DateTimeRange(soap, tag, id, (ns1__DateTimeRange *const*)ptr, "ns1:DateTimeRange");
	case SOAP_TYPE_PointerTons1__ActionsDate:
		return soap_out_PointerTons1__ActionsDate(soap, tag, id, (enum ns1__ActionsDate *const*)ptr, "ns1:ActionsDate");
	case SOAP_TYPE_PointerTons1__Actions:
		return soap_out_PointerTons1__Actions(soap, tag, id, (ns1__Actions *const*)ptr, "ns1:Actions");
	case SOAP_TYPE_PointerTons1__Periodicity:
		return soap_out_PointerTons1__Periodicity(soap, tag, id, (enum ns1__Periodicity *const*)ptr, "ns1:Periodicity");
	case SOAP_TYPE_PointerTons1__FilingStatus:
		return soap_out_PointerTons1__FilingStatus(soap, tag, id, (enum ns1__FilingStatus *const*)ptr, "ns1:FilingStatus");
	case SOAP_TYPE_PointerTons1__HistOption:
		return soap_out_PointerTons1__HistOption(soap, tag, id, (enum ns1__HistOption *const*)ptr, "ns1:HistOption");
	case SOAP_TYPE_PointerTons1__HistPeriod:
		return soap_out_PointerTons1__HistPeriod(soap, tag, id, (enum ns1__HistPeriod *const*)ptr, "ns1:HistPeriod");
	case SOAP_TYPE_PointerTons1__DateRange:
		return soap_out_PointerTons1__DateRange(soap, tag, id, (ns1__DateRange *const*)ptr, "ns1:DateRange");
	case SOAP_TYPE_PointerTons1__Duration:
		return soap_out_PointerTons1__Duration(soap, tag, id, (ns1__Duration *const*)ptr, "ns1:Duration");
	case SOAP_TYPE_PointerTons1__Period:
		return soap_out_PointerTons1__Period(soap, tag, id, (ns1__Period *const*)ptr, "ns1:Period");
	case SOAP_TYPE_PointerTons1__RegSolvency:
		return soap_out_PointerTons1__RegSolvency(soap, tag, id, (enum ns1__RegSolvency *const*)ptr, "ns1:RegSolvency");
	case SOAP_TYPE_PointerTons1__PortSecDes:
		return soap_out_PointerTons1__PortSecDes(soap, tag, id, (enum ns1__PortSecDes *const*)ptr, "ns1:PortSecDes");
	case SOAP_TYPE_PointerTons1__BvalSnapshot:
		return soap_out_PointerTons1__BvalSnapshot(soap, tag, id, (enum ns1__BvalSnapshot *const*)ptr, "ns1:BvalSnapshot");
	case SOAP_TYPE_PointerTons1__BvalTier:
		return soap_out_PointerTons1__BvalTier(soap, tag, id, (enum ns1__BvalTier *const*)ptr, "ns1:BvalTier");
	case SOAP_TYPE_PointerTons1__MarketSector:
		return soap_out_PointerTons1__MarketSector(soap, tag, id, (enum ns1__MarketSector *const*)ptr, "ns1:MarketSector");
	case SOAP_TYPE_PointerTons1__Version:
		return soap_out_PointerTons1__Version(soap, tag, id, (enum ns1__Version *const*)ptr, "ns1:Version");
	case SOAP_TYPE_PointerTons1__SpecialChar:
		return soap_out_PointerTons1__SpecialChar(soap, tag, id, (enum ns1__SpecialChar *const*)ptr, "ns1:SpecialChar");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerTons1__InstrumentType:
		return soap_out_PointerTons1__InstrumentType(soap, tag, id, (enum ns1__InstrumentType *const*)ptr, "ns1:InstrumentType");
	case SOAP_TYPE_PointerTons1__ProgramFlag:
		return soap_out_PointerTons1__ProgramFlag(soap, tag, id, (enum ns1__ProgramFlag *const*)ptr, "ns1:ProgramFlag");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTons1__DiffFlag:
		return soap_out_PointerTons1__DiffFlag(soap, tag, id, (enum ns1__DiffFlag *const*)ptr, "ns1:DiffFlag");
	case SOAP_TYPE_PointerTobool:
		return soap_out_PointerTobool(soap, tag, id, (bool *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerTons1__DateFormat:
		return soap_out_PointerTons1__DateFormat(soap, tag, id, (enum ns1__DateFormat *const*)ptr, "ns1:DateFormat");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	case 0:
		return SOAP_OK;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_putelement '%s' failed for type %d in soapC.cpp\n", tag ? tag : "", type));
	return soap_element_empty(soap, tag, 0, NULL); /* unknown type to serialize */
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_ns1__RetrieveMmktBvalDealsUploadResponse:
		((ns1__RetrieveMmktBvalDealsUploadResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__MmktBvalDealInfos:
		((ns1__MmktBvalDealInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__MmktBvalDealInformation:
		((ns1__MmktBvalDealInformation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RetrieveMmktBvalDealsUploadRequest:
		((ns1__RetrieveMmktBvalDealsUploadRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SubmitMmktBvalDealsUploadResponse:
		((ns1__SubmitMmktBvalDealsUploadResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SubmitMmktBvalDealsUploadRequest:
		((ns1__SubmitMmktBvalDealsUploadRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__MmktBvalHeaders:
		((ns1__MmktBvalHeaders *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__GetFieldsResponse:
		((ns1__GetFieldsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__GetFieldsRequest:
		((ns1__GetFieldsRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RetrieveOtcBvalDealsUploadResponse:
		((ns1__RetrieveOtcBvalDealsUploadResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RetrieveOtcBvalDealsUploadRequest:
		((ns1__RetrieveOtcBvalDealsUploadRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SubmitOtcBvalDealsUploadResponse:
		((ns1__SubmitOtcBvalDealsUploadResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SubmitOtcBvalDealsUploadRequest:
		((ns1__SubmitOtcBvalDealsUploadRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RetrieveOtcbvalUploadResponse:
		((ns1__RetrieveOtcbvalUploadResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RetrieveOtcbvalUploadRequest:
		((ns1__RetrieveOtcbvalUploadRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SubmitOtcbvalUploadResponse:
		((ns1__SubmitOtcbvalUploadResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SubmitOtcbvalUploadRequest:
		((ns1__SubmitOtcbvalUploadRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RetrieveGetAllQuotesResponse:
		((ns1__RetrieveGetAllQuotesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RetrieveGetAllQuotesRequest:
		((ns1__RetrieveGetAllQuotesRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SubmitGetAllQuotesResponse:
		((ns1__SubmitGetAllQuotesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SubmitGetAllQuotesRequest:
		((ns1__SubmitGetAllQuotesRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RetrieveGetQuotesResponse:
		((ns1__RetrieveGetQuotesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RetrieveGetQuotesRequest:
		((ns1__RetrieveGetQuotesRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SubmitGetQuotesResponse:
		((ns1__SubmitGetQuotesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SubmitGetQuotesRequest:
		((ns1__SubmitGetQuotesRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RetrieveGetActionsResponse:
		((ns1__RetrieveGetActionsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RetrieveGetActionsRequest:
		((ns1__RetrieveGetActionsRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SubmitGetActionsResponse:
		((ns1__SubmitGetActionsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SubmitGetActionsRequest:
		((ns1__SubmitGetActionsRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__GetPortfolioValidationResponse:
		((ns1__GetPortfolioValidationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__GetPortfolioValidationRequest:
		((ns1__GetPortfolioValidationRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RetrieveGetCompanyResponse:
		((ns1__RetrieveGetCompanyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RetrieveGetCompanyRequest:
		((ns1__RetrieveGetCompanyRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SubmitGetCompanyResponse:
		((ns1__SubmitGetCompanyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SubmitGetCompanyRequest:
		((ns1__SubmitGetCompanyRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RetrieveGetFundamentalsResponse:
		((ns1__RetrieveGetFundamentalsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RetrieveGetFundamentalsRequest:
		((ns1__RetrieveGetFundamentalsRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SubmitGetFundamentalsResponse:
		((ns1__SubmitGetFundamentalsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SubmitGetFundamentalsRequest:
		((ns1__SubmitGetFundamentalsRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RetrieveScheduledResponse:
		((ns1__RetrieveScheduledResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ScheduledResponse:
		((ns1__ScheduledResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ScheduledResponses:
		((ns1__ScheduledResponses *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RetrieveScheduledRequest:
		((ns1__RetrieveScheduledRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SubmitScheduledResponse:
		((ns1__SubmitScheduledResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SubmitScheduledRequest:
		((ns1__SubmitScheduledRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__GetCorrectionsResponse:
		((ns1__GetCorrectionsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__GetCorrectionsRequest:
		((ns1__GetCorrectionsRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RetrieveCancelResponse:
		((ns1__RetrieveCancelResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RetrieveCancelRequest:
		((ns1__RetrieveCancelRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SubmitCancelResponse:
		((ns1__SubmitCancelResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SubmitCancelRequest:
		((ns1__SubmitCancelRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RetrieveGetHistoryResponse:
		((ns1__RetrieveGetHistoryResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RetrieveGetHistoryRequest:
		((ns1__RetrieveGetHistoryRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SubmitGetHistoryResponse:
		((ns1__SubmitGetHistoryResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SubmitGetHistoryRequest:
		((ns1__SubmitGetHistoryRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RetrieveGetDataResponse:
		((ns1__RetrieveGetDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RetrieveGetDataRequest:
		((ns1__RetrieveGetDataRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SubmitGetDataResponse:
		((ns1__SubmitGetDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SubmitGetDataRequest:
		((ns1__SubmitGetDataRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__PerSecurityResponse:
		((ns1__PerSecurityResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__OtcDealInfos:
		((ns1__OtcDealInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__OtcDealInformation:
		((ns1__OtcDealInformation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__OtcBvalHeaders:
		((ns1__OtcBvalHeaders *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__FieldInfo:
		((ns1__FieldInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__FieldInfos:
		((ns1__FieldInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__FieldSearchCriteria:
		((ns1__FieldSearchCriteria *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CancelResponseStatus:
		((ns1__CancelResponseStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ResponseStatus:
		((ns1__ResponseStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__BulkArrayEntry:
		((ns1__BulkArrayEntry *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__BulkArray:
		((ns1__BulkArray *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ActionStandardFields:
		((ns1__ActionStandardFields *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__HistData:
		((ns1__HistData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__QRMQuote:
		((ns1__QRMQuote *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__QRMQuoteData:
		((ns1__QRMQuoteData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__QRQuote:
		((ns1__QRQuote *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__QRMQuotes:
		((ns1__QRMQuotes *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__QRQuotes:
		((ns1__QRQuotes *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Data:
		((ns1__Data *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CorrectionRecord:
		((ns1__CorrectionRecord *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ActionsInstrumentData:
		((ns1__ActionsInstrumentData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__AllQuotesInstrumentData:
		((ns1__AllQuotesInstrumentData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__QuotesInstrumentData:
		((ns1__QuotesInstrumentData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__FundInstrumentData:
		((ns1__FundInstrumentData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__HistInstrumentData:
		((ns1__HistInstrumentData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__InstrumentData:
		((ns1__InstrumentData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__DataItem:
		((ns1__DataItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Actions:
		((ns1__Actions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Override:
		((ns1__Override *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SecondaryQualifier:
		((ns1__SecondaryQualifier *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__PrimaryQualifier:
		((ns1__PrimaryQualifier *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Macro:
		((ns1__Macro *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__FundInstrument:
		((ns1__FundInstrument *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Instrument:
		((ns1__Instrument *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__AllQuotesInstrumentDatas:
		((ns1__AllQuotesInstrumentDatas *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__QuotesInstrumentDatas:
		((ns1__QuotesInstrumentDatas *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CorrectionRecords:
		((ns1__CorrectionRecords *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ActionsInstrumentDatas:
		((ns1__ActionsInstrumentDatas *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__FundInstrumentDatas:
		((ns1__FundInstrumentDatas *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__HistInstrumentDatas:
		((ns1__HistInstrumentDatas *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__InstrumentDatas:
		((ns1__InstrumentDatas *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__FundInstruments:
		((ns1__FundInstruments *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Instruments:
		((ns1__Instruments *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Overrides:
		((ns1__Overrides *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Fields:
		((ns1__Fields *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ScheduledHeaders:
		((ns1__ScheduledHeaders *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__BvalFieldSet:
		((ns1__BvalFieldSet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__BvalFieldSets:
		((ns1__BvalFieldSets *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__FieldSet:
		((ns1__FieldSet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__FieldSets:
		((ns1__FieldSets *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__TickOutputTz:
		((ns1__TickOutputTz *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__DateTimeRange:
		((ns1__DateTimeRange *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__QuotesHeaders:
		((ns1__QuotesHeaders *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__GetPortfolioValidationHeaders:
		((ns1__GetPortfolioValidationHeaders *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__GetActionsHeaders:
		((ns1__GetActionsHeaders *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__GetCompanyHeaders:
		((ns1__GetCompanyHeaders *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__GetFundamentalsHeaders:
		((ns1__GetFundamentalsHeaders *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__GetHistoryHeaders:
		((ns1__GetHistoryHeaders *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__DateRange:
		((ns1__DateRange *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Duration:
		((ns1__Duration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Period:
		((ns1__Period *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__GetDataHeaders:
		((ns1__GetDataHeaders *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__GetCorrectionsHeaders:
		((ns1__GetCorrectionsHeaders *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CancelHeaders:
		((ns1__CancelHeaders *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__time:
		soap_serialize_xsd__time(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__date:
		soap_serialize_xsd__date(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE___ns1__retrieveMmktBvalDealsUploadResponse:
		soap_serialize___ns1__retrieveMmktBvalDealsUploadResponse(soap, (const struct __ns1__retrieveMmktBvalDealsUploadResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__submitMmktBvalDealsUploadRequest:
		soap_serialize___ns1__submitMmktBvalDealsUploadRequest(soap, (const struct __ns1__submitMmktBvalDealsUploadRequest *)ptr);
		break;
	case SOAP_TYPE___ns1__getFields:
		soap_serialize___ns1__getFields(soap, (const struct __ns1__getFields *)ptr);
		break;
	case SOAP_TYPE___ns1__retrieveOtcBvalDealsUploadResponse:
		soap_serialize___ns1__retrieveOtcBvalDealsUploadResponse(soap, (const struct __ns1__retrieveOtcBvalDealsUploadResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__submitOtcBvalDealsUploadRequest:
		soap_serialize___ns1__submitOtcBvalDealsUploadRequest(soap, (const struct __ns1__submitOtcBvalDealsUploadRequest *)ptr);
		break;
	case SOAP_TYPE___ns1__retrieveOtcbvalUploadResponse:
		soap_serialize___ns1__retrieveOtcbvalUploadResponse(soap, (const struct __ns1__retrieveOtcbvalUploadResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__submitOtcbvalUploadRequest:
		soap_serialize___ns1__submitOtcbvalUploadRequest(soap, (const struct __ns1__submitOtcbvalUploadRequest *)ptr);
		break;
	case SOAP_TYPE___ns1__retrieveGetAllQuotesResponse:
		soap_serialize___ns1__retrieveGetAllQuotesResponse(soap, (const struct __ns1__retrieveGetAllQuotesResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__submitGetAllQuotesRequest:
		soap_serialize___ns1__submitGetAllQuotesRequest(soap, (const struct __ns1__submitGetAllQuotesRequest *)ptr);
		break;
	case SOAP_TYPE___ns1__retrieveGetQuotesResponse:
		soap_serialize___ns1__retrieveGetQuotesResponse(soap, (const struct __ns1__retrieveGetQuotesResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__submitGetQuotesRequest:
		soap_serialize___ns1__submitGetQuotesRequest(soap, (const struct __ns1__submitGetQuotesRequest *)ptr);
		break;
	case SOAP_TYPE___ns1__getPortfolioValidation:
		soap_serialize___ns1__getPortfolioValidation(soap, (const struct __ns1__getPortfolioValidation *)ptr);
		break;
	case SOAP_TYPE___ns1__retrieveGetActionsResponse:
		soap_serialize___ns1__retrieveGetActionsResponse(soap, (const struct __ns1__retrieveGetActionsResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__submitGetActionsRequest:
		soap_serialize___ns1__submitGetActionsRequest(soap, (const struct __ns1__submitGetActionsRequest *)ptr);
		break;
	case SOAP_TYPE___ns1__retrieveGetCompanyResponse:
		soap_serialize___ns1__retrieveGetCompanyResponse(soap, (const struct __ns1__retrieveGetCompanyResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__submitGetCompanyRequest:
		soap_serialize___ns1__submitGetCompanyRequest(soap, (const struct __ns1__submitGetCompanyRequest *)ptr);
		break;
	case SOAP_TYPE___ns1__retrieveGetFundamentalsResponse:
		soap_serialize___ns1__retrieveGetFundamentalsResponse(soap, (const struct __ns1__retrieveGetFundamentalsResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__submitGetFundamentalsRequest:
		soap_serialize___ns1__submitGetFundamentalsRequest(soap, (const struct __ns1__submitGetFundamentalsRequest *)ptr);
		break;
	case SOAP_TYPE___ns1__getCorrections:
		soap_serialize___ns1__getCorrections(soap, (const struct __ns1__getCorrections *)ptr);
		break;
	case SOAP_TYPE___ns1__retrieveCancelResponse:
		soap_serialize___ns1__retrieveCancelResponse(soap, (const struct __ns1__retrieveCancelResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__submitCancelRequest:
		soap_serialize___ns1__submitCancelRequest(soap, (const struct __ns1__submitCancelRequest *)ptr);
		break;
	case SOAP_TYPE___ns1__retrieveScheduledResponse:
		soap_serialize___ns1__retrieveScheduledResponse(soap, (const struct __ns1__retrieveScheduledResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__submitScheduledRequest:
		soap_serialize___ns1__submitScheduledRequest(soap, (const struct __ns1__submitScheduledRequest *)ptr);
		break;
	case SOAP_TYPE___ns1__retrieveGetHistoryResponse:
		soap_serialize___ns1__retrieveGetHistoryResponse(soap, (const struct __ns1__retrieveGetHistoryResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__submitGetHistoryRequest:
		soap_serialize___ns1__submitGetHistoryRequest(soap, (const struct __ns1__submitGetHistoryRequest *)ptr);
		break;
	case SOAP_TYPE___ns1__retrieveGetDataResponse:
		soap_serialize___ns1__retrieveGetDataResponse(soap, (const struct __ns1__retrieveGetDataResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__submitGetDataRequest:
		soap_serialize___ns1__submitGetDataRequest(soap, (const struct __ns1__submitGetDataRequest *)ptr);
		break;
	case SOAP_TYPE_PointerTons1__RetrieveMmktBvalDealsUploadRequest:
		soap_serialize_PointerTons1__RetrieveMmktBvalDealsUploadRequest(soap, (ns1__RetrieveMmktBvalDealsUploadRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SubmitMmktBvalDealsUploadRequest:
		soap_serialize_PointerTons1__SubmitMmktBvalDealsUploadRequest(soap, (ns1__SubmitMmktBvalDealsUploadRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__GetFieldsRequest:
		soap_serialize_PointerTons1__GetFieldsRequest(soap, (ns1__GetFieldsRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__RetrieveOtcBvalDealsUploadRequest:
		soap_serialize_PointerTons1__RetrieveOtcBvalDealsUploadRequest(soap, (ns1__RetrieveOtcBvalDealsUploadRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SubmitOtcBvalDealsUploadRequest:
		soap_serialize_PointerTons1__SubmitOtcBvalDealsUploadRequest(soap, (ns1__SubmitOtcBvalDealsUploadRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__RetrieveOtcbvalUploadRequest:
		soap_serialize_PointerTons1__RetrieveOtcbvalUploadRequest(soap, (ns1__RetrieveOtcbvalUploadRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SubmitOtcbvalUploadRequest:
		soap_serialize_PointerTons1__SubmitOtcbvalUploadRequest(soap, (ns1__SubmitOtcbvalUploadRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__RetrieveGetAllQuotesRequest:
		soap_serialize_PointerTons1__RetrieveGetAllQuotesRequest(soap, (ns1__RetrieveGetAllQuotesRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SubmitGetAllQuotesRequest:
		soap_serialize_PointerTons1__SubmitGetAllQuotesRequest(soap, (ns1__SubmitGetAllQuotesRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__RetrieveGetQuotesRequest:
		soap_serialize_PointerTons1__RetrieveGetQuotesRequest(soap, (ns1__RetrieveGetQuotesRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SubmitGetQuotesRequest:
		soap_serialize_PointerTons1__SubmitGetQuotesRequest(soap, (ns1__SubmitGetQuotesRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__GetPortfolioValidationRequest:
		soap_serialize_PointerTons1__GetPortfolioValidationRequest(soap, (ns1__GetPortfolioValidationRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__RetrieveGetActionsRequest:
		soap_serialize_PointerTons1__RetrieveGetActionsRequest(soap, (ns1__RetrieveGetActionsRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SubmitGetActionsRequest:
		soap_serialize_PointerTons1__SubmitGetActionsRequest(soap, (ns1__SubmitGetActionsRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__RetrieveGetCompanyRequest:
		soap_serialize_PointerTons1__RetrieveGetCompanyRequest(soap, (ns1__RetrieveGetCompanyRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SubmitGetCompanyRequest:
		soap_serialize_PointerTons1__SubmitGetCompanyRequest(soap, (ns1__SubmitGetCompanyRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__RetrieveGetFundamentalsRequest:
		soap_serialize_PointerTons1__RetrieveGetFundamentalsRequest(soap, (ns1__RetrieveGetFundamentalsRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SubmitGetFundamentalsRequest:
		soap_serialize_PointerTons1__SubmitGetFundamentalsRequest(soap, (ns1__SubmitGetFundamentalsRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__GetCorrectionsRequest:
		soap_serialize_PointerTons1__GetCorrectionsRequest(soap, (ns1__GetCorrectionsRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__RetrieveCancelRequest:
		soap_serialize_PointerTons1__RetrieveCancelRequest(soap, (ns1__RetrieveCancelRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SubmitCancelRequest:
		soap_serialize_PointerTons1__SubmitCancelRequest(soap, (ns1__SubmitCancelRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__RetrieveScheduledRequest:
		soap_serialize_PointerTons1__RetrieveScheduledRequest(soap, (ns1__RetrieveScheduledRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SubmitScheduledRequest:
		soap_serialize_PointerTons1__SubmitScheduledRequest(soap, (ns1__SubmitScheduledRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__RetrieveGetHistoryRequest:
		soap_serialize_PointerTons1__RetrieveGetHistoryRequest(soap, (ns1__RetrieveGetHistoryRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SubmitGetHistoryRequest:
		soap_serialize_PointerTons1__SubmitGetHistoryRequest(soap, (ns1__SubmitGetHistoryRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__RetrieveGetDataRequest:
		soap_serialize_PointerTons1__RetrieveGetDataRequest(soap, (ns1__RetrieveGetDataRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SubmitGetDataRequest:
		soap_serialize_PointerTons1__SubmitGetDataRequest(soap, (ns1__SubmitGetDataRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__MmktBvalDealInfos:
		soap_serialize_PointerTons1__MmktBvalDealInfos(soap, (ns1__MmktBvalDealInfos *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__FieldInfos:
		soap_serialize_PointerTons1__FieldInfos(soap, (ns1__FieldInfos *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__OtcDealInfos:
		soap_serialize_PointerTons1__OtcDealInfos(soap, (ns1__OtcDealInfos *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AllQuotesInstrumentDatas:
		soap_serialize_PointerTons1__AllQuotesInstrumentDatas(soap, (ns1__AllQuotesInstrumentDatas *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__QuotesInstrumentDatas:
		soap_serialize_PointerTons1__QuotesInstrumentDatas(soap, (ns1__QuotesInstrumentDatas *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ActionsInstrumentDatas:
		soap_serialize_PointerTons1__ActionsInstrumentDatas(soap, (ns1__ActionsInstrumentDatas *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__GetPortfolioValidationHeaders:
		soap_serialize_PointerTons1__GetPortfolioValidationHeaders(soap, (ns1__GetPortfolioValidationHeaders *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__FundInstrumentDatas:
		soap_serialize_PointerTons1__FundInstrumentDatas(soap, (ns1__FundInstrumentDatas *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ScheduledResponses:
		soap_serialize_PointerTons1__ScheduledResponses(soap, (ns1__ScheduledResponses *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CorrectionRecords:
		soap_serialize_PointerTons1__CorrectionRecords(soap, (ns1__CorrectionRecords *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__GetCorrectionsHeaders:
		soap_serialize_PointerTons1__GetCorrectionsHeaders(soap, (ns1__GetCorrectionsHeaders *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CancelResponseStatus:
		soap_serialize_PointerTons1__CancelResponseStatus(soap, (ns1__CancelResponseStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__HistInstrumentDatas:
		soap_serialize_PointerTons1__HistInstrumentDatas(soap, (ns1__HistInstrumentDatas *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__InstrumentDatas:
		soap_serialize_PointerTons1__InstrumentDatas(soap, (ns1__InstrumentDatas *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__MmktBvalDealInformation:
		soap_serialize_PointerTons1__MmktBvalDealInformation(soap, (ns1__MmktBvalDealInformation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__MmktBvalHeaders:
		soap_serialize_PointerTons1__MmktBvalHeaders(soap, (ns1__MmktBvalHeaders *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__FieldSearchCriteria:
		soap_serialize_PointerTons1__FieldSearchCriteria(soap, (ns1__FieldSearchCriteria *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__OtcBvalHeaders:
		soap_serialize_PointerTons1__OtcBvalHeaders(soap, (ns1__OtcBvalHeaders *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__FundInstruments:
		soap_serialize_PointerTons1__FundInstruments(soap, (ns1__FundInstruments *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__time:
		soap_serialize_PointerToxsd__time(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__FieldSets:
		soap_serialize_PointerTons1__FieldSets(soap, (ns1__FieldSets *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ScheduledHeaders:
		soap_serialize_PointerTons1__ScheduledHeaders(soap, (ns1__ScheduledHeaders *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ScheduledResponse:
		soap_serialize_PointerTons1__ScheduledResponse(soap, (ns1__ScheduledResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CancelHeaders:
		soap_serialize_PointerTons1__CancelHeaders(soap, (ns1__CancelHeaders *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Instruments:
		soap_serialize_PointerTons1__Instruments(soap, (ns1__Instruments *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Fields:
		soap_serialize_PointerTons1__Fields(soap, (ns1__Fields *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__BvalFieldSets:
		soap_serialize_PointerTons1__BvalFieldSets(soap, (ns1__BvalFieldSets *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__OtcDealInformation:
		soap_serialize_PointerTons1__OtcDealInformation(soap, (ns1__OtcDealInformation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__OtcBvalAction:
		soap_serialize_PointerTons1__OtcBvalAction(soap, (enum ns1__OtcBvalAction *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ResponseStatus:
		soap_serialize_PointerTons1__ResponseStatus(soap, (ns1__ResponseStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DLCategory2:
		soap_serialize_PointerTons1__DLCategory2(soap, (enum ns1__DLCategory2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DLCategory:
		soap_serialize_PointerTons1__DLCategory(soap, (enum ns1__DLCategory *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__FieldInfo:
		soap_serialize_PointerTons1__FieldInfo(soap, (ns1__FieldInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__FieldType:
		soap_serialize_PointerTons1__FieldType(soap, (enum ns1__FieldType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__BulkArrayEntry:
		soap_serialize_PointerTons1__BulkArrayEntry(soap, (ns1__BulkArrayEntry *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__QRMQuoteData:
		soap_serialize_PointerTons1__QRMQuoteData(soap, (ns1__QRMQuoteData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTodateTime:
		soap_serialize_PointerTodateTime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__QRMQuote:
		soap_serialize_PointerTons1__QRMQuote(soap, (ns1__QRMQuote *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__QRQuote:
		soap_serialize_PointerTons1__QRQuote(soap, (ns1__QRQuote *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__BulkArray:
		soap_serialize_PointerTons1__BulkArray(soap, (ns1__BulkArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ActionStandardFields:
		soap_serialize_PointerTons1__ActionStandardFields(soap, (ns1__ActionStandardFields *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__QRMQuotes:
		soap_serialize_PointerTons1__QRMQuotes(soap, (ns1__QRMQuotes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__QRQuotes:
		soap_serialize_PointerTons1__QRQuotes(soap, (ns1__QRQuotes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__HistData:
		soap_serialize_PointerTons1__HistData(soap, (ns1__HistData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Data:
		soap_serialize_PointerTons1__Data(soap, (ns1__Data *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SecondaryQualifier:
		soap_serialize_PointerTons1__SecondaryQualifier(soap, (ns1__SecondaryQualifier *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PrimaryQualifier:
		soap_serialize_PointerTons1__PrimaryQualifier(soap, (ns1__PrimaryQualifier *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Overrides:
		soap_serialize_PointerTons1__Overrides(soap, (ns1__Overrides *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AllQuotesInstrumentData:
		soap_serialize_PointerTons1__AllQuotesInstrumentData(soap, (ns1__AllQuotesInstrumentData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__QuotesInstrumentData:
		soap_serialize_PointerTons1__QuotesInstrumentData(soap, (ns1__QuotesInstrumentData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CorrectionRecord:
		soap_serialize_PointerTons1__CorrectionRecord(soap, (ns1__CorrectionRecord *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ActionsInstrumentData:
		soap_serialize_PointerTons1__ActionsInstrumentData(soap, (ns1__ActionsInstrumentData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__FundInstrumentData:
		soap_serialize_PointerTons1__FundInstrumentData(soap, (ns1__FundInstrumentData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__HistInstrumentData:
		soap_serialize_PointerTons1__HistInstrumentData(soap, (ns1__HistInstrumentData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__InstrumentData:
		soap_serialize_PointerTons1__InstrumentData(soap, (ns1__InstrumentData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__FundInstrument:
		soap_serialize_PointerTons1__FundInstrument(soap, (ns1__FundInstrument *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Macro:
		soap_serialize_PointerTons1__Macro(soap, (ns1__Macro *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Instrument:
		soap_serialize_PointerTons1__Instrument(soap, (ns1__Instrument *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Override:
		soap_serialize_PointerTons1__Override(soap, (ns1__Override *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__QuotesHeaders:
		soap_serialize_PointerTons1__QuotesHeaders(soap, (ns1__QuotesHeaders *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__GetActionsHeaders:
		soap_serialize_PointerTons1__GetActionsHeaders(soap, (ns1__GetActionsHeaders *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__GetCompanyHeaders:
		soap_serialize_PointerTons1__GetCompanyHeaders(soap, (ns1__GetCompanyHeaders *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__GetFundamentalsHeaders:
		soap_serialize_PointerTons1__GetFundamentalsHeaders(soap, (ns1__GetFundamentalsHeaders *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__GetHistoryHeaders:
		soap_serialize_PointerTons1__GetHistoryHeaders(soap, (ns1__GetHistoryHeaders *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__GetDataHeaders:
		soap_serialize_PointerTons1__GetDataHeaders(soap, (ns1__GetDataHeaders *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__BvalFieldSet:
		soap_serialize_PointerTons1__BvalFieldSet(soap, (ns1__BvalFieldSet *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__date:
		soap_serialize_PointerToxsd__date(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__FieldSet:
		soap_serialize_PointerTons1__FieldSet(soap, (ns1__FieldSet *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TickOutputTz:
		soap_serialize_PointerTons1__TickOutputTz(soap, (ns1__TickOutputTz *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DateTimeRange:
		soap_serialize_PointerTons1__DateTimeRange(soap, (ns1__DateTimeRange *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ActionsDate:
		soap_serialize_PointerTons1__ActionsDate(soap, (enum ns1__ActionsDate *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Actions:
		soap_serialize_PointerTons1__Actions(soap, (ns1__Actions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Periodicity:
		soap_serialize_PointerTons1__Periodicity(soap, (enum ns1__Periodicity *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__FilingStatus:
		soap_serialize_PointerTons1__FilingStatus(soap, (enum ns1__FilingStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__HistOption:
		soap_serialize_PointerTons1__HistOption(soap, (enum ns1__HistOption *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__HistPeriod:
		soap_serialize_PointerTons1__HistPeriod(soap, (enum ns1__HistPeriod *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DateRange:
		soap_serialize_PointerTons1__DateRange(soap, (ns1__DateRange *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Duration:
		soap_serialize_PointerTons1__Duration(soap, (ns1__Duration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Period:
		soap_serialize_PointerTons1__Period(soap, (ns1__Period *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__RegSolvency:
		soap_serialize_PointerTons1__RegSolvency(soap, (enum ns1__RegSolvency *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PortSecDes:
		soap_serialize_PointerTons1__PortSecDes(soap, (enum ns1__PortSecDes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__BvalSnapshot:
		soap_serialize_PointerTons1__BvalSnapshot(soap, (enum ns1__BvalSnapshot *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__BvalTier:
		soap_serialize_PointerTons1__BvalTier(soap, (enum ns1__BvalTier *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__MarketSector:
		soap_serialize_PointerTons1__MarketSector(soap, (enum ns1__MarketSector *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Version:
		soap_serialize_PointerTons1__Version(soap, (enum ns1__Version *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SpecialChar:
		soap_serialize_PointerTons1__SpecialChar(soap, (enum ns1__SpecialChar *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__InstrumentType:
		soap_serialize_PointerTons1__InstrumentType(soap, (enum ns1__InstrumentType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ProgramFlag:
		soap_serialize_PointerTons1__ProgramFlag(soap, (enum ns1__ProgramFlag *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DiffFlag:
		soap_serialize_PointerTons1__DiffFlag(soap, (enum ns1__DiffFlag *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobool:
		soap_serialize_PointerTobool(soap, (bool *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DateFormat:
		soap_serialize_PointerTons1__DateFormat(soap, (enum ns1__DateFormat *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#ifdef __cplusplus
}
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_dupelement(struct soap *soap, const void *ptr, int type)
{(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	return NULL;
}
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_delelement(const void *ptr, int type)
{(void)ptr; (void)type; /* appease -Wall -Werror */
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CancelHeaders:
		return (void*)soap_instantiate_ns1__CancelHeaders(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetCorrectionsHeaders:
		return (void*)soap_instantiate_ns1__GetCorrectionsHeaders(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetDataHeaders:
		return (void*)soap_instantiate_ns1__GetDataHeaders(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Period:
		return (void*)soap_instantiate_ns1__Period(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Duration:
		return (void*)soap_instantiate_ns1__Duration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DateRange:
		return (void*)soap_instantiate_ns1__DateRange(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetHistoryHeaders:
		return (void*)soap_instantiate_ns1__GetHistoryHeaders(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetFundamentalsHeaders:
		return (void*)soap_instantiate_ns1__GetFundamentalsHeaders(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetCompanyHeaders:
		return (void*)soap_instantiate_ns1__GetCompanyHeaders(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetActionsHeaders:
		return (void*)soap_instantiate_ns1__GetActionsHeaders(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetPortfolioValidationHeaders:
		return (void*)soap_instantiate_ns1__GetPortfolioValidationHeaders(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__QuotesHeaders:
		return (void*)soap_instantiate_ns1__QuotesHeaders(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DateTimeRange:
		return (void*)soap_instantiate_ns1__DateTimeRange(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__TickOutputTz:
		return (void*)soap_instantiate_ns1__TickOutputTz(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__FieldSets:
		return (void*)soap_instantiate_ns1__FieldSets(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__FieldSet:
		return (void*)soap_instantiate_ns1__FieldSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__BvalFieldSets:
		return (void*)soap_instantiate_ns1__BvalFieldSets(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__BvalFieldSet:
		return (void*)soap_instantiate_ns1__BvalFieldSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ScheduledHeaders:
		return (void*)soap_instantiate_ns1__ScheduledHeaders(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Fields:
		return (void*)soap_instantiate_ns1__Fields(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Overrides:
		return (void*)soap_instantiate_ns1__Overrides(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Instruments:
		return (void*)soap_instantiate_ns1__Instruments(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__FundInstruments:
		return (void*)soap_instantiate_ns1__FundInstruments(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__InstrumentDatas:
		return (void*)soap_instantiate_ns1__InstrumentDatas(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__HistInstrumentDatas:
		return (void*)soap_instantiate_ns1__HistInstrumentDatas(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__FundInstrumentDatas:
		return (void*)soap_instantiate_ns1__FundInstrumentDatas(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ActionsInstrumentDatas:
		return (void*)soap_instantiate_ns1__ActionsInstrumentDatas(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CorrectionRecords:
		return (void*)soap_instantiate_ns1__CorrectionRecords(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__QuotesInstrumentDatas:
		return (void*)soap_instantiate_ns1__QuotesInstrumentDatas(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AllQuotesInstrumentDatas:
		return (void*)soap_instantiate_ns1__AllQuotesInstrumentDatas(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Instrument:
		return (void*)soap_instantiate_ns1__Instrument(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__FundInstrument:
		return (void*)soap_instantiate_ns1__FundInstrument(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Macro:
		return (void*)soap_instantiate_ns1__Macro(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__PrimaryQualifier:
		return (void*)soap_instantiate_ns1__PrimaryQualifier(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SecondaryQualifier:
		return (void*)soap_instantiate_ns1__SecondaryQualifier(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Override:
		return (void*)soap_instantiate_ns1__Override(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Actions:
		return (void*)soap_instantiate_ns1__Actions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DataItem:
		return (void*)soap_instantiate_ns1__DataItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__InstrumentData:
		return (void*)soap_instantiate_ns1__InstrumentData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__HistInstrumentData:
		return (void*)soap_instantiate_ns1__HistInstrumentData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__FundInstrumentData:
		return (void*)soap_instantiate_ns1__FundInstrumentData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__QuotesInstrumentData:
		return (void*)soap_instantiate_ns1__QuotesInstrumentData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AllQuotesInstrumentData:
		return (void*)soap_instantiate_ns1__AllQuotesInstrumentData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ActionsInstrumentData:
		return (void*)soap_instantiate_ns1__ActionsInstrumentData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CorrectionRecord:
		return (void*)soap_instantiate_ns1__CorrectionRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Data:
		return (void*)soap_instantiate_ns1__Data(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__QRQuotes:
		return (void*)soap_instantiate_ns1__QRQuotes(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__QRMQuotes:
		return (void*)soap_instantiate_ns1__QRMQuotes(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__QRQuote:
		return (void*)soap_instantiate_ns1__QRQuote(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__QRMQuoteData:
		return (void*)soap_instantiate_ns1__QRMQuoteData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__QRMQuote:
		return (void*)soap_instantiate_ns1__QRMQuote(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__HistData:
		return (void*)soap_instantiate_ns1__HistData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ActionStandardFields:
		return (void*)soap_instantiate_ns1__ActionStandardFields(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__BulkArray:
		return (void*)soap_instantiate_ns1__BulkArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__BulkArrayEntry:
		return (void*)soap_instantiate_ns1__BulkArrayEntry(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ResponseStatus:
		return (void*)soap_instantiate_ns1__ResponseStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CancelResponseStatus:
		return (void*)soap_instantiate_ns1__CancelResponseStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__FieldSearchCriteria:
		return (void*)soap_instantiate_ns1__FieldSearchCriteria(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__FieldInfos:
		return (void*)soap_instantiate_ns1__FieldInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__FieldInfo:
		return (void*)soap_instantiate_ns1__FieldInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__OtcBvalHeaders:
		return (void*)soap_instantiate_ns1__OtcBvalHeaders(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__OtcDealInformation:
		return (void*)soap_instantiate_ns1__OtcDealInformation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__OtcDealInfos:
		return (void*)soap_instantiate_ns1__OtcDealInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__PerSecurityResponse:
		return (void*)soap_instantiate_ns1__PerSecurityResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SubmitGetDataRequest:
		return (void*)soap_instantiate_ns1__SubmitGetDataRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RetrieveGetDataRequest:
		return (void*)soap_instantiate_ns1__RetrieveGetDataRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SubmitGetHistoryRequest:
		return (void*)soap_instantiate_ns1__SubmitGetHistoryRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RetrieveGetHistoryRequest:
		return (void*)soap_instantiate_ns1__RetrieveGetHistoryRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SubmitCancelRequest:
		return (void*)soap_instantiate_ns1__SubmitCancelRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RetrieveCancelRequest:
		return (void*)soap_instantiate_ns1__RetrieveCancelRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetCorrectionsRequest:
		return (void*)soap_instantiate_ns1__GetCorrectionsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SubmitScheduledRequest:
		return (void*)soap_instantiate_ns1__SubmitScheduledRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RetrieveScheduledRequest:
		return (void*)soap_instantiate_ns1__RetrieveScheduledRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ScheduledResponses:
		return (void*)soap_instantiate_ns1__ScheduledResponses(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ScheduledResponse:
		return (void*)soap_instantiate_ns1__ScheduledResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SubmitGetFundamentalsRequest:
		return (void*)soap_instantiate_ns1__SubmitGetFundamentalsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RetrieveGetFundamentalsRequest:
		return (void*)soap_instantiate_ns1__RetrieveGetFundamentalsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SubmitGetCompanyRequest:
		return (void*)soap_instantiate_ns1__SubmitGetCompanyRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RetrieveGetCompanyRequest:
		return (void*)soap_instantiate_ns1__RetrieveGetCompanyRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetPortfolioValidationRequest:
		return (void*)soap_instantiate_ns1__GetPortfolioValidationRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SubmitGetActionsRequest:
		return (void*)soap_instantiate_ns1__SubmitGetActionsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RetrieveGetActionsRequest:
		return (void*)soap_instantiate_ns1__RetrieveGetActionsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SubmitGetQuotesRequest:
		return (void*)soap_instantiate_ns1__SubmitGetQuotesRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RetrieveGetQuotesRequest:
		return (void*)soap_instantiate_ns1__RetrieveGetQuotesRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SubmitGetAllQuotesRequest:
		return (void*)soap_instantiate_ns1__SubmitGetAllQuotesRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RetrieveGetAllQuotesRequest:
		return (void*)soap_instantiate_ns1__RetrieveGetAllQuotesRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SubmitOtcbvalUploadRequest:
		return (void*)soap_instantiate_ns1__SubmitOtcbvalUploadRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RetrieveOtcbvalUploadRequest:
		return (void*)soap_instantiate_ns1__RetrieveOtcbvalUploadRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SubmitOtcBvalDealsUploadRequest:
		return (void*)soap_instantiate_ns1__SubmitOtcBvalDealsUploadRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RetrieveOtcBvalDealsUploadRequest:
		return (void*)soap_instantiate_ns1__RetrieveOtcBvalDealsUploadRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetFieldsRequest:
		return (void*)soap_instantiate_ns1__GetFieldsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__MmktBvalHeaders:
		return (void*)soap_instantiate_ns1__MmktBvalHeaders(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SubmitMmktBvalDealsUploadRequest:
		return (void*)soap_instantiate_ns1__SubmitMmktBvalDealsUploadRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RetrieveMmktBvalDealsUploadRequest:
		return (void*)soap_instantiate_ns1__RetrieveMmktBvalDealsUploadRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__MmktBvalDealInformation:
		return (void*)soap_instantiate_ns1__MmktBvalDealInformation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__MmktBvalDealInfos:
		return (void*)soap_instantiate_ns1__MmktBvalDealInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SubmitGetDataResponse:
		return (void*)soap_instantiate_ns1__SubmitGetDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RetrieveGetDataResponse:
		return (void*)soap_instantiate_ns1__RetrieveGetDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SubmitGetHistoryResponse:
		return (void*)soap_instantiate_ns1__SubmitGetHistoryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RetrieveGetHistoryResponse:
		return (void*)soap_instantiate_ns1__RetrieveGetHistoryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SubmitCancelResponse:
		return (void*)soap_instantiate_ns1__SubmitCancelResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RetrieveCancelResponse:
		return (void*)soap_instantiate_ns1__RetrieveCancelResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetCorrectionsResponse:
		return (void*)soap_instantiate_ns1__GetCorrectionsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SubmitScheduledResponse:
		return (void*)soap_instantiate_ns1__SubmitScheduledResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RetrieveScheduledResponse:
		return (void*)soap_instantiate_ns1__RetrieveScheduledResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SubmitGetFundamentalsResponse:
		return (void*)soap_instantiate_ns1__SubmitGetFundamentalsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RetrieveGetFundamentalsResponse:
		return (void*)soap_instantiate_ns1__RetrieveGetFundamentalsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SubmitGetCompanyResponse:
		return (void*)soap_instantiate_ns1__SubmitGetCompanyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RetrieveGetCompanyResponse:
		return (void*)soap_instantiate_ns1__RetrieveGetCompanyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetPortfolioValidationResponse:
		return (void*)soap_instantiate_ns1__GetPortfolioValidationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SubmitGetActionsResponse:
		return (void*)soap_instantiate_ns1__SubmitGetActionsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RetrieveGetActionsResponse:
		return (void*)soap_instantiate_ns1__RetrieveGetActionsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SubmitGetQuotesResponse:
		return (void*)soap_instantiate_ns1__SubmitGetQuotesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RetrieveGetQuotesResponse:
		return (void*)soap_instantiate_ns1__RetrieveGetQuotesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SubmitGetAllQuotesResponse:
		return (void*)soap_instantiate_ns1__SubmitGetAllQuotesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RetrieveGetAllQuotesResponse:
		return (void*)soap_instantiate_ns1__RetrieveGetAllQuotesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SubmitOtcbvalUploadResponse:
		return (void*)soap_instantiate_ns1__SubmitOtcbvalUploadResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RetrieveOtcbvalUploadResponse:
		return (void*)soap_instantiate_ns1__RetrieveOtcbvalUploadResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SubmitOtcBvalDealsUploadResponse:
		return (void*)soap_instantiate_ns1__SubmitOtcBvalDealsUploadResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RetrieveOtcBvalDealsUploadResponse:
		return (void*)soap_instantiate_ns1__RetrieveOtcBvalDealsUploadResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetFieldsResponse:
		return (void*)soap_instantiate_ns1__GetFieldsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SubmitMmktBvalDealsUploadResponse:
		return (void*)soap_instantiate_ns1__SubmitMmktBvalDealsUploadResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RetrieveMmktBvalDealsUploadResponse:
		return (void*)soap_instantiate_ns1__RetrieveMmktBvalDealsUploadResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__submitGetDataRequest:
		return (void*)soap_instantiate___ns1__submitGetDataRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__retrieveGetDataResponse:
		return (void*)soap_instantiate___ns1__retrieveGetDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__submitGetHistoryRequest:
		return (void*)soap_instantiate___ns1__submitGetHistoryRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__retrieveGetHistoryResponse:
		return (void*)soap_instantiate___ns1__retrieveGetHistoryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__submitScheduledRequest:
		return (void*)soap_instantiate___ns1__submitScheduledRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__retrieveScheduledResponse:
		return (void*)soap_instantiate___ns1__retrieveScheduledResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__submitCancelRequest:
		return (void*)soap_instantiate___ns1__submitCancelRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__retrieveCancelResponse:
		return (void*)soap_instantiate___ns1__retrieveCancelResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getCorrections:
		return (void*)soap_instantiate___ns1__getCorrections(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__submitGetFundamentalsRequest:
		return (void*)soap_instantiate___ns1__submitGetFundamentalsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__retrieveGetFundamentalsResponse:
		return (void*)soap_instantiate___ns1__retrieveGetFundamentalsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__submitGetCompanyRequest:
		return (void*)soap_instantiate___ns1__submitGetCompanyRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__retrieveGetCompanyResponse:
		return (void*)soap_instantiate___ns1__retrieveGetCompanyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__submitGetActionsRequest:
		return (void*)soap_instantiate___ns1__submitGetActionsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__retrieveGetActionsResponse:
		return (void*)soap_instantiate___ns1__retrieveGetActionsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getPortfolioValidation:
		return (void*)soap_instantiate___ns1__getPortfolioValidation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__submitGetQuotesRequest:
		return (void*)soap_instantiate___ns1__submitGetQuotesRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__retrieveGetQuotesResponse:
		return (void*)soap_instantiate___ns1__retrieveGetQuotesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__submitGetAllQuotesRequest:
		return (void*)soap_instantiate___ns1__submitGetAllQuotesRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__retrieveGetAllQuotesResponse:
		return (void*)soap_instantiate___ns1__retrieveGetAllQuotesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__submitOtcbvalUploadRequest:
		return (void*)soap_instantiate___ns1__submitOtcbvalUploadRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__retrieveOtcbvalUploadResponse:
		return (void*)soap_instantiate___ns1__retrieveOtcbvalUploadResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__submitOtcBvalDealsUploadRequest:
		return (void*)soap_instantiate___ns1__submitOtcBvalDealsUploadRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__retrieveOtcBvalDealsUploadResponse:
		return (void*)soap_instantiate___ns1__retrieveOtcBvalDealsUploadResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getFields:
		return (void*)soap_instantiate___ns1__getFields(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__submitMmktBvalDealsUploadRequest:
		return (void*)soap_instantiate___ns1__submitMmktBvalDealsUploadRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__retrieveMmktBvalDealsUploadResponse:
		return (void*)soap_instantiate___ns1__retrieveMmktBvalDealsUploadResponse(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_xsd__date:
		return (void*)soap_instantiate_xsd__date(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__time:
		return (void*)soap_instantiate_xsd__time(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__CancelResponseStatus:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__CancelResponseStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__MmktBvalDealInformation:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__MmktBvalDealInformation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ScheduledResponse:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__ScheduledResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__OtcDealInformation:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__OtcDealInformation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__FieldInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__FieldInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfns1__DLCategory2:
		return (void*)soap_instantiate_std__vectorTemplateOfns1__DLCategory2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfns1__MarketSector:
		return (void*)soap_instantiate_std__vectorTemplateOfns1__MarketSector(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfns1__DLCategory:
		return (void*)soap_instantiate_std__vectorTemplateOfns1__DLCategory(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__BulkArrayEntry:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__BulkArrayEntry(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__QRMQuoteData:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__QRMQuoteData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__QRMQuote:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__QRMQuote(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__QRQuote:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__QRQuote(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__BulkArray:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__BulkArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__HistData:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__HistData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Data:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__Data(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SecondaryQualifier:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__SecondaryQualifier(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__AllQuotesInstrumentData:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__AllQuotesInstrumentData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__QuotesInstrumentData:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__QuotesInstrumentData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__CorrectionRecord:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__CorrectionRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ActionsInstrumentData:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__ActionsInstrumentData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__FundInstrumentData:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__FundInstrumentData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__HistInstrumentData:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__HistInstrumentData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__InstrumentData:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__InstrumentData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__FundInstrument:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__FundInstrument(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Macro:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__Macro(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Instrument:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__Instrument(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Override:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__Override(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		return (void*)soap_instantiate_std__vectorTemplateOfstd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__BvalFieldSet:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__BvalFieldSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__FieldSet:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__FieldSet(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap *soap, struct soap_clist *p)
{
	(void)soap; /* appease -Wall -Werror */
	if (!p->ptr)
		return SOAP_OK;
	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__CancelHeaders:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__CancelHeaders*>(p->ptr), ns1__CancelHeaders);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__CancelHeaders*>(p->ptr), ns1__CancelHeaders);
		break;
	case SOAP_TYPE_ns1__GetCorrectionsHeaders:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__GetCorrectionsHeaders*>(p->ptr), ns1__GetCorrectionsHeaders);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__GetCorrectionsHeaders*>(p->ptr), ns1__GetCorrectionsHeaders);
		break;
	case SOAP_TYPE_ns1__GetDataHeaders:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__GetDataHeaders*>(p->ptr), ns1__GetDataHeaders);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__GetDataHeaders*>(p->ptr), ns1__GetDataHeaders);
		break;
	case SOAP_TYPE_ns1__Period:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__Period*>(p->ptr), ns1__Period);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__Period*>(p->ptr), ns1__Period);
		break;
	case SOAP_TYPE_ns1__Duration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__Duration*>(p->ptr), ns1__Duration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__Duration*>(p->ptr), ns1__Duration);
		break;
	case SOAP_TYPE_ns1__DateRange:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__DateRange*>(p->ptr), ns1__DateRange);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__DateRange*>(p->ptr), ns1__DateRange);
		break;
	case SOAP_TYPE_ns1__GetHistoryHeaders:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__GetHistoryHeaders*>(p->ptr), ns1__GetHistoryHeaders);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__GetHistoryHeaders*>(p->ptr), ns1__GetHistoryHeaders);
		break;
	case SOAP_TYPE_ns1__GetFundamentalsHeaders:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__GetFundamentalsHeaders*>(p->ptr), ns1__GetFundamentalsHeaders);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__GetFundamentalsHeaders*>(p->ptr), ns1__GetFundamentalsHeaders);
		break;
	case SOAP_TYPE_ns1__GetCompanyHeaders:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__GetCompanyHeaders*>(p->ptr), ns1__GetCompanyHeaders);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__GetCompanyHeaders*>(p->ptr), ns1__GetCompanyHeaders);
		break;
	case SOAP_TYPE_ns1__GetActionsHeaders:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__GetActionsHeaders*>(p->ptr), ns1__GetActionsHeaders);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__GetActionsHeaders*>(p->ptr), ns1__GetActionsHeaders);
		break;
	case SOAP_TYPE_ns1__GetPortfolioValidationHeaders:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__GetPortfolioValidationHeaders*>(p->ptr), ns1__GetPortfolioValidationHeaders);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__GetPortfolioValidationHeaders*>(p->ptr), ns1__GetPortfolioValidationHeaders);
		break;
	case SOAP_TYPE_ns1__QuotesHeaders:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__QuotesHeaders*>(p->ptr), ns1__QuotesHeaders);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__QuotesHeaders*>(p->ptr), ns1__QuotesHeaders);
		break;
	case SOAP_TYPE_ns1__DateTimeRange:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__DateTimeRange*>(p->ptr), ns1__DateTimeRange);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__DateTimeRange*>(p->ptr), ns1__DateTimeRange);
		break;
	case SOAP_TYPE_ns1__TickOutputTz:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__TickOutputTz*>(p->ptr), ns1__TickOutputTz);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__TickOutputTz*>(p->ptr), ns1__TickOutputTz);
		break;
	case SOAP_TYPE_ns1__FieldSets:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__FieldSets*>(p->ptr), ns1__FieldSets);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__FieldSets*>(p->ptr), ns1__FieldSets);
		break;
	case SOAP_TYPE_ns1__FieldSet:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__FieldSet*>(p->ptr), ns1__FieldSet);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__FieldSet*>(p->ptr), ns1__FieldSet);
		break;
	case SOAP_TYPE_ns1__BvalFieldSets:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__BvalFieldSets*>(p->ptr), ns1__BvalFieldSets);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__BvalFieldSets*>(p->ptr), ns1__BvalFieldSets);
		break;
	case SOAP_TYPE_ns1__BvalFieldSet:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__BvalFieldSet*>(p->ptr), ns1__BvalFieldSet);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__BvalFieldSet*>(p->ptr), ns1__BvalFieldSet);
		break;
	case SOAP_TYPE_ns1__ScheduledHeaders:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ScheduledHeaders*>(p->ptr), ns1__ScheduledHeaders);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ScheduledHeaders*>(p->ptr), ns1__ScheduledHeaders);
		break;
	case SOAP_TYPE_ns1__Fields:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__Fields*>(p->ptr), ns1__Fields);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__Fields*>(p->ptr), ns1__Fields);
		break;
	case SOAP_TYPE_ns1__Overrides:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__Overrides*>(p->ptr), ns1__Overrides);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__Overrides*>(p->ptr), ns1__Overrides);
		break;
	case SOAP_TYPE_ns1__Instruments:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__Instruments*>(p->ptr), ns1__Instruments);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__Instruments*>(p->ptr), ns1__Instruments);
		break;
	case SOAP_TYPE_ns1__FundInstruments:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__FundInstruments*>(p->ptr), ns1__FundInstruments);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__FundInstruments*>(p->ptr), ns1__FundInstruments);
		break;
	case SOAP_TYPE_ns1__InstrumentDatas:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__InstrumentDatas*>(p->ptr), ns1__InstrumentDatas);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__InstrumentDatas*>(p->ptr), ns1__InstrumentDatas);
		break;
	case SOAP_TYPE_ns1__HistInstrumentDatas:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__HistInstrumentDatas*>(p->ptr), ns1__HistInstrumentDatas);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__HistInstrumentDatas*>(p->ptr), ns1__HistInstrumentDatas);
		break;
	case SOAP_TYPE_ns1__FundInstrumentDatas:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__FundInstrumentDatas*>(p->ptr), ns1__FundInstrumentDatas);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__FundInstrumentDatas*>(p->ptr), ns1__FundInstrumentDatas);
		break;
	case SOAP_TYPE_ns1__ActionsInstrumentDatas:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ActionsInstrumentDatas*>(p->ptr), ns1__ActionsInstrumentDatas);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ActionsInstrumentDatas*>(p->ptr), ns1__ActionsInstrumentDatas);
		break;
	case SOAP_TYPE_ns1__CorrectionRecords:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__CorrectionRecords*>(p->ptr), ns1__CorrectionRecords);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__CorrectionRecords*>(p->ptr), ns1__CorrectionRecords);
		break;
	case SOAP_TYPE_ns1__QuotesInstrumentDatas:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__QuotesInstrumentDatas*>(p->ptr), ns1__QuotesInstrumentDatas);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__QuotesInstrumentDatas*>(p->ptr), ns1__QuotesInstrumentDatas);
		break;
	case SOAP_TYPE_ns1__AllQuotesInstrumentDatas:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__AllQuotesInstrumentDatas*>(p->ptr), ns1__AllQuotesInstrumentDatas);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__AllQuotesInstrumentDatas*>(p->ptr), ns1__AllQuotesInstrumentDatas);
		break;
	case SOAP_TYPE_ns1__Instrument:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__Instrument*>(p->ptr), ns1__Instrument);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__Instrument*>(p->ptr), ns1__Instrument);
		break;
	case SOAP_TYPE_ns1__FundInstrument:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__FundInstrument*>(p->ptr), ns1__FundInstrument);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__FundInstrument*>(p->ptr), ns1__FundInstrument);
		break;
	case SOAP_TYPE_ns1__Macro:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__Macro*>(p->ptr), ns1__Macro);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__Macro*>(p->ptr), ns1__Macro);
		break;
	case SOAP_TYPE_ns1__PrimaryQualifier:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__PrimaryQualifier*>(p->ptr), ns1__PrimaryQualifier);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__PrimaryQualifier*>(p->ptr), ns1__PrimaryQualifier);
		break;
	case SOAP_TYPE_ns1__SecondaryQualifier:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__SecondaryQualifier*>(p->ptr), ns1__SecondaryQualifier);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__SecondaryQualifier*>(p->ptr), ns1__SecondaryQualifier);
		break;
	case SOAP_TYPE_ns1__Override:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__Override*>(p->ptr), ns1__Override);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__Override*>(p->ptr), ns1__Override);
		break;
	case SOAP_TYPE_ns1__Actions:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__Actions*>(p->ptr), ns1__Actions);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__Actions*>(p->ptr), ns1__Actions);
		break;
	case SOAP_TYPE_ns1__DataItem:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__DataItem*>(p->ptr), ns1__DataItem);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__DataItem*>(p->ptr), ns1__DataItem);
		break;
	case SOAP_TYPE_ns1__InstrumentData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__InstrumentData*>(p->ptr), ns1__InstrumentData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__InstrumentData*>(p->ptr), ns1__InstrumentData);
		break;
	case SOAP_TYPE_ns1__HistInstrumentData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__HistInstrumentData*>(p->ptr), ns1__HistInstrumentData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__HistInstrumentData*>(p->ptr), ns1__HistInstrumentData);
		break;
	case SOAP_TYPE_ns1__FundInstrumentData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__FundInstrumentData*>(p->ptr), ns1__FundInstrumentData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__FundInstrumentData*>(p->ptr), ns1__FundInstrumentData);
		break;
	case SOAP_TYPE_ns1__QuotesInstrumentData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__QuotesInstrumentData*>(p->ptr), ns1__QuotesInstrumentData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__QuotesInstrumentData*>(p->ptr), ns1__QuotesInstrumentData);
		break;
	case SOAP_TYPE_ns1__AllQuotesInstrumentData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__AllQuotesInstrumentData*>(p->ptr), ns1__AllQuotesInstrumentData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__AllQuotesInstrumentData*>(p->ptr), ns1__AllQuotesInstrumentData);
		break;
	case SOAP_TYPE_ns1__ActionsInstrumentData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ActionsInstrumentData*>(p->ptr), ns1__ActionsInstrumentData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ActionsInstrumentData*>(p->ptr), ns1__ActionsInstrumentData);
		break;
	case SOAP_TYPE_ns1__CorrectionRecord:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__CorrectionRecord*>(p->ptr), ns1__CorrectionRecord);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__CorrectionRecord*>(p->ptr), ns1__CorrectionRecord);
		break;
	case SOAP_TYPE_ns1__Data:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__Data*>(p->ptr), ns1__Data);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__Data*>(p->ptr), ns1__Data);
		break;
	case SOAP_TYPE_ns1__QRQuotes:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__QRQuotes*>(p->ptr), ns1__QRQuotes);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__QRQuotes*>(p->ptr), ns1__QRQuotes);
		break;
	case SOAP_TYPE_ns1__QRMQuotes:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__QRMQuotes*>(p->ptr), ns1__QRMQuotes);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__QRMQuotes*>(p->ptr), ns1__QRMQuotes);
		break;
	case SOAP_TYPE_ns1__QRQuote:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__QRQuote*>(p->ptr), ns1__QRQuote);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__QRQuote*>(p->ptr), ns1__QRQuote);
		break;
	case SOAP_TYPE_ns1__QRMQuoteData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__QRMQuoteData*>(p->ptr), ns1__QRMQuoteData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__QRMQuoteData*>(p->ptr), ns1__QRMQuoteData);
		break;
	case SOAP_TYPE_ns1__QRMQuote:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__QRMQuote*>(p->ptr), ns1__QRMQuote);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__QRMQuote*>(p->ptr), ns1__QRMQuote);
		break;
	case SOAP_TYPE_ns1__HistData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__HistData*>(p->ptr), ns1__HistData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__HistData*>(p->ptr), ns1__HistData);
		break;
	case SOAP_TYPE_ns1__ActionStandardFields:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ActionStandardFields*>(p->ptr), ns1__ActionStandardFields);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ActionStandardFields*>(p->ptr), ns1__ActionStandardFields);
		break;
	case SOAP_TYPE_ns1__BulkArray:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__BulkArray*>(p->ptr), ns1__BulkArray);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__BulkArray*>(p->ptr), ns1__BulkArray);
		break;
	case SOAP_TYPE_ns1__BulkArrayEntry:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__BulkArrayEntry*>(p->ptr), ns1__BulkArrayEntry);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__BulkArrayEntry*>(p->ptr), ns1__BulkArrayEntry);
		break;
	case SOAP_TYPE_ns1__ResponseStatus:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ResponseStatus*>(p->ptr), ns1__ResponseStatus);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ResponseStatus*>(p->ptr), ns1__ResponseStatus);
		break;
	case SOAP_TYPE_ns1__CancelResponseStatus:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__CancelResponseStatus*>(p->ptr), ns1__CancelResponseStatus);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__CancelResponseStatus*>(p->ptr), ns1__CancelResponseStatus);
		break;
	case SOAP_TYPE_ns1__FieldSearchCriteria:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__FieldSearchCriteria*>(p->ptr), ns1__FieldSearchCriteria);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__FieldSearchCriteria*>(p->ptr), ns1__FieldSearchCriteria);
		break;
	case SOAP_TYPE_ns1__FieldInfos:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__FieldInfos*>(p->ptr), ns1__FieldInfos);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__FieldInfos*>(p->ptr), ns1__FieldInfos);
		break;
	case SOAP_TYPE_ns1__FieldInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__FieldInfo*>(p->ptr), ns1__FieldInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__FieldInfo*>(p->ptr), ns1__FieldInfo);
		break;
	case SOAP_TYPE_ns1__OtcBvalHeaders:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__OtcBvalHeaders*>(p->ptr), ns1__OtcBvalHeaders);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__OtcBvalHeaders*>(p->ptr), ns1__OtcBvalHeaders);
		break;
	case SOAP_TYPE_ns1__OtcDealInformation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__OtcDealInformation*>(p->ptr), ns1__OtcDealInformation);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__OtcDealInformation*>(p->ptr), ns1__OtcDealInformation);
		break;
	case SOAP_TYPE_ns1__OtcDealInfos:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__OtcDealInfos*>(p->ptr), ns1__OtcDealInfos);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__OtcDealInfos*>(p->ptr), ns1__OtcDealInfos);
		break;
	case SOAP_TYPE_ns1__PerSecurityResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__PerSecurityResponse*>(p->ptr), ns1__PerSecurityResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__PerSecurityResponse*>(p->ptr), ns1__PerSecurityResponse);
		break;
	case SOAP_TYPE_ns1__SubmitGetDataRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__SubmitGetDataRequest*>(p->ptr), ns1__SubmitGetDataRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__SubmitGetDataRequest*>(p->ptr), ns1__SubmitGetDataRequest);
		break;
	case SOAP_TYPE_ns1__RetrieveGetDataRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__RetrieveGetDataRequest*>(p->ptr), ns1__RetrieveGetDataRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__RetrieveGetDataRequest*>(p->ptr), ns1__RetrieveGetDataRequest);
		break;
	case SOAP_TYPE_ns1__SubmitGetHistoryRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__SubmitGetHistoryRequest*>(p->ptr), ns1__SubmitGetHistoryRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__SubmitGetHistoryRequest*>(p->ptr), ns1__SubmitGetHistoryRequest);
		break;
	case SOAP_TYPE_ns1__RetrieveGetHistoryRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__RetrieveGetHistoryRequest*>(p->ptr), ns1__RetrieveGetHistoryRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__RetrieveGetHistoryRequest*>(p->ptr), ns1__RetrieveGetHistoryRequest);
		break;
	case SOAP_TYPE_ns1__SubmitCancelRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__SubmitCancelRequest*>(p->ptr), ns1__SubmitCancelRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__SubmitCancelRequest*>(p->ptr), ns1__SubmitCancelRequest);
		break;
	case SOAP_TYPE_ns1__RetrieveCancelRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__RetrieveCancelRequest*>(p->ptr), ns1__RetrieveCancelRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__RetrieveCancelRequest*>(p->ptr), ns1__RetrieveCancelRequest);
		break;
	case SOAP_TYPE_ns1__GetCorrectionsRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__GetCorrectionsRequest*>(p->ptr), ns1__GetCorrectionsRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__GetCorrectionsRequest*>(p->ptr), ns1__GetCorrectionsRequest);
		break;
	case SOAP_TYPE_ns1__SubmitScheduledRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__SubmitScheduledRequest*>(p->ptr), ns1__SubmitScheduledRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__SubmitScheduledRequest*>(p->ptr), ns1__SubmitScheduledRequest);
		break;
	case SOAP_TYPE_ns1__RetrieveScheduledRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__RetrieveScheduledRequest*>(p->ptr), ns1__RetrieveScheduledRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__RetrieveScheduledRequest*>(p->ptr), ns1__RetrieveScheduledRequest);
		break;
	case SOAP_TYPE_ns1__ScheduledResponses:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ScheduledResponses*>(p->ptr), ns1__ScheduledResponses);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ScheduledResponses*>(p->ptr), ns1__ScheduledResponses);
		break;
	case SOAP_TYPE_ns1__ScheduledResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ScheduledResponse*>(p->ptr), ns1__ScheduledResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ScheduledResponse*>(p->ptr), ns1__ScheduledResponse);
		break;
	case SOAP_TYPE_ns1__SubmitGetFundamentalsRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__SubmitGetFundamentalsRequest*>(p->ptr), ns1__SubmitGetFundamentalsRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__SubmitGetFundamentalsRequest*>(p->ptr), ns1__SubmitGetFundamentalsRequest);
		break;
	case SOAP_TYPE_ns1__RetrieveGetFundamentalsRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__RetrieveGetFundamentalsRequest*>(p->ptr), ns1__RetrieveGetFundamentalsRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__RetrieveGetFundamentalsRequest*>(p->ptr), ns1__RetrieveGetFundamentalsRequest);
		break;
	case SOAP_TYPE_ns1__SubmitGetCompanyRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__SubmitGetCompanyRequest*>(p->ptr), ns1__SubmitGetCompanyRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__SubmitGetCompanyRequest*>(p->ptr), ns1__SubmitGetCompanyRequest);
		break;
	case SOAP_TYPE_ns1__RetrieveGetCompanyRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__RetrieveGetCompanyRequest*>(p->ptr), ns1__RetrieveGetCompanyRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__RetrieveGetCompanyRequest*>(p->ptr), ns1__RetrieveGetCompanyRequest);
		break;
	case SOAP_TYPE_ns1__GetPortfolioValidationRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__GetPortfolioValidationRequest*>(p->ptr), ns1__GetPortfolioValidationRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__GetPortfolioValidationRequest*>(p->ptr), ns1__GetPortfolioValidationRequest);
		break;
	case SOAP_TYPE_ns1__SubmitGetActionsRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__SubmitGetActionsRequest*>(p->ptr), ns1__SubmitGetActionsRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__SubmitGetActionsRequest*>(p->ptr), ns1__SubmitGetActionsRequest);
		break;
	case SOAP_TYPE_ns1__RetrieveGetActionsRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__RetrieveGetActionsRequest*>(p->ptr), ns1__RetrieveGetActionsRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__RetrieveGetActionsRequest*>(p->ptr), ns1__RetrieveGetActionsRequest);
		break;
	case SOAP_TYPE_ns1__SubmitGetQuotesRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__SubmitGetQuotesRequest*>(p->ptr), ns1__SubmitGetQuotesRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__SubmitGetQuotesRequest*>(p->ptr), ns1__SubmitGetQuotesRequest);
		break;
	case SOAP_TYPE_ns1__RetrieveGetQuotesRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__RetrieveGetQuotesRequest*>(p->ptr), ns1__RetrieveGetQuotesRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__RetrieveGetQuotesRequest*>(p->ptr), ns1__RetrieveGetQuotesRequest);
		break;
	case SOAP_TYPE_ns1__SubmitGetAllQuotesRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__SubmitGetAllQuotesRequest*>(p->ptr), ns1__SubmitGetAllQuotesRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__SubmitGetAllQuotesRequest*>(p->ptr), ns1__SubmitGetAllQuotesRequest);
		break;
	case SOAP_TYPE_ns1__RetrieveGetAllQuotesRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__RetrieveGetAllQuotesRequest*>(p->ptr), ns1__RetrieveGetAllQuotesRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__RetrieveGetAllQuotesRequest*>(p->ptr), ns1__RetrieveGetAllQuotesRequest);
		break;
	case SOAP_TYPE_ns1__SubmitOtcbvalUploadRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__SubmitOtcbvalUploadRequest*>(p->ptr), ns1__SubmitOtcbvalUploadRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__SubmitOtcbvalUploadRequest*>(p->ptr), ns1__SubmitOtcbvalUploadRequest);
		break;
	case SOAP_TYPE_ns1__RetrieveOtcbvalUploadRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__RetrieveOtcbvalUploadRequest*>(p->ptr), ns1__RetrieveOtcbvalUploadRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__RetrieveOtcbvalUploadRequest*>(p->ptr), ns1__RetrieveOtcbvalUploadRequest);
		break;
	case SOAP_TYPE_ns1__SubmitOtcBvalDealsUploadRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__SubmitOtcBvalDealsUploadRequest*>(p->ptr), ns1__SubmitOtcBvalDealsUploadRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__SubmitOtcBvalDealsUploadRequest*>(p->ptr), ns1__SubmitOtcBvalDealsUploadRequest);
		break;
	case SOAP_TYPE_ns1__RetrieveOtcBvalDealsUploadRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__RetrieveOtcBvalDealsUploadRequest*>(p->ptr), ns1__RetrieveOtcBvalDealsUploadRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__RetrieveOtcBvalDealsUploadRequest*>(p->ptr), ns1__RetrieveOtcBvalDealsUploadRequest);
		break;
	case SOAP_TYPE_ns1__GetFieldsRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__GetFieldsRequest*>(p->ptr), ns1__GetFieldsRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__GetFieldsRequest*>(p->ptr), ns1__GetFieldsRequest);
		break;
	case SOAP_TYPE_ns1__MmktBvalHeaders:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__MmktBvalHeaders*>(p->ptr), ns1__MmktBvalHeaders);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__MmktBvalHeaders*>(p->ptr), ns1__MmktBvalHeaders);
		break;
	case SOAP_TYPE_ns1__SubmitMmktBvalDealsUploadRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__SubmitMmktBvalDealsUploadRequest*>(p->ptr), ns1__SubmitMmktBvalDealsUploadRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__SubmitMmktBvalDealsUploadRequest*>(p->ptr), ns1__SubmitMmktBvalDealsUploadRequest);
		break;
	case SOAP_TYPE_ns1__RetrieveMmktBvalDealsUploadRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__RetrieveMmktBvalDealsUploadRequest*>(p->ptr), ns1__RetrieveMmktBvalDealsUploadRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__RetrieveMmktBvalDealsUploadRequest*>(p->ptr), ns1__RetrieveMmktBvalDealsUploadRequest);
		break;
	case SOAP_TYPE_ns1__MmktBvalDealInformation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__MmktBvalDealInformation*>(p->ptr), ns1__MmktBvalDealInformation);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__MmktBvalDealInformation*>(p->ptr), ns1__MmktBvalDealInformation);
		break;
	case SOAP_TYPE_ns1__MmktBvalDealInfos:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__MmktBvalDealInfos*>(p->ptr), ns1__MmktBvalDealInfos);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__MmktBvalDealInfos*>(p->ptr), ns1__MmktBvalDealInfos);
		break;
	case SOAP_TYPE_ns1__SubmitGetDataResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__SubmitGetDataResponse*>(p->ptr), ns1__SubmitGetDataResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__SubmitGetDataResponse*>(p->ptr), ns1__SubmitGetDataResponse);
		break;
	case SOAP_TYPE_ns1__RetrieveGetDataResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__RetrieveGetDataResponse*>(p->ptr), ns1__RetrieveGetDataResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__RetrieveGetDataResponse*>(p->ptr), ns1__RetrieveGetDataResponse);
		break;
	case SOAP_TYPE_ns1__SubmitGetHistoryResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__SubmitGetHistoryResponse*>(p->ptr), ns1__SubmitGetHistoryResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__SubmitGetHistoryResponse*>(p->ptr), ns1__SubmitGetHistoryResponse);
		break;
	case SOAP_TYPE_ns1__RetrieveGetHistoryResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__RetrieveGetHistoryResponse*>(p->ptr), ns1__RetrieveGetHistoryResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__RetrieveGetHistoryResponse*>(p->ptr), ns1__RetrieveGetHistoryResponse);
		break;
	case SOAP_TYPE_ns1__SubmitCancelResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__SubmitCancelResponse*>(p->ptr), ns1__SubmitCancelResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__SubmitCancelResponse*>(p->ptr), ns1__SubmitCancelResponse);
		break;
	case SOAP_TYPE_ns1__RetrieveCancelResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__RetrieveCancelResponse*>(p->ptr), ns1__RetrieveCancelResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__RetrieveCancelResponse*>(p->ptr), ns1__RetrieveCancelResponse);
		break;
	case SOAP_TYPE_ns1__GetCorrectionsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__GetCorrectionsResponse*>(p->ptr), ns1__GetCorrectionsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__GetCorrectionsResponse*>(p->ptr), ns1__GetCorrectionsResponse);
		break;
	case SOAP_TYPE_ns1__SubmitScheduledResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__SubmitScheduledResponse*>(p->ptr), ns1__SubmitScheduledResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__SubmitScheduledResponse*>(p->ptr), ns1__SubmitScheduledResponse);
		break;
	case SOAP_TYPE_ns1__RetrieveScheduledResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__RetrieveScheduledResponse*>(p->ptr), ns1__RetrieveScheduledResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__RetrieveScheduledResponse*>(p->ptr), ns1__RetrieveScheduledResponse);
		break;
	case SOAP_TYPE_ns1__SubmitGetFundamentalsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__SubmitGetFundamentalsResponse*>(p->ptr), ns1__SubmitGetFundamentalsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__SubmitGetFundamentalsResponse*>(p->ptr), ns1__SubmitGetFundamentalsResponse);
		break;
	case SOAP_TYPE_ns1__RetrieveGetFundamentalsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__RetrieveGetFundamentalsResponse*>(p->ptr), ns1__RetrieveGetFundamentalsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__RetrieveGetFundamentalsResponse*>(p->ptr), ns1__RetrieveGetFundamentalsResponse);
		break;
	case SOAP_TYPE_ns1__SubmitGetCompanyResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__SubmitGetCompanyResponse*>(p->ptr), ns1__SubmitGetCompanyResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__SubmitGetCompanyResponse*>(p->ptr), ns1__SubmitGetCompanyResponse);
		break;
	case SOAP_TYPE_ns1__RetrieveGetCompanyResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__RetrieveGetCompanyResponse*>(p->ptr), ns1__RetrieveGetCompanyResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__RetrieveGetCompanyResponse*>(p->ptr), ns1__RetrieveGetCompanyResponse);
		break;
	case SOAP_TYPE_ns1__GetPortfolioValidationResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__GetPortfolioValidationResponse*>(p->ptr), ns1__GetPortfolioValidationResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__GetPortfolioValidationResponse*>(p->ptr), ns1__GetPortfolioValidationResponse);
		break;
	case SOAP_TYPE_ns1__SubmitGetActionsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__SubmitGetActionsResponse*>(p->ptr), ns1__SubmitGetActionsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__SubmitGetActionsResponse*>(p->ptr), ns1__SubmitGetActionsResponse);
		break;
	case SOAP_TYPE_ns1__RetrieveGetActionsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__RetrieveGetActionsResponse*>(p->ptr), ns1__RetrieveGetActionsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__RetrieveGetActionsResponse*>(p->ptr), ns1__RetrieveGetActionsResponse);
		break;
	case SOAP_TYPE_ns1__SubmitGetQuotesResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__SubmitGetQuotesResponse*>(p->ptr), ns1__SubmitGetQuotesResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__SubmitGetQuotesResponse*>(p->ptr), ns1__SubmitGetQuotesResponse);
		break;
	case SOAP_TYPE_ns1__RetrieveGetQuotesResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__RetrieveGetQuotesResponse*>(p->ptr), ns1__RetrieveGetQuotesResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__RetrieveGetQuotesResponse*>(p->ptr), ns1__RetrieveGetQuotesResponse);
		break;
	case SOAP_TYPE_ns1__SubmitGetAllQuotesResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__SubmitGetAllQuotesResponse*>(p->ptr), ns1__SubmitGetAllQuotesResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__SubmitGetAllQuotesResponse*>(p->ptr), ns1__SubmitGetAllQuotesResponse);
		break;
	case SOAP_TYPE_ns1__RetrieveGetAllQuotesResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__RetrieveGetAllQuotesResponse*>(p->ptr), ns1__RetrieveGetAllQuotesResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__RetrieveGetAllQuotesResponse*>(p->ptr), ns1__RetrieveGetAllQuotesResponse);
		break;
	case SOAP_TYPE_ns1__SubmitOtcbvalUploadResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__SubmitOtcbvalUploadResponse*>(p->ptr), ns1__SubmitOtcbvalUploadResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__SubmitOtcbvalUploadResponse*>(p->ptr), ns1__SubmitOtcbvalUploadResponse);
		break;
	case SOAP_TYPE_ns1__RetrieveOtcbvalUploadResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__RetrieveOtcbvalUploadResponse*>(p->ptr), ns1__RetrieveOtcbvalUploadResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__RetrieveOtcbvalUploadResponse*>(p->ptr), ns1__RetrieveOtcbvalUploadResponse);
		break;
	case SOAP_TYPE_ns1__SubmitOtcBvalDealsUploadResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__SubmitOtcBvalDealsUploadResponse*>(p->ptr), ns1__SubmitOtcBvalDealsUploadResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__SubmitOtcBvalDealsUploadResponse*>(p->ptr), ns1__SubmitOtcBvalDealsUploadResponse);
		break;
	case SOAP_TYPE_ns1__RetrieveOtcBvalDealsUploadResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__RetrieveOtcBvalDealsUploadResponse*>(p->ptr), ns1__RetrieveOtcBvalDealsUploadResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__RetrieveOtcBvalDealsUploadResponse*>(p->ptr), ns1__RetrieveOtcBvalDealsUploadResponse);
		break;
	case SOAP_TYPE_ns1__GetFieldsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__GetFieldsResponse*>(p->ptr), ns1__GetFieldsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__GetFieldsResponse*>(p->ptr), ns1__GetFieldsResponse);
		break;
	case SOAP_TYPE_ns1__SubmitMmktBvalDealsUploadResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__SubmitMmktBvalDealsUploadResponse*>(p->ptr), ns1__SubmitMmktBvalDealsUploadResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__SubmitMmktBvalDealsUploadResponse*>(p->ptr), ns1__SubmitMmktBvalDealsUploadResponse);
		break;
	case SOAP_TYPE_ns1__RetrieveMmktBvalDealsUploadResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__RetrieveMmktBvalDealsUploadResponse*>(p->ptr), ns1__RetrieveMmktBvalDealsUploadResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__RetrieveMmktBvalDealsUploadResponse*>(p->ptr), ns1__RetrieveMmktBvalDealsUploadResponse);
		break;
	case SOAP_TYPE___ns1__submitGetDataRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__submitGetDataRequest*>(p->ptr), struct __ns1__submitGetDataRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__submitGetDataRequest*>(p->ptr), struct __ns1__submitGetDataRequest);
		break;
	case SOAP_TYPE___ns1__retrieveGetDataResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__retrieveGetDataResponse*>(p->ptr), struct __ns1__retrieveGetDataResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__retrieveGetDataResponse*>(p->ptr), struct __ns1__retrieveGetDataResponse);
		break;
	case SOAP_TYPE___ns1__submitGetHistoryRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__submitGetHistoryRequest*>(p->ptr), struct __ns1__submitGetHistoryRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__submitGetHistoryRequest*>(p->ptr), struct __ns1__submitGetHistoryRequest);
		break;
	case SOAP_TYPE___ns1__retrieveGetHistoryResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__retrieveGetHistoryResponse*>(p->ptr), struct __ns1__retrieveGetHistoryResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__retrieveGetHistoryResponse*>(p->ptr), struct __ns1__retrieveGetHistoryResponse);
		break;
	case SOAP_TYPE___ns1__submitScheduledRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__submitScheduledRequest*>(p->ptr), struct __ns1__submitScheduledRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__submitScheduledRequest*>(p->ptr), struct __ns1__submitScheduledRequest);
		break;
	case SOAP_TYPE___ns1__retrieveScheduledResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__retrieveScheduledResponse*>(p->ptr), struct __ns1__retrieveScheduledResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__retrieveScheduledResponse*>(p->ptr), struct __ns1__retrieveScheduledResponse);
		break;
	case SOAP_TYPE___ns1__submitCancelRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__submitCancelRequest*>(p->ptr), struct __ns1__submitCancelRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__submitCancelRequest*>(p->ptr), struct __ns1__submitCancelRequest);
		break;
	case SOAP_TYPE___ns1__retrieveCancelResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__retrieveCancelResponse*>(p->ptr), struct __ns1__retrieveCancelResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__retrieveCancelResponse*>(p->ptr), struct __ns1__retrieveCancelResponse);
		break;
	case SOAP_TYPE___ns1__getCorrections:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__getCorrections*>(p->ptr), struct __ns1__getCorrections);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__getCorrections*>(p->ptr), struct __ns1__getCorrections);
		break;
	case SOAP_TYPE___ns1__submitGetFundamentalsRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__submitGetFundamentalsRequest*>(p->ptr), struct __ns1__submitGetFundamentalsRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__submitGetFundamentalsRequest*>(p->ptr), struct __ns1__submitGetFundamentalsRequest);
		break;
	case SOAP_TYPE___ns1__retrieveGetFundamentalsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__retrieveGetFundamentalsResponse*>(p->ptr), struct __ns1__retrieveGetFundamentalsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__retrieveGetFundamentalsResponse*>(p->ptr), struct __ns1__retrieveGetFundamentalsResponse);
		break;
	case SOAP_TYPE___ns1__submitGetCompanyRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__submitGetCompanyRequest*>(p->ptr), struct __ns1__submitGetCompanyRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__submitGetCompanyRequest*>(p->ptr), struct __ns1__submitGetCompanyRequest);
		break;
	case SOAP_TYPE___ns1__retrieveGetCompanyResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__retrieveGetCompanyResponse*>(p->ptr), struct __ns1__retrieveGetCompanyResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__retrieveGetCompanyResponse*>(p->ptr), struct __ns1__retrieveGetCompanyResponse);
		break;
	case SOAP_TYPE___ns1__submitGetActionsRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__submitGetActionsRequest*>(p->ptr), struct __ns1__submitGetActionsRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__submitGetActionsRequest*>(p->ptr), struct __ns1__submitGetActionsRequest);
		break;
	case SOAP_TYPE___ns1__retrieveGetActionsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__retrieveGetActionsResponse*>(p->ptr), struct __ns1__retrieveGetActionsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__retrieveGetActionsResponse*>(p->ptr), struct __ns1__retrieveGetActionsResponse);
		break;
	case SOAP_TYPE___ns1__getPortfolioValidation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__getPortfolioValidation*>(p->ptr), struct __ns1__getPortfolioValidation);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__getPortfolioValidation*>(p->ptr), struct __ns1__getPortfolioValidation);
		break;
	case SOAP_TYPE___ns1__submitGetQuotesRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__submitGetQuotesRequest*>(p->ptr), struct __ns1__submitGetQuotesRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__submitGetQuotesRequest*>(p->ptr), struct __ns1__submitGetQuotesRequest);
		break;
	case SOAP_TYPE___ns1__retrieveGetQuotesResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__retrieveGetQuotesResponse*>(p->ptr), struct __ns1__retrieveGetQuotesResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__retrieveGetQuotesResponse*>(p->ptr), struct __ns1__retrieveGetQuotesResponse);
		break;
	case SOAP_TYPE___ns1__submitGetAllQuotesRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__submitGetAllQuotesRequest*>(p->ptr), struct __ns1__submitGetAllQuotesRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__submitGetAllQuotesRequest*>(p->ptr), struct __ns1__submitGetAllQuotesRequest);
		break;
	case SOAP_TYPE___ns1__retrieveGetAllQuotesResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__retrieveGetAllQuotesResponse*>(p->ptr), struct __ns1__retrieveGetAllQuotesResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__retrieveGetAllQuotesResponse*>(p->ptr), struct __ns1__retrieveGetAllQuotesResponse);
		break;
	case SOAP_TYPE___ns1__submitOtcbvalUploadRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__submitOtcbvalUploadRequest*>(p->ptr), struct __ns1__submitOtcbvalUploadRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__submitOtcbvalUploadRequest*>(p->ptr), struct __ns1__submitOtcbvalUploadRequest);
		break;
	case SOAP_TYPE___ns1__retrieveOtcbvalUploadResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__retrieveOtcbvalUploadResponse*>(p->ptr), struct __ns1__retrieveOtcbvalUploadResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__retrieveOtcbvalUploadResponse*>(p->ptr), struct __ns1__retrieveOtcbvalUploadResponse);
		break;
	case SOAP_TYPE___ns1__submitOtcBvalDealsUploadRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__submitOtcBvalDealsUploadRequest*>(p->ptr), struct __ns1__submitOtcBvalDealsUploadRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__submitOtcBvalDealsUploadRequest*>(p->ptr), struct __ns1__submitOtcBvalDealsUploadRequest);
		break;
	case SOAP_TYPE___ns1__retrieveOtcBvalDealsUploadResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__retrieveOtcBvalDealsUploadResponse*>(p->ptr), struct __ns1__retrieveOtcBvalDealsUploadResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__retrieveOtcBvalDealsUploadResponse*>(p->ptr), struct __ns1__retrieveOtcBvalDealsUploadResponse);
		break;
	case SOAP_TYPE___ns1__getFields:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__getFields*>(p->ptr), struct __ns1__getFields);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__getFields*>(p->ptr), struct __ns1__getFields);
		break;
	case SOAP_TYPE___ns1__submitMmktBvalDealsUploadRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__submitMmktBvalDealsUploadRequest*>(p->ptr), struct __ns1__submitMmktBvalDealsUploadRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__submitMmktBvalDealsUploadRequest*>(p->ptr), struct __ns1__submitMmktBvalDealsUploadRequest);
		break;
	case SOAP_TYPE___ns1__retrieveMmktBvalDealsUploadResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__retrieveMmktBvalDealsUploadResponse*>(p->ptr), struct __ns1__retrieveMmktBvalDealsUploadResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__retrieveMmktBvalDealsUploadResponse*>(p->ptr), struct __ns1__retrieveMmktBvalDealsUploadResponse);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		break;
#endif
	case SOAP_TYPE_xsd__date:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_xsd__time:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__CancelResponseStatus:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__CancelResponseStatus *> *>(p->ptr), std::vector<ns1__CancelResponseStatus *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__CancelResponseStatus *> *>(p->ptr), std::vector<ns1__CancelResponseStatus *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__MmktBvalDealInformation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__MmktBvalDealInformation *> *>(p->ptr), std::vector<ns1__MmktBvalDealInformation *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__MmktBvalDealInformation *> *>(p->ptr), std::vector<ns1__MmktBvalDealInformation *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ScheduledResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__ScheduledResponse *> *>(p->ptr), std::vector<ns1__ScheduledResponse *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__ScheduledResponse *> *>(p->ptr), std::vector<ns1__ScheduledResponse *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__OtcDealInformation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__OtcDealInformation *> *>(p->ptr), std::vector<ns1__OtcDealInformation *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__OtcDealInformation *> *>(p->ptr), std::vector<ns1__OtcDealInformation *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__FieldInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__FieldInfo *> *>(p->ptr), std::vector<ns1__FieldInfo *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__FieldInfo *> *>(p->ptr), std::vector<ns1__FieldInfo *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfns1__DLCategory2:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<enum ns1__DLCategory2> *>(p->ptr), std::vector<enum ns1__DLCategory2> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<enum ns1__DLCategory2> *>(p->ptr), std::vector<enum ns1__DLCategory2> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfns1__MarketSector:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<enum ns1__MarketSector> *>(p->ptr), std::vector<enum ns1__MarketSector> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<enum ns1__MarketSector> *>(p->ptr), std::vector<enum ns1__MarketSector> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfns1__DLCategory:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<enum ns1__DLCategory> *>(p->ptr), std::vector<enum ns1__DLCategory> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<enum ns1__DLCategory> *>(p->ptr), std::vector<enum ns1__DLCategory> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__BulkArrayEntry:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__BulkArrayEntry *> *>(p->ptr), std::vector<ns1__BulkArrayEntry *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__BulkArrayEntry *> *>(p->ptr), std::vector<ns1__BulkArrayEntry *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__QRMQuoteData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__QRMQuoteData *> *>(p->ptr), std::vector<ns1__QRMQuoteData *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__QRMQuoteData *> *>(p->ptr), std::vector<ns1__QRMQuoteData *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__QRMQuote:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__QRMQuote *> *>(p->ptr), std::vector<ns1__QRMQuote *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__QRMQuote *> *>(p->ptr), std::vector<ns1__QRMQuote *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__QRQuote:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__QRQuote *> *>(p->ptr), std::vector<ns1__QRQuote *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__QRQuote *> *>(p->ptr), std::vector<ns1__QRQuote *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__BulkArray:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__BulkArray *> *>(p->ptr), std::vector<ns1__BulkArray *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__BulkArray *> *>(p->ptr), std::vector<ns1__BulkArray *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__HistData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__HistData *> *>(p->ptr), std::vector<ns1__HistData *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__HistData *> *>(p->ptr), std::vector<ns1__HistData *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Data:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__Data *> *>(p->ptr), std::vector<ns1__Data *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__Data *> *>(p->ptr), std::vector<ns1__Data *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SecondaryQualifier:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__SecondaryQualifier *> *>(p->ptr), std::vector<ns1__SecondaryQualifier *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__SecondaryQualifier *> *>(p->ptr), std::vector<ns1__SecondaryQualifier *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__AllQuotesInstrumentData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__AllQuotesInstrumentData *> *>(p->ptr), std::vector<ns1__AllQuotesInstrumentData *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__AllQuotesInstrumentData *> *>(p->ptr), std::vector<ns1__AllQuotesInstrumentData *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__QuotesInstrumentData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__QuotesInstrumentData *> *>(p->ptr), std::vector<ns1__QuotesInstrumentData *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__QuotesInstrumentData *> *>(p->ptr), std::vector<ns1__QuotesInstrumentData *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__CorrectionRecord:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__CorrectionRecord *> *>(p->ptr), std::vector<ns1__CorrectionRecord *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__CorrectionRecord *> *>(p->ptr), std::vector<ns1__CorrectionRecord *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ActionsInstrumentData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__ActionsInstrumentData *> *>(p->ptr), std::vector<ns1__ActionsInstrumentData *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__ActionsInstrumentData *> *>(p->ptr), std::vector<ns1__ActionsInstrumentData *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__FundInstrumentData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__FundInstrumentData *> *>(p->ptr), std::vector<ns1__FundInstrumentData *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__FundInstrumentData *> *>(p->ptr), std::vector<ns1__FundInstrumentData *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__HistInstrumentData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__HistInstrumentData *> *>(p->ptr), std::vector<ns1__HistInstrumentData *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__HistInstrumentData *> *>(p->ptr), std::vector<ns1__HistInstrumentData *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__InstrumentData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__InstrumentData *> *>(p->ptr), std::vector<ns1__InstrumentData *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__InstrumentData *> *>(p->ptr), std::vector<ns1__InstrumentData *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__FundInstrument:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__FundInstrument *> *>(p->ptr), std::vector<ns1__FundInstrument *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__FundInstrument *> *>(p->ptr), std::vector<ns1__FundInstrument *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Macro:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__Macro *> *>(p->ptr), std::vector<ns1__Macro *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__Macro *> *>(p->ptr), std::vector<ns1__Macro *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Instrument:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__Instrument *> *>(p->ptr), std::vector<ns1__Instrument *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__Instrument *> *>(p->ptr), std::vector<ns1__Instrument *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Override:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__Override *> *>(p->ptr), std::vector<ns1__Override *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__Override *> *>(p->ptr), std::vector<ns1__Override *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__BvalFieldSet:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__BvalFieldSet *> *>(p->ptr), std::vector<ns1__BvalFieldSet *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__BvalFieldSet *> *>(p->ptr), std::vector<ns1__BvalFieldSet *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__FieldSet:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__FieldSet *> *>(p->ptr), std::vector<ns1__FieldSet *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__FieldSet *> *>(p->ptr), std::vector<ns1__FieldSet *> );
		break;
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_fbase(int t, int b)
{
	do
	{	switch (t)
		{

		case SOAP_TYPE_ns1__SubmitGetDataResponse: t = SOAP_TYPE_ns1__PerSecurityResponse; break;
		case SOAP_TYPE_ns1__RetrieveGetDataResponse: t = SOAP_TYPE_ns1__PerSecurityResponse; break;
		case SOAP_TYPE_ns1__SubmitGetHistoryResponse: t = SOAP_TYPE_ns1__PerSecurityResponse; break;
		case SOAP_TYPE_ns1__RetrieveGetHistoryResponse: t = SOAP_TYPE_ns1__PerSecurityResponse; break;
		case SOAP_TYPE_ns1__SubmitCancelResponse: t = SOAP_TYPE_ns1__PerSecurityResponse; break;
		case SOAP_TYPE_ns1__RetrieveCancelResponse: t = SOAP_TYPE_ns1__PerSecurityResponse; break;
		case SOAP_TYPE_ns1__GetCorrectionsResponse: t = SOAP_TYPE_ns1__PerSecurityResponse; break;
		case SOAP_TYPE_ns1__SubmitScheduledResponse: t = SOAP_TYPE_ns1__PerSecurityResponse; break;
		case SOAP_TYPE_ns1__RetrieveScheduledResponse: t = SOAP_TYPE_ns1__PerSecurityResponse; break;
		case SOAP_TYPE_ns1__SubmitGetFundamentalsResponse: t = SOAP_TYPE_ns1__PerSecurityResponse; break;
		case SOAP_TYPE_ns1__RetrieveGetFundamentalsResponse: t = SOAP_TYPE_ns1__PerSecurityResponse; break;
		case SOAP_TYPE_ns1__SubmitGetCompanyResponse: t = SOAP_TYPE_ns1__PerSecurityResponse; break;
		case SOAP_TYPE_ns1__RetrieveGetCompanyResponse: t = SOAP_TYPE_ns1__PerSecurityResponse; break;
		case SOAP_TYPE_ns1__GetPortfolioValidationResponse: t = SOAP_TYPE_ns1__PerSecurityResponse; break;
		case SOAP_TYPE_ns1__SubmitGetActionsResponse: t = SOAP_TYPE_ns1__PerSecurityResponse; break;
		case SOAP_TYPE_ns1__RetrieveGetActionsResponse: t = SOAP_TYPE_ns1__PerSecurityResponse; break;
		case SOAP_TYPE_ns1__SubmitGetQuotesResponse: t = SOAP_TYPE_ns1__PerSecurityResponse; break;
		case SOAP_TYPE_ns1__RetrieveGetQuotesResponse: t = SOAP_TYPE_ns1__PerSecurityResponse; break;
		case SOAP_TYPE_ns1__SubmitGetAllQuotesResponse: t = SOAP_TYPE_ns1__PerSecurityResponse; break;
		case SOAP_TYPE_ns1__RetrieveGetAllQuotesResponse: t = SOAP_TYPE_ns1__PerSecurityResponse; break;
		case SOAP_TYPE_ns1__SubmitOtcbvalUploadResponse: t = SOAP_TYPE_ns1__PerSecurityResponse; break;
		case SOAP_TYPE_ns1__RetrieveOtcbvalUploadResponse: t = SOAP_TYPE_ns1__PerSecurityResponse; break;
		case SOAP_TYPE_ns1__SubmitOtcBvalDealsUploadResponse: t = SOAP_TYPE_ns1__PerSecurityResponse; break;
		case SOAP_TYPE_ns1__RetrieveOtcBvalDealsUploadResponse: t = SOAP_TYPE_ns1__PerSecurityResponse; break;
		case SOAP_TYPE_ns1__GetFieldsResponse: t = SOAP_TYPE_ns1__PerSecurityResponse; break;
		case SOAP_TYPE_ns1__SubmitMmktBvalDealsUploadResponse: t = SOAP_TYPE_ns1__PerSecurityResponse; break;
		case SOAP_TYPE_ns1__RetrieveMmktBvalDealsUploadResponse: t = SOAP_TYPE_ns1__PerSecurityResponse; break;
		default: return 0;
		}
	}
	while (t != b);
	return 1;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__CancelResponseStatus:
		if (t == SOAP_TYPE_ns1__CancelResponseStatus || soap_fbase(t, SOAP_TYPE_ns1__CancelResponseStatus))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__CancelResponseStatus *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__CancelResponseStatus *> *)p)[index] = *(ns1__CancelResponseStatus **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__MmktBvalDealInformation:
		if (t == SOAP_TYPE_ns1__MmktBvalDealInformation || soap_fbase(t, SOAP_TYPE_ns1__MmktBvalDealInformation))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__MmktBvalDealInformation *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__MmktBvalDealInformation *> *)p)[index] = *(ns1__MmktBvalDealInformation **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ScheduledResponse:
		if (t == SOAP_TYPE_ns1__ScheduledResponse || soap_fbase(t, SOAP_TYPE_ns1__ScheduledResponse))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__ScheduledResponse *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__ScheduledResponse *> *)p)[index] = *(ns1__ScheduledResponse **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__OtcDealInformation:
		if (t == SOAP_TYPE_ns1__OtcDealInformation || soap_fbase(t, SOAP_TYPE_ns1__OtcDealInformation))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__OtcDealInformation *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__OtcDealInformation *> *)p)[index] = *(ns1__OtcDealInformation **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__FieldInfo:
		if (t == SOAP_TYPE_ns1__FieldInfo || soap_fbase(t, SOAP_TYPE_ns1__FieldInfo))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__FieldInfo *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__FieldInfo *> *)p)[index] = *(ns1__FieldInfo **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfns1__DLCategory2:
		if (t == SOAP_TYPE_ns1__DLCategory2)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<enum ns1__DLCategory2>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<enum ns1__DLCategory2> *)p)[index] = *(enum ns1__DLCategory2 *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfns1__MarketSector:
		if (t == SOAP_TYPE_ns1__MarketSector)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<enum ns1__MarketSector>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<enum ns1__MarketSector> *)p)[index] = *(enum ns1__MarketSector *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfns1__DLCategory:
		if (t == SOAP_TYPE_ns1__DLCategory)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<enum ns1__DLCategory>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<enum ns1__DLCategory> *)p)[index] = *(enum ns1__DLCategory *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__BulkArrayEntry:
		if (t == SOAP_TYPE_ns1__BulkArrayEntry || soap_fbase(t, SOAP_TYPE_ns1__BulkArrayEntry))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__BulkArrayEntry *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__BulkArrayEntry *> *)p)[index] = *(ns1__BulkArrayEntry **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__QRMQuoteData:
		if (t == SOAP_TYPE_ns1__QRMQuoteData || soap_fbase(t, SOAP_TYPE_ns1__QRMQuoteData))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__QRMQuoteData *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__QRMQuoteData *> *)p)[index] = *(ns1__QRMQuoteData **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__QRMQuote:
		if (t == SOAP_TYPE_ns1__QRMQuote || soap_fbase(t, SOAP_TYPE_ns1__QRMQuote))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__QRMQuote *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__QRMQuote *> *)p)[index] = *(ns1__QRMQuote **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__QRQuote:
		if (t == SOAP_TYPE_ns1__QRQuote || soap_fbase(t, SOAP_TYPE_ns1__QRQuote))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__QRQuote *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__QRQuote *> *)p)[index] = *(ns1__QRQuote **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__BulkArray:
		if (t == SOAP_TYPE_ns1__BulkArray || soap_fbase(t, SOAP_TYPE_ns1__BulkArray))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__BulkArray *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__BulkArray *> *)p)[index] = *(ns1__BulkArray **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__HistData:
		if (t == SOAP_TYPE_ns1__HistData || soap_fbase(t, SOAP_TYPE_ns1__HistData))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__HistData *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__HistData *> *)p)[index] = *(ns1__HistData **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Data:
		if (t == SOAP_TYPE_ns1__Data || soap_fbase(t, SOAP_TYPE_ns1__Data))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__Data *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__Data *> *)p)[index] = *(ns1__Data **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SecondaryQualifier:
		if (t == SOAP_TYPE_ns1__SecondaryQualifier || soap_fbase(t, SOAP_TYPE_ns1__SecondaryQualifier))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__SecondaryQualifier *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__SecondaryQualifier *> *)p)[index] = *(ns1__SecondaryQualifier **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__AllQuotesInstrumentData:
		if (t == SOAP_TYPE_ns1__AllQuotesInstrumentData || soap_fbase(t, SOAP_TYPE_ns1__AllQuotesInstrumentData))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__AllQuotesInstrumentData *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__AllQuotesInstrumentData *> *)p)[index] = *(ns1__AllQuotesInstrumentData **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__QuotesInstrumentData:
		if (t == SOAP_TYPE_ns1__QuotesInstrumentData || soap_fbase(t, SOAP_TYPE_ns1__QuotesInstrumentData))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__QuotesInstrumentData *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__QuotesInstrumentData *> *)p)[index] = *(ns1__QuotesInstrumentData **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__CorrectionRecord:
		if (t == SOAP_TYPE_ns1__CorrectionRecord || soap_fbase(t, SOAP_TYPE_ns1__CorrectionRecord))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__CorrectionRecord *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__CorrectionRecord *> *)p)[index] = *(ns1__CorrectionRecord **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ActionsInstrumentData:
		if (t == SOAP_TYPE_ns1__ActionsInstrumentData || soap_fbase(t, SOAP_TYPE_ns1__ActionsInstrumentData))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__ActionsInstrumentData *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__ActionsInstrumentData *> *)p)[index] = *(ns1__ActionsInstrumentData **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__FundInstrumentData:
		if (t == SOAP_TYPE_ns1__FundInstrumentData || soap_fbase(t, SOAP_TYPE_ns1__FundInstrumentData))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__FundInstrumentData *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__FundInstrumentData *> *)p)[index] = *(ns1__FundInstrumentData **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__HistInstrumentData:
		if (t == SOAP_TYPE_ns1__HistInstrumentData || soap_fbase(t, SOAP_TYPE_ns1__HistInstrumentData))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__HistInstrumentData *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__HistInstrumentData *> *)p)[index] = *(ns1__HistInstrumentData **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__InstrumentData:
		if (t == SOAP_TYPE_ns1__InstrumentData || soap_fbase(t, SOAP_TYPE_ns1__InstrumentData))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__InstrumentData *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__InstrumentData *> *)p)[index] = *(ns1__InstrumentData **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__FundInstrument:
		if (t == SOAP_TYPE_ns1__FundInstrument || soap_fbase(t, SOAP_TYPE_ns1__FundInstrument))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__FundInstrument *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__FundInstrument *> *)p)[index] = *(ns1__FundInstrument **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Macro:
		if (t == SOAP_TYPE_ns1__Macro || soap_fbase(t, SOAP_TYPE_ns1__Macro))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__Macro *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__Macro *> *)p)[index] = *(ns1__Macro **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Instrument:
		if (t == SOAP_TYPE_ns1__Instrument || soap_fbase(t, SOAP_TYPE_ns1__Instrument))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__Instrument *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__Instrument *> *)p)[index] = *(ns1__Instrument **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Override:
		if (t == SOAP_TYPE_ns1__Override || soap_fbase(t, SOAP_TYPE_ns1__Override))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__Override *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__Override *> *)p)[index] = *(ns1__Override **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		if (t == SOAP_TYPE_std__string)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<std::string>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<std::string> *)p)[index] = *(std::string *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__BvalFieldSet:
		if (t == SOAP_TYPE_ns1__BvalFieldSet || soap_fbase(t, SOAP_TYPE_ns1__BvalFieldSet))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__BvalFieldSet *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__BvalFieldSet *> *)p)[index] = *(ns1__BvalFieldSet **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__FieldSet:
		if (t == SOAP_TYPE_ns1__FieldSet || soap_fbase(t, SOAP_TYPE_ns1__FieldSet))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__FieldSet *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__FieldSet *> *)p)[index] = *(ns1__FieldSet **)q;
		}
		break;
	case SOAP_TYPE_std__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__CancelHeaders:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__CancelHeaders type=%d location=%p object=%p\n", t, p, q));
		*(ns1__CancelHeaders*)p = *(ns1__CancelHeaders*)q;
		break;
	case SOAP_TYPE_ns1__GetCorrectionsHeaders:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__GetCorrectionsHeaders type=%d location=%p object=%p\n", t, p, q));
		*(ns1__GetCorrectionsHeaders*)p = *(ns1__GetCorrectionsHeaders*)q;
		break;
	case SOAP_TYPE_ns1__GetDataHeaders:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__GetDataHeaders type=%d location=%p object=%p\n", t, p, q));
		*(ns1__GetDataHeaders*)p = *(ns1__GetDataHeaders*)q;
		break;
	case SOAP_TYPE_ns1__Period:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__Period type=%d location=%p object=%p\n", t, p, q));
		*(ns1__Period*)p = *(ns1__Period*)q;
		break;
	case SOAP_TYPE_ns1__Duration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__Duration type=%d location=%p object=%p\n", t, p, q));
		*(ns1__Duration*)p = *(ns1__Duration*)q;
		break;
	case SOAP_TYPE_ns1__DateRange:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__DateRange type=%d location=%p object=%p\n", t, p, q));
		*(ns1__DateRange*)p = *(ns1__DateRange*)q;
		break;
	case SOAP_TYPE_ns1__GetHistoryHeaders:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__GetHistoryHeaders type=%d location=%p object=%p\n", t, p, q));
		*(ns1__GetHistoryHeaders*)p = *(ns1__GetHistoryHeaders*)q;
		break;
	case SOAP_TYPE_ns1__GetFundamentalsHeaders:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__GetFundamentalsHeaders type=%d location=%p object=%p\n", t, p, q));
		*(ns1__GetFundamentalsHeaders*)p = *(ns1__GetFundamentalsHeaders*)q;
		break;
	case SOAP_TYPE_ns1__GetCompanyHeaders:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__GetCompanyHeaders type=%d location=%p object=%p\n", t, p, q));
		*(ns1__GetCompanyHeaders*)p = *(ns1__GetCompanyHeaders*)q;
		break;
	case SOAP_TYPE_ns1__GetActionsHeaders:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__GetActionsHeaders type=%d location=%p object=%p\n", t, p, q));
		*(ns1__GetActionsHeaders*)p = *(ns1__GetActionsHeaders*)q;
		break;
	case SOAP_TYPE_ns1__GetPortfolioValidationHeaders:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__GetPortfolioValidationHeaders type=%d location=%p object=%p\n", t, p, q));
		*(ns1__GetPortfolioValidationHeaders*)p = *(ns1__GetPortfolioValidationHeaders*)q;
		break;
	case SOAP_TYPE_ns1__QuotesHeaders:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__QuotesHeaders type=%d location=%p object=%p\n", t, p, q));
		*(ns1__QuotesHeaders*)p = *(ns1__QuotesHeaders*)q;
		break;
	case SOAP_TYPE_ns1__DateTimeRange:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__DateTimeRange type=%d location=%p object=%p\n", t, p, q));
		*(ns1__DateTimeRange*)p = *(ns1__DateTimeRange*)q;
		break;
	case SOAP_TYPE_ns1__TickOutputTz:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__TickOutputTz type=%d location=%p object=%p\n", t, p, q));
		*(ns1__TickOutputTz*)p = *(ns1__TickOutputTz*)q;
		break;
	case SOAP_TYPE_ns1__FieldSets:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__FieldSets type=%d location=%p object=%p\n", t, p, q));
		*(ns1__FieldSets*)p = *(ns1__FieldSets*)q;
		break;
	case SOAP_TYPE_ns1__FieldSet:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__FieldSet type=%d location=%p object=%p\n", t, p, q));
		*(ns1__FieldSet*)p = *(ns1__FieldSet*)q;
		break;
	case SOAP_TYPE_ns1__BvalFieldSets:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__BvalFieldSets type=%d location=%p object=%p\n", t, p, q));
		*(ns1__BvalFieldSets*)p = *(ns1__BvalFieldSets*)q;
		break;
	case SOAP_TYPE_ns1__BvalFieldSet:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__BvalFieldSet type=%d location=%p object=%p\n", t, p, q));
		*(ns1__BvalFieldSet*)p = *(ns1__BvalFieldSet*)q;
		break;
	case SOAP_TYPE_ns1__ScheduledHeaders:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ScheduledHeaders type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ScheduledHeaders*)p = *(ns1__ScheduledHeaders*)q;
		break;
	case SOAP_TYPE_ns1__Fields:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__Fields type=%d location=%p object=%p\n", t, p, q));
		*(ns1__Fields*)p = *(ns1__Fields*)q;
		break;
	case SOAP_TYPE_ns1__Overrides:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__Overrides type=%d location=%p object=%p\n", t, p, q));
		*(ns1__Overrides*)p = *(ns1__Overrides*)q;
		break;
	case SOAP_TYPE_ns1__Instruments:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__Instruments type=%d location=%p object=%p\n", t, p, q));
		*(ns1__Instruments*)p = *(ns1__Instruments*)q;
		break;
	case SOAP_TYPE_ns1__FundInstruments:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__FundInstruments type=%d location=%p object=%p\n", t, p, q));
		*(ns1__FundInstruments*)p = *(ns1__FundInstruments*)q;
		break;
	case SOAP_TYPE_ns1__InstrumentDatas:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__InstrumentDatas type=%d location=%p object=%p\n", t, p, q));
		*(ns1__InstrumentDatas*)p = *(ns1__InstrumentDatas*)q;
		break;
	case SOAP_TYPE_ns1__HistInstrumentDatas:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__HistInstrumentDatas type=%d location=%p object=%p\n", t, p, q));
		*(ns1__HistInstrumentDatas*)p = *(ns1__HistInstrumentDatas*)q;
		break;
	case SOAP_TYPE_ns1__FundInstrumentDatas:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__FundInstrumentDatas type=%d location=%p object=%p\n", t, p, q));
		*(ns1__FundInstrumentDatas*)p = *(ns1__FundInstrumentDatas*)q;
		break;
	case SOAP_TYPE_ns1__ActionsInstrumentDatas:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ActionsInstrumentDatas type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ActionsInstrumentDatas*)p = *(ns1__ActionsInstrumentDatas*)q;
		break;
	case SOAP_TYPE_ns1__CorrectionRecords:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__CorrectionRecords type=%d location=%p object=%p\n", t, p, q));
		*(ns1__CorrectionRecords*)p = *(ns1__CorrectionRecords*)q;
		break;
	case SOAP_TYPE_ns1__QuotesInstrumentDatas:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__QuotesInstrumentDatas type=%d location=%p object=%p\n", t, p, q));
		*(ns1__QuotesInstrumentDatas*)p = *(ns1__QuotesInstrumentDatas*)q;
		break;
	case SOAP_TYPE_ns1__AllQuotesInstrumentDatas:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__AllQuotesInstrumentDatas type=%d location=%p object=%p\n", t, p, q));
		*(ns1__AllQuotesInstrumentDatas*)p = *(ns1__AllQuotesInstrumentDatas*)q;
		break;
	case SOAP_TYPE_ns1__Instrument:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__Instrument type=%d location=%p object=%p\n", t, p, q));
		*(ns1__Instrument*)p = *(ns1__Instrument*)q;
		break;
	case SOAP_TYPE_ns1__FundInstrument:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__FundInstrument type=%d location=%p object=%p\n", t, p, q));
		*(ns1__FundInstrument*)p = *(ns1__FundInstrument*)q;
		break;
	case SOAP_TYPE_ns1__Macro:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__Macro type=%d location=%p object=%p\n", t, p, q));
		*(ns1__Macro*)p = *(ns1__Macro*)q;
		break;
	case SOAP_TYPE_ns1__PrimaryQualifier:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__PrimaryQualifier type=%d location=%p object=%p\n", t, p, q));
		*(ns1__PrimaryQualifier*)p = *(ns1__PrimaryQualifier*)q;
		break;
	case SOAP_TYPE_ns1__SecondaryQualifier:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__SecondaryQualifier type=%d location=%p object=%p\n", t, p, q));
		*(ns1__SecondaryQualifier*)p = *(ns1__SecondaryQualifier*)q;
		break;
	case SOAP_TYPE_ns1__Override:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__Override type=%d location=%p object=%p\n", t, p, q));
		*(ns1__Override*)p = *(ns1__Override*)q;
		break;
	case SOAP_TYPE_ns1__Actions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__Actions type=%d location=%p object=%p\n", t, p, q));
		*(ns1__Actions*)p = *(ns1__Actions*)q;
		break;
	case SOAP_TYPE_ns1__DataItem:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__DataItem type=%d location=%p object=%p\n", t, p, q));
		*(ns1__DataItem*)p = *(ns1__DataItem*)q;
		break;
	case SOAP_TYPE_ns1__InstrumentData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__InstrumentData type=%d location=%p object=%p\n", t, p, q));
		*(ns1__InstrumentData*)p = *(ns1__InstrumentData*)q;
		break;
	case SOAP_TYPE_ns1__HistInstrumentData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__HistInstrumentData type=%d location=%p object=%p\n", t, p, q));
		*(ns1__HistInstrumentData*)p = *(ns1__HistInstrumentData*)q;
		break;
	case SOAP_TYPE_ns1__FundInstrumentData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__FundInstrumentData type=%d location=%p object=%p\n", t, p, q));
		*(ns1__FundInstrumentData*)p = *(ns1__FundInstrumentData*)q;
		break;
	case SOAP_TYPE_ns1__QuotesInstrumentData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__QuotesInstrumentData type=%d location=%p object=%p\n", t, p, q));
		*(ns1__QuotesInstrumentData*)p = *(ns1__QuotesInstrumentData*)q;
		break;
	case SOAP_TYPE_ns1__AllQuotesInstrumentData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__AllQuotesInstrumentData type=%d location=%p object=%p\n", t, p, q));
		*(ns1__AllQuotesInstrumentData*)p = *(ns1__AllQuotesInstrumentData*)q;
		break;
	case SOAP_TYPE_ns1__ActionsInstrumentData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ActionsInstrumentData type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ActionsInstrumentData*)p = *(ns1__ActionsInstrumentData*)q;
		break;
	case SOAP_TYPE_ns1__CorrectionRecord:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__CorrectionRecord type=%d location=%p object=%p\n", t, p, q));
		*(ns1__CorrectionRecord*)p = *(ns1__CorrectionRecord*)q;
		break;
	case SOAP_TYPE_ns1__Data:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__Data type=%d location=%p object=%p\n", t, p, q));
		*(ns1__Data*)p = *(ns1__Data*)q;
		break;
	case SOAP_TYPE_ns1__QRQuotes:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__QRQuotes type=%d location=%p object=%p\n", t, p, q));
		*(ns1__QRQuotes*)p = *(ns1__QRQuotes*)q;
		break;
	case SOAP_TYPE_ns1__QRMQuotes:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__QRMQuotes type=%d location=%p object=%p\n", t, p, q));
		*(ns1__QRMQuotes*)p = *(ns1__QRMQuotes*)q;
		break;
	case SOAP_TYPE_ns1__QRQuote:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__QRQuote type=%d location=%p object=%p\n", t, p, q));
		*(ns1__QRQuote*)p = *(ns1__QRQuote*)q;
		break;
	case SOAP_TYPE_ns1__QRMQuoteData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__QRMQuoteData type=%d location=%p object=%p\n", t, p, q));
		*(ns1__QRMQuoteData*)p = *(ns1__QRMQuoteData*)q;
		break;
	case SOAP_TYPE_ns1__QRMQuote:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__QRMQuote type=%d location=%p object=%p\n", t, p, q));
		*(ns1__QRMQuote*)p = *(ns1__QRMQuote*)q;
		break;
	case SOAP_TYPE_ns1__HistData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__HistData type=%d location=%p object=%p\n", t, p, q));
		*(ns1__HistData*)p = *(ns1__HistData*)q;
		break;
	case SOAP_TYPE_ns1__ActionStandardFields:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ActionStandardFields type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ActionStandardFields*)p = *(ns1__ActionStandardFields*)q;
		break;
	case SOAP_TYPE_ns1__BulkArray:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__BulkArray type=%d location=%p object=%p\n", t, p, q));
		*(ns1__BulkArray*)p = *(ns1__BulkArray*)q;
		break;
	case SOAP_TYPE_ns1__BulkArrayEntry:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__BulkArrayEntry type=%d location=%p object=%p\n", t, p, q));
		*(ns1__BulkArrayEntry*)p = *(ns1__BulkArrayEntry*)q;
		break;
	case SOAP_TYPE_ns1__ResponseStatus:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ResponseStatus type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ResponseStatus*)p = *(ns1__ResponseStatus*)q;
		break;
	case SOAP_TYPE_ns1__CancelResponseStatus:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__CancelResponseStatus type=%d location=%p object=%p\n", t, p, q));
		*(ns1__CancelResponseStatus*)p = *(ns1__CancelResponseStatus*)q;
		break;
	case SOAP_TYPE_ns1__FieldSearchCriteria:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__FieldSearchCriteria type=%d location=%p object=%p\n", t, p, q));
		*(ns1__FieldSearchCriteria*)p = *(ns1__FieldSearchCriteria*)q;
		break;
	case SOAP_TYPE_ns1__FieldInfos:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__FieldInfos type=%d location=%p object=%p\n", t, p, q));
		*(ns1__FieldInfos*)p = *(ns1__FieldInfos*)q;
		break;
	case SOAP_TYPE_ns1__FieldInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__FieldInfo type=%d location=%p object=%p\n", t, p, q));
		*(ns1__FieldInfo*)p = *(ns1__FieldInfo*)q;
		break;
	case SOAP_TYPE_ns1__OtcBvalHeaders:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__OtcBvalHeaders type=%d location=%p object=%p\n", t, p, q));
		*(ns1__OtcBvalHeaders*)p = *(ns1__OtcBvalHeaders*)q;
		break;
	case SOAP_TYPE_ns1__OtcDealInformation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__OtcDealInformation type=%d location=%p object=%p\n", t, p, q));
		*(ns1__OtcDealInformation*)p = *(ns1__OtcDealInformation*)q;
		break;
	case SOAP_TYPE_ns1__OtcDealInfos:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__OtcDealInfos type=%d location=%p object=%p\n", t, p, q));
		*(ns1__OtcDealInfos*)p = *(ns1__OtcDealInfos*)q;
		break;
	case SOAP_TYPE_ns1__PerSecurityResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__PerSecurityResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__PerSecurityResponse*)p = *(ns1__PerSecurityResponse*)q;
		break;
	case SOAP_TYPE_ns1__SubmitGetDataRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__SubmitGetDataRequest type=%d location=%p object=%p\n", t, p, q));
		*(ns1__SubmitGetDataRequest*)p = *(ns1__SubmitGetDataRequest*)q;
		break;
	case SOAP_TYPE_ns1__RetrieveGetDataRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__RetrieveGetDataRequest type=%d location=%p object=%p\n", t, p, q));
		*(ns1__RetrieveGetDataRequest*)p = *(ns1__RetrieveGetDataRequest*)q;
		break;
	case SOAP_TYPE_ns1__SubmitGetHistoryRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__SubmitGetHistoryRequest type=%d location=%p object=%p\n", t, p, q));
		*(ns1__SubmitGetHistoryRequest*)p = *(ns1__SubmitGetHistoryRequest*)q;
		break;
	case SOAP_TYPE_ns1__RetrieveGetHistoryRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__RetrieveGetHistoryRequest type=%d location=%p object=%p\n", t, p, q));
		*(ns1__RetrieveGetHistoryRequest*)p = *(ns1__RetrieveGetHistoryRequest*)q;
		break;
	case SOAP_TYPE_ns1__SubmitCancelRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__SubmitCancelRequest type=%d location=%p object=%p\n", t, p, q));
		*(ns1__SubmitCancelRequest*)p = *(ns1__SubmitCancelRequest*)q;
		break;
	case SOAP_TYPE_ns1__RetrieveCancelRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__RetrieveCancelRequest type=%d location=%p object=%p\n", t, p, q));
		*(ns1__RetrieveCancelRequest*)p = *(ns1__RetrieveCancelRequest*)q;
		break;
	case SOAP_TYPE_ns1__GetCorrectionsRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__GetCorrectionsRequest type=%d location=%p object=%p\n", t, p, q));
		*(ns1__GetCorrectionsRequest*)p = *(ns1__GetCorrectionsRequest*)q;
		break;
	case SOAP_TYPE_ns1__SubmitScheduledRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__SubmitScheduledRequest type=%d location=%p object=%p\n", t, p, q));
		*(ns1__SubmitScheduledRequest*)p = *(ns1__SubmitScheduledRequest*)q;
		break;
	case SOAP_TYPE_ns1__RetrieveScheduledRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__RetrieveScheduledRequest type=%d location=%p object=%p\n", t, p, q));
		*(ns1__RetrieveScheduledRequest*)p = *(ns1__RetrieveScheduledRequest*)q;
		break;
	case SOAP_TYPE_ns1__ScheduledResponses:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ScheduledResponses type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ScheduledResponses*)p = *(ns1__ScheduledResponses*)q;
		break;
	case SOAP_TYPE_ns1__ScheduledResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ScheduledResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ScheduledResponse*)p = *(ns1__ScheduledResponse*)q;
		break;
	case SOAP_TYPE_ns1__SubmitGetFundamentalsRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__SubmitGetFundamentalsRequest type=%d location=%p object=%p\n", t, p, q));
		*(ns1__SubmitGetFundamentalsRequest*)p = *(ns1__SubmitGetFundamentalsRequest*)q;
		break;
	case SOAP_TYPE_ns1__RetrieveGetFundamentalsRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__RetrieveGetFundamentalsRequest type=%d location=%p object=%p\n", t, p, q));
		*(ns1__RetrieveGetFundamentalsRequest*)p = *(ns1__RetrieveGetFundamentalsRequest*)q;
		break;
	case SOAP_TYPE_ns1__SubmitGetCompanyRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__SubmitGetCompanyRequest type=%d location=%p object=%p\n", t, p, q));
		*(ns1__SubmitGetCompanyRequest*)p = *(ns1__SubmitGetCompanyRequest*)q;
		break;
	case SOAP_TYPE_ns1__RetrieveGetCompanyRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__RetrieveGetCompanyRequest type=%d location=%p object=%p\n", t, p, q));
		*(ns1__RetrieveGetCompanyRequest*)p = *(ns1__RetrieveGetCompanyRequest*)q;
		break;
	case SOAP_TYPE_ns1__GetPortfolioValidationRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__GetPortfolioValidationRequest type=%d location=%p object=%p\n", t, p, q));
		*(ns1__GetPortfolioValidationRequest*)p = *(ns1__GetPortfolioValidationRequest*)q;
		break;
	case SOAP_TYPE_ns1__SubmitGetActionsRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__SubmitGetActionsRequest type=%d location=%p object=%p\n", t, p, q));
		*(ns1__SubmitGetActionsRequest*)p = *(ns1__SubmitGetActionsRequest*)q;
		break;
	case SOAP_TYPE_ns1__RetrieveGetActionsRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__RetrieveGetActionsRequest type=%d location=%p object=%p\n", t, p, q));
		*(ns1__RetrieveGetActionsRequest*)p = *(ns1__RetrieveGetActionsRequest*)q;
		break;
	case SOAP_TYPE_ns1__SubmitGetQuotesRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__SubmitGetQuotesRequest type=%d location=%p object=%p\n", t, p, q));
		*(ns1__SubmitGetQuotesRequest*)p = *(ns1__SubmitGetQuotesRequest*)q;
		break;
	case SOAP_TYPE_ns1__RetrieveGetQuotesRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__RetrieveGetQuotesRequest type=%d location=%p object=%p\n", t, p, q));
		*(ns1__RetrieveGetQuotesRequest*)p = *(ns1__RetrieveGetQuotesRequest*)q;
		break;
	case SOAP_TYPE_ns1__SubmitGetAllQuotesRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__SubmitGetAllQuotesRequest type=%d location=%p object=%p\n", t, p, q));
		*(ns1__SubmitGetAllQuotesRequest*)p = *(ns1__SubmitGetAllQuotesRequest*)q;
		break;
	case SOAP_TYPE_ns1__RetrieveGetAllQuotesRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__RetrieveGetAllQuotesRequest type=%d location=%p object=%p\n", t, p, q));
		*(ns1__RetrieveGetAllQuotesRequest*)p = *(ns1__RetrieveGetAllQuotesRequest*)q;
		break;
	case SOAP_TYPE_ns1__SubmitOtcbvalUploadRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__SubmitOtcbvalUploadRequest type=%d location=%p object=%p\n", t, p, q));
		*(ns1__SubmitOtcbvalUploadRequest*)p = *(ns1__SubmitOtcbvalUploadRequest*)q;
		break;
	case SOAP_TYPE_ns1__RetrieveOtcbvalUploadRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__RetrieveOtcbvalUploadRequest type=%d location=%p object=%p\n", t, p, q));
		*(ns1__RetrieveOtcbvalUploadRequest*)p = *(ns1__RetrieveOtcbvalUploadRequest*)q;
		break;
	case SOAP_TYPE_ns1__SubmitOtcBvalDealsUploadRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__SubmitOtcBvalDealsUploadRequest type=%d location=%p object=%p\n", t, p, q));
		*(ns1__SubmitOtcBvalDealsUploadRequest*)p = *(ns1__SubmitOtcBvalDealsUploadRequest*)q;
		break;
	case SOAP_TYPE_ns1__RetrieveOtcBvalDealsUploadRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__RetrieveOtcBvalDealsUploadRequest type=%d location=%p object=%p\n", t, p, q));
		*(ns1__RetrieveOtcBvalDealsUploadRequest*)p = *(ns1__RetrieveOtcBvalDealsUploadRequest*)q;
		break;
	case SOAP_TYPE_ns1__GetFieldsRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__GetFieldsRequest type=%d location=%p object=%p\n", t, p, q));
		*(ns1__GetFieldsRequest*)p = *(ns1__GetFieldsRequest*)q;
		break;
	case SOAP_TYPE_ns1__MmktBvalHeaders:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__MmktBvalHeaders type=%d location=%p object=%p\n", t, p, q));
		*(ns1__MmktBvalHeaders*)p = *(ns1__MmktBvalHeaders*)q;
		break;
	case SOAP_TYPE_ns1__SubmitMmktBvalDealsUploadRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__SubmitMmktBvalDealsUploadRequest type=%d location=%p object=%p\n", t, p, q));
		*(ns1__SubmitMmktBvalDealsUploadRequest*)p = *(ns1__SubmitMmktBvalDealsUploadRequest*)q;
		break;
	case SOAP_TYPE_ns1__RetrieveMmktBvalDealsUploadRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__RetrieveMmktBvalDealsUploadRequest type=%d location=%p object=%p\n", t, p, q));
		*(ns1__RetrieveMmktBvalDealsUploadRequest*)p = *(ns1__RetrieveMmktBvalDealsUploadRequest*)q;
		break;
	case SOAP_TYPE_ns1__MmktBvalDealInformation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__MmktBvalDealInformation type=%d location=%p object=%p\n", t, p, q));
		*(ns1__MmktBvalDealInformation*)p = *(ns1__MmktBvalDealInformation*)q;
		break;
	case SOAP_TYPE_ns1__MmktBvalDealInfos:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__MmktBvalDealInfos type=%d location=%p object=%p\n", t, p, q));
		*(ns1__MmktBvalDealInfos*)p = *(ns1__MmktBvalDealInfos*)q;
		break;
	case SOAP_TYPE_ns1__SubmitGetDataResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__SubmitGetDataResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__SubmitGetDataResponse*)p = *(ns1__SubmitGetDataResponse*)q;
		break;
	case SOAP_TYPE_ns1__RetrieveGetDataResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__RetrieveGetDataResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__RetrieveGetDataResponse*)p = *(ns1__RetrieveGetDataResponse*)q;
		break;
	case SOAP_TYPE_ns1__SubmitGetHistoryResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__SubmitGetHistoryResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__SubmitGetHistoryResponse*)p = *(ns1__SubmitGetHistoryResponse*)q;
		break;
	case SOAP_TYPE_ns1__RetrieveGetHistoryResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__RetrieveGetHistoryResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__RetrieveGetHistoryResponse*)p = *(ns1__RetrieveGetHistoryResponse*)q;
		break;
	case SOAP_TYPE_ns1__SubmitCancelResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__SubmitCancelResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__SubmitCancelResponse*)p = *(ns1__SubmitCancelResponse*)q;
		break;
	case SOAP_TYPE_ns1__RetrieveCancelResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__RetrieveCancelResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__RetrieveCancelResponse*)p = *(ns1__RetrieveCancelResponse*)q;
		break;
	case SOAP_TYPE_ns1__GetCorrectionsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__GetCorrectionsResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__GetCorrectionsResponse*)p = *(ns1__GetCorrectionsResponse*)q;
		break;
	case SOAP_TYPE_ns1__SubmitScheduledResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__SubmitScheduledResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__SubmitScheduledResponse*)p = *(ns1__SubmitScheduledResponse*)q;
		break;
	case SOAP_TYPE_ns1__RetrieveScheduledResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__RetrieveScheduledResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__RetrieveScheduledResponse*)p = *(ns1__RetrieveScheduledResponse*)q;
		break;
	case SOAP_TYPE_ns1__SubmitGetFundamentalsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__SubmitGetFundamentalsResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__SubmitGetFundamentalsResponse*)p = *(ns1__SubmitGetFundamentalsResponse*)q;
		break;
	case SOAP_TYPE_ns1__RetrieveGetFundamentalsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__RetrieveGetFundamentalsResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__RetrieveGetFundamentalsResponse*)p = *(ns1__RetrieveGetFundamentalsResponse*)q;
		break;
	case SOAP_TYPE_ns1__SubmitGetCompanyResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__SubmitGetCompanyResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__SubmitGetCompanyResponse*)p = *(ns1__SubmitGetCompanyResponse*)q;
		break;
	case SOAP_TYPE_ns1__RetrieveGetCompanyResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__RetrieveGetCompanyResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__RetrieveGetCompanyResponse*)p = *(ns1__RetrieveGetCompanyResponse*)q;
		break;
	case SOAP_TYPE_ns1__GetPortfolioValidationResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__GetPortfolioValidationResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__GetPortfolioValidationResponse*)p = *(ns1__GetPortfolioValidationResponse*)q;
		break;
	case SOAP_TYPE_ns1__SubmitGetActionsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__SubmitGetActionsResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__SubmitGetActionsResponse*)p = *(ns1__SubmitGetActionsResponse*)q;
		break;
	case SOAP_TYPE_ns1__RetrieveGetActionsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__RetrieveGetActionsResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__RetrieveGetActionsResponse*)p = *(ns1__RetrieveGetActionsResponse*)q;
		break;
	case SOAP_TYPE_ns1__SubmitGetQuotesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__SubmitGetQuotesResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__SubmitGetQuotesResponse*)p = *(ns1__SubmitGetQuotesResponse*)q;
		break;
	case SOAP_TYPE_ns1__RetrieveGetQuotesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__RetrieveGetQuotesResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__RetrieveGetQuotesResponse*)p = *(ns1__RetrieveGetQuotesResponse*)q;
		break;
	case SOAP_TYPE_ns1__SubmitGetAllQuotesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__SubmitGetAllQuotesResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__SubmitGetAllQuotesResponse*)p = *(ns1__SubmitGetAllQuotesResponse*)q;
		break;
	case SOAP_TYPE_ns1__RetrieveGetAllQuotesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__RetrieveGetAllQuotesResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__RetrieveGetAllQuotesResponse*)p = *(ns1__RetrieveGetAllQuotesResponse*)q;
		break;
	case SOAP_TYPE_ns1__SubmitOtcbvalUploadResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__SubmitOtcbvalUploadResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__SubmitOtcbvalUploadResponse*)p = *(ns1__SubmitOtcbvalUploadResponse*)q;
		break;
	case SOAP_TYPE_ns1__RetrieveOtcbvalUploadResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__RetrieveOtcbvalUploadResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__RetrieveOtcbvalUploadResponse*)p = *(ns1__RetrieveOtcbvalUploadResponse*)q;
		break;
	case SOAP_TYPE_ns1__SubmitOtcBvalDealsUploadResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__SubmitOtcBvalDealsUploadResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__SubmitOtcBvalDealsUploadResponse*)p = *(ns1__SubmitOtcBvalDealsUploadResponse*)q;
		break;
	case SOAP_TYPE_ns1__RetrieveOtcBvalDealsUploadResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__RetrieveOtcBvalDealsUploadResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__RetrieveOtcBvalDealsUploadResponse*)p = *(ns1__RetrieveOtcBvalDealsUploadResponse*)q;
		break;
	case SOAP_TYPE_ns1__GetFieldsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__GetFieldsResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__GetFieldsResponse*)p = *(ns1__GetFieldsResponse*)q;
		break;
	case SOAP_TYPE_ns1__SubmitMmktBvalDealsUploadResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__SubmitMmktBvalDealsUploadResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__SubmitMmktBvalDealsUploadResponse*)p = *(ns1__SubmitMmktBvalDealsUploadResponse*)q;
		break;
	case SOAP_TYPE_ns1__RetrieveMmktBvalDealsUploadResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__RetrieveMmktBvalDealsUploadResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__RetrieveMmktBvalDealsUploadResponse*)p = *(ns1__RetrieveMmktBvalDealsUploadResponse*)q;
		break;
	case SOAP_TYPE___ns1__submitGetDataRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__submitGetDataRequest type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__submitGetDataRequest*)p = *(struct __ns1__submitGetDataRequest*)q;
		break;
	case SOAP_TYPE___ns1__retrieveGetDataResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__retrieveGetDataResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__retrieveGetDataResponse*)p = *(struct __ns1__retrieveGetDataResponse*)q;
		break;
	case SOAP_TYPE___ns1__submitGetHistoryRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__submitGetHistoryRequest type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__submitGetHistoryRequest*)p = *(struct __ns1__submitGetHistoryRequest*)q;
		break;
	case SOAP_TYPE___ns1__retrieveGetHistoryResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__retrieveGetHistoryResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__retrieveGetHistoryResponse*)p = *(struct __ns1__retrieveGetHistoryResponse*)q;
		break;
	case SOAP_TYPE___ns1__submitScheduledRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__submitScheduledRequest type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__submitScheduledRequest*)p = *(struct __ns1__submitScheduledRequest*)q;
		break;
	case SOAP_TYPE___ns1__retrieveScheduledResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__retrieveScheduledResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__retrieveScheduledResponse*)p = *(struct __ns1__retrieveScheduledResponse*)q;
		break;
	case SOAP_TYPE___ns1__submitCancelRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__submitCancelRequest type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__submitCancelRequest*)p = *(struct __ns1__submitCancelRequest*)q;
		break;
	case SOAP_TYPE___ns1__retrieveCancelResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__retrieveCancelResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__retrieveCancelResponse*)p = *(struct __ns1__retrieveCancelResponse*)q;
		break;
	case SOAP_TYPE___ns1__getCorrections:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getCorrections type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getCorrections*)p = *(struct __ns1__getCorrections*)q;
		break;
	case SOAP_TYPE___ns1__submitGetFundamentalsRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__submitGetFundamentalsRequest type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__submitGetFundamentalsRequest*)p = *(struct __ns1__submitGetFundamentalsRequest*)q;
		break;
	case SOAP_TYPE___ns1__retrieveGetFundamentalsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__retrieveGetFundamentalsResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__retrieveGetFundamentalsResponse*)p = *(struct __ns1__retrieveGetFundamentalsResponse*)q;
		break;
	case SOAP_TYPE___ns1__submitGetCompanyRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__submitGetCompanyRequest type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__submitGetCompanyRequest*)p = *(struct __ns1__submitGetCompanyRequest*)q;
		break;
	case SOAP_TYPE___ns1__retrieveGetCompanyResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__retrieveGetCompanyResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__retrieveGetCompanyResponse*)p = *(struct __ns1__retrieveGetCompanyResponse*)q;
		break;
	case SOAP_TYPE___ns1__submitGetActionsRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__submitGetActionsRequest type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__submitGetActionsRequest*)p = *(struct __ns1__submitGetActionsRequest*)q;
		break;
	case SOAP_TYPE___ns1__retrieveGetActionsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__retrieveGetActionsResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__retrieveGetActionsResponse*)p = *(struct __ns1__retrieveGetActionsResponse*)q;
		break;
	case SOAP_TYPE___ns1__getPortfolioValidation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getPortfolioValidation type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getPortfolioValidation*)p = *(struct __ns1__getPortfolioValidation*)q;
		break;
	case SOAP_TYPE___ns1__submitGetQuotesRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__submitGetQuotesRequest type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__submitGetQuotesRequest*)p = *(struct __ns1__submitGetQuotesRequest*)q;
		break;
	case SOAP_TYPE___ns1__retrieveGetQuotesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__retrieveGetQuotesResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__retrieveGetQuotesResponse*)p = *(struct __ns1__retrieveGetQuotesResponse*)q;
		break;
	case SOAP_TYPE___ns1__submitGetAllQuotesRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__submitGetAllQuotesRequest type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__submitGetAllQuotesRequest*)p = *(struct __ns1__submitGetAllQuotesRequest*)q;
		break;
	case SOAP_TYPE___ns1__retrieveGetAllQuotesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__retrieveGetAllQuotesResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__retrieveGetAllQuotesResponse*)p = *(struct __ns1__retrieveGetAllQuotesResponse*)q;
		break;
	case SOAP_TYPE___ns1__submitOtcbvalUploadRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__submitOtcbvalUploadRequest type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__submitOtcbvalUploadRequest*)p = *(struct __ns1__submitOtcbvalUploadRequest*)q;
		break;
	case SOAP_TYPE___ns1__retrieveOtcbvalUploadResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__retrieveOtcbvalUploadResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__retrieveOtcbvalUploadResponse*)p = *(struct __ns1__retrieveOtcbvalUploadResponse*)q;
		break;
	case SOAP_TYPE___ns1__submitOtcBvalDealsUploadRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__submitOtcBvalDealsUploadRequest type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__submitOtcBvalDealsUploadRequest*)p = *(struct __ns1__submitOtcBvalDealsUploadRequest*)q;
		break;
	case SOAP_TYPE___ns1__retrieveOtcBvalDealsUploadResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__retrieveOtcBvalDealsUploadResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__retrieveOtcBvalDealsUploadResponse*)p = *(struct __ns1__retrieveOtcBvalDealsUploadResponse*)q;
		break;
	case SOAP_TYPE___ns1__getFields:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getFields type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getFields*)p = *(struct __ns1__getFields*)q;
		break;
	case SOAP_TYPE___ns1__submitMmktBvalDealsUploadRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__submitMmktBvalDealsUploadRequest type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__submitMmktBvalDealsUploadRequest*)p = *(struct __ns1__submitMmktBvalDealsUploadRequest*)q;
		break;
	case SOAP_TYPE___ns1__retrieveMmktBvalDealsUploadResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__retrieveMmktBvalDealsUploadResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__retrieveMmktBvalDealsUploadResponse*)p = *(struct __ns1__retrieveMmktBvalDealsUploadResponse*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Header type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Code type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Detail type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Reason type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Fault type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
		break;
#endif
	case SOAP_TYPE_xsd__date:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__time:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *a = static_cast<char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char)));
	for (char *p = a; p && n--; ++p)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n)
{
	int *a = static_cast<int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(int)));
	for (int *p = a; p && n--; ++p)
		soap_default_int(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dateTime(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_dateTime);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_dateTime(struct soap *soap, const char *tag, time_t *a, const char *type)
{
	a = soap_indateTime(soap, tag, a, type, SOAP_TYPE_dateTime);
	return a;
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_new_dateTime(struct soap *soap, int n)
{
	time_t *a = static_cast<time_t *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(time_t)));
	for (time_t *p = a; p && n--; ++p)
		soap_default_dateTime(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dateTime(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	if (soap_out_dateTime(soap, tag ? tag : "dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_dateTime(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_dateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (LONG64)false, "false" },
	{ (LONG64)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
	return soap_code_str(soap_codes_bool, n != 0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2bool(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_new_bool(struct soap *soap, int n)
{
	bool *a = static_cast<bool *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(bool)));
	for (bool *p = a; p && n--; ++p)
		soap_default_bool(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	if (soap_out_bool(soap, tag ? tag : "boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__DLCategory2[] =
{	{ (LONG64)ns1__DLCategory2__Security_x0020Master, "Security Master" },
	{ (LONG64)ns1__DLCategory2__Derived_x0020__x0020Intraday, "Derived - Intraday" },
	{ (LONG64)ns1__DLCategory2__Derived_x0020__x0020End_x0020of_x0020Day, "Derived - End of Day" },
	{ (LONG64)ns1__DLCategory2__Pricing_x0020__x0020Intraday, "Pricing - Intraday" },
	{ (LONG64)ns1__DLCategory2__Pricing_x0020__x0020End_x0020of_x0020Day, "Pricing - End of Day" },
	{ (LONG64)ns1__DLCategory2__User_x0020Entered_x0020Info_x002e, "User Entered Info." },
	{ (LONG64)ns1__DLCategory2__Corporate_x0020Actions, "Corporate Actions" },
	{ (LONG64)ns1__DLCategory2__Historical_x0020Time_x0020Series, "Historical Time Series" },
	{ (LONG64)ns1__DLCategory2__Estimates, "Estimates" },
	{ (LONG64)ns1__DLCategory2__Fundamentals, "Fundamentals" },
	{ (LONG64)ns1__DLCategory2__Quote_x0020Composite, "Quote Composite" },
	{ (LONG64)ns1__DLCategory2__Quote_x0020Composite_x0020History, "Quote Composite History" },
	{ (LONG64)ns1__DLCategory2__Credit_x0020Risk, "Credit Risk" },
	{ (LONG64)ns1__DLCategory2__Packaged, "Packaged" },
	{ (LONG64)ns1__DLCategory2__Open_x0020Source, "Open Source" },
	{ (LONG64)ns1__DLCategory2__Reg_x0020SSFA, "Reg SSFA" },
	{ (LONG64)ns1__DLCategory2__Volatility_x0020Surface, "Volatility Surface" },
	{ (LONG64)ns1__DLCategory2__Volatility_x0020Cube, "Volatility Cube" },
	{ (LONG64)ns1__DLCategory2__Bram_x0020Fair_x0020Value_x0020Hierarchy_x0020Leveling_x0020Tool, "Bram Fair Value Hierarchy Leveling Tool" },
	{ (LONG64)ns1__DLCategory2__Credit_x0020Risk_x0020Corporate_x0020Structure, "Credit Risk Corporate Structure" },
	{ (LONG64)ns1__DLCategory2__Credit_x0020Risk_x0020Capital_x0020Structure, "Credit Risk Capital Structure" },
	{ (LONG64)ns1__DLCategory2__Credit_x0020Risk_x0020Regulatory_x0020Compliance, "Credit Risk Regulatory Compliance" },
	{ (LONG64)ns1__DLCategory2__Premium_x0020BRAM_x0020Transparency, "Premium BRAM Transparency" },
	{ (LONG64)ns1__DLCategory2__Price_x0020Uncertainty, "Price Uncertainty" },
	{ (LONG64)ns1__DLCategory2__Not_x0020Downloadable, "Not Downloadable" },
	{ (LONG64)ns1__DLCategory2__Central_x0020Bank_x0020Eligibility, "Central Bank Eligibility" },
	{ (LONG64)ns1__DLCategory2__Covered_x0020Funds, "Covered Funds" },
	{ (LONG64)ns1__DLCategory2__High_x0020Quality_x0020Liquid_x0020Assets, "High Quality Liquid Assets" },
	{ (LONG64)ns1__DLCategory2__Liquidity_x0020Assessment, "Liquidity Assessment" },
	{ (LONG64)ns1__DLCategory2__MiFIR, "MiFIR" },
	{ (LONG64)ns1__DLCategory2__Default_x0020Risk, "Default Risk" },
	{ (LONG64)ns1__DLCategory2__IFRS_x00209_x0020SPPI, "IFRS 9 SPPI" },
	{ (LONG64)ns1__DLCategory2__Collateral_x0020Tagging, "Collateral Tagging" },
	{ (LONG64)ns1__DLCategory2__US_x0020Withholding_x0020Tax, "US Withholding Tax" },
	{ (LONG64)ns1__DLCategory2__Expected_x0020Credit_x0020Loss, "Expected Credit Loss" },
	{ (LONG64)ns1__DLCategory2__Basic_x0020Tax, "Basic Tax" },
	{ (LONG64)ns1__DLCategory2__Investor_x0020Protection, "Investor Protection" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__DLCategory22s(struct soap *soap, enum ns1__DLCategory2 n)
{
	const char *s = soap_code_str(soap_codes_ns1__DLCategory2, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DLCategory2(struct soap *soap, const char *tag, int id, const enum ns1__DLCategory2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DLCategory2), type) || soap_send(soap, soap_ns1__DLCategory22s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__DLCategory2(struct soap *soap, const char *s, enum ns1__DLCategory2 *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__DLCategory2, s);
	if (map)
		*a = (enum ns1__DLCategory2)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 36)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__DLCategory2)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__DLCategory2 * SOAP_FMAC4 soap_in_ns1__DLCategory2(struct soap *soap, const char *tag, enum ns1__DLCategory2 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__DLCategory2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DLCategory2, sizeof(enum ns1__DLCategory2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__DLCategory2(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__DLCategory2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DLCategory2, SOAP_TYPE_ns1__DLCategory2, sizeof(enum ns1__DLCategory2), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__DLCategory2 * SOAP_FMAC4 soap_new_ns1__DLCategory2(struct soap *soap, int n)
{
	enum ns1__DLCategory2 *a = static_cast<enum ns1__DLCategory2 *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__DLCategory2)));
	for (enum ns1__DLCategory2 *p = a; p && n--; ++p)
		soap_default_ns1__DLCategory2(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DLCategory2(struct soap *soap, const enum ns1__DLCategory2 *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DLCategory2(soap, tag ? tag : "ns1:DLCategory2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__DLCategory2 * SOAP_FMAC4 soap_get_ns1__DLCategory2(struct soap *soap, enum ns1__DLCategory2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DLCategory2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__DLCategory[] =
{	{ (LONG64)ns1__DLCategory__Security_x0020Master, "Security Master" },
	{ (LONG64)ns1__DLCategory__Derived_x0020Data, "Derived Data" },
	{ (LONG64)ns1__DLCategory__End_x0020of_x0020Day_x0020Pricing, "End of Day Pricing" },
	{ (LONG64)ns1__DLCategory__User_x0020Entered_x0020Info_x002e, "User Entered Info." },
	{ (LONG64)ns1__DLCategory__Corporate_x0020Actions, "Corporate Actions" },
	{ (LONG64)ns1__DLCategory__Historical_x0020Time_x0020Series, "Historical Time Series" },
	{ (LONG64)ns1__DLCategory__Estimates, "Estimates" },
	{ (LONG64)ns1__DLCategory__Fundamentals, "Fundamentals" },
	{ (LONG64)ns1__DLCategory__Quote_x0020Composite, "Quote Composite" },
	{ (LONG64)ns1__DLCategory__Credit_x0020Risk, "Credit Risk" },
	{ (LONG64)ns1__DLCategory__Reg_x0020SSFA, "Reg SSFA" },
	{ (LONG64)ns1__DLCategory__Bram_x0020Fair_x0020Value_x0020Hierarchy_x0020Leveling_x0020Tool, "Bram Fair Value Hierarchy Leveling Tool" },
	{ (LONG64)ns1__DLCategory__Premium_x0020BRAM_x0020Transparency, "Premium BRAM Transparency" },
	{ (LONG64)ns1__DLCategory__Price_x0020Uncertainty, "Price Uncertainty" },
	{ (LONG64)ns1__DLCategory__Not_x0020Downloadable, "Not Downloadable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__DLCategory2s(struct soap *soap, enum ns1__DLCategory n)
{
	const char *s = soap_code_str(soap_codes_ns1__DLCategory, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DLCategory(struct soap *soap, const char *tag, int id, const enum ns1__DLCategory *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DLCategory), type) || soap_send(soap, soap_ns1__DLCategory2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__DLCategory(struct soap *soap, const char *s, enum ns1__DLCategory *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__DLCategory, s);
	if (map)
		*a = (enum ns1__DLCategory)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 14)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__DLCategory)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__DLCategory * SOAP_FMAC4 soap_in_ns1__DLCategory(struct soap *soap, const char *tag, enum ns1__DLCategory *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__DLCategory*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DLCategory, sizeof(enum ns1__DLCategory), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__DLCategory(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__DLCategory *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DLCategory, SOAP_TYPE_ns1__DLCategory, sizeof(enum ns1__DLCategory), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__DLCategory * SOAP_FMAC4 soap_new_ns1__DLCategory(struct soap *soap, int n)
{
	enum ns1__DLCategory *a = static_cast<enum ns1__DLCategory *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__DLCategory)));
	for (enum ns1__DLCategory *p = a; p && n--; ++p)
		soap_default_ns1__DLCategory(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DLCategory(struct soap *soap, const enum ns1__DLCategory *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DLCategory(soap, tag ? tag : "ns1:DLCategory", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__DLCategory * SOAP_FMAC4 soap_get_ns1__DLCategory(struct soap *soap, enum ns1__DLCategory *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DLCategory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__BvalFieldMacro[] =
{	{ (LONG64)ns1__BvalFieldMacro__BVAL_USCOREALL, "BVAL_ALL" },
	{ (LONG64)ns1__BvalFieldMacro__BVAL_USCOREBOND, "BVAL_BOND" },
	{ (LONG64)ns1__BvalFieldMacro__BVAL_USCOREMTGE, "BVAL_MTGE" },
	{ (LONG64)ns1__BvalFieldMacro__BVAL_USCOREMUNI, "BVAL_MUNI" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__BvalFieldMacro2s(struct soap *soap, enum ns1__BvalFieldMacro n)
{
	const char *s = soap_code_str(soap_codes_ns1__BvalFieldMacro, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__BvalFieldMacro(struct soap *soap, const char *tag, int id, const enum ns1__BvalFieldMacro *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__BvalFieldMacro), type) || soap_send(soap, soap_ns1__BvalFieldMacro2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__BvalFieldMacro(struct soap *soap, const char *s, enum ns1__BvalFieldMacro *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__BvalFieldMacro, s);
	if (map)
		*a = (enum ns1__BvalFieldMacro)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__BvalFieldMacro)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__BvalFieldMacro * SOAP_FMAC4 soap_in_ns1__BvalFieldMacro(struct soap *soap, const char *tag, enum ns1__BvalFieldMacro *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__BvalFieldMacro*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__BvalFieldMacro, sizeof(enum ns1__BvalFieldMacro), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__BvalFieldMacro(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__BvalFieldMacro *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__BvalFieldMacro, SOAP_TYPE_ns1__BvalFieldMacro, sizeof(enum ns1__BvalFieldMacro), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__BvalFieldMacro * SOAP_FMAC4 soap_new_ns1__BvalFieldMacro(struct soap *soap, int n)
{
	enum ns1__BvalFieldMacro *a = static_cast<enum ns1__BvalFieldMacro *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__BvalFieldMacro)));
	for (enum ns1__BvalFieldMacro *p = a; p && n--; ++p)
		soap_default_ns1__BvalFieldMacro(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__BvalFieldMacro(struct soap *soap, const enum ns1__BvalFieldMacro *a, const char *tag, const char *type)
{
	if (soap_out_ns1__BvalFieldMacro(soap, tag ? tag : "ns1:BvalFieldMacro", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__BvalFieldMacro * SOAP_FMAC4 soap_get_ns1__BvalFieldMacro(struct soap *soap, enum ns1__BvalFieldMacro *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__BvalFieldMacro(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__FieldMacro[] =
{	{ (LONG64)ns1__FieldMacro__BO_USCORECREDIT_USCORERISK_USCORECOMPANY, "BO_CREDIT_RISK_COMPANY" },
	{ (LONG64)ns1__FieldMacro__BO_USCORECREDIT_USCORERISK_USCOREFITCH, "BO_CREDIT_RISK_FITCH" },
	{ (LONG64)ns1__FieldMacro__BO_USCORECREDIT_USCORERISK_USCOREMOODY, "BO_CREDIT_RISK_MOODY" },
	{ (LONG64)ns1__FieldMacro__BO_USCORECREDIT_USCORERISK_USCORERATINGS1, "BO_CREDIT_RISK_RATINGS1" },
	{ (LONG64)ns1__FieldMacro__BO_USCORECREDIT_USCORERISK_USCORERATINGS2, "BO_CREDIT_RISK_RATINGS2" },
	{ (LONG64)ns1__FieldMacro__BO_USCORECREDIT_USCORERISK_USCORESP, "BO_CREDIT_RISK_SP" },
	{ (LONG64)ns1__FieldMacro__BVAL_USCOREFVHL_USCOREREG_USCORETRANSPARENCY, "BVAL_FVHL_REG_TRANSPARENCY" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__FieldMacro2s(struct soap *soap, enum ns1__FieldMacro n)
{
	const char *s = soap_code_str(soap_codes_ns1__FieldMacro, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__FieldMacro(struct soap *soap, const char *tag, int id, const enum ns1__FieldMacro *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__FieldMacro), type) || soap_send(soap, soap_ns1__FieldMacro2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__FieldMacro(struct soap *soap, const char *s, enum ns1__FieldMacro *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__FieldMacro, s);
	if (map)
		*a = (enum ns1__FieldMacro)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 6)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__FieldMacro)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__FieldMacro * SOAP_FMAC4 soap_in_ns1__FieldMacro(struct soap *soap, const char *tag, enum ns1__FieldMacro *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__FieldMacro*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FieldMacro, sizeof(enum ns1__FieldMacro), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__FieldMacro(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__FieldMacro *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__FieldMacro, SOAP_TYPE_ns1__FieldMacro, sizeof(enum ns1__FieldMacro), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__FieldMacro * SOAP_FMAC4 soap_new_ns1__FieldMacro(struct soap *soap, int n)
{
	enum ns1__FieldMacro *a = static_cast<enum ns1__FieldMacro *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__FieldMacro)));
	for (enum ns1__FieldMacro *p = a; p && n--; ++p)
		soap_default_ns1__FieldMacro(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__FieldMacro(struct soap *soap, const enum ns1__FieldMacro *a, const char *tag, const char *type)
{
	if (soap_out_ns1__FieldMacro(soap, tag ? tag : "ns1:FieldMacro", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__FieldMacro * SOAP_FMAC4 soap_get_ns1__FieldMacro(struct soap *soap, enum ns1__FieldMacro *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__FieldMacro(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__RegSolvency[] =
{	{ (LONG64)ns1__RegSolvency__no, "no" },
	{ (LONG64)ns1__RegSolvency__packaged, "packaged" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__RegSolvency2s(struct soap *soap, enum ns1__RegSolvency n)
{
	const char *s = soap_code_str(soap_codes_ns1__RegSolvency, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RegSolvency(struct soap *soap, const char *tag, int id, const enum ns1__RegSolvency *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RegSolvency), type) || soap_send(soap, soap_ns1__RegSolvency2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__RegSolvency(struct soap *soap, const char *s, enum ns1__RegSolvency *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__RegSolvency, s);
	if (map)
		*a = (enum ns1__RegSolvency)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__RegSolvency)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__RegSolvency * SOAP_FMAC4 soap_in_ns1__RegSolvency(struct soap *soap, const char *tag, enum ns1__RegSolvency *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__RegSolvency*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RegSolvency, sizeof(enum ns1__RegSolvency), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__RegSolvency(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__RegSolvency *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RegSolvency, SOAP_TYPE_ns1__RegSolvency, sizeof(enum ns1__RegSolvency), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__RegSolvency * SOAP_FMAC4 soap_new_ns1__RegSolvency(struct soap *soap, int n)
{
	enum ns1__RegSolvency *a = static_cast<enum ns1__RegSolvency *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__RegSolvency)));
	for (enum ns1__RegSolvency *p = a; p && n--; ++p)
		soap_default_ns1__RegSolvency(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__RegSolvency(struct soap *soap, const enum ns1__RegSolvency *a, const char *tag, const char *type)
{
	if (soap_out_ns1__RegSolvency(soap, tag ? tag : "ns1:RegSolvency", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__RegSolvency * SOAP_FMAC4 soap_get_ns1__RegSolvency(struct soap *soap, enum ns1__RegSolvency *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RegSolvency(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__OtcBvalAction[] =
{	{ (LONG64)ns1__OtcBvalAction__insert, "insert" },
	{ (LONG64)ns1__OtcBvalAction__update, "update" },
	{ (LONG64)ns1__OtcBvalAction__unwind, "unwind" },
	{ (LONG64)ns1__OtcBvalAction__reprice, "reprice" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__OtcBvalAction2s(struct soap *soap, enum ns1__OtcBvalAction n)
{
	const char *s = soap_code_str(soap_codes_ns1__OtcBvalAction, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__OtcBvalAction(struct soap *soap, const char *tag, int id, const enum ns1__OtcBvalAction *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__OtcBvalAction), type) || soap_send(soap, soap_ns1__OtcBvalAction2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__OtcBvalAction(struct soap *soap, const char *s, enum ns1__OtcBvalAction *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__OtcBvalAction, s);
	if (map)
		*a = (enum ns1__OtcBvalAction)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__OtcBvalAction)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__OtcBvalAction * SOAP_FMAC4 soap_in_ns1__OtcBvalAction(struct soap *soap, const char *tag, enum ns1__OtcBvalAction *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__OtcBvalAction*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__OtcBvalAction, sizeof(enum ns1__OtcBvalAction), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__OtcBvalAction(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__OtcBvalAction *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__OtcBvalAction, SOAP_TYPE_ns1__OtcBvalAction, sizeof(enum ns1__OtcBvalAction), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__OtcBvalAction * SOAP_FMAC4 soap_new_ns1__OtcBvalAction(struct soap *soap, int n)
{
	enum ns1__OtcBvalAction *a = static_cast<enum ns1__OtcBvalAction *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__OtcBvalAction)));
	for (enum ns1__OtcBvalAction *p = a; p && n--; ++p)
		soap_default_ns1__OtcBvalAction(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__OtcBvalAction(struct soap *soap, const enum ns1__OtcBvalAction *a, const char *tag, const char *type)
{
	if (soap_out_ns1__OtcBvalAction(soap, tag ? tag : "ns1:OtcBvalAction", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__OtcBvalAction * SOAP_FMAC4 soap_get_ns1__OtcBvalAction(struct soap *soap, enum ns1__OtcBvalAction *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__OtcBvalAction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__ActionsDate[] =
{	{ (LONG64)ns1__ActionsDate__entry, "entry" },
	{ (LONG64)ns1__ActionsDate__effective, "effective" },
	{ (LONG64)ns1__ActionsDate__both, "both" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__ActionsDate2s(struct soap *soap, enum ns1__ActionsDate n)
{
	const char *s = soap_code_str(soap_codes_ns1__ActionsDate, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ActionsDate(struct soap *soap, const char *tag, int id, const enum ns1__ActionsDate *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ActionsDate), type) || soap_send(soap, soap_ns1__ActionsDate2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__ActionsDate(struct soap *soap, const char *s, enum ns1__ActionsDate *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__ActionsDate, s);
	if (map)
		*a = (enum ns1__ActionsDate)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__ActionsDate)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__ActionsDate * SOAP_FMAC4 soap_in_ns1__ActionsDate(struct soap *soap, const char *tag, enum ns1__ActionsDate *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__ActionsDate*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ActionsDate, sizeof(enum ns1__ActionsDate), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__ActionsDate(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__ActionsDate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ActionsDate, SOAP_TYPE_ns1__ActionsDate, sizeof(enum ns1__ActionsDate), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__ActionsDate * SOAP_FMAC4 soap_new_ns1__ActionsDate(struct soap *soap, int n)
{
	enum ns1__ActionsDate *a = static_cast<enum ns1__ActionsDate *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__ActionsDate)));
	for (enum ns1__ActionsDate *p = a; p && n--; ++p)
		soap_default_ns1__ActionsDate(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ActionsDate(struct soap *soap, const enum ns1__ActionsDate *a, const char *tag, const char *type)
{
	if (soap_out_ns1__ActionsDate(soap, tag ? tag : "ns1:ActionsDate", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__ActionsDate * SOAP_FMAC4 soap_get_ns1__ActionsDate(struct soap *soap, enum ns1__ActionsDate *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ActionsDate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__PortSecDes[] =
{	{ (LONG64)ns1__PortSecDes__adjusted, "adjusted" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__PortSecDes2s(struct soap *soap, enum ns1__PortSecDes n)
{
	const char *s = soap_code_str(soap_codes_ns1__PortSecDes, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PortSecDes(struct soap *soap, const char *tag, int id, const enum ns1__PortSecDes *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PortSecDes), type) || soap_send(soap, soap_ns1__PortSecDes2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__PortSecDes(struct soap *soap, const char *s, enum ns1__PortSecDes *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__PortSecDes, s);
	if (map)
		*a = (enum ns1__PortSecDes)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 0)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__PortSecDes)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__PortSecDes * SOAP_FMAC4 soap_in_ns1__PortSecDes(struct soap *soap, const char *tag, enum ns1__PortSecDes *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__PortSecDes*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PortSecDes, sizeof(enum ns1__PortSecDes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__PortSecDes(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__PortSecDes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PortSecDes, SOAP_TYPE_ns1__PortSecDes, sizeof(enum ns1__PortSecDes), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__PortSecDes * SOAP_FMAC4 soap_new_ns1__PortSecDes(struct soap *soap, int n)
{
	enum ns1__PortSecDes *a = static_cast<enum ns1__PortSecDes *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__PortSecDes)));
	for (enum ns1__PortSecDes *p = a; p && n--; ++p)
		soap_default_ns1__PortSecDes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__PortSecDes(struct soap *soap, const enum ns1__PortSecDes *a, const char *tag, const char *type)
{
	if (soap_out_ns1__PortSecDes(soap, tag ? tag : "ns1:PortSecDes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__PortSecDes * SOAP_FMAC4 soap_get_ns1__PortSecDes(struct soap *soap, enum ns1__PortSecDes *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PortSecDes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__CancelStatus[] =
{	{ (LONG64)ns1__CancelStatus__ERROR, "ERROR" },
	{ (LONG64)ns1__CancelStatus__NOT_x0020FOUND, "NOT FOUND" },
	{ (LONG64)ns1__CancelStatus__CANCELLED, "CANCELLED" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__CancelStatus2s(struct soap *soap, enum ns1__CancelStatus n)
{
	const char *s = soap_code_str(soap_codes_ns1__CancelStatus, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CancelStatus(struct soap *soap, const char *tag, int id, const enum ns1__CancelStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CancelStatus), type) || soap_send(soap, soap_ns1__CancelStatus2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__CancelStatus(struct soap *soap, const char *s, enum ns1__CancelStatus *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__CancelStatus, s);
	if (map)
		*a = (enum ns1__CancelStatus)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__CancelStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__CancelStatus * SOAP_FMAC4 soap_in_ns1__CancelStatus(struct soap *soap, const char *tag, enum ns1__CancelStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__CancelStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CancelStatus, sizeof(enum ns1__CancelStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__CancelStatus(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__CancelStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CancelStatus, SOAP_TYPE_ns1__CancelStatus, sizeof(enum ns1__CancelStatus), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__CancelStatus * SOAP_FMAC4 soap_new_ns1__CancelStatus(struct soap *soap, int n)
{
	enum ns1__CancelStatus *a = static_cast<enum ns1__CancelStatus *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__CancelStatus)));
	for (enum ns1__CancelStatus *p = a; p && n--; ++p)
		soap_default_ns1__CancelStatus(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__CancelStatus(struct soap *soap, const enum ns1__CancelStatus *a, const char *tag, const char *type)
{
	if (soap_out_ns1__CancelStatus(soap, tag ? tag : "ns1:CancelStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__CancelStatus * SOAP_FMAC4 soap_get_ns1__CancelStatus(struct soap *soap, enum ns1__CancelStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CancelStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__BvalSnapshot[] =
{	{ (LONG64)ns1__BvalSnapshot__ny4pm, "ny4pm" },
	{ (LONG64)ns1__BvalSnapshot__lo4pm, "lo4pm" },
	{ (LONG64)ns1__BvalSnapshot__to4pm, "to4pm" },
	{ (LONG64)ns1__BvalSnapshot__ny3pm, "ny3pm" },
	{ (LONG64)ns1__BvalSnapshot__lo3pm, "lo3pm" },
	{ (LONG64)ns1__BvalSnapshot__to3pm, "to3pm" },
	{ (LONG64)ns1__BvalSnapshot__lo12pm, "lo12pm" },
	{ (LONG64)ns1__BvalSnapshot__to5pm, "to5pm" },
	{ (LONG64)ns1__BvalSnapshot__sy5pm, "sy5pm" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__BvalSnapshot2s(struct soap *soap, enum ns1__BvalSnapshot n)
{
	const char *s = soap_code_str(soap_codes_ns1__BvalSnapshot, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__BvalSnapshot(struct soap *soap, const char *tag, int id, const enum ns1__BvalSnapshot *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__BvalSnapshot), type) || soap_send(soap, soap_ns1__BvalSnapshot2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__BvalSnapshot(struct soap *soap, const char *s, enum ns1__BvalSnapshot *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__BvalSnapshot, s);
	if (map)
		*a = (enum ns1__BvalSnapshot)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 8)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__BvalSnapshot)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__BvalSnapshot * SOAP_FMAC4 soap_in_ns1__BvalSnapshot(struct soap *soap, const char *tag, enum ns1__BvalSnapshot *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__BvalSnapshot*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__BvalSnapshot, sizeof(enum ns1__BvalSnapshot), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__BvalSnapshot(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__BvalSnapshot *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__BvalSnapshot, SOAP_TYPE_ns1__BvalSnapshot, sizeof(enum ns1__BvalSnapshot), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__BvalSnapshot * SOAP_FMAC4 soap_new_ns1__BvalSnapshot(struct soap *soap, int n)
{
	enum ns1__BvalSnapshot *a = static_cast<enum ns1__BvalSnapshot *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__BvalSnapshot)));
	for (enum ns1__BvalSnapshot *p = a; p && n--; ++p)
		soap_default_ns1__BvalSnapshot(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__BvalSnapshot(struct soap *soap, const enum ns1__BvalSnapshot *a, const char *tag, const char *type)
{
	if (soap_out_ns1__BvalSnapshot(soap, tag ? tag : "ns1:BvalSnapshot", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__BvalSnapshot * SOAP_FMAC4 soap_get_ns1__BvalSnapshot(struct soap *soap, enum ns1__BvalSnapshot *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__BvalSnapshot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__BvalTier[] =
{	{ (LONG64)ns1__BvalTier__1, "1" },
	{ (LONG64)ns1__BvalTier__2, "2" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__BvalTier2s(struct soap *soap, enum ns1__BvalTier n)
{
	const char *s = soap_code_str(soap_codes_ns1__BvalTier, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__BvalTier(struct soap *soap, const char *tag, int id, const enum ns1__BvalTier *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__BvalTier), type) || soap_send(soap, soap_ns1__BvalTier2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__BvalTier(struct soap *soap, const char *s, enum ns1__BvalTier *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__BvalTier, s);
	if (map)
		*a = (enum ns1__BvalTier)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__BvalTier)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__BvalTier * SOAP_FMAC4 soap_in_ns1__BvalTier(struct soap *soap, const char *tag, enum ns1__BvalTier *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__BvalTier*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__BvalTier, sizeof(enum ns1__BvalTier), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__BvalTier(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__BvalTier *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__BvalTier, SOAP_TYPE_ns1__BvalTier, sizeof(enum ns1__BvalTier), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__BvalTier * SOAP_FMAC4 soap_new_ns1__BvalTier(struct soap *soap, int n)
{
	enum ns1__BvalTier *a = static_cast<enum ns1__BvalTier *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__BvalTier)));
	for (enum ns1__BvalTier *p = a; p && n--; ++p)
		soap_default_ns1__BvalTier(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__BvalTier(struct soap *soap, const enum ns1__BvalTier *a, const char *tag, const char *type)
{
	if (soap_out_ns1__BvalTier(soap, tag ? tag : "ns1:BvalTier", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__BvalTier * SOAP_FMAC4 soap_get_ns1__BvalTier(struct soap *soap, enum ns1__BvalTier *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__BvalTier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__Periodicity[] =
{	{ (LONG64)ns1__Periodicity__y, "y" },
	{ (LONG64)ns1__Periodicity__q, "q" },
	{ (LONG64)ns1__Periodicity__s, "s" },
	{ (LONG64)ns1__Periodicity__a, "a" },
	{ (LONG64)ns1__Periodicity__c, "c" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__Periodicity2s(struct soap *soap, enum ns1__Periodicity n)
{
	const char *s = soap_code_str(soap_codes_ns1__Periodicity, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Periodicity(struct soap *soap, const char *tag, int id, const enum ns1__Periodicity *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Periodicity), type) || soap_send(soap, soap_ns1__Periodicity2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__Periodicity(struct soap *soap, const char *s, enum ns1__Periodicity *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__Periodicity, s);
	if (map)
		*a = (enum ns1__Periodicity)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 121)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__Periodicity)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__Periodicity * SOAP_FMAC4 soap_in_ns1__Periodicity(struct soap *soap, const char *tag, enum ns1__Periodicity *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__Periodicity*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Periodicity, sizeof(enum ns1__Periodicity), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__Periodicity(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__Periodicity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Periodicity, SOAP_TYPE_ns1__Periodicity, sizeof(enum ns1__Periodicity), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__Periodicity * SOAP_FMAC4 soap_new_ns1__Periodicity(struct soap *soap, int n)
{
	enum ns1__Periodicity *a = static_cast<enum ns1__Periodicity *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__Periodicity)));
	for (enum ns1__Periodicity *p = a; p && n--; ++p)
		soap_default_ns1__Periodicity(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Periodicity(struct soap *soap, const enum ns1__Periodicity *a, const char *tag, const char *type)
{
	if (soap_out_ns1__Periodicity(soap, tag ? tag : "ns1:Periodicity", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__Periodicity * SOAP_FMAC4 soap_get_ns1__Periodicity(struct soap *soap, enum ns1__Periodicity *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Periodicity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__FilingStatus[] =
{	{ (LONG64)ns1__FilingStatus__mostrecent, "mostrecent" },
	{ (LONG64)ns1__FilingStatus__prelim, "prelim" },
	{ (LONG64)ns1__FilingStatus__original, "original" },
	{ (LONG64)ns1__FilingStatus__restated, "restated" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__FilingStatus2s(struct soap *soap, enum ns1__FilingStatus n)
{
	const char *s = soap_code_str(soap_codes_ns1__FilingStatus, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__FilingStatus(struct soap *soap, const char *tag, int id, const enum ns1__FilingStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__FilingStatus), type) || soap_send(soap, soap_ns1__FilingStatus2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__FilingStatus(struct soap *soap, const char *s, enum ns1__FilingStatus *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__FilingStatus, s);
	if (map)
		*a = (enum ns1__FilingStatus)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__FilingStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__FilingStatus * SOAP_FMAC4 soap_in_ns1__FilingStatus(struct soap *soap, const char *tag, enum ns1__FilingStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__FilingStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FilingStatus, sizeof(enum ns1__FilingStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__FilingStatus(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__FilingStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__FilingStatus, SOAP_TYPE_ns1__FilingStatus, sizeof(enum ns1__FilingStatus), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__FilingStatus * SOAP_FMAC4 soap_new_ns1__FilingStatus(struct soap *soap, int n)
{
	enum ns1__FilingStatus *a = static_cast<enum ns1__FilingStatus *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__FilingStatus)));
	for (enum ns1__FilingStatus *p = a; p && n--; ++p)
		soap_default_ns1__FilingStatus(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__FilingStatus(struct soap *soap, const enum ns1__FilingStatus *a, const char *tag, const char *type)
{
	if (soap_out_ns1__FilingStatus(soap, tag ? tag : "ns1:FilingStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__FilingStatus * SOAP_FMAC4 soap_get_ns1__FilingStatus(struct soap *soap, enum ns1__FilingStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__FilingStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__HistOption[] =
{	{ (LONG64)ns1__HistOption__average, "average" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__HistOption2s(struct soap *soap, enum ns1__HistOption n)
{
	const char *s = soap_code_str(soap_codes_ns1__HistOption, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__HistOption(struct soap *soap, const char *tag, int id, const enum ns1__HistOption *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__HistOption), type) || soap_send(soap, soap_ns1__HistOption2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__HistOption(struct soap *soap, const char *s, enum ns1__HistOption *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__HistOption, s);
	if (map)
		*a = (enum ns1__HistOption)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 0)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__HistOption)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__HistOption * SOAP_FMAC4 soap_in_ns1__HistOption(struct soap *soap, const char *tag, enum ns1__HistOption *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__HistOption*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__HistOption, sizeof(enum ns1__HistOption), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__HistOption(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__HistOption *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__HistOption, SOAP_TYPE_ns1__HistOption, sizeof(enum ns1__HistOption), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__HistOption * SOAP_FMAC4 soap_new_ns1__HistOption(struct soap *soap, int n)
{
	enum ns1__HistOption *a = static_cast<enum ns1__HistOption *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__HistOption)));
	for (enum ns1__HistOption *p = a; p && n--; ++p)
		soap_default_ns1__HistOption(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__HistOption(struct soap *soap, const enum ns1__HistOption *a, const char *tag, const char *type)
{
	if (soap_out_ns1__HistOption(soap, tag ? tag : "ns1:HistOption", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__HistOption * SOAP_FMAC4 soap_get_ns1__HistOption(struct soap *soap, enum ns1__HistOption *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__HistOption(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__HistPeriod[] =
{	{ (LONG64)ns1__HistPeriod__daily, "daily" },
	{ (LONG64)ns1__HistPeriod__weekly, "weekly" },
	{ (LONG64)ns1__HistPeriod__monthly, "monthly" },
	{ (LONG64)ns1__HistPeriod__quarterly, "quarterly" },
	{ (LONG64)ns1__HistPeriod__yearly, "yearly" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__HistPeriod2s(struct soap *soap, enum ns1__HistPeriod n)
{
	const char *s = soap_code_str(soap_codes_ns1__HistPeriod, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__HistPeriod(struct soap *soap, const char *tag, int id, const enum ns1__HistPeriod *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__HistPeriod), type) || soap_send(soap, soap_ns1__HistPeriod2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__HistPeriod(struct soap *soap, const char *s, enum ns1__HistPeriod *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__HistPeriod, s);
	if (map)
		*a = (enum ns1__HistPeriod)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 4)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__HistPeriod)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__HistPeriod * SOAP_FMAC4 soap_in_ns1__HistPeriod(struct soap *soap, const char *tag, enum ns1__HistPeriod *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__HistPeriod*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__HistPeriod, sizeof(enum ns1__HistPeriod), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__HistPeriod(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__HistPeriod *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__HistPeriod, SOAP_TYPE_ns1__HistPeriod, sizeof(enum ns1__HistPeriod), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__HistPeriod * SOAP_FMAC4 soap_new_ns1__HistPeriod(struct soap *soap, int n)
{
	enum ns1__HistPeriod *a = static_cast<enum ns1__HistPeriod *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__HistPeriod)));
	for (enum ns1__HistPeriod *p = a; p && n--; ++p)
		soap_default_ns1__HistPeriod(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__HistPeriod(struct soap *soap, const enum ns1__HistPeriod *a, const char *tag, const char *type)
{
	if (soap_out_ns1__HistPeriod(soap, tag ? tag : "ns1:HistPeriod", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__HistPeriod * SOAP_FMAC4 soap_get_ns1__HistPeriod(struct soap *soap, enum ns1__HistPeriod *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__HistPeriod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__FieldType[] =
{	{ (LONG64)ns1__FieldType__Character, "Character" },
	{ (LONG64)ns1__FieldType__Numeric, "Numeric" },
	{ (LONG64)ns1__FieldType__Price, "Price" },
	{ (LONG64)ns1__FieldType__Security, "Security" },
	{ (LONG64)ns1__FieldType__Date, "Date" },
	{ (LONG64)ns1__FieldType__Time, "Time" },
	{ (LONG64)ns1__FieldType__Date_x002fTime, "Date/Time" },
	{ (LONG64)ns1__FieldType__Bulk, "Bulk" },
	{ (LONG64)ns1__FieldType__Month_x002fYear, "Month/Year" },
	{ (LONG64)ns1__FieldType__Boolean, "Boolean" },
	{ (LONG64)ns1__FieldType__Currency, "Currency" },
	{ (LONG64)ns1__FieldType__Integer, "Integer" },
	{ (LONG64)ns1__FieldType__Real, "Real" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__FieldType2s(struct soap *soap, enum ns1__FieldType n)
{
	const char *s = soap_code_str(soap_codes_ns1__FieldType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__FieldType(struct soap *soap, const char *tag, int id, const enum ns1__FieldType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__FieldType), type) || soap_send(soap, soap_ns1__FieldType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__FieldType(struct soap *soap, const char *s, enum ns1__FieldType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__FieldType, s);
	if (map)
		*a = (enum ns1__FieldType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 12)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__FieldType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__FieldType * SOAP_FMAC4 soap_in_ns1__FieldType(struct soap *soap, const char *tag, enum ns1__FieldType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__FieldType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FieldType, sizeof(enum ns1__FieldType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__FieldType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__FieldType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__FieldType, SOAP_TYPE_ns1__FieldType, sizeof(enum ns1__FieldType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__FieldType * SOAP_FMAC4 soap_new_ns1__FieldType(struct soap *soap, int n)
{
	enum ns1__FieldType *a = static_cast<enum ns1__FieldType *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__FieldType)));
	for (enum ns1__FieldType *p = a; p && n--; ++p)
		soap_default_ns1__FieldType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__FieldType(struct soap *soap, const enum ns1__FieldType *a, const char *tag, const char *type)
{
	if (soap_out_ns1__FieldType(soap, tag ? tag : "ns1:FieldType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__FieldType * SOAP_FMAC4 soap_get_ns1__FieldType(struct soap *soap, enum ns1__FieldType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__FieldType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__DateFormat[] =
{	{ (LONG64)ns1__DateFormat__mmddyy, "mmddyy" },
	{ (LONG64)ns1__DateFormat__yyddmm, "yyddmm" },
	{ (LONG64)ns1__DateFormat__mmyydd, "mmyydd" },
	{ (LONG64)ns1__DateFormat__ddmmyy, "ddmmyy" },
	{ (LONG64)ns1__DateFormat__yyyyddmm, "yyyyddmm" },
	{ (LONG64)ns1__DateFormat__mmyyyydd, "mmyyyydd" },
	{ (LONG64)ns1__DateFormat__yyyymmdd, "yyyymmdd" },
	{ (LONG64)ns1__DateFormat__yymmdd, "yymmdd" },
	{ (LONG64)ns1__DateFormat__ddyymm, "ddyymm" },
	{ (LONG64)ns1__DateFormat__mmddyyyy, "mmddyyyy" },
	{ (LONG64)ns1__DateFormat__yyyy_x002fmm_x002fdd, "yyyy/mm/dd" },
	{ (LONG64)ns1__DateFormat__ddyyyymm, "ddyyyymm" },
	{ (LONG64)ns1__DateFormat__dd_mmm_yy, "dd-mmm-yy" },
	{ (LONG64)ns1__DateFormat__ddmmyyyy, "ddmmyyyy" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__DateFormat2s(struct soap *soap, enum ns1__DateFormat n)
{
	const char *s = soap_code_str(soap_codes_ns1__DateFormat, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DateFormat(struct soap *soap, const char *tag, int id, const enum ns1__DateFormat *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DateFormat), type) || soap_send(soap, soap_ns1__DateFormat2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__DateFormat(struct soap *soap, const char *s, enum ns1__DateFormat *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__DateFormat, s);
	if (map)
		*a = (enum ns1__DateFormat)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 13)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__DateFormat)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__DateFormat * SOAP_FMAC4 soap_in_ns1__DateFormat(struct soap *soap, const char *tag, enum ns1__DateFormat *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__DateFormat*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DateFormat, sizeof(enum ns1__DateFormat), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__DateFormat(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__DateFormat *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DateFormat, SOAP_TYPE_ns1__DateFormat, sizeof(enum ns1__DateFormat), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__DateFormat * SOAP_FMAC4 soap_new_ns1__DateFormat(struct soap *soap, int n)
{
	enum ns1__DateFormat *a = static_cast<enum ns1__DateFormat *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__DateFormat)));
	for (enum ns1__DateFormat *p = a; p && n--; ++p)
		soap_default_ns1__DateFormat(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DateFormat(struct soap *soap, const enum ns1__DateFormat *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DateFormat(soap, tag ? tag : "ns1:DateFormat", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__DateFormat * SOAP_FMAC4 soap_get_ns1__DateFormat(struct soap *soap, enum ns1__DateFormat *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DateFormat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__DiffFlag[] =
{	{ (LONG64)ns1__DiffFlag__yes, "yes" },
	{ (LONG64)ns1__DiffFlag__no, "no" },
	{ (LONG64)ns1__DiffFlag__changes, "changes" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__DiffFlag2s(struct soap *soap, enum ns1__DiffFlag n)
{
	const char *s = soap_code_str(soap_codes_ns1__DiffFlag, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DiffFlag(struct soap *soap, const char *tag, int id, const enum ns1__DiffFlag *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DiffFlag), type) || soap_send(soap, soap_ns1__DiffFlag2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__DiffFlag(struct soap *soap, const char *s, enum ns1__DiffFlag *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__DiffFlag, s);
	if (map)
		*a = (enum ns1__DiffFlag)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__DiffFlag)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__DiffFlag * SOAP_FMAC4 soap_in_ns1__DiffFlag(struct soap *soap, const char *tag, enum ns1__DiffFlag *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__DiffFlag*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DiffFlag, sizeof(enum ns1__DiffFlag), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__DiffFlag(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__DiffFlag *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DiffFlag, SOAP_TYPE_ns1__DiffFlag, sizeof(enum ns1__DiffFlag), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__DiffFlag * SOAP_FMAC4 soap_new_ns1__DiffFlag(struct soap *soap, int n)
{
	enum ns1__DiffFlag *a = static_cast<enum ns1__DiffFlag *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__DiffFlag)));
	for (enum ns1__DiffFlag *p = a; p && n--; ++p)
		soap_default_ns1__DiffFlag(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DiffFlag(struct soap *soap, const enum ns1__DiffFlag *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DiffFlag(soap, tag ? tag : "ns1:DiffFlag", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__DiffFlag * SOAP_FMAC4 soap_get_ns1__DiffFlag(struct soap *soap, enum ns1__DiffFlag *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DiffFlag(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__Version[] =
{	{ (LONG64)ns1__Version__new_, "new" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__Version2s(struct soap *soap, enum ns1__Version n)
{
	const char *s = soap_code_str(soap_codes_ns1__Version, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Version(struct soap *soap, const char *tag, int id, const enum ns1__Version *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Version), type) || soap_send(soap, soap_ns1__Version2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__Version(struct soap *soap, const char *s, enum ns1__Version *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__Version, s);
	if (map)
		*a = (enum ns1__Version)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 0)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__Version)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__Version * SOAP_FMAC4 soap_in_ns1__Version(struct soap *soap, const char *tag, enum ns1__Version *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__Version*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Version, sizeof(enum ns1__Version), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__Version(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__Version *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Version, SOAP_TYPE_ns1__Version, sizeof(enum ns1__Version), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__Version * SOAP_FMAC4 soap_new_ns1__Version(struct soap *soap, int n)
{
	enum ns1__Version *a = static_cast<enum ns1__Version *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__Version)));
	for (enum ns1__Version *p = a; p && n--; ++p)
		soap_default_ns1__Version(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Version(struct soap *soap, const enum ns1__Version *a, const char *tag, const char *type)
{
	if (soap_out_ns1__Version(soap, tag ? tag : "ns1:Version", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__Version * SOAP_FMAC4 soap_get_ns1__Version(struct soap *soap, enum ns1__Version *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Version(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__ProgramFlag[] =
{	{ (LONG64)ns1__ProgramFlag__oneshot, "oneshot" },
	{ (LONG64)ns1__ProgramFlag__daily, "daily" },
	{ (LONG64)ns1__ProgramFlag__weekly, "weekly" },
	{ (LONG64)ns1__ProgramFlag__monthly, "monthly" },
	{ (LONG64)ns1__ProgramFlag__weekday, "weekday" },
	{ (LONG64)ns1__ProgramFlag__weekend, "weekend" },
	{ (LONG64)ns1__ProgramFlag__adhoc, "adhoc" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__ProgramFlag2s(struct soap *soap, enum ns1__ProgramFlag n)
{
	const char *s = soap_code_str(soap_codes_ns1__ProgramFlag, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ProgramFlag(struct soap *soap, const char *tag, int id, const enum ns1__ProgramFlag *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ProgramFlag), type) || soap_send(soap, soap_ns1__ProgramFlag2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__ProgramFlag(struct soap *soap, const char *s, enum ns1__ProgramFlag *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__ProgramFlag, s);
	if (map)
		*a = (enum ns1__ProgramFlag)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 6)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__ProgramFlag)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__ProgramFlag * SOAP_FMAC4 soap_in_ns1__ProgramFlag(struct soap *soap, const char *tag, enum ns1__ProgramFlag *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__ProgramFlag*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ProgramFlag, sizeof(enum ns1__ProgramFlag), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__ProgramFlag(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__ProgramFlag *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ProgramFlag, SOAP_TYPE_ns1__ProgramFlag, sizeof(enum ns1__ProgramFlag), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__ProgramFlag * SOAP_FMAC4 soap_new_ns1__ProgramFlag(struct soap *soap, int n)
{
	enum ns1__ProgramFlag *a = static_cast<enum ns1__ProgramFlag *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__ProgramFlag)));
	for (enum ns1__ProgramFlag *p = a; p && n--; ++p)
		soap_default_ns1__ProgramFlag(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ProgramFlag(struct soap *soap, const enum ns1__ProgramFlag *a, const char *tag, const char *type)
{
	if (soap_out_ns1__ProgramFlag(soap, tag ? tag : "ns1:ProgramFlag", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__ProgramFlag * SOAP_FMAC4 soap_get_ns1__ProgramFlag(struct soap *soap, enum ns1__ProgramFlag *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ProgramFlag(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__SpecialChar[] =
{	{ (LONG64)ns1__SpecialChar__fraction, "fraction" },
	{ (LONG64)ns1__SpecialChar__decimal, "decimal" },
	{ (LONG64)ns1__SpecialChar__altdecimal, "altdecimal" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__SpecialChar2s(struct soap *soap, enum ns1__SpecialChar n)
{
	const char *s = soap_code_str(soap_codes_ns1__SpecialChar, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SpecialChar(struct soap *soap, const char *tag, int id, const enum ns1__SpecialChar *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SpecialChar), type) || soap_send(soap, soap_ns1__SpecialChar2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__SpecialChar(struct soap *soap, const char *s, enum ns1__SpecialChar *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__SpecialChar, s);
	if (map)
		*a = (enum ns1__SpecialChar)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__SpecialChar)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__SpecialChar * SOAP_FMAC4 soap_in_ns1__SpecialChar(struct soap *soap, const char *tag, enum ns1__SpecialChar *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__SpecialChar*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SpecialChar, sizeof(enum ns1__SpecialChar), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__SpecialChar(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__SpecialChar *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SpecialChar, SOAP_TYPE_ns1__SpecialChar, sizeof(enum ns1__SpecialChar), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__SpecialChar * SOAP_FMAC4 soap_new_ns1__SpecialChar(struct soap *soap, int n)
{
	enum ns1__SpecialChar *a = static_cast<enum ns1__SpecialChar *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__SpecialChar)));
	for (enum ns1__SpecialChar *p = a; p && n--; ++p)
		soap_default_ns1__SpecialChar(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SpecialChar(struct soap *soap, const enum ns1__SpecialChar *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SpecialChar(soap, tag ? tag : "ns1:SpecialChar", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__SpecialChar * SOAP_FMAC4 soap_get_ns1__SpecialChar(struct soap *soap, enum ns1__SpecialChar *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SpecialChar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__InstrumentType[] =
{	{ (LONG64)ns1__InstrumentType__AUSTRIAN, "AUSTRIAN" },
	{ (LONG64)ns1__InstrumentType__BB_USCOREUNIQUE, "BB_UNIQUE" },
	{ (LONG64)ns1__InstrumentType__BB_USCOREGLOBAL, "BB_GLOBAL" },
	{ (LONG64)ns1__InstrumentType__BELGIAN, "BELGIAN" },
	{ (LONG64)ns1__InstrumentType__CATS, "CATS" },
	{ (LONG64)ns1__InstrumentType__CEDEL, "CEDEL" },
	{ (LONG64)ns1__InstrumentType__CINS, "CINS" },
	{ (LONG64)ns1__InstrumentType__COMMON_USCORENUMBER, "COMMON_NUMBER" },
	{ (LONG64)ns1__InstrumentType__CUSIP, "CUSIP" },
	{ (LONG64)ns1__InstrumentType__CZECH, "CZECH" },
	{ (LONG64)ns1__InstrumentType__DUTCH, "DUTCH" },
	{ (LONG64)ns1__InstrumentType__EUROCLEAR, "EUROCLEAR" },
	{ (LONG64)ns1__InstrumentType__FRENCH, "FRENCH" },
	{ (LONG64)ns1__InstrumentType__IRISH, "IRISH" },
	{ (LONG64)ns1__InstrumentType__ISIN, "ISIN" },
	{ (LONG64)ns1__InstrumentType__ISRAELI, "ISRAELI" },
	{ (LONG64)ns1__InstrumentType__ITALY, "ITALY" },
	{ (LONG64)ns1__InstrumentType__JAPAN, "JAPAN" },
	{ (LONG64)ns1__InstrumentType__LUXEMBOURG, "LUXEMBOURG" },
	{ (LONG64)ns1__InstrumentType__SEDOL, "SEDOL" },
	{ (LONG64)ns1__InstrumentType__SPAIN, "SPAIN" },
	{ (LONG64)ns1__InstrumentType__TICKER, "TICKER" },
	{ (LONG64)ns1__InstrumentType__VALOREN, "VALOREN" },
	{ (LONG64)ns1__InstrumentType__WPK, "WPK" },
	{ (LONG64)ns1__InstrumentType__BB_USCORECOMPANY, "BB_COMPANY" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__InstrumentType2s(struct soap *soap, enum ns1__InstrumentType n)
{
	const char *s = soap_code_str(soap_codes_ns1__InstrumentType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__InstrumentType(struct soap *soap, const char *tag, int id, const enum ns1__InstrumentType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__InstrumentType), type) || soap_send(soap, soap_ns1__InstrumentType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__InstrumentType(struct soap *soap, const char *s, enum ns1__InstrumentType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__InstrumentType, s);
	if (map)
		*a = (enum ns1__InstrumentType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 24)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__InstrumentType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__InstrumentType * SOAP_FMAC4 soap_in_ns1__InstrumentType(struct soap *soap, const char *tag, enum ns1__InstrumentType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__InstrumentType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__InstrumentType, sizeof(enum ns1__InstrumentType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__InstrumentType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__InstrumentType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__InstrumentType, SOAP_TYPE_ns1__InstrumentType, sizeof(enum ns1__InstrumentType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__InstrumentType * SOAP_FMAC4 soap_new_ns1__InstrumentType(struct soap *soap, int n)
{
	enum ns1__InstrumentType *a = static_cast<enum ns1__InstrumentType *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__InstrumentType)));
	for (enum ns1__InstrumentType *p = a; p && n--; ++p)
		soap_default_ns1__InstrumentType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__InstrumentType(struct soap *soap, const enum ns1__InstrumentType *a, const char *tag, const char *type)
{
	if (soap_out_ns1__InstrumentType(soap, tag ? tag : "ns1:InstrumentType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__InstrumentType * SOAP_FMAC4 soap_get_ns1__InstrumentType(struct soap *soap, enum ns1__InstrumentType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__InstrumentType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__SecondaryQualifierType[] =
{	{ (LONG64)ns1__SecondaryQualifierType__ACTIVE_USCOREPRICING, "ACTIVE_PRICING" },
	{ (LONG64)ns1__SecondaryQualifierType__COUNTRY, "COUNTRY" },
	{ (LONG64)ns1__SecondaryQualifierType__CPN_USCORETYP, "CPN_TYP" },
	{ (LONG64)ns1__SecondaryQualifierType__CRNCY, "CRNCY" },
	{ (LONG64)ns1__SecondaryQualifierType__EXCH_USCORETRADED, "EXCH_TRADED" },
	{ (LONG64)ns1__SecondaryQualifierType__MATURED, "MATURED" },
	{ (LONG64)ns1__SecondaryQualifierType__NET_USCORECPN, "NET_CPN" },
	{ (LONG64)ns1__SecondaryQualifierType__RATE, "RATE" },
	{ (LONG64)ns1__SecondaryQualifierType__RATING, "RATING" },
	{ (LONG64)ns1__SecondaryQualifierType__SECURITY_USCOREDES, "SECURITY_DES" },
	{ (LONG64)ns1__SecondaryQualifierType__SECURITY_USCORETYP, "SECURITY_TYP" },
	{ (LONG64)ns1__SecondaryQualifierType__SERIES, "SERIES" },
	{ (LONG64)ns1__SecondaryQualifierType__TICKER, "TICKER" },
	{ (LONG64)ns1__SecondaryQualifierType__WAC, "WAC" },
	{ (LONG64)ns1__SecondaryQualifierType__WALA, "WALA" },
	{ (LONG64)ns1__SecondaryQualifierType__WAM, "WAM" },
	{ (LONG64)ns1__SecondaryQualifierType__BVAL_USCOREOTC_USCOREFREQUENCY, "BVAL_OTC_FREQUENCY" },
	{ (LONG64)ns1__SecondaryQualifierType__BVAL_USCOREOTC_USCOREEXPIRED, "BVAL_OTC_EXPIRED" },
	{ (LONG64)ns1__SecondaryQualifierType__BVAL_USCOREOTC_USCOREASSET, "BVAL_OTC_ASSET" },
	{ (LONG64)ns1__SecondaryQualifierType__BVAL_USCOREOTC_USCORESNAPSHOT, "BVAL_OTC_SNAPSHOT" },
	{ (LONG64)ns1__SecondaryQualifierType__BVAL_USCOREOTC_USCOREUNWOUND, "BVAL_OTC_UNWOUND" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__SecondaryQualifierType2s(struct soap *soap, enum ns1__SecondaryQualifierType n)
{
	const char *s = soap_code_str(soap_codes_ns1__SecondaryQualifierType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SecondaryQualifierType(struct soap *soap, const char *tag, int id, const enum ns1__SecondaryQualifierType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SecondaryQualifierType), type) || soap_send(soap, soap_ns1__SecondaryQualifierType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__SecondaryQualifierType(struct soap *soap, const char *s, enum ns1__SecondaryQualifierType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__SecondaryQualifierType, s);
	if (map)
		*a = (enum ns1__SecondaryQualifierType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 20)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__SecondaryQualifierType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__SecondaryQualifierType * SOAP_FMAC4 soap_in_ns1__SecondaryQualifierType(struct soap *soap, const char *tag, enum ns1__SecondaryQualifierType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__SecondaryQualifierType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SecondaryQualifierType, sizeof(enum ns1__SecondaryQualifierType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__SecondaryQualifierType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__SecondaryQualifierType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SecondaryQualifierType, SOAP_TYPE_ns1__SecondaryQualifierType, sizeof(enum ns1__SecondaryQualifierType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__SecondaryQualifierType * SOAP_FMAC4 soap_new_ns1__SecondaryQualifierType(struct soap *soap, int n)
{
	enum ns1__SecondaryQualifierType *a = static_cast<enum ns1__SecondaryQualifierType *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__SecondaryQualifierType)));
	for (enum ns1__SecondaryQualifierType *p = a; p && n--; ++p)
		soap_default_ns1__SecondaryQualifierType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SecondaryQualifierType(struct soap *soap, const enum ns1__SecondaryQualifierType *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SecondaryQualifierType(soap, tag ? tag : "ns1:SecondaryQualifierType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__SecondaryQualifierType * SOAP_FMAC4 soap_get_ns1__SecondaryQualifierType(struct soap *soap, enum ns1__SecondaryQualifierType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SecondaryQualifierType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__SecondaryQualifierOperator[] =
{	{ (LONG64)ns1__SecondaryQualifierOperator__Equals, "Equals" },
	{ (LONG64)ns1__SecondaryQualifierOperator__NotEquals, "NotEquals" },
	{ (LONG64)ns1__SecondaryQualifierOperator__GreaterThan, "GreaterThan" },
	{ (LONG64)ns1__SecondaryQualifierOperator__LessThan, "LessThan" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__SecondaryQualifierOperator2s(struct soap *soap, enum ns1__SecondaryQualifierOperator n)
{
	const char *s = soap_code_str(soap_codes_ns1__SecondaryQualifierOperator, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SecondaryQualifierOperator(struct soap *soap, const char *tag, int id, const enum ns1__SecondaryQualifierOperator *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SecondaryQualifierOperator), type) || soap_send(soap, soap_ns1__SecondaryQualifierOperator2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__SecondaryQualifierOperator(struct soap *soap, const char *s, enum ns1__SecondaryQualifierOperator *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__SecondaryQualifierOperator, s);
	if (map)
		*a = (enum ns1__SecondaryQualifierOperator)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__SecondaryQualifierOperator)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__SecondaryQualifierOperator * SOAP_FMAC4 soap_in_ns1__SecondaryQualifierOperator(struct soap *soap, const char *tag, enum ns1__SecondaryQualifierOperator *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__SecondaryQualifierOperator*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SecondaryQualifierOperator, sizeof(enum ns1__SecondaryQualifierOperator), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__SecondaryQualifierOperator(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__SecondaryQualifierOperator *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SecondaryQualifierOperator, SOAP_TYPE_ns1__SecondaryQualifierOperator, sizeof(enum ns1__SecondaryQualifierOperator), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__SecondaryQualifierOperator * SOAP_FMAC4 soap_new_ns1__SecondaryQualifierOperator(struct soap *soap, int n)
{
	enum ns1__SecondaryQualifierOperator *a = static_cast<enum ns1__SecondaryQualifierOperator *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__SecondaryQualifierOperator)));
	for (enum ns1__SecondaryQualifierOperator *p = a; p && n--; ++p)
		soap_default_ns1__SecondaryQualifierOperator(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SecondaryQualifierOperator(struct soap *soap, const enum ns1__SecondaryQualifierOperator *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SecondaryQualifierOperator(soap, tag ? tag : "ns1:SecondaryQualifierOperator", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__SecondaryQualifierOperator * SOAP_FMAC4 soap_get_ns1__SecondaryQualifierOperator(struct soap *soap, enum ns1__SecondaryQualifierOperator *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SecondaryQualifierOperator(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__MacroType[] =
{	{ (LONG64)ns1__MacroType__BOND_USCORESRCH, "BOND_SRCH" },
	{ (LONG64)ns1__MacroType__EQUITY_USCORESRCH, "EQUITY_SRCH" },
	{ (LONG64)ns1__MacroType__EXCH, "EXCH" },
	{ (LONG64)ns1__MacroType__INDEX, "INDEX" },
	{ (LONG64)ns1__MacroType__PFD_USCORESRCH, "PFD_SRCH" },
	{ (LONG64)ns1__MacroType__PORTFOLIO, "PORTFOLIO" },
	{ (LONG64)ns1__MacroType__SECTYP, "SECTYP" },
	{ (LONG64)ns1__MacroType__BSRCH, "BSRCH" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__MacroType2s(struct soap *soap, enum ns1__MacroType n)
{
	const char *s = soap_code_str(soap_codes_ns1__MacroType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MacroType(struct soap *soap, const char *tag, int id, const enum ns1__MacroType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MacroType), type) || soap_send(soap, soap_ns1__MacroType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__MacroType(struct soap *soap, const char *s, enum ns1__MacroType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__MacroType, s);
	if (map)
		*a = (enum ns1__MacroType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 7)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__MacroType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__MacroType * SOAP_FMAC4 soap_in_ns1__MacroType(struct soap *soap, const char *tag, enum ns1__MacroType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__MacroType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MacroType, sizeof(enum ns1__MacroType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__MacroType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__MacroType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MacroType, SOAP_TYPE_ns1__MacroType, sizeof(enum ns1__MacroType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__MacroType * SOAP_FMAC4 soap_new_ns1__MacroType(struct soap *soap, int n)
{
	enum ns1__MacroType *a = static_cast<enum ns1__MacroType *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__MacroType)));
	for (enum ns1__MacroType *p = a; p && n--; ++p)
		soap_default_ns1__MacroType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__MacroType(struct soap *soap, const enum ns1__MacroType *a, const char *tag, const char *type)
{
	if (soap_out_ns1__MacroType(soap, tag ? tag : "ns1:MacroType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__MacroType * SOAP_FMAC4 soap_get_ns1__MacroType(struct soap *soap, enum ns1__MacroType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MacroType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__MarketSector[] =
{	{ (LONG64)ns1__MarketSector__Govt, "Govt" },
	{ (LONG64)ns1__MarketSector__Corp, "Corp" },
	{ (LONG64)ns1__MarketSector__Mtge, "Mtge" },
	{ (LONG64)ns1__MarketSector__M_Mkt, "M-Mkt" },
	{ (LONG64)ns1__MarketSector__Muni, "Muni" },
	{ (LONG64)ns1__MarketSector__Pfd, "Pfd" },
	{ (LONG64)ns1__MarketSector__Equity, "Equity" },
	{ (LONG64)ns1__MarketSector__Comdty, "Comdty" },
	{ (LONG64)ns1__MarketSector__Index, "Index" },
	{ (LONG64)ns1__MarketSector__Curncy, "Curncy" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__MarketSector2s(struct soap *soap, enum ns1__MarketSector n)
{
	const char *s = soap_code_str(soap_codes_ns1__MarketSector, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MarketSector(struct soap *soap, const char *tag, int id, const enum ns1__MarketSector *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MarketSector), type) || soap_send(soap, soap_ns1__MarketSector2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__MarketSector(struct soap *soap, const char *s, enum ns1__MarketSector *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__MarketSector, s);
	if (map)
		*a = (enum ns1__MarketSector)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 9)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__MarketSector)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__MarketSector * SOAP_FMAC4 soap_in_ns1__MarketSector(struct soap *soap, const char *tag, enum ns1__MarketSector *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__MarketSector*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MarketSector, sizeof(enum ns1__MarketSector), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__MarketSector(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__MarketSector *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MarketSector, SOAP_TYPE_ns1__MarketSector, sizeof(enum ns1__MarketSector), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__MarketSector * SOAP_FMAC4 soap_new_ns1__MarketSector(struct soap *soap, int n)
{
	enum ns1__MarketSector *a = static_cast<enum ns1__MarketSector *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__MarketSector)));
	for (enum ns1__MarketSector *p = a; p && n--; ++p)
		soap_default_ns1__MarketSector(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__MarketSector(struct soap *soap, const enum ns1__MarketSector *a, const char *tag, const char *type)
{
	if (soap_out_ns1__MarketSector(soap, tag ? tag : "ns1:MarketSector", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__MarketSector * SOAP_FMAC4 soap_get_ns1__MarketSector(struct soap *soap, enum ns1__MarketSector *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MarketSector(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__RetrieveMmktBvalDealsUploadResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__PerSecurityResponse::soap_default(soap);
	soap_default_std__string(soap, &this->ns1__RetrieveMmktBvalDealsUploadResponse::responseId);
	this->ns1__RetrieveMmktBvalDealsUploadResponse::timestarted = NULL;
	this->ns1__RetrieveMmktBvalDealsUploadResponse::deals = NULL;
	this->ns1__RetrieveMmktBvalDealsUploadResponse::timefinished = NULL;
}

void ns1__RetrieveMmktBvalDealsUploadResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__RetrieveMmktBvalDealsUploadResponse::responseId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__RetrieveMmktBvalDealsUploadResponse::responseId);
	soap_serialize_PointerTodateTime(soap, &this->ns1__RetrieveMmktBvalDealsUploadResponse::timestarted);
	soap_serialize_PointerTons1__MmktBvalDealInfos(soap, &this->ns1__RetrieveMmktBvalDealsUploadResponse::deals);
	soap_serialize_PointerTodateTime(soap, &this->ns1__RetrieveMmktBvalDealsUploadResponse::timefinished);
	this->ns1__PerSecurityResponse::soap_serialize(soap);
#endif
}

int ns1__RetrieveMmktBvalDealsUploadResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RetrieveMmktBvalDealsUploadResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RetrieveMmktBvalDealsUploadResponse(struct soap *soap, const char *tag, int id, const ns1__RetrieveMmktBvalDealsUploadResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RetrieveMmktBvalDealsUploadResponse), type ? type : "ns1:RetrieveMmktBvalDealsUploadResponse"))
		return soap->error;
	if (!a->ns1__PerSecurityResponse::statusCode)
	{	if (soap_element_empty(soap, "ns1:statusCode", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__ResponseStatus(soap, "ns1:statusCode", -1, &a->ns1__PerSecurityResponse::statusCode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:requestId", -1, &a->ns1__PerSecurityResponse::requestId, ""))
		return soap->error;
	soap_element_result(soap, "ns1:responseId");
	if (soap_out_std__string(soap, "ns1:responseId", -1, &a->ns1__RetrieveMmktBvalDealsUploadResponse::responseId, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns1:timestarted", -1, &a->ns1__RetrieveMmktBvalDealsUploadResponse::timestarted, ""))
		return soap->error;
	if (soap_out_PointerTons1__MmktBvalDealInfos(soap, "ns1:deals", -1, &a->ns1__RetrieveMmktBvalDealsUploadResponse::deals, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns1:timefinished", -1, &a->ns1__RetrieveMmktBvalDealsUploadResponse::timefinished, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__RetrieveMmktBvalDealsUploadResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__RetrieveMmktBvalDealsUploadResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RetrieveMmktBvalDealsUploadResponse * SOAP_FMAC4 soap_in_ns1__RetrieveMmktBvalDealsUploadResponse(struct soap *soap, const char *tag, ns1__RetrieveMmktBvalDealsUploadResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RetrieveMmktBvalDealsUploadResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RetrieveMmktBvalDealsUploadResponse, sizeof(ns1__RetrieveMmktBvalDealsUploadResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__RetrieveMmktBvalDealsUploadResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__RetrieveMmktBvalDealsUploadResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_statusCode2 = 1;
	size_t soap_flag_requestId2 = 1;
	size_t soap_flag_responseId1 = 1;
	size_t soap_flag_timestarted1 = 1;
	size_t soap_flag_deals1 = 1;
	size_t soap_flag_timefinished1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ResponseStatus(soap, "ns1:statusCode", &a->ns1__PerSecurityResponse::statusCode, "ns1:ResponseStatus"))
				{	soap_flag_statusCode2--;
					continue;
				}
			}
			if (soap_flag_requestId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:requestId", &a->ns1__PerSecurityResponse::requestId, "xsd:string"))
				{	soap_flag_requestId2--;
					continue;
				}
			}
			if (soap_flag_responseId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:responseId", &a->ns1__RetrieveMmktBvalDealsUploadResponse::responseId, "xsd:string"))
				{	soap_flag_responseId1--;
					continue;
				}
			}
			if (soap_flag_timestarted1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns1:timestarted", &a->ns1__RetrieveMmktBvalDealsUploadResponse::timestarted, "xsd:dateTime"))
				{	soap_flag_timestarted1--;
					continue;
				}
			}
			if (soap_flag_deals1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__MmktBvalDealInfos(soap, "ns1:deals", &a->ns1__RetrieveMmktBvalDealsUploadResponse::deals, "ns1:MmktBvalDealInfos"))
				{	soap_flag_deals1--;
					continue;
				}
			}
			if (soap_flag_timefinished1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns1:timefinished", &a->ns1__RetrieveMmktBvalDealsUploadResponse::timefinished, "xsd:dateTime"))
				{	soap_flag_timefinished1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:responseId");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__PerSecurityResponse::statusCode || soap_flag_requestId2 > 0 || soap_flag_responseId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__RetrieveMmktBvalDealsUploadResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RetrieveMmktBvalDealsUploadResponse, SOAP_TYPE_ns1__RetrieveMmktBvalDealsUploadResponse, sizeof(ns1__RetrieveMmktBvalDealsUploadResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__RetrieveMmktBvalDealsUploadResponse * SOAP_FMAC2 soap_instantiate_ns1__RetrieveMmktBvalDealsUploadResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RetrieveMmktBvalDealsUploadResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__RetrieveMmktBvalDealsUploadResponse *p;
	size_t k = sizeof(ns1__RetrieveMmktBvalDealsUploadResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__RetrieveMmktBvalDealsUploadResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__RetrieveMmktBvalDealsUploadResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__RetrieveMmktBvalDealsUploadResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__RetrieveMmktBvalDealsUploadResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__RetrieveMmktBvalDealsUploadResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__RetrieveMmktBvalDealsUploadResponse(soap, tag ? tag : "ns1:RetrieveMmktBvalDealsUploadResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__RetrieveMmktBvalDealsUploadResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RetrieveMmktBvalDealsUploadResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RetrieveMmktBvalDealsUploadResponse * SOAP_FMAC4 soap_get_ns1__RetrieveMmktBvalDealsUploadResponse(struct soap *soap, ns1__RetrieveMmktBvalDealsUploadResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RetrieveMmktBvalDealsUploadResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__MmktBvalDealInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__MmktBvalDealInformation(soap, &this->ns1__MmktBvalDealInfos::deal);
}

void ns1__MmktBvalDealInfos::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__MmktBvalDealInformation(soap, &this->ns1__MmktBvalDealInfos::deal);
#endif
}

int ns1__MmktBvalDealInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__MmktBvalDealInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MmktBvalDealInfos(struct soap *soap, const char *tag, int id, const ns1__MmktBvalDealInfos *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MmktBvalDealInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__MmktBvalDealInformation(soap, "ns1:deal", -1, &a->ns1__MmktBvalDealInfos::deal, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__MmktBvalDealInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__MmktBvalDealInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns1__MmktBvalDealInfos * SOAP_FMAC4 soap_in_ns1__MmktBvalDealInfos(struct soap *soap, const char *tag, ns1__MmktBvalDealInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__MmktBvalDealInfos*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MmktBvalDealInfos, sizeof(ns1__MmktBvalDealInfos), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__MmktBvalDealInfos)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__MmktBvalDealInfos *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__MmktBvalDealInformation(soap, "ns1:deal", &a->ns1__MmktBvalDealInfos::deal, "ns1:MmktBvalDealInformation"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__MmktBvalDealInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MmktBvalDealInfos, SOAP_TYPE_ns1__MmktBvalDealInfos, sizeof(ns1__MmktBvalDealInfos), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__MmktBvalDealInfos * SOAP_FMAC2 soap_instantiate_ns1__MmktBvalDealInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__MmktBvalDealInfos(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__MmktBvalDealInfos *p;
	size_t k = sizeof(ns1__MmktBvalDealInfos);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__MmktBvalDealInfos, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__MmktBvalDealInfos);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__MmktBvalDealInfos, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__MmktBvalDealInfos location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__MmktBvalDealInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__MmktBvalDealInfos(soap, tag ? tag : "ns1:MmktBvalDealInfos", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__MmktBvalDealInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__MmktBvalDealInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns1__MmktBvalDealInfos * SOAP_FMAC4 soap_get_ns1__MmktBvalDealInfos(struct soap *soap, ns1__MmktBvalDealInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MmktBvalDealInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__MmktBvalDealInformation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__MmktBvalDealInformation::statusCode = NULL;
	this->ns1__MmktBvalDealInformation::clientDealId = NULL;
	this->ns1__MmktBvalDealInformation::bbDealId = NULL;
	this->ns1__MmktBvalDealInformation::dtcCusip = NULL;
	this->ns1__MmktBvalDealInformation::ticker = NULL;
	this->ns1__MmktBvalDealInformation::programType = NULL;
	this->ns1__MmktBvalDealInformation::currency = NULL;
	this->ns1__MmktBvalDealInformation::maturity = NULL;
}

void ns1__MmktBvalDealInformation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ResponseStatus(soap, &this->ns1__MmktBvalDealInformation::statusCode);
	soap_serialize_PointerTostd__string(soap, &this->ns1__MmktBvalDealInformation::clientDealId);
	soap_serialize_PointerTostd__string(soap, &this->ns1__MmktBvalDealInformation::bbDealId);
	soap_serialize_PointerTostd__string(soap, &this->ns1__MmktBvalDealInformation::dtcCusip);
	soap_serialize_PointerTostd__string(soap, &this->ns1__MmktBvalDealInformation::ticker);
	soap_serialize_PointerTostd__string(soap, &this->ns1__MmktBvalDealInformation::programType);
	soap_serialize_PointerTostd__string(soap, &this->ns1__MmktBvalDealInformation::currency);
	soap_serialize_PointerToxsd__date(soap, &this->ns1__MmktBvalDealInformation::maturity);
#endif
}

int ns1__MmktBvalDealInformation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__MmktBvalDealInformation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MmktBvalDealInformation(struct soap *soap, const char *tag, int id, const ns1__MmktBvalDealInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MmktBvalDealInformation), type))
		return soap->error;
	if (!a->ns1__MmktBvalDealInformation::statusCode)
	{	if (soap_element_empty(soap, "ns1:statusCode", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__ResponseStatus(soap, "ns1:statusCode", -1, &a->ns1__MmktBvalDealInformation::statusCode, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:clientDealId", -1, &a->ns1__MmktBvalDealInformation::clientDealId, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:bbDealId", -1, &a->ns1__MmktBvalDealInformation::bbDealId, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:dtcCusip", -1, &a->ns1__MmktBvalDealInformation::dtcCusip, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:ticker", -1, &a->ns1__MmktBvalDealInformation::ticker, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:programType", -1, &a->ns1__MmktBvalDealInformation::programType, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:currency", -1, &a->ns1__MmktBvalDealInformation::currency, ""))
		return soap->error;
	if (soap_out_PointerToxsd__date(soap, "ns1:maturity", -1, &a->ns1__MmktBvalDealInformation::maturity, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__MmktBvalDealInformation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__MmktBvalDealInformation(soap, tag, this, type);
}

SOAP_FMAC3 ns1__MmktBvalDealInformation * SOAP_FMAC4 soap_in_ns1__MmktBvalDealInformation(struct soap *soap, const char *tag, ns1__MmktBvalDealInformation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__MmktBvalDealInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MmktBvalDealInformation, sizeof(ns1__MmktBvalDealInformation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__MmktBvalDealInformation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__MmktBvalDealInformation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_statusCode1 = 1;
	size_t soap_flag_clientDealId1 = 1;
	size_t soap_flag_bbDealId1 = 1;
	size_t soap_flag_dtcCusip1 = 1;
	size_t soap_flag_ticker1 = 1;
	size_t soap_flag_programType1 = 1;
	size_t soap_flag_currency1 = 1;
	size_t soap_flag_maturity1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusCode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ResponseStatus(soap, "ns1:statusCode", &a->ns1__MmktBvalDealInformation::statusCode, "ns1:ResponseStatus"))
				{	soap_flag_statusCode1--;
					continue;
				}
			}
			if (soap_flag_clientDealId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:clientDealId", &a->ns1__MmktBvalDealInformation::clientDealId, "xsd:string"))
				{	soap_flag_clientDealId1--;
					continue;
				}
			}
			if (soap_flag_bbDealId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:bbDealId", &a->ns1__MmktBvalDealInformation::bbDealId, "xsd:string"))
				{	soap_flag_bbDealId1--;
					continue;
				}
			}
			if (soap_flag_dtcCusip1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:dtcCusip", &a->ns1__MmktBvalDealInformation::dtcCusip, "xsd:string"))
				{	soap_flag_dtcCusip1--;
					continue;
				}
			}
			if (soap_flag_ticker1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:ticker", &a->ns1__MmktBvalDealInformation::ticker, "xsd:string"))
				{	soap_flag_ticker1--;
					continue;
				}
			}
			if (soap_flag_programType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:programType", &a->ns1__MmktBvalDealInformation::programType, "xsd:string"))
				{	soap_flag_programType1--;
					continue;
				}
			}
			if (soap_flag_currency1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:currency", &a->ns1__MmktBvalDealInformation::currency, "xsd:string"))
				{	soap_flag_currency1--;
					continue;
				}
			}
			if (soap_flag_maturity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__date(soap, "ns1:maturity", &a->ns1__MmktBvalDealInformation::maturity, "xsd:date"))
				{	soap_flag_maturity1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__MmktBvalDealInformation::statusCode))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__MmktBvalDealInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MmktBvalDealInformation, SOAP_TYPE_ns1__MmktBvalDealInformation, sizeof(ns1__MmktBvalDealInformation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__MmktBvalDealInformation * SOAP_FMAC2 soap_instantiate_ns1__MmktBvalDealInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__MmktBvalDealInformation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__MmktBvalDealInformation *p;
	size_t k = sizeof(ns1__MmktBvalDealInformation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__MmktBvalDealInformation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__MmktBvalDealInformation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__MmktBvalDealInformation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__MmktBvalDealInformation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__MmktBvalDealInformation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__MmktBvalDealInformation(soap, tag ? tag : "ns1:MmktBvalDealInformation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__MmktBvalDealInformation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__MmktBvalDealInformation(soap, this, tag, type);
}

SOAP_FMAC3 ns1__MmktBvalDealInformation * SOAP_FMAC4 soap_get_ns1__MmktBvalDealInformation(struct soap *soap, ns1__MmktBvalDealInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MmktBvalDealInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__RetrieveMmktBvalDealsUploadRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__RetrieveMmktBvalDealsUploadRequest::responseId);
	this->ns1__RetrieveMmktBvalDealsUploadRequest::responseDate = NULL;
}

void ns1__RetrieveMmktBvalDealsUploadRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__RetrieveMmktBvalDealsUploadRequest::responseId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__RetrieveMmktBvalDealsUploadRequest::responseId);
	soap_serialize_PointerToxsd__date(soap, &this->ns1__RetrieveMmktBvalDealsUploadRequest::responseDate);
#endif
}

int ns1__RetrieveMmktBvalDealsUploadRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RetrieveMmktBvalDealsUploadRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RetrieveMmktBvalDealsUploadRequest(struct soap *soap, const char *tag, int id, const ns1__RetrieveMmktBvalDealsUploadRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RetrieveMmktBvalDealsUploadRequest), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:responseId", -1, &a->ns1__RetrieveMmktBvalDealsUploadRequest::responseId, ""))
		return soap->error;
	if (soap_out_PointerToxsd__date(soap, "ns1:responseDate", -1, &a->ns1__RetrieveMmktBvalDealsUploadRequest::responseDate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__RetrieveMmktBvalDealsUploadRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__RetrieveMmktBvalDealsUploadRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RetrieveMmktBvalDealsUploadRequest * SOAP_FMAC4 soap_in_ns1__RetrieveMmktBvalDealsUploadRequest(struct soap *soap, const char *tag, ns1__RetrieveMmktBvalDealsUploadRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RetrieveMmktBvalDealsUploadRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RetrieveMmktBvalDealsUploadRequest, sizeof(ns1__RetrieveMmktBvalDealsUploadRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__RetrieveMmktBvalDealsUploadRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__RetrieveMmktBvalDealsUploadRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_responseId1 = 1;
	size_t soap_flag_responseDate1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_responseId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:responseId", &a->ns1__RetrieveMmktBvalDealsUploadRequest::responseId, "xsd:string"))
				{	soap_flag_responseId1--;
					continue;
				}
			}
			if (soap_flag_responseDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__date(soap, "ns1:responseDate", &a->ns1__RetrieveMmktBvalDealsUploadRequest::responseDate, "xsd:date"))
				{	soap_flag_responseDate1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_responseId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__RetrieveMmktBvalDealsUploadRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RetrieveMmktBvalDealsUploadRequest, SOAP_TYPE_ns1__RetrieveMmktBvalDealsUploadRequest, sizeof(ns1__RetrieveMmktBvalDealsUploadRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__RetrieveMmktBvalDealsUploadRequest * SOAP_FMAC2 soap_instantiate_ns1__RetrieveMmktBvalDealsUploadRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RetrieveMmktBvalDealsUploadRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__RetrieveMmktBvalDealsUploadRequest *p;
	size_t k = sizeof(ns1__RetrieveMmktBvalDealsUploadRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__RetrieveMmktBvalDealsUploadRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__RetrieveMmktBvalDealsUploadRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__RetrieveMmktBvalDealsUploadRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__RetrieveMmktBvalDealsUploadRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__RetrieveMmktBvalDealsUploadRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__RetrieveMmktBvalDealsUploadRequest(soap, tag ? tag : "ns1:RetrieveMmktBvalDealsUploadRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__RetrieveMmktBvalDealsUploadRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RetrieveMmktBvalDealsUploadRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RetrieveMmktBvalDealsUploadRequest * SOAP_FMAC4 soap_get_ns1__RetrieveMmktBvalDealsUploadRequest(struct soap *soap, ns1__RetrieveMmktBvalDealsUploadRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RetrieveMmktBvalDealsUploadRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__SubmitMmktBvalDealsUploadResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__PerSecurityResponse::soap_default(soap);
	soap_default_std__string(soap, &this->ns1__SubmitMmktBvalDealsUploadResponse::responseId);
}

void ns1__SubmitMmktBvalDealsUploadResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__SubmitMmktBvalDealsUploadResponse::responseId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__SubmitMmktBvalDealsUploadResponse::responseId);
	this->ns1__PerSecurityResponse::soap_serialize(soap);
#endif
}

int ns1__SubmitMmktBvalDealsUploadResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SubmitMmktBvalDealsUploadResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SubmitMmktBvalDealsUploadResponse(struct soap *soap, const char *tag, int id, const ns1__SubmitMmktBvalDealsUploadResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SubmitMmktBvalDealsUploadResponse), type ? type : "ns1:SubmitMmktBvalDealsUploadResponse"))
		return soap->error;
	if (!a->ns1__PerSecurityResponse::statusCode)
	{	if (soap_element_empty(soap, "ns1:statusCode", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__ResponseStatus(soap, "ns1:statusCode", -1, &a->ns1__PerSecurityResponse::statusCode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:requestId", -1, &a->ns1__PerSecurityResponse::requestId, ""))
		return soap->error;
	soap_element_result(soap, "ns1:responseId");
	if (soap_out_std__string(soap, "ns1:responseId", -1, &a->ns1__SubmitMmktBvalDealsUploadResponse::responseId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SubmitMmktBvalDealsUploadResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__SubmitMmktBvalDealsUploadResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SubmitMmktBvalDealsUploadResponse * SOAP_FMAC4 soap_in_ns1__SubmitMmktBvalDealsUploadResponse(struct soap *soap, const char *tag, ns1__SubmitMmktBvalDealsUploadResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SubmitMmktBvalDealsUploadResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SubmitMmktBvalDealsUploadResponse, sizeof(ns1__SubmitMmktBvalDealsUploadResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__SubmitMmktBvalDealsUploadResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__SubmitMmktBvalDealsUploadResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_statusCode2 = 1;
	size_t soap_flag_requestId2 = 1;
	size_t soap_flag_responseId1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ResponseStatus(soap, "ns1:statusCode", &a->ns1__PerSecurityResponse::statusCode, "ns1:ResponseStatus"))
				{	soap_flag_statusCode2--;
					continue;
				}
			}
			if (soap_flag_requestId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:requestId", &a->ns1__PerSecurityResponse::requestId, "xsd:string"))
				{	soap_flag_requestId2--;
					continue;
				}
			}
			if (soap_flag_responseId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:responseId", &a->ns1__SubmitMmktBvalDealsUploadResponse::responseId, "xsd:string"))
				{	soap_flag_responseId1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:responseId");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__PerSecurityResponse::statusCode || soap_flag_requestId2 > 0 || soap_flag_responseId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__SubmitMmktBvalDealsUploadResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SubmitMmktBvalDealsUploadResponse, SOAP_TYPE_ns1__SubmitMmktBvalDealsUploadResponse, sizeof(ns1__SubmitMmktBvalDealsUploadResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__SubmitMmktBvalDealsUploadResponse * SOAP_FMAC2 soap_instantiate_ns1__SubmitMmktBvalDealsUploadResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SubmitMmktBvalDealsUploadResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__SubmitMmktBvalDealsUploadResponse *p;
	size_t k = sizeof(ns1__SubmitMmktBvalDealsUploadResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__SubmitMmktBvalDealsUploadResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__SubmitMmktBvalDealsUploadResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__SubmitMmktBvalDealsUploadResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__SubmitMmktBvalDealsUploadResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__SubmitMmktBvalDealsUploadResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__SubmitMmktBvalDealsUploadResponse(soap, tag ? tag : "ns1:SubmitMmktBvalDealsUploadResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SubmitMmktBvalDealsUploadResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SubmitMmktBvalDealsUploadResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SubmitMmktBvalDealsUploadResponse * SOAP_FMAC4 soap_get_ns1__SubmitMmktBvalDealsUploadResponse(struct soap *soap, ns1__SubmitMmktBvalDealsUploadResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SubmitMmktBvalDealsUploadResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__SubmitMmktBvalDealsUploadRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__SubmitMmktBvalDealsUploadRequest::usernumber);
	this->ns1__SubmitMmktBvalDealsUploadRequest::mmktBvalHeaders = NULL;
	soap_default_std__string(soap, &this->ns1__SubmitMmktBvalDealsUploadRequest::fileContent);
}

void ns1__SubmitMmktBvalDealsUploadRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__SubmitMmktBvalDealsUploadRequest::usernumber, SOAP_TYPE_int);
	soap_serialize_PointerTons1__MmktBvalHeaders(soap, &this->ns1__SubmitMmktBvalDealsUploadRequest::mmktBvalHeaders);
	soap_embedded(soap, &this->ns1__SubmitMmktBvalDealsUploadRequest::fileContent, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__SubmitMmktBvalDealsUploadRequest::fileContent);
#endif
}

int ns1__SubmitMmktBvalDealsUploadRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SubmitMmktBvalDealsUploadRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SubmitMmktBvalDealsUploadRequest(struct soap *soap, const char *tag, int id, const ns1__SubmitMmktBvalDealsUploadRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SubmitMmktBvalDealsUploadRequest), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:usernumber", -1, &a->ns1__SubmitMmktBvalDealsUploadRequest::usernumber, ""))
		return soap->error;
	if (!a->ns1__SubmitMmktBvalDealsUploadRequest::mmktBvalHeaders)
	{	if (soap_element_empty(soap, "ns1:mmktBvalHeaders", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__MmktBvalHeaders(soap, "ns1:mmktBvalHeaders", -1, &a->ns1__SubmitMmktBvalDealsUploadRequest::mmktBvalHeaders, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:fileContent", -1, &a->ns1__SubmitMmktBvalDealsUploadRequest::fileContent, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SubmitMmktBvalDealsUploadRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__SubmitMmktBvalDealsUploadRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SubmitMmktBvalDealsUploadRequest * SOAP_FMAC4 soap_in_ns1__SubmitMmktBvalDealsUploadRequest(struct soap *soap, const char *tag, ns1__SubmitMmktBvalDealsUploadRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SubmitMmktBvalDealsUploadRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SubmitMmktBvalDealsUploadRequest, sizeof(ns1__SubmitMmktBvalDealsUploadRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__SubmitMmktBvalDealsUploadRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__SubmitMmktBvalDealsUploadRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_usernumber1 = 1;
	size_t soap_flag_mmktBvalHeaders1 = 1;
	size_t soap_flag_fileContent1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_usernumber1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:usernumber", &a->ns1__SubmitMmktBvalDealsUploadRequest::usernumber, "xsd:int"))
				{	soap_flag_usernumber1--;
					continue;
				}
			}
			if (soap_flag_mmktBvalHeaders1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__MmktBvalHeaders(soap, "ns1:mmktBvalHeaders", &a->ns1__SubmitMmktBvalDealsUploadRequest::mmktBvalHeaders, "ns1:MmktBvalHeaders"))
				{	soap_flag_mmktBvalHeaders1--;
					continue;
				}
			}
			if (soap_flag_fileContent1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:fileContent", &a->ns1__SubmitMmktBvalDealsUploadRequest::fileContent, "xsd:string"))
				{	soap_flag_fileContent1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_usernumber1 > 0 || !a->ns1__SubmitMmktBvalDealsUploadRequest::mmktBvalHeaders || soap_flag_fileContent1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__SubmitMmktBvalDealsUploadRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SubmitMmktBvalDealsUploadRequest, SOAP_TYPE_ns1__SubmitMmktBvalDealsUploadRequest, sizeof(ns1__SubmitMmktBvalDealsUploadRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__SubmitMmktBvalDealsUploadRequest * SOAP_FMAC2 soap_instantiate_ns1__SubmitMmktBvalDealsUploadRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SubmitMmktBvalDealsUploadRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__SubmitMmktBvalDealsUploadRequest *p;
	size_t k = sizeof(ns1__SubmitMmktBvalDealsUploadRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__SubmitMmktBvalDealsUploadRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__SubmitMmktBvalDealsUploadRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__SubmitMmktBvalDealsUploadRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__SubmitMmktBvalDealsUploadRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__SubmitMmktBvalDealsUploadRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__SubmitMmktBvalDealsUploadRequest(soap, tag ? tag : "ns1:SubmitMmktBvalDealsUploadRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SubmitMmktBvalDealsUploadRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SubmitMmktBvalDealsUploadRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SubmitMmktBvalDealsUploadRequest * SOAP_FMAC4 soap_get_ns1__SubmitMmktBvalDealsUploadRequest(struct soap *soap, ns1__SubmitMmktBvalDealsUploadRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SubmitMmktBvalDealsUploadRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__MmktBvalHeaders::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__MmktBvalHeaders::contentType);
	soap_default_std__string(soap, &this->ns1__MmktBvalHeaders::mimeVersion);
	soap_default_std__string(soap, &this->ns1__MmktBvalHeaders::contentEncoding);
	soap_default_std__string(soap, &this->ns1__MmktBvalHeaders::contentDisposition);
	soap_default_std__string(soap, &this->ns1__MmktBvalHeaders::fileName);
}

void ns1__MmktBvalHeaders::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__MmktBvalHeaders::contentType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__MmktBvalHeaders::contentType);
	soap_embedded(soap, &this->ns1__MmktBvalHeaders::mimeVersion, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__MmktBvalHeaders::mimeVersion);
	soap_embedded(soap, &this->ns1__MmktBvalHeaders::contentEncoding, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__MmktBvalHeaders::contentEncoding);
	soap_embedded(soap, &this->ns1__MmktBvalHeaders::contentDisposition, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__MmktBvalHeaders::contentDisposition);
	soap_embedded(soap, &this->ns1__MmktBvalHeaders::fileName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__MmktBvalHeaders::fileName);
#endif
}

int ns1__MmktBvalHeaders::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__MmktBvalHeaders(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MmktBvalHeaders(struct soap *soap, const char *tag, int id, const ns1__MmktBvalHeaders *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MmktBvalHeaders), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:contentType", -1, &a->ns1__MmktBvalHeaders::contentType, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:mimeVersion", -1, &a->ns1__MmktBvalHeaders::mimeVersion, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:contentEncoding", -1, &a->ns1__MmktBvalHeaders::contentEncoding, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:contentDisposition", -1, &a->ns1__MmktBvalHeaders::contentDisposition, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:fileName", -1, &a->ns1__MmktBvalHeaders::fileName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__MmktBvalHeaders::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__MmktBvalHeaders(soap, tag, this, type);
}

SOAP_FMAC3 ns1__MmktBvalHeaders * SOAP_FMAC4 soap_in_ns1__MmktBvalHeaders(struct soap *soap, const char *tag, ns1__MmktBvalHeaders *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__MmktBvalHeaders*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MmktBvalHeaders, sizeof(ns1__MmktBvalHeaders), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__MmktBvalHeaders)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__MmktBvalHeaders *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_contentType1 = 1;
	size_t soap_flag_mimeVersion1 = 1;
	size_t soap_flag_contentEncoding1 = 1;
	size_t soap_flag_contentDisposition1 = 1;
	size_t soap_flag_fileName1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_contentType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:contentType", &a->ns1__MmktBvalHeaders::contentType, "xsd:string"))
				{	soap_flag_contentType1--;
					continue;
				}
			}
			if (soap_flag_mimeVersion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:mimeVersion", &a->ns1__MmktBvalHeaders::mimeVersion, "xsd:string"))
				{	soap_flag_mimeVersion1--;
					continue;
				}
			}
			if (soap_flag_contentEncoding1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:contentEncoding", &a->ns1__MmktBvalHeaders::contentEncoding, "xsd:string"))
				{	soap_flag_contentEncoding1--;
					continue;
				}
			}
			if (soap_flag_contentDisposition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:contentDisposition", &a->ns1__MmktBvalHeaders::contentDisposition, "xsd:string"))
				{	soap_flag_contentDisposition1--;
					continue;
				}
			}
			if (soap_flag_fileName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:fileName", &a->ns1__MmktBvalHeaders::fileName, "xsd:string"))
				{	soap_flag_fileName1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_contentType1 > 0 || soap_flag_mimeVersion1 > 0 || soap_flag_contentEncoding1 > 0 || soap_flag_contentDisposition1 > 0 || soap_flag_fileName1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__MmktBvalHeaders *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MmktBvalHeaders, SOAP_TYPE_ns1__MmktBvalHeaders, sizeof(ns1__MmktBvalHeaders), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__MmktBvalHeaders * SOAP_FMAC2 soap_instantiate_ns1__MmktBvalHeaders(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__MmktBvalHeaders(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__MmktBvalHeaders *p;
	size_t k = sizeof(ns1__MmktBvalHeaders);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__MmktBvalHeaders, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__MmktBvalHeaders);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__MmktBvalHeaders, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__MmktBvalHeaders location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__MmktBvalHeaders::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__MmktBvalHeaders(soap, tag ? tag : "ns1:MmktBvalHeaders", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__MmktBvalHeaders::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__MmktBvalHeaders(soap, this, tag, type);
}

SOAP_FMAC3 ns1__MmktBvalHeaders * SOAP_FMAC4 soap_get_ns1__MmktBvalHeaders(struct soap *soap, ns1__MmktBvalHeaders *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MmktBvalHeaders(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__GetFieldsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__PerSecurityResponse::soap_default(soap);
	this->ns1__GetFieldsResponse::fields = NULL;
}

void ns1__GetFieldsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__FieldInfos(soap, &this->ns1__GetFieldsResponse::fields);
	this->ns1__PerSecurityResponse::soap_serialize(soap);
#endif
}

int ns1__GetFieldsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__GetFieldsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetFieldsResponse(struct soap *soap, const char *tag, int id, const ns1__GetFieldsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetFieldsResponse), type ? type : "ns1:GetFieldsResponse"))
		return soap->error;
	if (!a->ns1__PerSecurityResponse::statusCode)
	{	if (soap_element_empty(soap, "ns1:statusCode", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__ResponseStatus(soap, "ns1:statusCode", -1, &a->ns1__PerSecurityResponse::statusCode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:requestId", -1, &a->ns1__PerSecurityResponse::requestId, ""))
		return soap->error;
	if (a->fields)
		soap_element_result(soap, "ns1:fields");
	if (soap_out_PointerTons1__FieldInfos(soap, "ns1:fields", -1, &a->ns1__GetFieldsResponse::fields, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__GetFieldsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__GetFieldsResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__GetFieldsResponse * SOAP_FMAC4 soap_in_ns1__GetFieldsResponse(struct soap *soap, const char *tag, ns1__GetFieldsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__GetFieldsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetFieldsResponse, sizeof(ns1__GetFieldsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__GetFieldsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__GetFieldsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_statusCode2 = 1;
	size_t soap_flag_requestId2 = 1;
	size_t soap_flag_fields1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ResponseStatus(soap, "ns1:statusCode", &a->ns1__PerSecurityResponse::statusCode, "ns1:ResponseStatus"))
				{	soap_flag_statusCode2--;
					continue;
				}
			}
			if (soap_flag_requestId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:requestId", &a->ns1__PerSecurityResponse::requestId, "xsd:string"))
				{	soap_flag_requestId2--;
					continue;
				}
			}
			if (soap_flag_fields1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__FieldInfos(soap, "ns1:fields", &a->ns1__GetFieldsResponse::fields, "ns1:FieldInfos"))
				{	soap_flag_fields1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:fields");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__PerSecurityResponse::statusCode || soap_flag_requestId2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__GetFieldsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetFieldsResponse, SOAP_TYPE_ns1__GetFieldsResponse, sizeof(ns1__GetFieldsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__GetFieldsResponse * SOAP_FMAC2 soap_instantiate_ns1__GetFieldsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetFieldsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__GetFieldsResponse *p;
	size_t k = sizeof(ns1__GetFieldsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetFieldsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__GetFieldsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__GetFieldsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__GetFieldsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__GetFieldsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__GetFieldsResponse(soap, tag ? tag : "ns1:GetFieldsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__GetFieldsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__GetFieldsResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__GetFieldsResponse * SOAP_FMAC4 soap_get_ns1__GetFieldsResponse(struct soap *soap, ns1__GetFieldsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetFieldsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__GetFieldsRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__GetFieldsRequest::criteria = NULL;
}

void ns1__GetFieldsRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__FieldSearchCriteria(soap, &this->ns1__GetFieldsRequest::criteria);
#endif
}

int ns1__GetFieldsRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__GetFieldsRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetFieldsRequest(struct soap *soap, const char *tag, int id, const ns1__GetFieldsRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetFieldsRequest), type))
		return soap->error;
	if (!a->ns1__GetFieldsRequest::criteria)
	{	if (soap_element_empty(soap, "ns1:criteria", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__FieldSearchCriteria(soap, "ns1:criteria", -1, &a->ns1__GetFieldsRequest::criteria, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__GetFieldsRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__GetFieldsRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__GetFieldsRequest * SOAP_FMAC4 soap_in_ns1__GetFieldsRequest(struct soap *soap, const char *tag, ns1__GetFieldsRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__GetFieldsRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetFieldsRequest, sizeof(ns1__GetFieldsRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__GetFieldsRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__GetFieldsRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_criteria1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_criteria1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__FieldSearchCriteria(soap, "ns1:criteria", &a->ns1__GetFieldsRequest::criteria, "ns1:FieldSearchCriteria"))
				{	soap_flag_criteria1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__GetFieldsRequest::criteria))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__GetFieldsRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetFieldsRequest, SOAP_TYPE_ns1__GetFieldsRequest, sizeof(ns1__GetFieldsRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__GetFieldsRequest * SOAP_FMAC2 soap_instantiate_ns1__GetFieldsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetFieldsRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__GetFieldsRequest *p;
	size_t k = sizeof(ns1__GetFieldsRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetFieldsRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__GetFieldsRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__GetFieldsRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__GetFieldsRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__GetFieldsRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__GetFieldsRequest(soap, tag ? tag : "ns1:GetFieldsRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__GetFieldsRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__GetFieldsRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__GetFieldsRequest * SOAP_FMAC4 soap_get_ns1__GetFieldsRequest(struct soap *soap, ns1__GetFieldsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetFieldsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__RetrieveOtcBvalDealsUploadResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__PerSecurityResponse::soap_default(soap);
	soap_default_std__string(soap, &this->ns1__RetrieveOtcBvalDealsUploadResponse::responseId);
	this->ns1__RetrieveOtcBvalDealsUploadResponse::timestarted = NULL;
	this->ns1__RetrieveOtcBvalDealsUploadResponse::deals = NULL;
	this->ns1__RetrieveOtcBvalDealsUploadResponse::timefinished = NULL;
}

void ns1__RetrieveOtcBvalDealsUploadResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__RetrieveOtcBvalDealsUploadResponse::responseId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__RetrieveOtcBvalDealsUploadResponse::responseId);
	soap_serialize_PointerTodateTime(soap, &this->ns1__RetrieveOtcBvalDealsUploadResponse::timestarted);
	soap_serialize_PointerTons1__OtcDealInfos(soap, &this->ns1__RetrieveOtcBvalDealsUploadResponse::deals);
	soap_serialize_PointerTodateTime(soap, &this->ns1__RetrieveOtcBvalDealsUploadResponse::timefinished);
	this->ns1__PerSecurityResponse::soap_serialize(soap);
#endif
}

int ns1__RetrieveOtcBvalDealsUploadResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RetrieveOtcBvalDealsUploadResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RetrieveOtcBvalDealsUploadResponse(struct soap *soap, const char *tag, int id, const ns1__RetrieveOtcBvalDealsUploadResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RetrieveOtcBvalDealsUploadResponse), type ? type : "ns1:RetrieveOtcBvalDealsUploadResponse"))
		return soap->error;
	if (!a->ns1__PerSecurityResponse::statusCode)
	{	if (soap_element_empty(soap, "ns1:statusCode", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__ResponseStatus(soap, "ns1:statusCode", -1, &a->ns1__PerSecurityResponse::statusCode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:requestId", -1, &a->ns1__PerSecurityResponse::requestId, ""))
		return soap->error;
	soap_element_result(soap, "ns1:responseId");
	if (soap_out_std__string(soap, "ns1:responseId", -1, &a->ns1__RetrieveOtcBvalDealsUploadResponse::responseId, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns1:timestarted", -1, &a->ns1__RetrieveOtcBvalDealsUploadResponse::timestarted, ""))
		return soap->error;
	if (soap_out_PointerTons1__OtcDealInfos(soap, "ns1:deals", -1, &a->ns1__RetrieveOtcBvalDealsUploadResponse::deals, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns1:timefinished", -1, &a->ns1__RetrieveOtcBvalDealsUploadResponse::timefinished, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__RetrieveOtcBvalDealsUploadResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__RetrieveOtcBvalDealsUploadResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RetrieveOtcBvalDealsUploadResponse * SOAP_FMAC4 soap_in_ns1__RetrieveOtcBvalDealsUploadResponse(struct soap *soap, const char *tag, ns1__RetrieveOtcBvalDealsUploadResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RetrieveOtcBvalDealsUploadResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RetrieveOtcBvalDealsUploadResponse, sizeof(ns1__RetrieveOtcBvalDealsUploadResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__RetrieveOtcBvalDealsUploadResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__RetrieveOtcBvalDealsUploadResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_statusCode2 = 1;
	size_t soap_flag_requestId2 = 1;
	size_t soap_flag_responseId1 = 1;
	size_t soap_flag_timestarted1 = 1;
	size_t soap_flag_deals1 = 1;
	size_t soap_flag_timefinished1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ResponseStatus(soap, "ns1:statusCode", &a->ns1__PerSecurityResponse::statusCode, "ns1:ResponseStatus"))
				{	soap_flag_statusCode2--;
					continue;
				}
			}
			if (soap_flag_requestId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:requestId", &a->ns1__PerSecurityResponse::requestId, "xsd:string"))
				{	soap_flag_requestId2--;
					continue;
				}
			}
			if (soap_flag_responseId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:responseId", &a->ns1__RetrieveOtcBvalDealsUploadResponse::responseId, "xsd:string"))
				{	soap_flag_responseId1--;
					continue;
				}
			}
			if (soap_flag_timestarted1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns1:timestarted", &a->ns1__RetrieveOtcBvalDealsUploadResponse::timestarted, "xsd:dateTime"))
				{	soap_flag_timestarted1--;
					continue;
				}
			}
			if (soap_flag_deals1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__OtcDealInfos(soap, "ns1:deals", &a->ns1__RetrieveOtcBvalDealsUploadResponse::deals, "ns1:OtcDealInfos"))
				{	soap_flag_deals1--;
					continue;
				}
			}
			if (soap_flag_timefinished1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns1:timefinished", &a->ns1__RetrieveOtcBvalDealsUploadResponse::timefinished, "xsd:dateTime"))
				{	soap_flag_timefinished1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:responseId");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__PerSecurityResponse::statusCode || soap_flag_requestId2 > 0 || soap_flag_responseId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__RetrieveOtcBvalDealsUploadResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RetrieveOtcBvalDealsUploadResponse, SOAP_TYPE_ns1__RetrieveOtcBvalDealsUploadResponse, sizeof(ns1__RetrieveOtcBvalDealsUploadResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__RetrieveOtcBvalDealsUploadResponse * SOAP_FMAC2 soap_instantiate_ns1__RetrieveOtcBvalDealsUploadResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RetrieveOtcBvalDealsUploadResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__RetrieveOtcBvalDealsUploadResponse *p;
	size_t k = sizeof(ns1__RetrieveOtcBvalDealsUploadResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__RetrieveOtcBvalDealsUploadResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__RetrieveOtcBvalDealsUploadResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__RetrieveOtcBvalDealsUploadResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__RetrieveOtcBvalDealsUploadResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__RetrieveOtcBvalDealsUploadResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__RetrieveOtcBvalDealsUploadResponse(soap, tag ? tag : "ns1:RetrieveOtcBvalDealsUploadResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__RetrieveOtcBvalDealsUploadResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RetrieveOtcBvalDealsUploadResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RetrieveOtcBvalDealsUploadResponse * SOAP_FMAC4 soap_get_ns1__RetrieveOtcBvalDealsUploadResponse(struct soap *soap, ns1__RetrieveOtcBvalDealsUploadResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RetrieveOtcBvalDealsUploadResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__RetrieveOtcBvalDealsUploadRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__RetrieveOtcBvalDealsUploadRequest::responseId);
	this->ns1__RetrieveOtcBvalDealsUploadRequest::responseDate = NULL;
}

void ns1__RetrieveOtcBvalDealsUploadRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__RetrieveOtcBvalDealsUploadRequest::responseId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__RetrieveOtcBvalDealsUploadRequest::responseId);
	soap_serialize_PointerToxsd__date(soap, &this->ns1__RetrieveOtcBvalDealsUploadRequest::responseDate);
#endif
}

int ns1__RetrieveOtcBvalDealsUploadRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RetrieveOtcBvalDealsUploadRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RetrieveOtcBvalDealsUploadRequest(struct soap *soap, const char *tag, int id, const ns1__RetrieveOtcBvalDealsUploadRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RetrieveOtcBvalDealsUploadRequest), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:responseId", -1, &a->ns1__RetrieveOtcBvalDealsUploadRequest::responseId, ""))
		return soap->error;
	if (soap_out_PointerToxsd__date(soap, "ns1:responseDate", -1, &a->ns1__RetrieveOtcBvalDealsUploadRequest::responseDate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__RetrieveOtcBvalDealsUploadRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__RetrieveOtcBvalDealsUploadRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RetrieveOtcBvalDealsUploadRequest * SOAP_FMAC4 soap_in_ns1__RetrieveOtcBvalDealsUploadRequest(struct soap *soap, const char *tag, ns1__RetrieveOtcBvalDealsUploadRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RetrieveOtcBvalDealsUploadRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RetrieveOtcBvalDealsUploadRequest, sizeof(ns1__RetrieveOtcBvalDealsUploadRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__RetrieveOtcBvalDealsUploadRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__RetrieveOtcBvalDealsUploadRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_responseId1 = 1;
	size_t soap_flag_responseDate1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_responseId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:responseId", &a->ns1__RetrieveOtcBvalDealsUploadRequest::responseId, "xsd:string"))
				{	soap_flag_responseId1--;
					continue;
				}
			}
			if (soap_flag_responseDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__date(soap, "ns1:responseDate", &a->ns1__RetrieveOtcBvalDealsUploadRequest::responseDate, "xsd:date"))
				{	soap_flag_responseDate1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_responseId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__RetrieveOtcBvalDealsUploadRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RetrieveOtcBvalDealsUploadRequest, SOAP_TYPE_ns1__RetrieveOtcBvalDealsUploadRequest, sizeof(ns1__RetrieveOtcBvalDealsUploadRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__RetrieveOtcBvalDealsUploadRequest * SOAP_FMAC2 soap_instantiate_ns1__RetrieveOtcBvalDealsUploadRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RetrieveOtcBvalDealsUploadRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__RetrieveOtcBvalDealsUploadRequest *p;
	size_t k = sizeof(ns1__RetrieveOtcBvalDealsUploadRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__RetrieveOtcBvalDealsUploadRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__RetrieveOtcBvalDealsUploadRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__RetrieveOtcBvalDealsUploadRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__RetrieveOtcBvalDealsUploadRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__RetrieveOtcBvalDealsUploadRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__RetrieveOtcBvalDealsUploadRequest(soap, tag ? tag : "ns1:RetrieveOtcBvalDealsUploadRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__RetrieveOtcBvalDealsUploadRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RetrieveOtcBvalDealsUploadRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RetrieveOtcBvalDealsUploadRequest * SOAP_FMAC4 soap_get_ns1__RetrieveOtcBvalDealsUploadRequest(struct soap *soap, ns1__RetrieveOtcBvalDealsUploadRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RetrieveOtcBvalDealsUploadRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__SubmitOtcBvalDealsUploadResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__PerSecurityResponse::soap_default(soap);
	soap_default_std__string(soap, &this->ns1__SubmitOtcBvalDealsUploadResponse::responseId);
}

void ns1__SubmitOtcBvalDealsUploadResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__SubmitOtcBvalDealsUploadResponse::responseId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__SubmitOtcBvalDealsUploadResponse::responseId);
	this->ns1__PerSecurityResponse::soap_serialize(soap);
#endif
}

int ns1__SubmitOtcBvalDealsUploadResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SubmitOtcBvalDealsUploadResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SubmitOtcBvalDealsUploadResponse(struct soap *soap, const char *tag, int id, const ns1__SubmitOtcBvalDealsUploadResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SubmitOtcBvalDealsUploadResponse), type ? type : "ns1:SubmitOtcBvalDealsUploadResponse"))
		return soap->error;
	if (!a->ns1__PerSecurityResponse::statusCode)
	{	if (soap_element_empty(soap, "ns1:statusCode", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__ResponseStatus(soap, "ns1:statusCode", -1, &a->ns1__PerSecurityResponse::statusCode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:requestId", -1, &a->ns1__PerSecurityResponse::requestId, ""))
		return soap->error;
	soap_element_result(soap, "ns1:responseId");
	if (soap_out_std__string(soap, "ns1:responseId", -1, &a->ns1__SubmitOtcBvalDealsUploadResponse::responseId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SubmitOtcBvalDealsUploadResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__SubmitOtcBvalDealsUploadResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SubmitOtcBvalDealsUploadResponse * SOAP_FMAC4 soap_in_ns1__SubmitOtcBvalDealsUploadResponse(struct soap *soap, const char *tag, ns1__SubmitOtcBvalDealsUploadResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SubmitOtcBvalDealsUploadResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SubmitOtcBvalDealsUploadResponse, sizeof(ns1__SubmitOtcBvalDealsUploadResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__SubmitOtcBvalDealsUploadResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__SubmitOtcBvalDealsUploadResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_statusCode2 = 1;
	size_t soap_flag_requestId2 = 1;
	size_t soap_flag_responseId1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ResponseStatus(soap, "ns1:statusCode", &a->ns1__PerSecurityResponse::statusCode, "ns1:ResponseStatus"))
				{	soap_flag_statusCode2--;
					continue;
				}
			}
			if (soap_flag_requestId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:requestId", &a->ns1__PerSecurityResponse::requestId, "xsd:string"))
				{	soap_flag_requestId2--;
					continue;
				}
			}
			if (soap_flag_responseId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:responseId", &a->ns1__SubmitOtcBvalDealsUploadResponse::responseId, "xsd:string"))
				{	soap_flag_responseId1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:responseId");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__PerSecurityResponse::statusCode || soap_flag_requestId2 > 0 || soap_flag_responseId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__SubmitOtcBvalDealsUploadResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SubmitOtcBvalDealsUploadResponse, SOAP_TYPE_ns1__SubmitOtcBvalDealsUploadResponse, sizeof(ns1__SubmitOtcBvalDealsUploadResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__SubmitOtcBvalDealsUploadResponse * SOAP_FMAC2 soap_instantiate_ns1__SubmitOtcBvalDealsUploadResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SubmitOtcBvalDealsUploadResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__SubmitOtcBvalDealsUploadResponse *p;
	size_t k = sizeof(ns1__SubmitOtcBvalDealsUploadResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__SubmitOtcBvalDealsUploadResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__SubmitOtcBvalDealsUploadResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__SubmitOtcBvalDealsUploadResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__SubmitOtcBvalDealsUploadResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__SubmitOtcBvalDealsUploadResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__SubmitOtcBvalDealsUploadResponse(soap, tag ? tag : "ns1:SubmitOtcBvalDealsUploadResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SubmitOtcBvalDealsUploadResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SubmitOtcBvalDealsUploadResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SubmitOtcBvalDealsUploadResponse * SOAP_FMAC4 soap_get_ns1__SubmitOtcBvalDealsUploadResponse(struct soap *soap, ns1__SubmitOtcBvalDealsUploadResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SubmitOtcBvalDealsUploadResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__SubmitOtcBvalDealsUploadRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__SubmitOtcBvalDealsUploadRequest::usernumber);
	this->ns1__SubmitOtcBvalDealsUploadRequest::otcBvalHeaders = NULL;
	soap_default_std__string(soap, &this->ns1__SubmitOtcBvalDealsUploadRequest::fileContent);
}

void ns1__SubmitOtcBvalDealsUploadRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__SubmitOtcBvalDealsUploadRequest::usernumber, SOAP_TYPE_int);
	soap_serialize_PointerTons1__OtcBvalHeaders(soap, &this->ns1__SubmitOtcBvalDealsUploadRequest::otcBvalHeaders);
	soap_embedded(soap, &this->ns1__SubmitOtcBvalDealsUploadRequest::fileContent, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__SubmitOtcBvalDealsUploadRequest::fileContent);
#endif
}

int ns1__SubmitOtcBvalDealsUploadRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SubmitOtcBvalDealsUploadRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SubmitOtcBvalDealsUploadRequest(struct soap *soap, const char *tag, int id, const ns1__SubmitOtcBvalDealsUploadRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SubmitOtcBvalDealsUploadRequest), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:usernumber", -1, &a->ns1__SubmitOtcBvalDealsUploadRequest::usernumber, ""))
		return soap->error;
	if (!a->ns1__SubmitOtcBvalDealsUploadRequest::otcBvalHeaders)
	{	if (soap_element_empty(soap, "ns1:otcBvalHeaders", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__OtcBvalHeaders(soap, "ns1:otcBvalHeaders", -1, &a->ns1__SubmitOtcBvalDealsUploadRequest::otcBvalHeaders, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:fileContent", -1, &a->ns1__SubmitOtcBvalDealsUploadRequest::fileContent, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SubmitOtcBvalDealsUploadRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__SubmitOtcBvalDealsUploadRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SubmitOtcBvalDealsUploadRequest * SOAP_FMAC4 soap_in_ns1__SubmitOtcBvalDealsUploadRequest(struct soap *soap, const char *tag, ns1__SubmitOtcBvalDealsUploadRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SubmitOtcBvalDealsUploadRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SubmitOtcBvalDealsUploadRequest, sizeof(ns1__SubmitOtcBvalDealsUploadRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__SubmitOtcBvalDealsUploadRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__SubmitOtcBvalDealsUploadRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_usernumber1 = 1;
	size_t soap_flag_otcBvalHeaders1 = 1;
	size_t soap_flag_fileContent1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_usernumber1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:usernumber", &a->ns1__SubmitOtcBvalDealsUploadRequest::usernumber, "xsd:int"))
				{	soap_flag_usernumber1--;
					continue;
				}
			}
			if (soap_flag_otcBvalHeaders1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__OtcBvalHeaders(soap, "ns1:otcBvalHeaders", &a->ns1__SubmitOtcBvalDealsUploadRequest::otcBvalHeaders, "ns1:OtcBvalHeaders"))
				{	soap_flag_otcBvalHeaders1--;
					continue;
				}
			}
			if (soap_flag_fileContent1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:fileContent", &a->ns1__SubmitOtcBvalDealsUploadRequest::fileContent, "xsd:string"))
				{	soap_flag_fileContent1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_usernumber1 > 0 || !a->ns1__SubmitOtcBvalDealsUploadRequest::otcBvalHeaders || soap_flag_fileContent1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__SubmitOtcBvalDealsUploadRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SubmitOtcBvalDealsUploadRequest, SOAP_TYPE_ns1__SubmitOtcBvalDealsUploadRequest, sizeof(ns1__SubmitOtcBvalDealsUploadRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__SubmitOtcBvalDealsUploadRequest * SOAP_FMAC2 soap_instantiate_ns1__SubmitOtcBvalDealsUploadRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SubmitOtcBvalDealsUploadRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__SubmitOtcBvalDealsUploadRequest *p;
	size_t k = sizeof(ns1__SubmitOtcBvalDealsUploadRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__SubmitOtcBvalDealsUploadRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__SubmitOtcBvalDealsUploadRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__SubmitOtcBvalDealsUploadRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__SubmitOtcBvalDealsUploadRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__SubmitOtcBvalDealsUploadRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__SubmitOtcBvalDealsUploadRequest(soap, tag ? tag : "ns1:SubmitOtcBvalDealsUploadRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SubmitOtcBvalDealsUploadRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SubmitOtcBvalDealsUploadRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SubmitOtcBvalDealsUploadRequest * SOAP_FMAC4 soap_get_ns1__SubmitOtcBvalDealsUploadRequest(struct soap *soap, ns1__SubmitOtcBvalDealsUploadRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SubmitOtcBvalDealsUploadRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__RetrieveOtcbvalUploadResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__PerSecurityResponse::soap_default(soap);
	soap_default_std__string(soap, &this->ns1__RetrieveOtcbvalUploadResponse::responseId);
	this->ns1__RetrieveOtcbvalUploadResponse::response = NULL;
}

void ns1__RetrieveOtcbvalUploadResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__RetrieveOtcbvalUploadResponse::responseId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__RetrieveOtcbvalUploadResponse::responseId);
	soap_serialize_PointerTostd__string(soap, &this->ns1__RetrieveOtcbvalUploadResponse::response);
	this->ns1__PerSecurityResponse::soap_serialize(soap);
#endif
}

int ns1__RetrieveOtcbvalUploadResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RetrieveOtcbvalUploadResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RetrieveOtcbvalUploadResponse(struct soap *soap, const char *tag, int id, const ns1__RetrieveOtcbvalUploadResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RetrieveOtcbvalUploadResponse), type ? type : "ns1:RetrieveOtcbvalUploadResponse"))
		return soap->error;
	if (!a->ns1__PerSecurityResponse::statusCode)
	{	if (soap_element_empty(soap, "ns1:statusCode", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__ResponseStatus(soap, "ns1:statusCode", -1, &a->ns1__PerSecurityResponse::statusCode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:requestId", -1, &a->ns1__PerSecurityResponse::requestId, ""))
		return soap->error;
	soap_element_result(soap, "ns1:responseId");
	if (soap_out_std__string(soap, "ns1:responseId", -1, &a->ns1__RetrieveOtcbvalUploadResponse::responseId, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:response", -1, &a->ns1__RetrieveOtcbvalUploadResponse::response, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__RetrieveOtcbvalUploadResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__RetrieveOtcbvalUploadResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RetrieveOtcbvalUploadResponse * SOAP_FMAC4 soap_in_ns1__RetrieveOtcbvalUploadResponse(struct soap *soap, const char *tag, ns1__RetrieveOtcbvalUploadResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RetrieveOtcbvalUploadResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RetrieveOtcbvalUploadResponse, sizeof(ns1__RetrieveOtcbvalUploadResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__RetrieveOtcbvalUploadResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__RetrieveOtcbvalUploadResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_statusCode2 = 1;
	size_t soap_flag_requestId2 = 1;
	size_t soap_flag_responseId1 = 1;
	size_t soap_flag_response1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ResponseStatus(soap, "ns1:statusCode", &a->ns1__PerSecurityResponse::statusCode, "ns1:ResponseStatus"))
				{	soap_flag_statusCode2--;
					continue;
				}
			}
			if (soap_flag_requestId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:requestId", &a->ns1__PerSecurityResponse::requestId, "xsd:string"))
				{	soap_flag_requestId2--;
					continue;
				}
			}
			if (soap_flag_responseId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:responseId", &a->ns1__RetrieveOtcbvalUploadResponse::responseId, "xsd:string"))
				{	soap_flag_responseId1--;
					continue;
				}
			}
			if (soap_flag_response1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:response", &a->ns1__RetrieveOtcbvalUploadResponse::response, "xsd:string"))
				{	soap_flag_response1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:responseId");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__PerSecurityResponse::statusCode || soap_flag_requestId2 > 0 || soap_flag_responseId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__RetrieveOtcbvalUploadResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RetrieveOtcbvalUploadResponse, SOAP_TYPE_ns1__RetrieveOtcbvalUploadResponse, sizeof(ns1__RetrieveOtcbvalUploadResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__RetrieveOtcbvalUploadResponse * SOAP_FMAC2 soap_instantiate_ns1__RetrieveOtcbvalUploadResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RetrieveOtcbvalUploadResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__RetrieveOtcbvalUploadResponse *p;
	size_t k = sizeof(ns1__RetrieveOtcbvalUploadResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__RetrieveOtcbvalUploadResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__RetrieveOtcbvalUploadResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__RetrieveOtcbvalUploadResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__RetrieveOtcbvalUploadResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__RetrieveOtcbvalUploadResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__RetrieveOtcbvalUploadResponse(soap, tag ? tag : "ns1:RetrieveOtcbvalUploadResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__RetrieveOtcbvalUploadResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RetrieveOtcbvalUploadResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RetrieveOtcbvalUploadResponse * SOAP_FMAC4 soap_get_ns1__RetrieveOtcbvalUploadResponse(struct soap *soap, ns1__RetrieveOtcbvalUploadResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RetrieveOtcbvalUploadResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__RetrieveOtcbvalUploadRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__RetrieveOtcbvalUploadRequest::responseId);
	this->ns1__RetrieveOtcbvalUploadRequest::responseDate = NULL;
}

void ns1__RetrieveOtcbvalUploadRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__RetrieveOtcbvalUploadRequest::responseId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__RetrieveOtcbvalUploadRequest::responseId);
	soap_serialize_PointerToxsd__date(soap, &this->ns1__RetrieveOtcbvalUploadRequest::responseDate);
#endif
}

int ns1__RetrieveOtcbvalUploadRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RetrieveOtcbvalUploadRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RetrieveOtcbvalUploadRequest(struct soap *soap, const char *tag, int id, const ns1__RetrieveOtcbvalUploadRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RetrieveOtcbvalUploadRequest), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:responseId", -1, &a->ns1__RetrieveOtcbvalUploadRequest::responseId, ""))
		return soap->error;
	if (soap_out_PointerToxsd__date(soap, "ns1:responseDate", -1, &a->ns1__RetrieveOtcbvalUploadRequest::responseDate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__RetrieveOtcbvalUploadRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__RetrieveOtcbvalUploadRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RetrieveOtcbvalUploadRequest * SOAP_FMAC4 soap_in_ns1__RetrieveOtcbvalUploadRequest(struct soap *soap, const char *tag, ns1__RetrieveOtcbvalUploadRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RetrieveOtcbvalUploadRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RetrieveOtcbvalUploadRequest, sizeof(ns1__RetrieveOtcbvalUploadRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__RetrieveOtcbvalUploadRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__RetrieveOtcbvalUploadRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_responseId1 = 1;
	size_t soap_flag_responseDate1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_responseId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:responseId", &a->ns1__RetrieveOtcbvalUploadRequest::responseId, "xsd:string"))
				{	soap_flag_responseId1--;
					continue;
				}
			}
			if (soap_flag_responseDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__date(soap, "ns1:responseDate", &a->ns1__RetrieveOtcbvalUploadRequest::responseDate, "xsd:date"))
				{	soap_flag_responseDate1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_responseId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__RetrieveOtcbvalUploadRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RetrieveOtcbvalUploadRequest, SOAP_TYPE_ns1__RetrieveOtcbvalUploadRequest, sizeof(ns1__RetrieveOtcbvalUploadRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__RetrieveOtcbvalUploadRequest * SOAP_FMAC2 soap_instantiate_ns1__RetrieveOtcbvalUploadRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RetrieveOtcbvalUploadRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__RetrieveOtcbvalUploadRequest *p;
	size_t k = sizeof(ns1__RetrieveOtcbvalUploadRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__RetrieveOtcbvalUploadRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__RetrieveOtcbvalUploadRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__RetrieveOtcbvalUploadRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__RetrieveOtcbvalUploadRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__RetrieveOtcbvalUploadRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__RetrieveOtcbvalUploadRequest(soap, tag ? tag : "ns1:RetrieveOtcbvalUploadRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__RetrieveOtcbvalUploadRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RetrieveOtcbvalUploadRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RetrieveOtcbvalUploadRequest * SOAP_FMAC4 soap_get_ns1__RetrieveOtcbvalUploadRequest(struct soap *soap, ns1__RetrieveOtcbvalUploadRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RetrieveOtcbvalUploadRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__SubmitOtcbvalUploadResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__PerSecurityResponse::soap_default(soap);
	soap_default_std__string(soap, &this->ns1__SubmitOtcbvalUploadResponse::responseId);
}

void ns1__SubmitOtcbvalUploadResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__SubmitOtcbvalUploadResponse::responseId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__SubmitOtcbvalUploadResponse::responseId);
	this->ns1__PerSecurityResponse::soap_serialize(soap);
#endif
}

int ns1__SubmitOtcbvalUploadResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SubmitOtcbvalUploadResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SubmitOtcbvalUploadResponse(struct soap *soap, const char *tag, int id, const ns1__SubmitOtcbvalUploadResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SubmitOtcbvalUploadResponse), type ? type : "ns1:SubmitOtcbvalUploadResponse"))
		return soap->error;
	if (!a->ns1__PerSecurityResponse::statusCode)
	{	if (soap_element_empty(soap, "ns1:statusCode", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__ResponseStatus(soap, "ns1:statusCode", -1, &a->ns1__PerSecurityResponse::statusCode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:requestId", -1, &a->ns1__PerSecurityResponse::requestId, ""))
		return soap->error;
	soap_element_result(soap, "ns1:responseId");
	if (soap_out_std__string(soap, "ns1:responseId", -1, &a->ns1__SubmitOtcbvalUploadResponse::responseId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SubmitOtcbvalUploadResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__SubmitOtcbvalUploadResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SubmitOtcbvalUploadResponse * SOAP_FMAC4 soap_in_ns1__SubmitOtcbvalUploadResponse(struct soap *soap, const char *tag, ns1__SubmitOtcbvalUploadResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SubmitOtcbvalUploadResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SubmitOtcbvalUploadResponse, sizeof(ns1__SubmitOtcbvalUploadResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__SubmitOtcbvalUploadResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__SubmitOtcbvalUploadResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_statusCode2 = 1;
	size_t soap_flag_requestId2 = 1;
	size_t soap_flag_responseId1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ResponseStatus(soap, "ns1:statusCode", &a->ns1__PerSecurityResponse::statusCode, "ns1:ResponseStatus"))
				{	soap_flag_statusCode2--;
					continue;
				}
			}
			if (soap_flag_requestId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:requestId", &a->ns1__PerSecurityResponse::requestId, "xsd:string"))
				{	soap_flag_requestId2--;
					continue;
				}
			}
			if (soap_flag_responseId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:responseId", &a->ns1__SubmitOtcbvalUploadResponse::responseId, "xsd:string"))
				{	soap_flag_responseId1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:responseId");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__PerSecurityResponse::statusCode || soap_flag_requestId2 > 0 || soap_flag_responseId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__SubmitOtcbvalUploadResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SubmitOtcbvalUploadResponse, SOAP_TYPE_ns1__SubmitOtcbvalUploadResponse, sizeof(ns1__SubmitOtcbvalUploadResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__SubmitOtcbvalUploadResponse * SOAP_FMAC2 soap_instantiate_ns1__SubmitOtcbvalUploadResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SubmitOtcbvalUploadResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__SubmitOtcbvalUploadResponse *p;
	size_t k = sizeof(ns1__SubmitOtcbvalUploadResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__SubmitOtcbvalUploadResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__SubmitOtcbvalUploadResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__SubmitOtcbvalUploadResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__SubmitOtcbvalUploadResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__SubmitOtcbvalUploadResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__SubmitOtcbvalUploadResponse(soap, tag ? tag : "ns1:SubmitOtcbvalUploadResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SubmitOtcbvalUploadResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SubmitOtcbvalUploadResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SubmitOtcbvalUploadResponse * SOAP_FMAC4 soap_get_ns1__SubmitOtcbvalUploadResponse(struct soap *soap, ns1__SubmitOtcbvalUploadResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SubmitOtcbvalUploadResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__SubmitOtcbvalUploadRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__SubmitOtcbvalUploadRequest::usernumber);
	this->ns1__SubmitOtcbvalUploadRequest::otcBvalHeaders = NULL;
	soap_default_std__string(soap, &this->ns1__SubmitOtcbvalUploadRequest::fileContent);
}

void ns1__SubmitOtcbvalUploadRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__SubmitOtcbvalUploadRequest::usernumber, SOAP_TYPE_int);
	soap_serialize_PointerTons1__OtcBvalHeaders(soap, &this->ns1__SubmitOtcbvalUploadRequest::otcBvalHeaders);
	soap_embedded(soap, &this->ns1__SubmitOtcbvalUploadRequest::fileContent, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__SubmitOtcbvalUploadRequest::fileContent);
#endif
}

int ns1__SubmitOtcbvalUploadRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SubmitOtcbvalUploadRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SubmitOtcbvalUploadRequest(struct soap *soap, const char *tag, int id, const ns1__SubmitOtcbvalUploadRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SubmitOtcbvalUploadRequest), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:usernumber", -1, &a->ns1__SubmitOtcbvalUploadRequest::usernumber, ""))
		return soap->error;
	if (!a->ns1__SubmitOtcbvalUploadRequest::otcBvalHeaders)
	{	if (soap_element_empty(soap, "ns1:otcBvalHeaders", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__OtcBvalHeaders(soap, "ns1:otcBvalHeaders", -1, &a->ns1__SubmitOtcbvalUploadRequest::otcBvalHeaders, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:fileContent", -1, &a->ns1__SubmitOtcbvalUploadRequest::fileContent, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SubmitOtcbvalUploadRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__SubmitOtcbvalUploadRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SubmitOtcbvalUploadRequest * SOAP_FMAC4 soap_in_ns1__SubmitOtcbvalUploadRequest(struct soap *soap, const char *tag, ns1__SubmitOtcbvalUploadRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SubmitOtcbvalUploadRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SubmitOtcbvalUploadRequest, sizeof(ns1__SubmitOtcbvalUploadRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__SubmitOtcbvalUploadRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__SubmitOtcbvalUploadRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_usernumber1 = 1;
	size_t soap_flag_otcBvalHeaders1 = 1;
	size_t soap_flag_fileContent1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_usernumber1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:usernumber", &a->ns1__SubmitOtcbvalUploadRequest::usernumber, "xsd:int"))
				{	soap_flag_usernumber1--;
					continue;
				}
			}
			if (soap_flag_otcBvalHeaders1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__OtcBvalHeaders(soap, "ns1:otcBvalHeaders", &a->ns1__SubmitOtcbvalUploadRequest::otcBvalHeaders, "ns1:OtcBvalHeaders"))
				{	soap_flag_otcBvalHeaders1--;
					continue;
				}
			}
			if (soap_flag_fileContent1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:fileContent", &a->ns1__SubmitOtcbvalUploadRequest::fileContent, "xsd:string"))
				{	soap_flag_fileContent1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_usernumber1 > 0 || !a->ns1__SubmitOtcbvalUploadRequest::otcBvalHeaders || soap_flag_fileContent1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__SubmitOtcbvalUploadRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SubmitOtcbvalUploadRequest, SOAP_TYPE_ns1__SubmitOtcbvalUploadRequest, sizeof(ns1__SubmitOtcbvalUploadRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__SubmitOtcbvalUploadRequest * SOAP_FMAC2 soap_instantiate_ns1__SubmitOtcbvalUploadRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SubmitOtcbvalUploadRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__SubmitOtcbvalUploadRequest *p;
	size_t k = sizeof(ns1__SubmitOtcbvalUploadRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__SubmitOtcbvalUploadRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__SubmitOtcbvalUploadRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__SubmitOtcbvalUploadRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__SubmitOtcbvalUploadRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__SubmitOtcbvalUploadRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__SubmitOtcbvalUploadRequest(soap, tag ? tag : "ns1:SubmitOtcbvalUploadRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SubmitOtcbvalUploadRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SubmitOtcbvalUploadRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SubmitOtcbvalUploadRequest * SOAP_FMAC4 soap_get_ns1__SubmitOtcbvalUploadRequest(struct soap *soap, ns1__SubmitOtcbvalUploadRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SubmitOtcbvalUploadRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__RetrieveGetAllQuotesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__PerSecurityResponse::soap_default(soap);
	soap_default_std__string(soap, &this->ns1__RetrieveGetAllQuotesResponse::responseId);
	this->ns1__RetrieveGetAllQuotesResponse::headers = NULL;
	this->ns1__RetrieveGetAllQuotesResponse::timestarted = NULL;
	this->ns1__RetrieveGetAllQuotesResponse::instrumentDatas = NULL;
	this->ns1__RetrieveGetAllQuotesResponse::timefinished = NULL;
}

void ns1__RetrieveGetAllQuotesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__RetrieveGetAllQuotesResponse::responseId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__RetrieveGetAllQuotesResponse::responseId);
	soap_serialize_PointerTons1__QuotesHeaders(soap, &this->ns1__RetrieveGetAllQuotesResponse::headers);
	soap_serialize_PointerTodateTime(soap, &this->ns1__RetrieveGetAllQuotesResponse::timestarted);
	soap_serialize_PointerTons1__AllQuotesInstrumentDatas(soap, &this->ns1__RetrieveGetAllQuotesResponse::instrumentDatas);
	soap_serialize_PointerTodateTime(soap, &this->ns1__RetrieveGetAllQuotesResponse::timefinished);
	this->ns1__PerSecurityResponse::soap_serialize(soap);
#endif
}

int ns1__RetrieveGetAllQuotesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RetrieveGetAllQuotesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RetrieveGetAllQuotesResponse(struct soap *soap, const char *tag, int id, const ns1__RetrieveGetAllQuotesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RetrieveGetAllQuotesResponse), type ? type : "ns1:RetrieveGetAllQuotesResponse"))
		return soap->error;
	if (!a->ns1__PerSecurityResponse::statusCode)
	{	if (soap_element_empty(soap, "ns1:statusCode", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__ResponseStatus(soap, "ns1:statusCode", -1, &a->ns1__PerSecurityResponse::statusCode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:requestId", -1, &a->ns1__PerSecurityResponse::requestId, ""))
		return soap->error;
	soap_element_result(soap, "ns1:responseId");
	if (soap_out_std__string(soap, "ns1:responseId", -1, &a->ns1__RetrieveGetAllQuotesResponse::responseId, ""))
		return soap->error;
	if (soap_out_PointerTons1__QuotesHeaders(soap, "ns1:headers", -1, &a->ns1__RetrieveGetAllQuotesResponse::headers, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns1:timestarted", -1, &a->ns1__RetrieveGetAllQuotesResponse::timestarted, ""))
		return soap->error;
	if (soap_out_PointerTons1__AllQuotesInstrumentDatas(soap, "ns1:instrumentDatas", -1, &a->ns1__RetrieveGetAllQuotesResponse::instrumentDatas, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns1:timefinished", -1, &a->ns1__RetrieveGetAllQuotesResponse::timefinished, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__RetrieveGetAllQuotesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__RetrieveGetAllQuotesResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RetrieveGetAllQuotesResponse * SOAP_FMAC4 soap_in_ns1__RetrieveGetAllQuotesResponse(struct soap *soap, const char *tag, ns1__RetrieveGetAllQuotesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RetrieveGetAllQuotesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RetrieveGetAllQuotesResponse, sizeof(ns1__RetrieveGetAllQuotesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__RetrieveGetAllQuotesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__RetrieveGetAllQuotesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_statusCode2 = 1;
	size_t soap_flag_requestId2 = 1;
	size_t soap_flag_responseId1 = 1;
	size_t soap_flag_headers1 = 1;
	size_t soap_flag_timestarted1 = 1;
	size_t soap_flag_instrumentDatas1 = 1;
	size_t soap_flag_timefinished1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ResponseStatus(soap, "ns1:statusCode", &a->ns1__PerSecurityResponse::statusCode, "ns1:ResponseStatus"))
				{	soap_flag_statusCode2--;
					continue;
				}
			}
			if (soap_flag_requestId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:requestId", &a->ns1__PerSecurityResponse::requestId, "xsd:string"))
				{	soap_flag_requestId2--;
					continue;
				}
			}
			if (soap_flag_responseId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:responseId", &a->ns1__RetrieveGetAllQuotesResponse::responseId, "xsd:string"))
				{	soap_flag_responseId1--;
					continue;
				}
			}
			if (soap_flag_headers1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__QuotesHeaders(soap, "ns1:headers", &a->ns1__RetrieveGetAllQuotesResponse::headers, "ns1:QuotesHeaders"))
				{	soap_flag_headers1--;
					continue;
				}
			}
			if (soap_flag_timestarted1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns1:timestarted", &a->ns1__RetrieveGetAllQuotesResponse::timestarted, "xsd:dateTime"))
				{	soap_flag_timestarted1--;
					continue;
				}
			}
			if (soap_flag_instrumentDatas1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__AllQuotesInstrumentDatas(soap, "ns1:instrumentDatas", &a->ns1__RetrieveGetAllQuotesResponse::instrumentDatas, "ns1:AllQuotesInstrumentDatas"))
				{	soap_flag_instrumentDatas1--;
					continue;
				}
			}
			if (soap_flag_timefinished1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns1:timefinished", &a->ns1__RetrieveGetAllQuotesResponse::timefinished, "xsd:dateTime"))
				{	soap_flag_timefinished1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:responseId");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__PerSecurityResponse::statusCode || soap_flag_requestId2 > 0 || soap_flag_responseId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__RetrieveGetAllQuotesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RetrieveGetAllQuotesResponse, SOAP_TYPE_ns1__RetrieveGetAllQuotesResponse, sizeof(ns1__RetrieveGetAllQuotesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__RetrieveGetAllQuotesResponse * SOAP_FMAC2 soap_instantiate_ns1__RetrieveGetAllQuotesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RetrieveGetAllQuotesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__RetrieveGetAllQuotesResponse *p;
	size_t k = sizeof(ns1__RetrieveGetAllQuotesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__RetrieveGetAllQuotesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__RetrieveGetAllQuotesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__RetrieveGetAllQuotesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__RetrieveGetAllQuotesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__RetrieveGetAllQuotesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__RetrieveGetAllQuotesResponse(soap, tag ? tag : "ns1:RetrieveGetAllQuotesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__RetrieveGetAllQuotesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RetrieveGetAllQuotesResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RetrieveGetAllQuotesResponse * SOAP_FMAC4 soap_get_ns1__RetrieveGetAllQuotesResponse(struct soap *soap, ns1__RetrieveGetAllQuotesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RetrieveGetAllQuotesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__RetrieveGetAllQuotesRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__RetrieveGetAllQuotesRequest::responseId);
	this->ns1__RetrieveGetAllQuotesRequest::responseDate = NULL;
}

void ns1__RetrieveGetAllQuotesRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__RetrieveGetAllQuotesRequest::responseId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__RetrieveGetAllQuotesRequest::responseId);
	soap_serialize_PointerToxsd__date(soap, &this->ns1__RetrieveGetAllQuotesRequest::responseDate);
#endif
}

int ns1__RetrieveGetAllQuotesRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RetrieveGetAllQuotesRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RetrieveGetAllQuotesRequest(struct soap *soap, const char *tag, int id, const ns1__RetrieveGetAllQuotesRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RetrieveGetAllQuotesRequest), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:responseId", -1, &a->ns1__RetrieveGetAllQuotesRequest::responseId, ""))
		return soap->error;
	if (soap_out_PointerToxsd__date(soap, "ns1:responseDate", -1, &a->ns1__RetrieveGetAllQuotesRequest::responseDate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__RetrieveGetAllQuotesRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__RetrieveGetAllQuotesRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RetrieveGetAllQuotesRequest * SOAP_FMAC4 soap_in_ns1__RetrieveGetAllQuotesRequest(struct soap *soap, const char *tag, ns1__RetrieveGetAllQuotesRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RetrieveGetAllQuotesRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RetrieveGetAllQuotesRequest, sizeof(ns1__RetrieveGetAllQuotesRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__RetrieveGetAllQuotesRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__RetrieveGetAllQuotesRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_responseId1 = 1;
	size_t soap_flag_responseDate1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_responseId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:responseId", &a->ns1__RetrieveGetAllQuotesRequest::responseId, "xsd:string"))
				{	soap_flag_responseId1--;
					continue;
				}
			}
			if (soap_flag_responseDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__date(soap, "ns1:responseDate", &a->ns1__RetrieveGetAllQuotesRequest::responseDate, "xsd:date"))
				{	soap_flag_responseDate1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_responseId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__RetrieveGetAllQuotesRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RetrieveGetAllQuotesRequest, SOAP_TYPE_ns1__RetrieveGetAllQuotesRequest, sizeof(ns1__RetrieveGetAllQuotesRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__RetrieveGetAllQuotesRequest * SOAP_FMAC2 soap_instantiate_ns1__RetrieveGetAllQuotesRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RetrieveGetAllQuotesRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__RetrieveGetAllQuotesRequest *p;
	size_t k = sizeof(ns1__RetrieveGetAllQuotesRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__RetrieveGetAllQuotesRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__RetrieveGetAllQuotesRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__RetrieveGetAllQuotesRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__RetrieveGetAllQuotesRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__RetrieveGetAllQuotesRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__RetrieveGetAllQuotesRequest(soap, tag ? tag : "ns1:RetrieveGetAllQuotesRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__RetrieveGetAllQuotesRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RetrieveGetAllQuotesRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RetrieveGetAllQuotesRequest * SOAP_FMAC4 soap_get_ns1__RetrieveGetAllQuotesRequest(struct soap *soap, ns1__RetrieveGetAllQuotesRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RetrieveGetAllQuotesRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__SubmitGetAllQuotesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__PerSecurityResponse::soap_default(soap);
	soap_default_std__string(soap, &this->ns1__SubmitGetAllQuotesResponse::responseId);
}

void ns1__SubmitGetAllQuotesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__SubmitGetAllQuotesResponse::responseId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__SubmitGetAllQuotesResponse::responseId);
	this->ns1__PerSecurityResponse::soap_serialize(soap);
#endif
}

int ns1__SubmitGetAllQuotesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SubmitGetAllQuotesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SubmitGetAllQuotesResponse(struct soap *soap, const char *tag, int id, const ns1__SubmitGetAllQuotesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SubmitGetAllQuotesResponse), type ? type : "ns1:SubmitGetAllQuotesResponse"))
		return soap->error;
	if (!a->ns1__PerSecurityResponse::statusCode)
	{	if (soap_element_empty(soap, "ns1:statusCode", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__ResponseStatus(soap, "ns1:statusCode", -1, &a->ns1__PerSecurityResponse::statusCode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:requestId", -1, &a->ns1__PerSecurityResponse::requestId, ""))
		return soap->error;
	soap_element_result(soap, "ns1:responseId");
	if (soap_out_std__string(soap, "ns1:responseId", -1, &a->ns1__SubmitGetAllQuotesResponse::responseId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SubmitGetAllQuotesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__SubmitGetAllQuotesResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SubmitGetAllQuotesResponse * SOAP_FMAC4 soap_in_ns1__SubmitGetAllQuotesResponse(struct soap *soap, const char *tag, ns1__SubmitGetAllQuotesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SubmitGetAllQuotesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SubmitGetAllQuotesResponse, sizeof(ns1__SubmitGetAllQuotesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__SubmitGetAllQuotesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__SubmitGetAllQuotesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_statusCode2 = 1;
	size_t soap_flag_requestId2 = 1;
	size_t soap_flag_responseId1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ResponseStatus(soap, "ns1:statusCode", &a->ns1__PerSecurityResponse::statusCode, "ns1:ResponseStatus"))
				{	soap_flag_statusCode2--;
					continue;
				}
			}
			if (soap_flag_requestId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:requestId", &a->ns1__PerSecurityResponse::requestId, "xsd:string"))
				{	soap_flag_requestId2--;
					continue;
				}
			}
			if (soap_flag_responseId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:responseId", &a->ns1__SubmitGetAllQuotesResponse::responseId, "xsd:string"))
				{	soap_flag_responseId1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:responseId");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__PerSecurityResponse::statusCode || soap_flag_requestId2 > 0 || soap_flag_responseId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__SubmitGetAllQuotesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SubmitGetAllQuotesResponse, SOAP_TYPE_ns1__SubmitGetAllQuotesResponse, sizeof(ns1__SubmitGetAllQuotesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__SubmitGetAllQuotesResponse * SOAP_FMAC2 soap_instantiate_ns1__SubmitGetAllQuotesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SubmitGetAllQuotesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__SubmitGetAllQuotesResponse *p;
	size_t k = sizeof(ns1__SubmitGetAllQuotesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__SubmitGetAllQuotesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__SubmitGetAllQuotesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__SubmitGetAllQuotesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__SubmitGetAllQuotesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__SubmitGetAllQuotesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__SubmitGetAllQuotesResponse(soap, tag ? tag : "ns1:SubmitGetAllQuotesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SubmitGetAllQuotesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SubmitGetAllQuotesResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SubmitGetAllQuotesResponse * SOAP_FMAC4 soap_get_ns1__SubmitGetAllQuotesResponse(struct soap *soap, ns1__SubmitGetAllQuotesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SubmitGetAllQuotesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__SubmitGetAllQuotesRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__SubmitGetAllQuotesRequest::headers = NULL;
	this->ns1__SubmitGetAllQuotesRequest::instruments = NULL;
}

void ns1__SubmitGetAllQuotesRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__QuotesHeaders(soap, &this->ns1__SubmitGetAllQuotesRequest::headers);
	soap_serialize_PointerTons1__Instruments(soap, &this->ns1__SubmitGetAllQuotesRequest::instruments);
#endif
}

int ns1__SubmitGetAllQuotesRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SubmitGetAllQuotesRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SubmitGetAllQuotesRequest(struct soap *soap, const char *tag, int id, const ns1__SubmitGetAllQuotesRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SubmitGetAllQuotesRequest), type))
		return soap->error;
	if (!a->ns1__SubmitGetAllQuotesRequest::headers)
	{	if (soap_element_empty(soap, "ns1:headers", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__QuotesHeaders(soap, "ns1:headers", -1, &a->ns1__SubmitGetAllQuotesRequest::headers, ""))
		return soap->error;
	if (!a->ns1__SubmitGetAllQuotesRequest::instruments)
	{	if (soap_element_empty(soap, "ns1:instruments", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__Instruments(soap, "ns1:instruments", -1, &a->ns1__SubmitGetAllQuotesRequest::instruments, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SubmitGetAllQuotesRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__SubmitGetAllQuotesRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SubmitGetAllQuotesRequest * SOAP_FMAC4 soap_in_ns1__SubmitGetAllQuotesRequest(struct soap *soap, const char *tag, ns1__SubmitGetAllQuotesRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SubmitGetAllQuotesRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SubmitGetAllQuotesRequest, sizeof(ns1__SubmitGetAllQuotesRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__SubmitGetAllQuotesRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__SubmitGetAllQuotesRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_headers1 = 1;
	size_t soap_flag_instruments1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_headers1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__QuotesHeaders(soap, "ns1:headers", &a->ns1__SubmitGetAllQuotesRequest::headers, "ns1:QuotesHeaders"))
				{	soap_flag_headers1--;
					continue;
				}
			}
			if (soap_flag_instruments1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Instruments(soap, "ns1:instruments", &a->ns1__SubmitGetAllQuotesRequest::instruments, "ns1:Instruments"))
				{	soap_flag_instruments1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__SubmitGetAllQuotesRequest::headers || !a->ns1__SubmitGetAllQuotesRequest::instruments))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__SubmitGetAllQuotesRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SubmitGetAllQuotesRequest, SOAP_TYPE_ns1__SubmitGetAllQuotesRequest, sizeof(ns1__SubmitGetAllQuotesRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__SubmitGetAllQuotesRequest * SOAP_FMAC2 soap_instantiate_ns1__SubmitGetAllQuotesRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SubmitGetAllQuotesRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__SubmitGetAllQuotesRequest *p;
	size_t k = sizeof(ns1__SubmitGetAllQuotesRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__SubmitGetAllQuotesRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__SubmitGetAllQuotesRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__SubmitGetAllQuotesRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__SubmitGetAllQuotesRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__SubmitGetAllQuotesRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__SubmitGetAllQuotesRequest(soap, tag ? tag : "ns1:SubmitGetAllQuotesRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SubmitGetAllQuotesRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SubmitGetAllQuotesRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SubmitGetAllQuotesRequest * SOAP_FMAC4 soap_get_ns1__SubmitGetAllQuotesRequest(struct soap *soap, ns1__SubmitGetAllQuotesRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SubmitGetAllQuotesRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__RetrieveGetQuotesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__PerSecurityResponse::soap_default(soap);
	soap_default_std__string(soap, &this->ns1__RetrieveGetQuotesResponse::responseId);
	this->ns1__RetrieveGetQuotesResponse::headers = NULL;
	this->ns1__RetrieveGetQuotesResponse::timestarted = NULL;
	this->ns1__RetrieveGetQuotesResponse::instrumentDatas = NULL;
	this->ns1__RetrieveGetQuotesResponse::timefinished = NULL;
}

void ns1__RetrieveGetQuotesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__RetrieveGetQuotesResponse::responseId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__RetrieveGetQuotesResponse::responseId);
	soap_serialize_PointerTons1__QuotesHeaders(soap, &this->ns1__RetrieveGetQuotesResponse::headers);
	soap_serialize_PointerTodateTime(soap, &this->ns1__RetrieveGetQuotesResponse::timestarted);
	soap_serialize_PointerTons1__QuotesInstrumentDatas(soap, &this->ns1__RetrieveGetQuotesResponse::instrumentDatas);
	soap_serialize_PointerTodateTime(soap, &this->ns1__RetrieveGetQuotesResponse::timefinished);
	this->ns1__PerSecurityResponse::soap_serialize(soap);
#endif
}

int ns1__RetrieveGetQuotesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RetrieveGetQuotesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RetrieveGetQuotesResponse(struct soap *soap, const char *tag, int id, const ns1__RetrieveGetQuotesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RetrieveGetQuotesResponse), type ? type : "ns1:RetrieveGetQuotesResponse"))
		return soap->error;
	if (!a->ns1__PerSecurityResponse::statusCode)
	{	if (soap_element_empty(soap, "ns1:statusCode", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__ResponseStatus(soap, "ns1:statusCode", -1, &a->ns1__PerSecurityResponse::statusCode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:requestId", -1, &a->ns1__PerSecurityResponse::requestId, ""))
		return soap->error;
	soap_element_result(soap, "ns1:responseId");
	if (soap_out_std__string(soap, "ns1:responseId", -1, &a->ns1__RetrieveGetQuotesResponse::responseId, ""))
		return soap->error;
	if (soap_out_PointerTons1__QuotesHeaders(soap, "ns1:headers", -1, &a->ns1__RetrieveGetQuotesResponse::headers, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns1:timestarted", -1, &a->ns1__RetrieveGetQuotesResponse::timestarted, ""))
		return soap->error;
	if (soap_out_PointerTons1__QuotesInstrumentDatas(soap, "ns1:instrumentDatas", -1, &a->ns1__RetrieveGetQuotesResponse::instrumentDatas, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns1:timefinished", -1, &a->ns1__RetrieveGetQuotesResponse::timefinished, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__RetrieveGetQuotesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__RetrieveGetQuotesResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RetrieveGetQuotesResponse * SOAP_FMAC4 soap_in_ns1__RetrieveGetQuotesResponse(struct soap *soap, const char *tag, ns1__RetrieveGetQuotesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RetrieveGetQuotesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RetrieveGetQuotesResponse, sizeof(ns1__RetrieveGetQuotesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__RetrieveGetQuotesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__RetrieveGetQuotesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_statusCode2 = 1;
	size_t soap_flag_requestId2 = 1;
	size_t soap_flag_responseId1 = 1;
	size_t soap_flag_headers1 = 1;
	size_t soap_flag_timestarted1 = 1;
	size_t soap_flag_instrumentDatas1 = 1;
	size_t soap_flag_timefinished1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ResponseStatus(soap, "ns1:statusCode", &a->ns1__PerSecurityResponse::statusCode, "ns1:ResponseStatus"))
				{	soap_flag_statusCode2--;
					continue;
				}
			}
			if (soap_flag_requestId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:requestId", &a->ns1__PerSecurityResponse::requestId, "xsd:string"))
				{	soap_flag_requestId2--;
					continue;
				}
			}
			if (soap_flag_responseId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:responseId", &a->ns1__RetrieveGetQuotesResponse::responseId, "xsd:string"))
				{	soap_flag_responseId1--;
					continue;
				}
			}
			if (soap_flag_headers1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__QuotesHeaders(soap, "ns1:headers", &a->ns1__RetrieveGetQuotesResponse::headers, "ns1:QuotesHeaders"))
				{	soap_flag_headers1--;
					continue;
				}
			}
			if (soap_flag_timestarted1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns1:timestarted", &a->ns1__RetrieveGetQuotesResponse::timestarted, "xsd:dateTime"))
				{	soap_flag_timestarted1--;
					continue;
				}
			}
			if (soap_flag_instrumentDatas1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__QuotesInstrumentDatas(soap, "ns1:instrumentDatas", &a->ns1__RetrieveGetQuotesResponse::instrumentDatas, "ns1:QuotesInstrumentDatas"))
				{	soap_flag_instrumentDatas1--;
					continue;
				}
			}
			if (soap_flag_timefinished1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns1:timefinished", &a->ns1__RetrieveGetQuotesResponse::timefinished, "xsd:dateTime"))
				{	soap_flag_timefinished1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:responseId");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__PerSecurityResponse::statusCode || soap_flag_requestId2 > 0 || soap_flag_responseId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__RetrieveGetQuotesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RetrieveGetQuotesResponse, SOAP_TYPE_ns1__RetrieveGetQuotesResponse, sizeof(ns1__RetrieveGetQuotesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__RetrieveGetQuotesResponse * SOAP_FMAC2 soap_instantiate_ns1__RetrieveGetQuotesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RetrieveGetQuotesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__RetrieveGetQuotesResponse *p;
	size_t k = sizeof(ns1__RetrieveGetQuotesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__RetrieveGetQuotesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__RetrieveGetQuotesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__RetrieveGetQuotesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__RetrieveGetQuotesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__RetrieveGetQuotesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__RetrieveGetQuotesResponse(soap, tag ? tag : "ns1:RetrieveGetQuotesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__RetrieveGetQuotesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RetrieveGetQuotesResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RetrieveGetQuotesResponse * SOAP_FMAC4 soap_get_ns1__RetrieveGetQuotesResponse(struct soap *soap, ns1__RetrieveGetQuotesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RetrieveGetQuotesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__RetrieveGetQuotesRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__RetrieveGetQuotesRequest::responseId);
	this->ns1__RetrieveGetQuotesRequest::responseDate = NULL;
}

void ns1__RetrieveGetQuotesRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__RetrieveGetQuotesRequest::responseId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__RetrieveGetQuotesRequest::responseId);
	soap_serialize_PointerToxsd__date(soap, &this->ns1__RetrieveGetQuotesRequest::responseDate);
#endif
}

int ns1__RetrieveGetQuotesRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RetrieveGetQuotesRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RetrieveGetQuotesRequest(struct soap *soap, const char *tag, int id, const ns1__RetrieveGetQuotesRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RetrieveGetQuotesRequest), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:responseId", -1, &a->ns1__RetrieveGetQuotesRequest::responseId, ""))
		return soap->error;
	if (soap_out_PointerToxsd__date(soap, "ns1:responseDate", -1, &a->ns1__RetrieveGetQuotesRequest::responseDate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__RetrieveGetQuotesRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__RetrieveGetQuotesRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RetrieveGetQuotesRequest * SOAP_FMAC4 soap_in_ns1__RetrieveGetQuotesRequest(struct soap *soap, const char *tag, ns1__RetrieveGetQuotesRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RetrieveGetQuotesRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RetrieveGetQuotesRequest, sizeof(ns1__RetrieveGetQuotesRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__RetrieveGetQuotesRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__RetrieveGetQuotesRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_responseId1 = 1;
	size_t soap_flag_responseDate1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_responseId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:responseId", &a->ns1__RetrieveGetQuotesRequest::responseId, "xsd:string"))
				{	soap_flag_responseId1--;
					continue;
				}
			}
			if (soap_flag_responseDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__date(soap, "ns1:responseDate", &a->ns1__RetrieveGetQuotesRequest::responseDate, "xsd:date"))
				{	soap_flag_responseDate1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_responseId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__RetrieveGetQuotesRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RetrieveGetQuotesRequest, SOAP_TYPE_ns1__RetrieveGetQuotesRequest, sizeof(ns1__RetrieveGetQuotesRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__RetrieveGetQuotesRequest * SOAP_FMAC2 soap_instantiate_ns1__RetrieveGetQuotesRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RetrieveGetQuotesRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__RetrieveGetQuotesRequest *p;
	size_t k = sizeof(ns1__RetrieveGetQuotesRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__RetrieveGetQuotesRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__RetrieveGetQuotesRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__RetrieveGetQuotesRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__RetrieveGetQuotesRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__RetrieveGetQuotesRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__RetrieveGetQuotesRequest(soap, tag ? tag : "ns1:RetrieveGetQuotesRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__RetrieveGetQuotesRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RetrieveGetQuotesRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RetrieveGetQuotesRequest * SOAP_FMAC4 soap_get_ns1__RetrieveGetQuotesRequest(struct soap *soap, ns1__RetrieveGetQuotesRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RetrieveGetQuotesRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__SubmitGetQuotesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__PerSecurityResponse::soap_default(soap);
	soap_default_std__string(soap, &this->ns1__SubmitGetQuotesResponse::responseId);
}

void ns1__SubmitGetQuotesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__SubmitGetQuotesResponse::responseId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__SubmitGetQuotesResponse::responseId);
	this->ns1__PerSecurityResponse::soap_serialize(soap);
#endif
}

int ns1__SubmitGetQuotesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SubmitGetQuotesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SubmitGetQuotesResponse(struct soap *soap, const char *tag, int id, const ns1__SubmitGetQuotesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SubmitGetQuotesResponse), type ? type : "ns1:SubmitGetQuotesResponse"))
		return soap->error;
	if (!a->ns1__PerSecurityResponse::statusCode)
	{	if (soap_element_empty(soap, "ns1:statusCode", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__ResponseStatus(soap, "ns1:statusCode", -1, &a->ns1__PerSecurityResponse::statusCode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:requestId", -1, &a->ns1__PerSecurityResponse::requestId, ""))
		return soap->error;
	soap_element_result(soap, "ns1:responseId");
	if (soap_out_std__string(soap, "ns1:responseId", -1, &a->ns1__SubmitGetQuotesResponse::responseId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SubmitGetQuotesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__SubmitGetQuotesResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SubmitGetQuotesResponse * SOAP_FMAC4 soap_in_ns1__SubmitGetQuotesResponse(struct soap *soap, const char *tag, ns1__SubmitGetQuotesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SubmitGetQuotesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SubmitGetQuotesResponse, sizeof(ns1__SubmitGetQuotesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__SubmitGetQuotesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__SubmitGetQuotesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_statusCode2 = 1;
	size_t soap_flag_requestId2 = 1;
	size_t soap_flag_responseId1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ResponseStatus(soap, "ns1:statusCode", &a->ns1__PerSecurityResponse::statusCode, "ns1:ResponseStatus"))
				{	soap_flag_statusCode2--;
					continue;
				}
			}
			if (soap_flag_requestId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:requestId", &a->ns1__PerSecurityResponse::requestId, "xsd:string"))
				{	soap_flag_requestId2--;
					continue;
				}
			}
			if (soap_flag_responseId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:responseId", &a->ns1__SubmitGetQuotesResponse::responseId, "xsd:string"))
				{	soap_flag_responseId1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:responseId");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__PerSecurityResponse::statusCode || soap_flag_requestId2 > 0 || soap_flag_responseId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__SubmitGetQuotesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SubmitGetQuotesResponse, SOAP_TYPE_ns1__SubmitGetQuotesResponse, sizeof(ns1__SubmitGetQuotesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__SubmitGetQuotesResponse * SOAP_FMAC2 soap_instantiate_ns1__SubmitGetQuotesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SubmitGetQuotesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__SubmitGetQuotesResponse *p;
	size_t k = sizeof(ns1__SubmitGetQuotesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__SubmitGetQuotesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__SubmitGetQuotesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__SubmitGetQuotesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__SubmitGetQuotesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__SubmitGetQuotesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__SubmitGetQuotesResponse(soap, tag ? tag : "ns1:SubmitGetQuotesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SubmitGetQuotesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SubmitGetQuotesResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SubmitGetQuotesResponse * SOAP_FMAC4 soap_get_ns1__SubmitGetQuotesResponse(struct soap *soap, ns1__SubmitGetQuotesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SubmitGetQuotesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__SubmitGetQuotesRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__SubmitGetQuotesRequest::headers = NULL;
	this->ns1__SubmitGetQuotesRequest::instruments = NULL;
}

void ns1__SubmitGetQuotesRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__QuotesHeaders(soap, &this->ns1__SubmitGetQuotesRequest::headers);
	soap_serialize_PointerTons1__Instruments(soap, &this->ns1__SubmitGetQuotesRequest::instruments);
#endif
}

int ns1__SubmitGetQuotesRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SubmitGetQuotesRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SubmitGetQuotesRequest(struct soap *soap, const char *tag, int id, const ns1__SubmitGetQuotesRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SubmitGetQuotesRequest), type))
		return soap->error;
	if (!a->ns1__SubmitGetQuotesRequest::headers)
	{	if (soap_element_empty(soap, "ns1:headers", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__QuotesHeaders(soap, "ns1:headers", -1, &a->ns1__SubmitGetQuotesRequest::headers, ""))
		return soap->error;
	if (!a->ns1__SubmitGetQuotesRequest::instruments)
	{	if (soap_element_empty(soap, "ns1:instruments", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__Instruments(soap, "ns1:instruments", -1, &a->ns1__SubmitGetQuotesRequest::instruments, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SubmitGetQuotesRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__SubmitGetQuotesRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SubmitGetQuotesRequest * SOAP_FMAC4 soap_in_ns1__SubmitGetQuotesRequest(struct soap *soap, const char *tag, ns1__SubmitGetQuotesRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SubmitGetQuotesRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SubmitGetQuotesRequest, sizeof(ns1__SubmitGetQuotesRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__SubmitGetQuotesRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__SubmitGetQuotesRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_headers1 = 1;
	size_t soap_flag_instruments1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_headers1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__QuotesHeaders(soap, "ns1:headers", &a->ns1__SubmitGetQuotesRequest::headers, "ns1:QuotesHeaders"))
				{	soap_flag_headers1--;
					continue;
				}
			}
			if (soap_flag_instruments1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Instruments(soap, "ns1:instruments", &a->ns1__SubmitGetQuotesRequest::instruments, "ns1:Instruments"))
				{	soap_flag_instruments1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__SubmitGetQuotesRequest::headers || !a->ns1__SubmitGetQuotesRequest::instruments))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__SubmitGetQuotesRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SubmitGetQuotesRequest, SOAP_TYPE_ns1__SubmitGetQuotesRequest, sizeof(ns1__SubmitGetQuotesRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__SubmitGetQuotesRequest * SOAP_FMAC2 soap_instantiate_ns1__SubmitGetQuotesRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SubmitGetQuotesRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__SubmitGetQuotesRequest *p;
	size_t k = sizeof(ns1__SubmitGetQuotesRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__SubmitGetQuotesRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__SubmitGetQuotesRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__SubmitGetQuotesRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__SubmitGetQuotesRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__SubmitGetQuotesRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__SubmitGetQuotesRequest(soap, tag ? tag : "ns1:SubmitGetQuotesRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SubmitGetQuotesRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SubmitGetQuotesRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SubmitGetQuotesRequest * SOAP_FMAC4 soap_get_ns1__SubmitGetQuotesRequest(struct soap *soap, ns1__SubmitGetQuotesRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SubmitGetQuotesRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__RetrieveGetActionsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__PerSecurityResponse::soap_default(soap);
	soap_default_std__string(soap, &this->ns1__RetrieveGetActionsResponse::responseId);
	this->ns1__RetrieveGetActionsResponse::headers = NULL;
	this->ns1__RetrieveGetActionsResponse::timestarted = NULL;
	this->ns1__RetrieveGetActionsResponse::instrumentDatas = NULL;
	this->ns1__RetrieveGetActionsResponse::timefinished = NULL;
}

void ns1__RetrieveGetActionsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__RetrieveGetActionsResponse::responseId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__RetrieveGetActionsResponse::responseId);
	soap_serialize_PointerTons1__GetActionsHeaders(soap, &this->ns1__RetrieveGetActionsResponse::headers);
	soap_serialize_PointerTodateTime(soap, &this->ns1__RetrieveGetActionsResponse::timestarted);
	soap_serialize_PointerTons1__ActionsInstrumentDatas(soap, &this->ns1__RetrieveGetActionsResponse::instrumentDatas);
	soap_serialize_PointerTodateTime(soap, &this->ns1__RetrieveGetActionsResponse::timefinished);
	this->ns1__PerSecurityResponse::soap_serialize(soap);
#endif
}

int ns1__RetrieveGetActionsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RetrieveGetActionsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RetrieveGetActionsResponse(struct soap *soap, const char *tag, int id, const ns1__RetrieveGetActionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RetrieveGetActionsResponse), type ? type : "ns1:RetrieveGetActionsResponse"))
		return soap->error;
	if (!a->ns1__PerSecurityResponse::statusCode)
	{	if (soap_element_empty(soap, "ns1:statusCode", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__ResponseStatus(soap, "ns1:statusCode", -1, &a->ns1__PerSecurityResponse::statusCode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:requestId", -1, &a->ns1__PerSecurityResponse::requestId, ""))
		return soap->error;
	soap_element_result(soap, "ns1:responseId");
	if (soap_out_std__string(soap, "ns1:responseId", -1, &a->ns1__RetrieveGetActionsResponse::responseId, ""))
		return soap->error;
	if (soap_out_PointerTons1__GetActionsHeaders(soap, "ns1:headers", -1, &a->ns1__RetrieveGetActionsResponse::headers, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns1:timestarted", -1, &a->ns1__RetrieveGetActionsResponse::timestarted, ""))
		return soap->error;
	if (soap_out_PointerTons1__ActionsInstrumentDatas(soap, "ns1:instrumentDatas", -1, &a->ns1__RetrieveGetActionsResponse::instrumentDatas, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns1:timefinished", -1, &a->ns1__RetrieveGetActionsResponse::timefinished, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__RetrieveGetActionsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__RetrieveGetActionsResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RetrieveGetActionsResponse * SOAP_FMAC4 soap_in_ns1__RetrieveGetActionsResponse(struct soap *soap, const char *tag, ns1__RetrieveGetActionsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RetrieveGetActionsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RetrieveGetActionsResponse, sizeof(ns1__RetrieveGetActionsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__RetrieveGetActionsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__RetrieveGetActionsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_statusCode2 = 1;
	size_t soap_flag_requestId2 = 1;
	size_t soap_flag_responseId1 = 1;
	size_t soap_flag_headers1 = 1;
	size_t soap_flag_timestarted1 = 1;
	size_t soap_flag_instrumentDatas1 = 1;
	size_t soap_flag_timefinished1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ResponseStatus(soap, "ns1:statusCode", &a->ns1__PerSecurityResponse::statusCode, "ns1:ResponseStatus"))
				{	soap_flag_statusCode2--;
					continue;
				}
			}
			if (soap_flag_requestId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:requestId", &a->ns1__PerSecurityResponse::requestId, "xsd:string"))
				{	soap_flag_requestId2--;
					continue;
				}
			}
			if (soap_flag_responseId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:responseId", &a->ns1__RetrieveGetActionsResponse::responseId, "xsd:string"))
				{	soap_flag_responseId1--;
					continue;
				}
			}
			if (soap_flag_headers1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GetActionsHeaders(soap, "ns1:headers", &a->ns1__RetrieveGetActionsResponse::headers, "ns1:GetActionsHeaders"))
				{	soap_flag_headers1--;
					continue;
				}
			}
			if (soap_flag_timestarted1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns1:timestarted", &a->ns1__RetrieveGetActionsResponse::timestarted, "xsd:dateTime"))
				{	soap_flag_timestarted1--;
					continue;
				}
			}
			if (soap_flag_instrumentDatas1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ActionsInstrumentDatas(soap, "ns1:instrumentDatas", &a->ns1__RetrieveGetActionsResponse::instrumentDatas, "ns1:ActionsInstrumentDatas"))
				{	soap_flag_instrumentDatas1--;
					continue;
				}
			}
			if (soap_flag_timefinished1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns1:timefinished", &a->ns1__RetrieveGetActionsResponse::timefinished, "xsd:dateTime"))
				{	soap_flag_timefinished1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:responseId");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__PerSecurityResponse::statusCode || soap_flag_requestId2 > 0 || soap_flag_responseId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__RetrieveGetActionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RetrieveGetActionsResponse, SOAP_TYPE_ns1__RetrieveGetActionsResponse, sizeof(ns1__RetrieveGetActionsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__RetrieveGetActionsResponse * SOAP_FMAC2 soap_instantiate_ns1__RetrieveGetActionsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RetrieveGetActionsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__RetrieveGetActionsResponse *p;
	size_t k = sizeof(ns1__RetrieveGetActionsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__RetrieveGetActionsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__RetrieveGetActionsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__RetrieveGetActionsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__RetrieveGetActionsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__RetrieveGetActionsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__RetrieveGetActionsResponse(soap, tag ? tag : "ns1:RetrieveGetActionsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__RetrieveGetActionsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RetrieveGetActionsResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RetrieveGetActionsResponse * SOAP_FMAC4 soap_get_ns1__RetrieveGetActionsResponse(struct soap *soap, ns1__RetrieveGetActionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RetrieveGetActionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__RetrieveGetActionsRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__RetrieveGetActionsRequest::responseId);
	this->ns1__RetrieveGetActionsRequest::responseDate = NULL;
}

void ns1__RetrieveGetActionsRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__RetrieveGetActionsRequest::responseId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__RetrieveGetActionsRequest::responseId);
	soap_serialize_PointerToxsd__date(soap, &this->ns1__RetrieveGetActionsRequest::responseDate);
#endif
}

int ns1__RetrieveGetActionsRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RetrieveGetActionsRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RetrieveGetActionsRequest(struct soap *soap, const char *tag, int id, const ns1__RetrieveGetActionsRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RetrieveGetActionsRequest), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:responseId", -1, &a->ns1__RetrieveGetActionsRequest::responseId, ""))
		return soap->error;
	if (soap_out_PointerToxsd__date(soap, "ns1:responseDate", -1, &a->ns1__RetrieveGetActionsRequest::responseDate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__RetrieveGetActionsRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__RetrieveGetActionsRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RetrieveGetActionsRequest * SOAP_FMAC4 soap_in_ns1__RetrieveGetActionsRequest(struct soap *soap, const char *tag, ns1__RetrieveGetActionsRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RetrieveGetActionsRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RetrieveGetActionsRequest, sizeof(ns1__RetrieveGetActionsRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__RetrieveGetActionsRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__RetrieveGetActionsRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_responseId1 = 1;
	size_t soap_flag_responseDate1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_responseId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:responseId", &a->ns1__RetrieveGetActionsRequest::responseId, "xsd:string"))
				{	soap_flag_responseId1--;
					continue;
				}
			}
			if (soap_flag_responseDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__date(soap, "ns1:responseDate", &a->ns1__RetrieveGetActionsRequest::responseDate, "xsd:date"))
				{	soap_flag_responseDate1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_responseId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__RetrieveGetActionsRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RetrieveGetActionsRequest, SOAP_TYPE_ns1__RetrieveGetActionsRequest, sizeof(ns1__RetrieveGetActionsRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__RetrieveGetActionsRequest * SOAP_FMAC2 soap_instantiate_ns1__RetrieveGetActionsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RetrieveGetActionsRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__RetrieveGetActionsRequest *p;
	size_t k = sizeof(ns1__RetrieveGetActionsRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__RetrieveGetActionsRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__RetrieveGetActionsRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__RetrieveGetActionsRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__RetrieveGetActionsRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__RetrieveGetActionsRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__RetrieveGetActionsRequest(soap, tag ? tag : "ns1:RetrieveGetActionsRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__RetrieveGetActionsRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RetrieveGetActionsRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RetrieveGetActionsRequest * SOAP_FMAC4 soap_get_ns1__RetrieveGetActionsRequest(struct soap *soap, ns1__RetrieveGetActionsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RetrieveGetActionsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__SubmitGetActionsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__PerSecurityResponse::soap_default(soap);
	soap_default_std__string(soap, &this->ns1__SubmitGetActionsResponse::responseId);
}

void ns1__SubmitGetActionsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__SubmitGetActionsResponse::responseId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__SubmitGetActionsResponse::responseId);
	this->ns1__PerSecurityResponse::soap_serialize(soap);
#endif
}

int ns1__SubmitGetActionsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SubmitGetActionsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SubmitGetActionsResponse(struct soap *soap, const char *tag, int id, const ns1__SubmitGetActionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SubmitGetActionsResponse), type ? type : "ns1:SubmitGetActionsResponse"))
		return soap->error;
	if (!a->ns1__PerSecurityResponse::statusCode)
	{	if (soap_element_empty(soap, "ns1:statusCode", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__ResponseStatus(soap, "ns1:statusCode", -1, &a->ns1__PerSecurityResponse::statusCode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:requestId", -1, &a->ns1__PerSecurityResponse::requestId, ""))
		return soap->error;
	soap_element_result(soap, "ns1:responseId");
	if (soap_out_std__string(soap, "ns1:responseId", -1, &a->ns1__SubmitGetActionsResponse::responseId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SubmitGetActionsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__SubmitGetActionsResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SubmitGetActionsResponse * SOAP_FMAC4 soap_in_ns1__SubmitGetActionsResponse(struct soap *soap, const char *tag, ns1__SubmitGetActionsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SubmitGetActionsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SubmitGetActionsResponse, sizeof(ns1__SubmitGetActionsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__SubmitGetActionsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__SubmitGetActionsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_statusCode2 = 1;
	size_t soap_flag_requestId2 = 1;
	size_t soap_flag_responseId1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ResponseStatus(soap, "ns1:statusCode", &a->ns1__PerSecurityResponse::statusCode, "ns1:ResponseStatus"))
				{	soap_flag_statusCode2--;
					continue;
				}
			}
			if (soap_flag_requestId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:requestId", &a->ns1__PerSecurityResponse::requestId, "xsd:string"))
				{	soap_flag_requestId2--;
					continue;
				}
			}
			if (soap_flag_responseId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:responseId", &a->ns1__SubmitGetActionsResponse::responseId, "xsd:string"))
				{	soap_flag_responseId1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:responseId");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__PerSecurityResponse::statusCode || soap_flag_requestId2 > 0 || soap_flag_responseId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__SubmitGetActionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SubmitGetActionsResponse, SOAP_TYPE_ns1__SubmitGetActionsResponse, sizeof(ns1__SubmitGetActionsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__SubmitGetActionsResponse * SOAP_FMAC2 soap_instantiate_ns1__SubmitGetActionsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SubmitGetActionsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__SubmitGetActionsResponse *p;
	size_t k = sizeof(ns1__SubmitGetActionsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__SubmitGetActionsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__SubmitGetActionsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__SubmitGetActionsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__SubmitGetActionsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__SubmitGetActionsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__SubmitGetActionsResponse(soap, tag ? tag : "ns1:SubmitGetActionsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SubmitGetActionsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SubmitGetActionsResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SubmitGetActionsResponse * SOAP_FMAC4 soap_get_ns1__SubmitGetActionsResponse(struct soap *soap, ns1__SubmitGetActionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SubmitGetActionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__SubmitGetActionsRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__SubmitGetActionsRequest::headers = NULL;
	this->ns1__SubmitGetActionsRequest::instruments = NULL;
}

void ns1__SubmitGetActionsRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__GetActionsHeaders(soap, &this->ns1__SubmitGetActionsRequest::headers);
	soap_serialize_PointerTons1__Instruments(soap, &this->ns1__SubmitGetActionsRequest::instruments);
#endif
}

int ns1__SubmitGetActionsRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SubmitGetActionsRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SubmitGetActionsRequest(struct soap *soap, const char *tag, int id, const ns1__SubmitGetActionsRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SubmitGetActionsRequest), type))
		return soap->error;
	if (!a->ns1__SubmitGetActionsRequest::headers)
	{	if (soap_element_empty(soap, "ns1:headers", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__GetActionsHeaders(soap, "ns1:headers", -1, &a->ns1__SubmitGetActionsRequest::headers, ""))
		return soap->error;
	if (!a->ns1__SubmitGetActionsRequest::instruments)
	{	if (soap_element_empty(soap, "ns1:instruments", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__Instruments(soap, "ns1:instruments", -1, &a->ns1__SubmitGetActionsRequest::instruments, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SubmitGetActionsRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__SubmitGetActionsRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SubmitGetActionsRequest * SOAP_FMAC4 soap_in_ns1__SubmitGetActionsRequest(struct soap *soap, const char *tag, ns1__SubmitGetActionsRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SubmitGetActionsRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SubmitGetActionsRequest, sizeof(ns1__SubmitGetActionsRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__SubmitGetActionsRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__SubmitGetActionsRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_headers1 = 1;
	size_t soap_flag_instruments1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_headers1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GetActionsHeaders(soap, "ns1:headers", &a->ns1__SubmitGetActionsRequest::headers, "ns1:GetActionsHeaders"))
				{	soap_flag_headers1--;
					continue;
				}
			}
			if (soap_flag_instruments1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Instruments(soap, "ns1:instruments", &a->ns1__SubmitGetActionsRequest::instruments, "ns1:Instruments"))
				{	soap_flag_instruments1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__SubmitGetActionsRequest::headers || !a->ns1__SubmitGetActionsRequest::instruments))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__SubmitGetActionsRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SubmitGetActionsRequest, SOAP_TYPE_ns1__SubmitGetActionsRequest, sizeof(ns1__SubmitGetActionsRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__SubmitGetActionsRequest * SOAP_FMAC2 soap_instantiate_ns1__SubmitGetActionsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SubmitGetActionsRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__SubmitGetActionsRequest *p;
	size_t k = sizeof(ns1__SubmitGetActionsRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__SubmitGetActionsRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__SubmitGetActionsRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__SubmitGetActionsRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__SubmitGetActionsRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__SubmitGetActionsRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__SubmitGetActionsRequest(soap, tag ? tag : "ns1:SubmitGetActionsRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SubmitGetActionsRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SubmitGetActionsRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SubmitGetActionsRequest * SOAP_FMAC4 soap_get_ns1__SubmitGetActionsRequest(struct soap *soap, ns1__SubmitGetActionsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SubmitGetActionsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__GetPortfolioValidationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__PerSecurityResponse::soap_default(soap);
	soap_default_std__string(soap, &this->ns1__GetPortfolioValidationResponse::responseId);
	this->ns1__GetPortfolioValidationResponse::headers = NULL;
	this->ns1__GetPortfolioValidationResponse::fields = NULL;
	this->ns1__GetPortfolioValidationResponse::timestarted = NULL;
	this->ns1__GetPortfolioValidationResponse::instrumentDatas = NULL;
	this->ns1__GetPortfolioValidationResponse::timefinished = NULL;
}

void ns1__GetPortfolioValidationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__GetPortfolioValidationResponse::responseId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__GetPortfolioValidationResponse::responseId);
	soap_serialize_PointerTons1__GetPortfolioValidationHeaders(soap, &this->ns1__GetPortfolioValidationResponse::headers);
	soap_serialize_PointerTons1__Fields(soap, &this->ns1__GetPortfolioValidationResponse::fields);
	soap_serialize_PointerTodateTime(soap, &this->ns1__GetPortfolioValidationResponse::timestarted);
	soap_serialize_PointerTons1__InstrumentDatas(soap, &this->ns1__GetPortfolioValidationResponse::instrumentDatas);
	soap_serialize_PointerTodateTime(soap, &this->ns1__GetPortfolioValidationResponse::timefinished);
	this->ns1__PerSecurityResponse::soap_serialize(soap);
#endif
}

int ns1__GetPortfolioValidationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__GetPortfolioValidationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetPortfolioValidationResponse(struct soap *soap, const char *tag, int id, const ns1__GetPortfolioValidationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetPortfolioValidationResponse), type ? type : "ns1:GetPortfolioValidationResponse"))
		return soap->error;
	if (!a->ns1__PerSecurityResponse::statusCode)
	{	if (soap_element_empty(soap, "ns1:statusCode", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__ResponseStatus(soap, "ns1:statusCode", -1, &a->ns1__PerSecurityResponse::statusCode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:requestId", -1, &a->ns1__PerSecurityResponse::requestId, ""))
		return soap->error;
	soap_element_result(soap, "ns1:responseId");
	if (soap_out_std__string(soap, "ns1:responseId", -1, &a->ns1__GetPortfolioValidationResponse::responseId, ""))
		return soap->error;
	if (soap_out_PointerTons1__GetPortfolioValidationHeaders(soap, "ns1:headers", -1, &a->ns1__GetPortfolioValidationResponse::headers, ""))
		return soap->error;
	if (soap_out_PointerTons1__Fields(soap, "ns1:fields", -1, &a->ns1__GetPortfolioValidationResponse::fields, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns1:timestarted", -1, &a->ns1__GetPortfolioValidationResponse::timestarted, ""))
		return soap->error;
	if (soap_out_PointerTons1__InstrumentDatas(soap, "ns1:instrumentDatas", -1, &a->ns1__GetPortfolioValidationResponse::instrumentDatas, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns1:timefinished", -1, &a->ns1__GetPortfolioValidationResponse::timefinished, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__GetPortfolioValidationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__GetPortfolioValidationResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__GetPortfolioValidationResponse * SOAP_FMAC4 soap_in_ns1__GetPortfolioValidationResponse(struct soap *soap, const char *tag, ns1__GetPortfolioValidationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__GetPortfolioValidationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetPortfolioValidationResponse, sizeof(ns1__GetPortfolioValidationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__GetPortfolioValidationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__GetPortfolioValidationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_statusCode2 = 1;
	size_t soap_flag_requestId2 = 1;
	size_t soap_flag_responseId1 = 1;
	size_t soap_flag_headers1 = 1;
	size_t soap_flag_fields1 = 1;
	size_t soap_flag_timestarted1 = 1;
	size_t soap_flag_instrumentDatas1 = 1;
	size_t soap_flag_timefinished1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ResponseStatus(soap, "ns1:statusCode", &a->ns1__PerSecurityResponse::statusCode, "ns1:ResponseStatus"))
				{	soap_flag_statusCode2--;
					continue;
				}
			}
			if (soap_flag_requestId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:requestId", &a->ns1__PerSecurityResponse::requestId, "xsd:string"))
				{	soap_flag_requestId2--;
					continue;
				}
			}
			if (soap_flag_responseId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:responseId", &a->ns1__GetPortfolioValidationResponse::responseId, "xsd:string"))
				{	soap_flag_responseId1--;
					continue;
				}
			}
			if (soap_flag_headers1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GetPortfolioValidationHeaders(soap, "ns1:headers", &a->ns1__GetPortfolioValidationResponse::headers, "ns1:GetPortfolioValidationHeaders"))
				{	soap_flag_headers1--;
					continue;
				}
			}
			if (soap_flag_fields1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Fields(soap, "ns1:fields", &a->ns1__GetPortfolioValidationResponse::fields, "ns1:Fields"))
				{	soap_flag_fields1--;
					continue;
				}
			}
			if (soap_flag_timestarted1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns1:timestarted", &a->ns1__GetPortfolioValidationResponse::timestarted, "xsd:dateTime"))
				{	soap_flag_timestarted1--;
					continue;
				}
			}
			if (soap_flag_instrumentDatas1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__InstrumentDatas(soap, "ns1:instrumentDatas", &a->ns1__GetPortfolioValidationResponse::instrumentDatas, "ns1:InstrumentDatas"))
				{	soap_flag_instrumentDatas1--;
					continue;
				}
			}
			if (soap_flag_timefinished1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns1:timefinished", &a->ns1__GetPortfolioValidationResponse::timefinished, "xsd:dateTime"))
				{	soap_flag_timefinished1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:responseId");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__PerSecurityResponse::statusCode || soap_flag_requestId2 > 0 || soap_flag_responseId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__GetPortfolioValidationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetPortfolioValidationResponse, SOAP_TYPE_ns1__GetPortfolioValidationResponse, sizeof(ns1__GetPortfolioValidationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__GetPortfolioValidationResponse * SOAP_FMAC2 soap_instantiate_ns1__GetPortfolioValidationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetPortfolioValidationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__GetPortfolioValidationResponse *p;
	size_t k = sizeof(ns1__GetPortfolioValidationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetPortfolioValidationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__GetPortfolioValidationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__GetPortfolioValidationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__GetPortfolioValidationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__GetPortfolioValidationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__GetPortfolioValidationResponse(soap, tag ? tag : "ns1:GetPortfolioValidationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__GetPortfolioValidationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__GetPortfolioValidationResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__GetPortfolioValidationResponse * SOAP_FMAC4 soap_get_ns1__GetPortfolioValidationResponse(struct soap *soap, ns1__GetPortfolioValidationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetPortfolioValidationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__GetPortfolioValidationRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__GetPortfolioValidationRequest::responseId);
	this->ns1__GetPortfolioValidationRequest::responseDate = NULL;
}

void ns1__GetPortfolioValidationRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__GetPortfolioValidationRequest::responseId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__GetPortfolioValidationRequest::responseId);
	soap_serialize_PointerToxsd__date(soap, &this->ns1__GetPortfolioValidationRequest::responseDate);
#endif
}

int ns1__GetPortfolioValidationRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__GetPortfolioValidationRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetPortfolioValidationRequest(struct soap *soap, const char *tag, int id, const ns1__GetPortfolioValidationRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetPortfolioValidationRequest), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:responseId", -1, &a->ns1__GetPortfolioValidationRequest::responseId, ""))
		return soap->error;
	if (soap_out_PointerToxsd__date(soap, "ns1:responseDate", -1, &a->ns1__GetPortfolioValidationRequest::responseDate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__GetPortfolioValidationRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__GetPortfolioValidationRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__GetPortfolioValidationRequest * SOAP_FMAC4 soap_in_ns1__GetPortfolioValidationRequest(struct soap *soap, const char *tag, ns1__GetPortfolioValidationRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__GetPortfolioValidationRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetPortfolioValidationRequest, sizeof(ns1__GetPortfolioValidationRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__GetPortfolioValidationRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__GetPortfolioValidationRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_responseId1 = 1;
	size_t soap_flag_responseDate1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_responseId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:responseId", &a->ns1__GetPortfolioValidationRequest::responseId, "xsd:string"))
				{	soap_flag_responseId1--;
					continue;
				}
			}
			if (soap_flag_responseDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__date(soap, "ns1:responseDate", &a->ns1__GetPortfolioValidationRequest::responseDate, "xsd:date"))
				{	soap_flag_responseDate1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_responseId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__GetPortfolioValidationRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetPortfolioValidationRequest, SOAP_TYPE_ns1__GetPortfolioValidationRequest, sizeof(ns1__GetPortfolioValidationRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__GetPortfolioValidationRequest * SOAP_FMAC2 soap_instantiate_ns1__GetPortfolioValidationRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetPortfolioValidationRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__GetPortfolioValidationRequest *p;
	size_t k = sizeof(ns1__GetPortfolioValidationRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetPortfolioValidationRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__GetPortfolioValidationRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__GetPortfolioValidationRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__GetPortfolioValidationRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__GetPortfolioValidationRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__GetPortfolioValidationRequest(soap, tag ? tag : "ns1:GetPortfolioValidationRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__GetPortfolioValidationRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__GetPortfolioValidationRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__GetPortfolioValidationRequest * SOAP_FMAC4 soap_get_ns1__GetPortfolioValidationRequest(struct soap *soap, ns1__GetPortfolioValidationRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetPortfolioValidationRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__RetrieveGetCompanyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__PerSecurityResponse::soap_default(soap);
	soap_default_std__string(soap, &this->ns1__RetrieveGetCompanyResponse::responseId);
	this->ns1__RetrieveGetCompanyResponse::headers = NULL;
	this->ns1__RetrieveGetCompanyResponse::fields = NULL;
	this->ns1__RetrieveGetCompanyResponse::timestarted = NULL;
	this->ns1__RetrieveGetCompanyResponse::instrumentDatas = NULL;
	this->ns1__RetrieveGetCompanyResponse::timefinished = NULL;
}

void ns1__RetrieveGetCompanyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__RetrieveGetCompanyResponse::responseId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__RetrieveGetCompanyResponse::responseId);
	soap_serialize_PointerTons1__GetCompanyHeaders(soap, &this->ns1__RetrieveGetCompanyResponse::headers);
	soap_serialize_PointerTons1__Fields(soap, &this->ns1__RetrieveGetCompanyResponse::fields);
	soap_serialize_PointerTodateTime(soap, &this->ns1__RetrieveGetCompanyResponse::timestarted);
	soap_serialize_PointerTons1__InstrumentDatas(soap, &this->ns1__RetrieveGetCompanyResponse::instrumentDatas);
	soap_serialize_PointerTodateTime(soap, &this->ns1__RetrieveGetCompanyResponse::timefinished);
	this->ns1__PerSecurityResponse::soap_serialize(soap);
#endif
}

int ns1__RetrieveGetCompanyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RetrieveGetCompanyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RetrieveGetCompanyResponse(struct soap *soap, const char *tag, int id, const ns1__RetrieveGetCompanyResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RetrieveGetCompanyResponse), type ? type : "ns1:RetrieveGetCompanyResponse"))
		return soap->error;
	if (!a->ns1__PerSecurityResponse::statusCode)
	{	if (soap_element_empty(soap, "ns1:statusCode", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__ResponseStatus(soap, "ns1:statusCode", -1, &a->ns1__PerSecurityResponse::statusCode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:requestId", -1, &a->ns1__PerSecurityResponse::requestId, ""))
		return soap->error;
	soap_element_result(soap, "ns1:responseId");
	if (soap_out_std__string(soap, "ns1:responseId", -1, &a->ns1__RetrieveGetCompanyResponse::responseId, ""))
		return soap->error;
	if (soap_out_PointerTons1__GetCompanyHeaders(soap, "ns1:headers", -1, &a->ns1__RetrieveGetCompanyResponse::headers, ""))
		return soap->error;
	if (soap_out_PointerTons1__Fields(soap, "ns1:fields", -1, &a->ns1__RetrieveGetCompanyResponse::fields, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns1:timestarted", -1, &a->ns1__RetrieveGetCompanyResponse::timestarted, ""))
		return soap->error;
	if (soap_out_PointerTons1__InstrumentDatas(soap, "ns1:instrumentDatas", -1, &a->ns1__RetrieveGetCompanyResponse::instrumentDatas, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns1:timefinished", -1, &a->ns1__RetrieveGetCompanyResponse::timefinished, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__RetrieveGetCompanyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__RetrieveGetCompanyResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RetrieveGetCompanyResponse * SOAP_FMAC4 soap_in_ns1__RetrieveGetCompanyResponse(struct soap *soap, const char *tag, ns1__RetrieveGetCompanyResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RetrieveGetCompanyResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RetrieveGetCompanyResponse, sizeof(ns1__RetrieveGetCompanyResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__RetrieveGetCompanyResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__RetrieveGetCompanyResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_statusCode2 = 1;
	size_t soap_flag_requestId2 = 1;
	size_t soap_flag_responseId1 = 1;
	size_t soap_flag_headers1 = 1;
	size_t soap_flag_fields1 = 1;
	size_t soap_flag_timestarted1 = 1;
	size_t soap_flag_instrumentDatas1 = 1;
	size_t soap_flag_timefinished1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ResponseStatus(soap, "ns1:statusCode", &a->ns1__PerSecurityResponse::statusCode, "ns1:ResponseStatus"))
				{	soap_flag_statusCode2--;
					continue;
				}
			}
			if (soap_flag_requestId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:requestId", &a->ns1__PerSecurityResponse::requestId, "xsd:string"))
				{	soap_flag_requestId2--;
					continue;
				}
			}
			if (soap_flag_responseId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:responseId", &a->ns1__RetrieveGetCompanyResponse::responseId, "xsd:string"))
				{	soap_flag_responseId1--;
					continue;
				}
			}
			if (soap_flag_headers1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GetCompanyHeaders(soap, "ns1:headers", &a->ns1__RetrieveGetCompanyResponse::headers, "ns1:GetCompanyHeaders"))
				{	soap_flag_headers1--;
					continue;
				}
			}
			if (soap_flag_fields1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Fields(soap, "ns1:fields", &a->ns1__RetrieveGetCompanyResponse::fields, "ns1:Fields"))
				{	soap_flag_fields1--;
					continue;
				}
			}
			if (soap_flag_timestarted1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns1:timestarted", &a->ns1__RetrieveGetCompanyResponse::timestarted, "xsd:dateTime"))
				{	soap_flag_timestarted1--;
					continue;
				}
			}
			if (soap_flag_instrumentDatas1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__InstrumentDatas(soap, "ns1:instrumentDatas", &a->ns1__RetrieveGetCompanyResponse::instrumentDatas, "ns1:InstrumentDatas"))
				{	soap_flag_instrumentDatas1--;
					continue;
				}
			}
			if (soap_flag_timefinished1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns1:timefinished", &a->ns1__RetrieveGetCompanyResponse::timefinished, "xsd:dateTime"))
				{	soap_flag_timefinished1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:responseId");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__PerSecurityResponse::statusCode || soap_flag_requestId2 > 0 || soap_flag_responseId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__RetrieveGetCompanyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RetrieveGetCompanyResponse, SOAP_TYPE_ns1__RetrieveGetCompanyResponse, sizeof(ns1__RetrieveGetCompanyResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__RetrieveGetCompanyResponse * SOAP_FMAC2 soap_instantiate_ns1__RetrieveGetCompanyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RetrieveGetCompanyResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__RetrieveGetCompanyResponse *p;
	size_t k = sizeof(ns1__RetrieveGetCompanyResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__RetrieveGetCompanyResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__RetrieveGetCompanyResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__RetrieveGetCompanyResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__RetrieveGetCompanyResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__RetrieveGetCompanyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__RetrieveGetCompanyResponse(soap, tag ? tag : "ns1:RetrieveGetCompanyResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__RetrieveGetCompanyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RetrieveGetCompanyResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RetrieveGetCompanyResponse * SOAP_FMAC4 soap_get_ns1__RetrieveGetCompanyResponse(struct soap *soap, ns1__RetrieveGetCompanyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RetrieveGetCompanyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__RetrieveGetCompanyRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__RetrieveGetCompanyRequest::responseId);
	this->ns1__RetrieveGetCompanyRequest::responseDate = NULL;
}

void ns1__RetrieveGetCompanyRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__RetrieveGetCompanyRequest::responseId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__RetrieveGetCompanyRequest::responseId);
	soap_serialize_PointerToxsd__date(soap, &this->ns1__RetrieveGetCompanyRequest::responseDate);
#endif
}

int ns1__RetrieveGetCompanyRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RetrieveGetCompanyRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RetrieveGetCompanyRequest(struct soap *soap, const char *tag, int id, const ns1__RetrieveGetCompanyRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RetrieveGetCompanyRequest), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:responseId", -1, &a->ns1__RetrieveGetCompanyRequest::responseId, ""))
		return soap->error;
	if (soap_out_PointerToxsd__date(soap, "ns1:responseDate", -1, &a->ns1__RetrieveGetCompanyRequest::responseDate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__RetrieveGetCompanyRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__RetrieveGetCompanyRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RetrieveGetCompanyRequest * SOAP_FMAC4 soap_in_ns1__RetrieveGetCompanyRequest(struct soap *soap, const char *tag, ns1__RetrieveGetCompanyRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RetrieveGetCompanyRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RetrieveGetCompanyRequest, sizeof(ns1__RetrieveGetCompanyRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__RetrieveGetCompanyRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__RetrieveGetCompanyRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_responseId1 = 1;
	size_t soap_flag_responseDate1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_responseId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:responseId", &a->ns1__RetrieveGetCompanyRequest::responseId, "xsd:string"))
				{	soap_flag_responseId1--;
					continue;
				}
			}
			if (soap_flag_responseDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__date(soap, "ns1:responseDate", &a->ns1__RetrieveGetCompanyRequest::responseDate, "xsd:date"))
				{	soap_flag_responseDate1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_responseId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__RetrieveGetCompanyRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RetrieveGetCompanyRequest, SOAP_TYPE_ns1__RetrieveGetCompanyRequest, sizeof(ns1__RetrieveGetCompanyRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__RetrieveGetCompanyRequest * SOAP_FMAC2 soap_instantiate_ns1__RetrieveGetCompanyRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RetrieveGetCompanyRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__RetrieveGetCompanyRequest *p;
	size_t k = sizeof(ns1__RetrieveGetCompanyRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__RetrieveGetCompanyRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__RetrieveGetCompanyRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__RetrieveGetCompanyRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__RetrieveGetCompanyRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__RetrieveGetCompanyRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__RetrieveGetCompanyRequest(soap, tag ? tag : "ns1:RetrieveGetCompanyRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__RetrieveGetCompanyRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RetrieveGetCompanyRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RetrieveGetCompanyRequest * SOAP_FMAC4 soap_get_ns1__RetrieveGetCompanyRequest(struct soap *soap, ns1__RetrieveGetCompanyRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RetrieveGetCompanyRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__SubmitGetCompanyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__PerSecurityResponse::soap_default(soap);
	soap_default_std__string(soap, &this->ns1__SubmitGetCompanyResponse::responseId);
}

void ns1__SubmitGetCompanyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__SubmitGetCompanyResponse::responseId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__SubmitGetCompanyResponse::responseId);
	this->ns1__PerSecurityResponse::soap_serialize(soap);
#endif
}

int ns1__SubmitGetCompanyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SubmitGetCompanyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SubmitGetCompanyResponse(struct soap *soap, const char *tag, int id, const ns1__SubmitGetCompanyResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SubmitGetCompanyResponse), type ? type : "ns1:SubmitGetCompanyResponse"))
		return soap->error;
	if (!a->ns1__PerSecurityResponse::statusCode)
	{	if (soap_element_empty(soap, "ns1:statusCode", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__ResponseStatus(soap, "ns1:statusCode", -1, &a->ns1__PerSecurityResponse::statusCode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:requestId", -1, &a->ns1__PerSecurityResponse::requestId, ""))
		return soap->error;
	soap_element_result(soap, "ns1:responseId");
	if (soap_out_std__string(soap, "ns1:responseId", -1, &a->ns1__SubmitGetCompanyResponse::responseId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SubmitGetCompanyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__SubmitGetCompanyResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SubmitGetCompanyResponse * SOAP_FMAC4 soap_in_ns1__SubmitGetCompanyResponse(struct soap *soap, const char *tag, ns1__SubmitGetCompanyResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SubmitGetCompanyResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SubmitGetCompanyResponse, sizeof(ns1__SubmitGetCompanyResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__SubmitGetCompanyResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__SubmitGetCompanyResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_statusCode2 = 1;
	size_t soap_flag_requestId2 = 1;
	size_t soap_flag_responseId1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ResponseStatus(soap, "ns1:statusCode", &a->ns1__PerSecurityResponse::statusCode, "ns1:ResponseStatus"))
				{	soap_flag_statusCode2--;
					continue;
				}
			}
			if (soap_flag_requestId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:requestId", &a->ns1__PerSecurityResponse::requestId, "xsd:string"))
				{	soap_flag_requestId2--;
					continue;
				}
			}
			if (soap_flag_responseId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:responseId", &a->ns1__SubmitGetCompanyResponse::responseId, "xsd:string"))
				{	soap_flag_responseId1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:responseId");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__PerSecurityResponse::statusCode || soap_flag_requestId2 > 0 || soap_flag_responseId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__SubmitGetCompanyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SubmitGetCompanyResponse, SOAP_TYPE_ns1__SubmitGetCompanyResponse, sizeof(ns1__SubmitGetCompanyResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__SubmitGetCompanyResponse * SOAP_FMAC2 soap_instantiate_ns1__SubmitGetCompanyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SubmitGetCompanyResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__SubmitGetCompanyResponse *p;
	size_t k = sizeof(ns1__SubmitGetCompanyResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__SubmitGetCompanyResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__SubmitGetCompanyResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__SubmitGetCompanyResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__SubmitGetCompanyResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__SubmitGetCompanyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__SubmitGetCompanyResponse(soap, tag ? tag : "ns1:SubmitGetCompanyResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SubmitGetCompanyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SubmitGetCompanyResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SubmitGetCompanyResponse * SOAP_FMAC4 soap_get_ns1__SubmitGetCompanyResponse(struct soap *soap, ns1__SubmitGetCompanyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SubmitGetCompanyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__SubmitGetCompanyRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__SubmitGetCompanyRequest::headers = NULL;
	this->ns1__SubmitGetCompanyRequest::fieldset = NULL;
	this->ns1__SubmitGetCompanyRequest::fields = NULL;
	this->ns1__SubmitGetCompanyRequest::instruments = NULL;
}

void ns1__SubmitGetCompanyRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__GetCompanyHeaders(soap, &this->ns1__SubmitGetCompanyRequest::headers);
	soap_serialize_PointerTons1__FieldSet(soap, &this->ns1__SubmitGetCompanyRequest::fieldset);
	soap_serialize_PointerTons1__Fields(soap, &this->ns1__SubmitGetCompanyRequest::fields);
	soap_serialize_PointerTons1__Instruments(soap, &this->ns1__SubmitGetCompanyRequest::instruments);
#endif
}

int ns1__SubmitGetCompanyRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SubmitGetCompanyRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SubmitGetCompanyRequest(struct soap *soap, const char *tag, int id, const ns1__SubmitGetCompanyRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SubmitGetCompanyRequest), type))
		return soap->error;
	if (!a->ns1__SubmitGetCompanyRequest::headers)
	{	if (soap_element_empty(soap, "ns1:headers", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__GetCompanyHeaders(soap, "ns1:headers", -1, &a->ns1__SubmitGetCompanyRequest::headers, ""))
		return soap->error;
	if (soap_out_PointerTons1__FieldSet(soap, "ns1:fieldset", -1, &a->ns1__SubmitGetCompanyRequest::fieldset, ""))
		return soap->error;
	if (soap_out_PointerTons1__Fields(soap, "ns1:fields", -1, &a->ns1__SubmitGetCompanyRequest::fields, ""))
		return soap->error;
	if (!a->ns1__SubmitGetCompanyRequest::instruments)
	{	if (soap_element_empty(soap, "ns1:instruments", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__Instruments(soap, "ns1:instruments", -1, &a->ns1__SubmitGetCompanyRequest::instruments, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SubmitGetCompanyRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__SubmitGetCompanyRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SubmitGetCompanyRequest * SOAP_FMAC4 soap_in_ns1__SubmitGetCompanyRequest(struct soap *soap, const char *tag, ns1__SubmitGetCompanyRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SubmitGetCompanyRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SubmitGetCompanyRequest, sizeof(ns1__SubmitGetCompanyRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__SubmitGetCompanyRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__SubmitGetCompanyRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_headers1 = 1;
	size_t soap_flag_fieldset1 = 1;
	size_t soap_flag_fields1 = 1;
	size_t soap_flag_instruments1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_headers1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GetCompanyHeaders(soap, "ns1:headers", &a->ns1__SubmitGetCompanyRequest::headers, "ns1:GetCompanyHeaders"))
				{	soap_flag_headers1--;
					continue;
				}
			}
			if (soap_flag_fieldset1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__FieldSet(soap, "ns1:fieldset", &a->ns1__SubmitGetCompanyRequest::fieldset, "ns1:FieldSet"))
				{	soap_flag_fieldset1--;
					continue;
				}
			}
			if (soap_flag_fields1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Fields(soap, "ns1:fields", &a->ns1__SubmitGetCompanyRequest::fields, "ns1:Fields"))
				{	soap_flag_fields1--;
					continue;
				}
			}
			if (soap_flag_instruments1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Instruments(soap, "ns1:instruments", &a->ns1__SubmitGetCompanyRequest::instruments, "ns1:Instruments"))
				{	soap_flag_instruments1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__SubmitGetCompanyRequest::headers || !a->ns1__SubmitGetCompanyRequest::instruments))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__SubmitGetCompanyRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SubmitGetCompanyRequest, SOAP_TYPE_ns1__SubmitGetCompanyRequest, sizeof(ns1__SubmitGetCompanyRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__SubmitGetCompanyRequest * SOAP_FMAC2 soap_instantiate_ns1__SubmitGetCompanyRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SubmitGetCompanyRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__SubmitGetCompanyRequest *p;
	size_t k = sizeof(ns1__SubmitGetCompanyRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__SubmitGetCompanyRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__SubmitGetCompanyRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__SubmitGetCompanyRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__SubmitGetCompanyRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__SubmitGetCompanyRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__SubmitGetCompanyRequest(soap, tag ? tag : "ns1:SubmitGetCompanyRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SubmitGetCompanyRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SubmitGetCompanyRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SubmitGetCompanyRequest * SOAP_FMAC4 soap_get_ns1__SubmitGetCompanyRequest(struct soap *soap, ns1__SubmitGetCompanyRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SubmitGetCompanyRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__RetrieveGetFundamentalsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__PerSecurityResponse::soap_default(soap);
	soap_default_std__string(soap, &this->ns1__RetrieveGetFundamentalsResponse::responseId);
	this->ns1__RetrieveGetFundamentalsResponse::headers = NULL;
	this->ns1__RetrieveGetFundamentalsResponse::fields = NULL;
	this->ns1__RetrieveGetFundamentalsResponse::timestarted = NULL;
	this->ns1__RetrieveGetFundamentalsResponse::instrumentDatas = NULL;
	this->ns1__RetrieveGetFundamentalsResponse::timefinished = NULL;
}

void ns1__RetrieveGetFundamentalsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__RetrieveGetFundamentalsResponse::responseId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__RetrieveGetFundamentalsResponse::responseId);
	soap_serialize_PointerTons1__GetFundamentalsHeaders(soap, &this->ns1__RetrieveGetFundamentalsResponse::headers);
	soap_serialize_PointerTons1__Fields(soap, &this->ns1__RetrieveGetFundamentalsResponse::fields);
	soap_serialize_PointerTodateTime(soap, &this->ns1__RetrieveGetFundamentalsResponse::timestarted);
	soap_serialize_PointerTons1__FundInstrumentDatas(soap, &this->ns1__RetrieveGetFundamentalsResponse::instrumentDatas);
	soap_serialize_PointerTodateTime(soap, &this->ns1__RetrieveGetFundamentalsResponse::timefinished);
	this->ns1__PerSecurityResponse::soap_serialize(soap);
#endif
}

int ns1__RetrieveGetFundamentalsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RetrieveGetFundamentalsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RetrieveGetFundamentalsResponse(struct soap *soap, const char *tag, int id, const ns1__RetrieveGetFundamentalsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RetrieveGetFundamentalsResponse), type ? type : "ns1:RetrieveGetFundamentalsResponse"))
		return soap->error;
	if (!a->ns1__PerSecurityResponse::statusCode)
	{	if (soap_element_empty(soap, "ns1:statusCode", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__ResponseStatus(soap, "ns1:statusCode", -1, &a->ns1__PerSecurityResponse::statusCode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:requestId", -1, &a->ns1__PerSecurityResponse::requestId, ""))
		return soap->error;
	soap_element_result(soap, "ns1:responseId");
	if (soap_out_std__string(soap, "ns1:responseId", -1, &a->ns1__RetrieveGetFundamentalsResponse::responseId, ""))
		return soap->error;
	if (soap_out_PointerTons1__GetFundamentalsHeaders(soap, "ns1:headers", -1, &a->ns1__RetrieveGetFundamentalsResponse::headers, ""))
		return soap->error;
	if (soap_out_PointerTons1__Fields(soap, "ns1:fields", -1, &a->ns1__RetrieveGetFundamentalsResponse::fields, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns1:timestarted", -1, &a->ns1__RetrieveGetFundamentalsResponse::timestarted, ""))
		return soap->error;
	if (soap_out_PointerTons1__FundInstrumentDatas(soap, "ns1:instrumentDatas", -1, &a->ns1__RetrieveGetFundamentalsResponse::instrumentDatas, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns1:timefinished", -1, &a->ns1__RetrieveGetFundamentalsResponse::timefinished, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__RetrieveGetFundamentalsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__RetrieveGetFundamentalsResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RetrieveGetFundamentalsResponse * SOAP_FMAC4 soap_in_ns1__RetrieveGetFundamentalsResponse(struct soap *soap, const char *tag, ns1__RetrieveGetFundamentalsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RetrieveGetFundamentalsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RetrieveGetFundamentalsResponse, sizeof(ns1__RetrieveGetFundamentalsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__RetrieveGetFundamentalsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__RetrieveGetFundamentalsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_statusCode2 = 1;
	size_t soap_flag_requestId2 = 1;
	size_t soap_flag_responseId1 = 1;
	size_t soap_flag_headers1 = 1;
	size_t soap_flag_fields1 = 1;
	size_t soap_flag_timestarted1 = 1;
	size_t soap_flag_instrumentDatas1 = 1;
	size_t soap_flag_timefinished1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ResponseStatus(soap, "ns1:statusCode", &a->ns1__PerSecurityResponse::statusCode, "ns1:ResponseStatus"))
				{	soap_flag_statusCode2--;
					continue;
				}
			}
			if (soap_flag_requestId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:requestId", &a->ns1__PerSecurityResponse::requestId, "xsd:string"))
				{	soap_flag_requestId2--;
					continue;
				}
			}
			if (soap_flag_responseId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:responseId", &a->ns1__RetrieveGetFundamentalsResponse::responseId, "xsd:string"))
				{	soap_flag_responseId1--;
					continue;
				}
			}
			if (soap_flag_headers1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GetFundamentalsHeaders(soap, "ns1:headers", &a->ns1__RetrieveGetFundamentalsResponse::headers, "ns1:GetFundamentalsHeaders"))
				{	soap_flag_headers1--;
					continue;
				}
			}
			if (soap_flag_fields1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Fields(soap, "ns1:fields", &a->ns1__RetrieveGetFundamentalsResponse::fields, "ns1:Fields"))
				{	soap_flag_fields1--;
					continue;
				}
			}
			if (soap_flag_timestarted1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns1:timestarted", &a->ns1__RetrieveGetFundamentalsResponse::timestarted, "xsd:dateTime"))
				{	soap_flag_timestarted1--;
					continue;
				}
			}
			if (soap_flag_instrumentDatas1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__FundInstrumentDatas(soap, "ns1:instrumentDatas", &a->ns1__RetrieveGetFundamentalsResponse::instrumentDatas, "ns1:FundInstrumentDatas"))
				{	soap_flag_instrumentDatas1--;
					continue;
				}
			}
			if (soap_flag_timefinished1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns1:timefinished", &a->ns1__RetrieveGetFundamentalsResponse::timefinished, "xsd:dateTime"))
				{	soap_flag_timefinished1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:responseId");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__PerSecurityResponse::statusCode || soap_flag_requestId2 > 0 || soap_flag_responseId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__RetrieveGetFundamentalsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RetrieveGetFundamentalsResponse, SOAP_TYPE_ns1__RetrieveGetFundamentalsResponse, sizeof(ns1__RetrieveGetFundamentalsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__RetrieveGetFundamentalsResponse * SOAP_FMAC2 soap_instantiate_ns1__RetrieveGetFundamentalsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RetrieveGetFundamentalsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__RetrieveGetFundamentalsResponse *p;
	size_t k = sizeof(ns1__RetrieveGetFundamentalsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__RetrieveGetFundamentalsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__RetrieveGetFundamentalsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__RetrieveGetFundamentalsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__RetrieveGetFundamentalsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__RetrieveGetFundamentalsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__RetrieveGetFundamentalsResponse(soap, tag ? tag : "ns1:RetrieveGetFundamentalsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__RetrieveGetFundamentalsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RetrieveGetFundamentalsResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RetrieveGetFundamentalsResponse * SOAP_FMAC4 soap_get_ns1__RetrieveGetFundamentalsResponse(struct soap *soap, ns1__RetrieveGetFundamentalsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RetrieveGetFundamentalsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__RetrieveGetFundamentalsRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__RetrieveGetFundamentalsRequest::responseId);
	this->ns1__RetrieveGetFundamentalsRequest::responseDate = NULL;
}

void ns1__RetrieveGetFundamentalsRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__RetrieveGetFundamentalsRequest::responseId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__RetrieveGetFundamentalsRequest::responseId);
	soap_serialize_PointerToxsd__date(soap, &this->ns1__RetrieveGetFundamentalsRequest::responseDate);
#endif
}

int ns1__RetrieveGetFundamentalsRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RetrieveGetFundamentalsRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RetrieveGetFundamentalsRequest(struct soap *soap, const char *tag, int id, const ns1__RetrieveGetFundamentalsRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RetrieveGetFundamentalsRequest), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:responseId", -1, &a->ns1__RetrieveGetFundamentalsRequest::responseId, ""))
		return soap->error;
	if (soap_out_PointerToxsd__date(soap, "ns1:responseDate", -1, &a->ns1__RetrieveGetFundamentalsRequest::responseDate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__RetrieveGetFundamentalsRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__RetrieveGetFundamentalsRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RetrieveGetFundamentalsRequest * SOAP_FMAC4 soap_in_ns1__RetrieveGetFundamentalsRequest(struct soap *soap, const char *tag, ns1__RetrieveGetFundamentalsRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RetrieveGetFundamentalsRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RetrieveGetFundamentalsRequest, sizeof(ns1__RetrieveGetFundamentalsRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__RetrieveGetFundamentalsRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__RetrieveGetFundamentalsRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_responseId1 = 1;
	size_t soap_flag_responseDate1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_responseId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:responseId", &a->ns1__RetrieveGetFundamentalsRequest::responseId, "xsd:string"))
				{	soap_flag_responseId1--;
					continue;
				}
			}
			if (soap_flag_responseDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__date(soap, "ns1:responseDate", &a->ns1__RetrieveGetFundamentalsRequest::responseDate, "xsd:date"))
				{	soap_flag_responseDate1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_responseId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__RetrieveGetFundamentalsRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RetrieveGetFundamentalsRequest, SOAP_TYPE_ns1__RetrieveGetFundamentalsRequest, sizeof(ns1__RetrieveGetFundamentalsRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__RetrieveGetFundamentalsRequest * SOAP_FMAC2 soap_instantiate_ns1__RetrieveGetFundamentalsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RetrieveGetFundamentalsRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__RetrieveGetFundamentalsRequest *p;
	size_t k = sizeof(ns1__RetrieveGetFundamentalsRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__RetrieveGetFundamentalsRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__RetrieveGetFundamentalsRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__RetrieveGetFundamentalsRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__RetrieveGetFundamentalsRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__RetrieveGetFundamentalsRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__RetrieveGetFundamentalsRequest(soap, tag ? tag : "ns1:RetrieveGetFundamentalsRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__RetrieveGetFundamentalsRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RetrieveGetFundamentalsRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RetrieveGetFundamentalsRequest * SOAP_FMAC4 soap_get_ns1__RetrieveGetFundamentalsRequest(struct soap *soap, ns1__RetrieveGetFundamentalsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RetrieveGetFundamentalsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__SubmitGetFundamentalsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__PerSecurityResponse::soap_default(soap);
	soap_default_std__string(soap, &this->ns1__SubmitGetFundamentalsResponse::responseId);
}

void ns1__SubmitGetFundamentalsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__SubmitGetFundamentalsResponse::responseId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__SubmitGetFundamentalsResponse::responseId);
	this->ns1__PerSecurityResponse::soap_serialize(soap);
#endif
}

int ns1__SubmitGetFundamentalsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SubmitGetFundamentalsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SubmitGetFundamentalsResponse(struct soap *soap, const char *tag, int id, const ns1__SubmitGetFundamentalsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SubmitGetFundamentalsResponse), type ? type : "ns1:SubmitGetFundamentalsResponse"))
		return soap->error;
	if (!a->ns1__PerSecurityResponse::statusCode)
	{	if (soap_element_empty(soap, "ns1:statusCode", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__ResponseStatus(soap, "ns1:statusCode", -1, &a->ns1__PerSecurityResponse::statusCode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:requestId", -1, &a->ns1__PerSecurityResponse::requestId, ""))
		return soap->error;
	soap_element_result(soap, "ns1:responseId");
	if (soap_out_std__string(soap, "ns1:responseId", -1, &a->ns1__SubmitGetFundamentalsResponse::responseId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SubmitGetFundamentalsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__SubmitGetFundamentalsResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SubmitGetFundamentalsResponse * SOAP_FMAC4 soap_in_ns1__SubmitGetFundamentalsResponse(struct soap *soap, const char *tag, ns1__SubmitGetFundamentalsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SubmitGetFundamentalsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SubmitGetFundamentalsResponse, sizeof(ns1__SubmitGetFundamentalsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__SubmitGetFundamentalsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__SubmitGetFundamentalsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_statusCode2 = 1;
	size_t soap_flag_requestId2 = 1;
	size_t soap_flag_responseId1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ResponseStatus(soap, "ns1:statusCode", &a->ns1__PerSecurityResponse::statusCode, "ns1:ResponseStatus"))
				{	soap_flag_statusCode2--;
					continue;
				}
			}
			if (soap_flag_requestId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:requestId", &a->ns1__PerSecurityResponse::requestId, "xsd:string"))
				{	soap_flag_requestId2--;
					continue;
				}
			}
			if (soap_flag_responseId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:responseId", &a->ns1__SubmitGetFundamentalsResponse::responseId, "xsd:string"))
				{	soap_flag_responseId1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:responseId");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__PerSecurityResponse::statusCode || soap_flag_requestId2 > 0 || soap_flag_responseId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__SubmitGetFundamentalsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SubmitGetFundamentalsResponse, SOAP_TYPE_ns1__SubmitGetFundamentalsResponse, sizeof(ns1__SubmitGetFundamentalsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__SubmitGetFundamentalsResponse * SOAP_FMAC2 soap_instantiate_ns1__SubmitGetFundamentalsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SubmitGetFundamentalsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__SubmitGetFundamentalsResponse *p;
	size_t k = sizeof(ns1__SubmitGetFundamentalsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__SubmitGetFundamentalsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__SubmitGetFundamentalsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__SubmitGetFundamentalsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__SubmitGetFundamentalsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__SubmitGetFundamentalsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__SubmitGetFundamentalsResponse(soap, tag ? tag : "ns1:SubmitGetFundamentalsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SubmitGetFundamentalsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SubmitGetFundamentalsResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SubmitGetFundamentalsResponse * SOAP_FMAC4 soap_get_ns1__SubmitGetFundamentalsResponse(struct soap *soap, ns1__SubmitGetFundamentalsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SubmitGetFundamentalsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__SubmitGetFundamentalsRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__SubmitGetFundamentalsRequest::headers = NULL;
	this->ns1__SubmitGetFundamentalsRequest::fields = NULL;
	this->ns1__SubmitGetFundamentalsRequest::instruments = NULL;
}

void ns1__SubmitGetFundamentalsRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__GetFundamentalsHeaders(soap, &this->ns1__SubmitGetFundamentalsRequest::headers);
	soap_serialize_PointerTons1__Fields(soap, &this->ns1__SubmitGetFundamentalsRequest::fields);
	soap_serialize_PointerTons1__FundInstruments(soap, &this->ns1__SubmitGetFundamentalsRequest::instruments);
#endif
}

int ns1__SubmitGetFundamentalsRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SubmitGetFundamentalsRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SubmitGetFundamentalsRequest(struct soap *soap, const char *tag, int id, const ns1__SubmitGetFundamentalsRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SubmitGetFundamentalsRequest), type))
		return soap->error;
	if (!a->ns1__SubmitGetFundamentalsRequest::headers)
	{	if (soap_element_empty(soap, "ns1:headers", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__GetFundamentalsHeaders(soap, "ns1:headers", -1, &a->ns1__SubmitGetFundamentalsRequest::headers, ""))
		return soap->error;
	if (!a->ns1__SubmitGetFundamentalsRequest::fields)
	{	if (soap_element_empty(soap, "ns1:fields", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__Fields(soap, "ns1:fields", -1, &a->ns1__SubmitGetFundamentalsRequest::fields, ""))
		return soap->error;
	if (!a->ns1__SubmitGetFundamentalsRequest::instruments)
	{	if (soap_element_empty(soap, "ns1:instruments", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__FundInstruments(soap, "ns1:instruments", -1, &a->ns1__SubmitGetFundamentalsRequest::instruments, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SubmitGetFundamentalsRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__SubmitGetFundamentalsRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SubmitGetFundamentalsRequest * SOAP_FMAC4 soap_in_ns1__SubmitGetFundamentalsRequest(struct soap *soap, const char *tag, ns1__SubmitGetFundamentalsRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SubmitGetFundamentalsRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SubmitGetFundamentalsRequest, sizeof(ns1__SubmitGetFundamentalsRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__SubmitGetFundamentalsRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__SubmitGetFundamentalsRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_headers1 = 1;
	size_t soap_flag_fields1 = 1;
	size_t soap_flag_instruments1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_headers1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GetFundamentalsHeaders(soap, "ns1:headers", &a->ns1__SubmitGetFundamentalsRequest::headers, "ns1:GetFundamentalsHeaders"))
				{	soap_flag_headers1--;
					continue;
				}
			}
			if (soap_flag_fields1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Fields(soap, "ns1:fields", &a->ns1__SubmitGetFundamentalsRequest::fields, "ns1:Fields"))
				{	soap_flag_fields1--;
					continue;
				}
			}
			if (soap_flag_instruments1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__FundInstruments(soap, "ns1:instruments", &a->ns1__SubmitGetFundamentalsRequest::instruments, "ns1:FundInstruments"))
				{	soap_flag_instruments1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__SubmitGetFundamentalsRequest::headers || !a->ns1__SubmitGetFundamentalsRequest::fields || !a->ns1__SubmitGetFundamentalsRequest::instruments))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__SubmitGetFundamentalsRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SubmitGetFundamentalsRequest, SOAP_TYPE_ns1__SubmitGetFundamentalsRequest, sizeof(ns1__SubmitGetFundamentalsRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__SubmitGetFundamentalsRequest * SOAP_FMAC2 soap_instantiate_ns1__SubmitGetFundamentalsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SubmitGetFundamentalsRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__SubmitGetFundamentalsRequest *p;
	size_t k = sizeof(ns1__SubmitGetFundamentalsRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__SubmitGetFundamentalsRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__SubmitGetFundamentalsRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__SubmitGetFundamentalsRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__SubmitGetFundamentalsRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__SubmitGetFundamentalsRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__SubmitGetFundamentalsRequest(soap, tag ? tag : "ns1:SubmitGetFundamentalsRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SubmitGetFundamentalsRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SubmitGetFundamentalsRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SubmitGetFundamentalsRequest * SOAP_FMAC4 soap_get_ns1__SubmitGetFundamentalsRequest(struct soap *soap, ns1__SubmitGetFundamentalsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SubmitGetFundamentalsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__RetrieveScheduledResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__PerSecurityResponse::soap_default(soap);
	soap_default_std__string(soap, &this->ns1__RetrieveScheduledResponse::responseId);
	this->ns1__RetrieveScheduledResponse::fileDatas = NULL;
}

void ns1__RetrieveScheduledResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__RetrieveScheduledResponse::responseId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__RetrieveScheduledResponse::responseId);
	soap_serialize_PointerTons1__ScheduledResponses(soap, &this->ns1__RetrieveScheduledResponse::fileDatas);
	this->ns1__PerSecurityResponse::soap_serialize(soap);
#endif
}

int ns1__RetrieveScheduledResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RetrieveScheduledResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RetrieveScheduledResponse(struct soap *soap, const char *tag, int id, const ns1__RetrieveScheduledResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RetrieveScheduledResponse), type ? type : "ns1:RetrieveScheduledResponse"))
		return soap->error;
	if (!a->ns1__PerSecurityResponse::statusCode)
	{	if (soap_element_empty(soap, "ns1:statusCode", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__ResponseStatus(soap, "ns1:statusCode", -1, &a->ns1__PerSecurityResponse::statusCode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:requestId", -1, &a->ns1__PerSecurityResponse::requestId, ""))
		return soap->error;
	soap_element_result(soap, "ns1:responseId");
	if (soap_out_std__string(soap, "ns1:responseId", -1, &a->ns1__RetrieveScheduledResponse::responseId, ""))
		return soap->error;
	if (soap_out_PointerTons1__ScheduledResponses(soap, "ns1:fileDatas", -1, &a->ns1__RetrieveScheduledResponse::fileDatas, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__RetrieveScheduledResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__RetrieveScheduledResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RetrieveScheduledResponse * SOAP_FMAC4 soap_in_ns1__RetrieveScheduledResponse(struct soap *soap, const char *tag, ns1__RetrieveScheduledResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RetrieveScheduledResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RetrieveScheduledResponse, sizeof(ns1__RetrieveScheduledResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__RetrieveScheduledResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__RetrieveScheduledResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_statusCode2 = 1;
	size_t soap_flag_requestId2 = 1;
	size_t soap_flag_responseId1 = 1;
	size_t soap_flag_fileDatas1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ResponseStatus(soap, "ns1:statusCode", &a->ns1__PerSecurityResponse::statusCode, "ns1:ResponseStatus"))
				{	soap_flag_statusCode2--;
					continue;
				}
			}
			if (soap_flag_requestId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:requestId", &a->ns1__PerSecurityResponse::requestId, "xsd:string"))
				{	soap_flag_requestId2--;
					continue;
				}
			}
			if (soap_flag_responseId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:responseId", &a->ns1__RetrieveScheduledResponse::responseId, "xsd:string"))
				{	soap_flag_responseId1--;
					continue;
				}
			}
			if (soap_flag_fileDatas1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ScheduledResponses(soap, "ns1:fileDatas", &a->ns1__RetrieveScheduledResponse::fileDatas, "ns1:ScheduledResponses"))
				{	soap_flag_fileDatas1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:responseId");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__PerSecurityResponse::statusCode || soap_flag_requestId2 > 0 || soap_flag_responseId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__RetrieveScheduledResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RetrieveScheduledResponse, SOAP_TYPE_ns1__RetrieveScheduledResponse, sizeof(ns1__RetrieveScheduledResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__RetrieveScheduledResponse * SOAP_FMAC2 soap_instantiate_ns1__RetrieveScheduledResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RetrieveScheduledResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__RetrieveScheduledResponse *p;
	size_t k = sizeof(ns1__RetrieveScheduledResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__RetrieveScheduledResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__RetrieveScheduledResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__RetrieveScheduledResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__RetrieveScheduledResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__RetrieveScheduledResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__RetrieveScheduledResponse(soap, tag ? tag : "ns1:RetrieveScheduledResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__RetrieveScheduledResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RetrieveScheduledResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RetrieveScheduledResponse * SOAP_FMAC4 soap_get_ns1__RetrieveScheduledResponse(struct soap *soap, ns1__RetrieveScheduledResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RetrieveScheduledResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ScheduledResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ScheduledResponse::headers = NULL;
	this->ns1__ScheduledResponse::fields = NULL;
	this->ns1__ScheduledResponse::bvalfieldsets = NULL;
	this->ns1__ScheduledResponse::fieldsets = NULL;
	this->ns1__ScheduledResponse::instruments = NULL;
	this->ns1__ScheduledResponse::responseId = NULL;
	this->ns1__ScheduledResponse::time = NULL;
}

void ns1__ScheduledResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ScheduledHeaders(soap, &this->ns1__ScheduledResponse::headers);
	soap_serialize_PointerTons1__Fields(soap, &this->ns1__ScheduledResponse::fields);
	soap_serialize_PointerTons1__BvalFieldSets(soap, &this->ns1__ScheduledResponse::bvalfieldsets);
	soap_serialize_PointerTons1__FieldSets(soap, &this->ns1__ScheduledResponse::fieldsets);
	soap_serialize_PointerTons1__Instruments(soap, &this->ns1__ScheduledResponse::instruments);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ScheduledResponse::responseId);
	soap_serialize_PointerToxsd__time(soap, &this->ns1__ScheduledResponse::time);
#endif
}

int ns1__ScheduledResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ScheduledResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ScheduledResponse(struct soap *soap, const char *tag, int id, const ns1__ScheduledResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ScheduledResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__ScheduledHeaders(soap, "ns1:headers", -1, &a->ns1__ScheduledResponse::headers, ""))
		return soap->error;
	if (soap_out_PointerTons1__Fields(soap, "ns1:fields", -1, &a->ns1__ScheduledResponse::fields, ""))
		return soap->error;
	if (soap_out_PointerTons1__BvalFieldSets(soap, "ns1:bvalfieldsets", -1, &a->ns1__ScheduledResponse::bvalfieldsets, ""))
		return soap->error;
	if (soap_out_PointerTons1__FieldSets(soap, "ns1:fieldsets", -1, &a->ns1__ScheduledResponse::fieldsets, ""))
		return soap->error;
	if (soap_out_PointerTons1__Instruments(soap, "ns1:instruments", -1, &a->ns1__ScheduledResponse::instruments, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:responseId", -1, &a->ns1__ScheduledResponse::responseId, ""))
		return soap->error;
	if (soap_out_PointerToxsd__time(soap, "ns1:time", -1, &a->ns1__ScheduledResponse::time, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ScheduledResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ScheduledResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ScheduledResponse * SOAP_FMAC4 soap_in_ns1__ScheduledResponse(struct soap *soap, const char *tag, ns1__ScheduledResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ScheduledResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ScheduledResponse, sizeof(ns1__ScheduledResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ScheduledResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ScheduledResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_headers1 = 1;
	size_t soap_flag_fields1 = 1;
	size_t soap_flag_bvalfieldsets1 = 1;
	size_t soap_flag_fieldsets1 = 1;
	size_t soap_flag_instruments1 = 1;
	size_t soap_flag_responseId1 = 1;
	size_t soap_flag_time1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_headers1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ScheduledHeaders(soap, "ns1:headers", &a->ns1__ScheduledResponse::headers, "ns1:ScheduledHeaders"))
				{	soap_flag_headers1--;
					continue;
				}
			}
			if (soap_flag_fields1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Fields(soap, "ns1:fields", &a->ns1__ScheduledResponse::fields, "ns1:Fields"))
				{	soap_flag_fields1--;
					continue;
				}
			}
			if (soap_flag_bvalfieldsets1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__BvalFieldSets(soap, "ns1:bvalfieldsets", &a->ns1__ScheduledResponse::bvalfieldsets, "ns1:BvalFieldSets"))
				{	soap_flag_bvalfieldsets1--;
					continue;
				}
			}
			if (soap_flag_fieldsets1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__FieldSets(soap, "ns1:fieldsets", &a->ns1__ScheduledResponse::fieldsets, "ns1:FieldSets"))
				{	soap_flag_fieldsets1--;
					continue;
				}
			}
			if (soap_flag_instruments1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Instruments(soap, "ns1:instruments", &a->ns1__ScheduledResponse::instruments, "ns1:Instruments"))
				{	soap_flag_instruments1--;
					continue;
				}
			}
			if (soap_flag_responseId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:responseId", &a->ns1__ScheduledResponse::responseId, "xsd:string"))
				{	soap_flag_responseId1--;
					continue;
				}
			}
			if (soap_flag_time1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__time(soap, "ns1:time", &a->ns1__ScheduledResponse::time, "xsd:time"))
				{	soap_flag_time1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ScheduledResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ScheduledResponse, SOAP_TYPE_ns1__ScheduledResponse, sizeof(ns1__ScheduledResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ScheduledResponse * SOAP_FMAC2 soap_instantiate_ns1__ScheduledResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ScheduledResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ScheduledResponse *p;
	size_t k = sizeof(ns1__ScheduledResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ScheduledResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ScheduledResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ScheduledResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ScheduledResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ScheduledResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ScheduledResponse(soap, tag ? tag : "ns1:ScheduledResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ScheduledResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ScheduledResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ScheduledResponse * SOAP_FMAC4 soap_get_ns1__ScheduledResponse(struct soap *soap, ns1__ScheduledResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ScheduledResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ScheduledResponses::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__ScheduledResponse(soap, &this->ns1__ScheduledResponses::fileData);
}

void ns1__ScheduledResponses::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__ScheduledResponse(soap, &this->ns1__ScheduledResponses::fileData);
#endif
}

int ns1__ScheduledResponses::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ScheduledResponses(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ScheduledResponses(struct soap *soap, const char *tag, int id, const ns1__ScheduledResponses *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ScheduledResponses), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__ScheduledResponse(soap, "ns1:fileData", -1, &a->ns1__ScheduledResponses::fileData, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ScheduledResponses::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ScheduledResponses(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ScheduledResponses * SOAP_FMAC4 soap_in_ns1__ScheduledResponses(struct soap *soap, const char *tag, ns1__ScheduledResponses *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ScheduledResponses*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ScheduledResponses, sizeof(ns1__ScheduledResponses), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ScheduledResponses)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ScheduledResponses *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__ScheduledResponse(soap, "ns1:fileData", &a->ns1__ScheduledResponses::fileData, "ns1:ScheduledResponse"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ScheduledResponses *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ScheduledResponses, SOAP_TYPE_ns1__ScheduledResponses, sizeof(ns1__ScheduledResponses), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ScheduledResponses * SOAP_FMAC2 soap_instantiate_ns1__ScheduledResponses(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ScheduledResponses(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ScheduledResponses *p;
	size_t k = sizeof(ns1__ScheduledResponses);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ScheduledResponses, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ScheduledResponses);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ScheduledResponses, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ScheduledResponses location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ScheduledResponses::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ScheduledResponses(soap, tag ? tag : "ns1:ScheduledResponses", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ScheduledResponses::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ScheduledResponses(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ScheduledResponses * SOAP_FMAC4 soap_get_ns1__ScheduledResponses(struct soap *soap, ns1__ScheduledResponses *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ScheduledResponses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__RetrieveScheduledRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__RetrieveScheduledRequest::responseId);
}

void ns1__RetrieveScheduledRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__RetrieveScheduledRequest::responseId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__RetrieveScheduledRequest::responseId);
#endif
}

int ns1__RetrieveScheduledRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RetrieveScheduledRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RetrieveScheduledRequest(struct soap *soap, const char *tag, int id, const ns1__RetrieveScheduledRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RetrieveScheduledRequest), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:responseId", -1, &a->ns1__RetrieveScheduledRequest::responseId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__RetrieveScheduledRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__RetrieveScheduledRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RetrieveScheduledRequest * SOAP_FMAC4 soap_in_ns1__RetrieveScheduledRequest(struct soap *soap, const char *tag, ns1__RetrieveScheduledRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RetrieveScheduledRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RetrieveScheduledRequest, sizeof(ns1__RetrieveScheduledRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__RetrieveScheduledRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__RetrieveScheduledRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_responseId1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_responseId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:responseId", &a->ns1__RetrieveScheduledRequest::responseId, "xsd:string"))
				{	soap_flag_responseId1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_responseId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__RetrieveScheduledRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RetrieveScheduledRequest, SOAP_TYPE_ns1__RetrieveScheduledRequest, sizeof(ns1__RetrieveScheduledRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__RetrieveScheduledRequest * SOAP_FMAC2 soap_instantiate_ns1__RetrieveScheduledRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RetrieveScheduledRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__RetrieveScheduledRequest *p;
	size_t k = sizeof(ns1__RetrieveScheduledRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__RetrieveScheduledRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__RetrieveScheduledRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__RetrieveScheduledRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__RetrieveScheduledRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__RetrieveScheduledRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__RetrieveScheduledRequest(soap, tag ? tag : "ns1:RetrieveScheduledRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__RetrieveScheduledRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RetrieveScheduledRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RetrieveScheduledRequest * SOAP_FMAC4 soap_get_ns1__RetrieveScheduledRequest(struct soap *soap, ns1__RetrieveScheduledRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RetrieveScheduledRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__SubmitScheduledResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__PerSecurityResponse::soap_default(soap);
	soap_default_std__string(soap, &this->ns1__SubmitScheduledResponse::responseId);
}

void ns1__SubmitScheduledResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__SubmitScheduledResponse::responseId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__SubmitScheduledResponse::responseId);
	this->ns1__PerSecurityResponse::soap_serialize(soap);
#endif
}

int ns1__SubmitScheduledResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SubmitScheduledResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SubmitScheduledResponse(struct soap *soap, const char *tag, int id, const ns1__SubmitScheduledResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SubmitScheduledResponse), type ? type : "ns1:SubmitScheduledResponse"))
		return soap->error;
	if (!a->ns1__PerSecurityResponse::statusCode)
	{	if (soap_element_empty(soap, "ns1:statusCode", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__ResponseStatus(soap, "ns1:statusCode", -1, &a->ns1__PerSecurityResponse::statusCode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:requestId", -1, &a->ns1__PerSecurityResponse::requestId, ""))
		return soap->error;
	soap_element_result(soap, "ns1:responseId");
	if (soap_out_std__string(soap, "ns1:responseId", -1, &a->ns1__SubmitScheduledResponse::responseId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SubmitScheduledResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__SubmitScheduledResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SubmitScheduledResponse * SOAP_FMAC4 soap_in_ns1__SubmitScheduledResponse(struct soap *soap, const char *tag, ns1__SubmitScheduledResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SubmitScheduledResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SubmitScheduledResponse, sizeof(ns1__SubmitScheduledResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__SubmitScheduledResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__SubmitScheduledResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_statusCode2 = 1;
	size_t soap_flag_requestId2 = 1;
	size_t soap_flag_responseId1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ResponseStatus(soap, "ns1:statusCode", &a->ns1__PerSecurityResponse::statusCode, "ns1:ResponseStatus"))
				{	soap_flag_statusCode2--;
					continue;
				}
			}
			if (soap_flag_requestId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:requestId", &a->ns1__PerSecurityResponse::requestId, "xsd:string"))
				{	soap_flag_requestId2--;
					continue;
				}
			}
			if (soap_flag_responseId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:responseId", &a->ns1__SubmitScheduledResponse::responseId, "xsd:string"))
				{	soap_flag_responseId1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:responseId");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__PerSecurityResponse::statusCode || soap_flag_requestId2 > 0 || soap_flag_responseId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__SubmitScheduledResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SubmitScheduledResponse, SOAP_TYPE_ns1__SubmitScheduledResponse, sizeof(ns1__SubmitScheduledResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__SubmitScheduledResponse * SOAP_FMAC2 soap_instantiate_ns1__SubmitScheduledResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SubmitScheduledResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__SubmitScheduledResponse *p;
	size_t k = sizeof(ns1__SubmitScheduledResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__SubmitScheduledResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__SubmitScheduledResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__SubmitScheduledResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__SubmitScheduledResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__SubmitScheduledResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__SubmitScheduledResponse(soap, tag ? tag : "ns1:SubmitScheduledResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SubmitScheduledResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SubmitScheduledResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SubmitScheduledResponse * SOAP_FMAC4 soap_get_ns1__SubmitScheduledResponse(struct soap *soap, ns1__SubmitScheduledResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SubmitScheduledResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__SubmitScheduledRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void ns1__SubmitScheduledRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns1__SubmitScheduledRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SubmitScheduledRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SubmitScheduledRequest(struct soap *soap, const char *tag, int id, const ns1__SubmitScheduledRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SubmitScheduledRequest), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SubmitScheduledRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__SubmitScheduledRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SubmitScheduledRequest * SOAP_FMAC4 soap_in_ns1__SubmitScheduledRequest(struct soap *soap, const char *tag, ns1__SubmitScheduledRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SubmitScheduledRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SubmitScheduledRequest, sizeof(ns1__SubmitScheduledRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__SubmitScheduledRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__SubmitScheduledRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SubmitScheduledRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SubmitScheduledRequest, SOAP_TYPE_ns1__SubmitScheduledRequest, sizeof(ns1__SubmitScheduledRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__SubmitScheduledRequest * SOAP_FMAC2 soap_instantiate_ns1__SubmitScheduledRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SubmitScheduledRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__SubmitScheduledRequest *p;
	size_t k = sizeof(ns1__SubmitScheduledRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__SubmitScheduledRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__SubmitScheduledRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__SubmitScheduledRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__SubmitScheduledRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__SubmitScheduledRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__SubmitScheduledRequest(soap, tag ? tag : "ns1:SubmitScheduledRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SubmitScheduledRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SubmitScheduledRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SubmitScheduledRequest * SOAP_FMAC4 soap_get_ns1__SubmitScheduledRequest(struct soap *soap, ns1__SubmitScheduledRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SubmitScheduledRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__GetCorrectionsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__PerSecurityResponse::soap_default(soap);
	this->ns1__GetCorrectionsResponse::headers = NULL;
	this->ns1__GetCorrectionsResponse::timestarted = NULL;
	this->ns1__GetCorrectionsResponse::correctionRecords = NULL;
	this->ns1__GetCorrectionsResponse::timefinished = NULL;
}

void ns1__GetCorrectionsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__GetCorrectionsHeaders(soap, &this->ns1__GetCorrectionsResponse::headers);
	soap_serialize_PointerTodateTime(soap, &this->ns1__GetCorrectionsResponse::timestarted);
	soap_serialize_PointerTons1__CorrectionRecords(soap, &this->ns1__GetCorrectionsResponse::correctionRecords);
	soap_serialize_PointerTodateTime(soap, &this->ns1__GetCorrectionsResponse::timefinished);
	this->ns1__PerSecurityResponse::soap_serialize(soap);
#endif
}

int ns1__GetCorrectionsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__GetCorrectionsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetCorrectionsResponse(struct soap *soap, const char *tag, int id, const ns1__GetCorrectionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetCorrectionsResponse), type ? type : "ns1:GetCorrectionsResponse"))
		return soap->error;
	if (!a->ns1__PerSecurityResponse::statusCode)
	{	if (soap_element_empty(soap, "ns1:statusCode", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__ResponseStatus(soap, "ns1:statusCode", -1, &a->ns1__PerSecurityResponse::statusCode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:requestId", -1, &a->ns1__PerSecurityResponse::requestId, ""))
		return soap->error;
	if (a->headers)
		soap_element_result(soap, "ns1:headers");
	if (soap_out_PointerTons1__GetCorrectionsHeaders(soap, "ns1:headers", -1, &a->ns1__GetCorrectionsResponse::headers, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns1:timestarted", -1, &a->ns1__GetCorrectionsResponse::timestarted, ""))
		return soap->error;
	if (soap_out_PointerTons1__CorrectionRecords(soap, "ns1:correctionRecords", -1, &a->ns1__GetCorrectionsResponse::correctionRecords, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns1:timefinished", -1, &a->ns1__GetCorrectionsResponse::timefinished, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__GetCorrectionsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__GetCorrectionsResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__GetCorrectionsResponse * SOAP_FMAC4 soap_in_ns1__GetCorrectionsResponse(struct soap *soap, const char *tag, ns1__GetCorrectionsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__GetCorrectionsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetCorrectionsResponse, sizeof(ns1__GetCorrectionsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__GetCorrectionsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__GetCorrectionsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_statusCode2 = 1;
	size_t soap_flag_requestId2 = 1;
	size_t soap_flag_headers1 = 1;
	size_t soap_flag_timestarted1 = 1;
	size_t soap_flag_correctionRecords1 = 1;
	size_t soap_flag_timefinished1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ResponseStatus(soap, "ns1:statusCode", &a->ns1__PerSecurityResponse::statusCode, "ns1:ResponseStatus"))
				{	soap_flag_statusCode2--;
					continue;
				}
			}
			if (soap_flag_requestId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:requestId", &a->ns1__PerSecurityResponse::requestId, "xsd:string"))
				{	soap_flag_requestId2--;
					continue;
				}
			}
			if (soap_flag_headers1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GetCorrectionsHeaders(soap, "ns1:headers", &a->ns1__GetCorrectionsResponse::headers, "ns1:GetCorrectionsHeaders"))
				{	soap_flag_headers1--;
					continue;
				}
			}
			if (soap_flag_timestarted1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns1:timestarted", &a->ns1__GetCorrectionsResponse::timestarted, "xsd:dateTime"))
				{	soap_flag_timestarted1--;
					continue;
				}
			}
			if (soap_flag_correctionRecords1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__CorrectionRecords(soap, "ns1:correctionRecords", &a->ns1__GetCorrectionsResponse::correctionRecords, "ns1:CorrectionRecords"))
				{	soap_flag_correctionRecords1--;
					continue;
				}
			}
			if (soap_flag_timefinished1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns1:timefinished", &a->ns1__GetCorrectionsResponse::timefinished, "xsd:dateTime"))
				{	soap_flag_timefinished1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:headers");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__PerSecurityResponse::statusCode || soap_flag_requestId2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__GetCorrectionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetCorrectionsResponse, SOAP_TYPE_ns1__GetCorrectionsResponse, sizeof(ns1__GetCorrectionsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__GetCorrectionsResponse * SOAP_FMAC2 soap_instantiate_ns1__GetCorrectionsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetCorrectionsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__GetCorrectionsResponse *p;
	size_t k = sizeof(ns1__GetCorrectionsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetCorrectionsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__GetCorrectionsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__GetCorrectionsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__GetCorrectionsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__GetCorrectionsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__GetCorrectionsResponse(soap, tag ? tag : "ns1:GetCorrectionsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__GetCorrectionsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__GetCorrectionsResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__GetCorrectionsResponse * SOAP_FMAC4 soap_get_ns1__GetCorrectionsResponse(struct soap *soap, ns1__GetCorrectionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetCorrectionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__GetCorrectionsRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__GetCorrectionsRequest::responseDate = NULL;
}

void ns1__GetCorrectionsRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxsd__date(soap, &this->ns1__GetCorrectionsRequest::responseDate);
#endif
}

int ns1__GetCorrectionsRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__GetCorrectionsRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetCorrectionsRequest(struct soap *soap, const char *tag, int id, const ns1__GetCorrectionsRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetCorrectionsRequest), type))
		return soap->error;
	if (soap_out_PointerToxsd__date(soap, "ns1:responseDate", -1, &a->ns1__GetCorrectionsRequest::responseDate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__GetCorrectionsRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__GetCorrectionsRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__GetCorrectionsRequest * SOAP_FMAC4 soap_in_ns1__GetCorrectionsRequest(struct soap *soap, const char *tag, ns1__GetCorrectionsRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__GetCorrectionsRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetCorrectionsRequest, sizeof(ns1__GetCorrectionsRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__GetCorrectionsRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__GetCorrectionsRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_responseDate1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_responseDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__date(soap, "ns1:responseDate", &a->ns1__GetCorrectionsRequest::responseDate, "xsd:date"))
				{	soap_flag_responseDate1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__GetCorrectionsRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetCorrectionsRequest, SOAP_TYPE_ns1__GetCorrectionsRequest, sizeof(ns1__GetCorrectionsRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__GetCorrectionsRequest * SOAP_FMAC2 soap_instantiate_ns1__GetCorrectionsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetCorrectionsRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__GetCorrectionsRequest *p;
	size_t k = sizeof(ns1__GetCorrectionsRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetCorrectionsRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__GetCorrectionsRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__GetCorrectionsRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__GetCorrectionsRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__GetCorrectionsRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__GetCorrectionsRequest(soap, tag ? tag : "ns1:GetCorrectionsRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__GetCorrectionsRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__GetCorrectionsRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__GetCorrectionsRequest * SOAP_FMAC4 soap_get_ns1__GetCorrectionsRequest(struct soap *soap, ns1__GetCorrectionsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetCorrectionsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__RetrieveCancelResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__PerSecurityResponse::soap_default(soap);
	this->ns1__RetrieveCancelResponse::headers = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__CancelResponseStatus(soap, &this->ns1__RetrieveCancelResponse::cancelResponseStatus);
}

void ns1__RetrieveCancelResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__CancelHeaders(soap, &this->ns1__RetrieveCancelResponse::headers);
	soap_serialize_std__vectorTemplateOfPointerTons1__CancelResponseStatus(soap, &this->ns1__RetrieveCancelResponse::cancelResponseStatus);
	this->ns1__PerSecurityResponse::soap_serialize(soap);
#endif
}

int ns1__RetrieveCancelResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RetrieveCancelResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RetrieveCancelResponse(struct soap *soap, const char *tag, int id, const ns1__RetrieveCancelResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RetrieveCancelResponse), type ? type : "ns1:RetrieveCancelResponse"))
		return soap->error;
	if (!a->ns1__PerSecurityResponse::statusCode)
	{	if (soap_element_empty(soap, "ns1:statusCode", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__ResponseStatus(soap, "ns1:statusCode", -1, &a->ns1__PerSecurityResponse::statusCode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:requestId", -1, &a->ns1__PerSecurityResponse::requestId, ""))
		return soap->error;
	if (a->headers)
		soap_element_result(soap, "ns1:headers");
	if (soap_out_PointerTons1__CancelHeaders(soap, "ns1:headers", -1, &a->ns1__RetrieveCancelResponse::headers, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__CancelResponseStatus(soap, "ns1:cancelResponseStatus", -1, &a->ns1__RetrieveCancelResponse::cancelResponseStatus, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__RetrieveCancelResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__RetrieveCancelResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RetrieveCancelResponse * SOAP_FMAC4 soap_in_ns1__RetrieveCancelResponse(struct soap *soap, const char *tag, ns1__RetrieveCancelResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RetrieveCancelResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RetrieveCancelResponse, sizeof(ns1__RetrieveCancelResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__RetrieveCancelResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__RetrieveCancelResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_statusCode2 = 1;
	size_t soap_flag_requestId2 = 1;
	size_t soap_flag_headers1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ResponseStatus(soap, "ns1:statusCode", &a->ns1__PerSecurityResponse::statusCode, "ns1:ResponseStatus"))
				{	soap_flag_statusCode2--;
					continue;
				}
			}
			if (soap_flag_requestId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:requestId", &a->ns1__PerSecurityResponse::requestId, "xsd:string"))
				{	soap_flag_requestId2--;
					continue;
				}
			}
			if (soap_flag_headers1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__CancelHeaders(soap, "ns1:headers", &a->ns1__RetrieveCancelResponse::headers, "ns1:CancelHeaders"))
				{	soap_flag_headers1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__CancelResponseStatus(soap, "ns1:cancelResponseStatus", &a->ns1__RetrieveCancelResponse::cancelResponseStatus, "ns1:CancelResponseStatus"))
					continue;
			}
			soap_check_result(soap, "ns1:headers");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__PerSecurityResponse::statusCode || soap_flag_requestId2 > 0 || a->ns1__RetrieveCancelResponse::cancelResponseStatus.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__RetrieveCancelResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RetrieveCancelResponse, SOAP_TYPE_ns1__RetrieveCancelResponse, sizeof(ns1__RetrieveCancelResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__RetrieveCancelResponse * SOAP_FMAC2 soap_instantiate_ns1__RetrieveCancelResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RetrieveCancelResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__RetrieveCancelResponse *p;
	size_t k = sizeof(ns1__RetrieveCancelResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__RetrieveCancelResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__RetrieveCancelResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__RetrieveCancelResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__RetrieveCancelResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__RetrieveCancelResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__RetrieveCancelResponse(soap, tag ? tag : "ns1:RetrieveCancelResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__RetrieveCancelResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RetrieveCancelResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RetrieveCancelResponse * SOAP_FMAC4 soap_get_ns1__RetrieveCancelResponse(struct soap *soap, ns1__RetrieveCancelResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RetrieveCancelResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__RetrieveCancelRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__RetrieveCancelRequest::responseId);
}

void ns1__RetrieveCancelRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__RetrieveCancelRequest::responseId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__RetrieveCancelRequest::responseId);
#endif
}

int ns1__RetrieveCancelRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RetrieveCancelRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RetrieveCancelRequest(struct soap *soap, const char *tag, int id, const ns1__RetrieveCancelRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RetrieveCancelRequest), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:responseId", -1, &a->ns1__RetrieveCancelRequest::responseId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__RetrieveCancelRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__RetrieveCancelRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RetrieveCancelRequest * SOAP_FMAC4 soap_in_ns1__RetrieveCancelRequest(struct soap *soap, const char *tag, ns1__RetrieveCancelRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RetrieveCancelRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RetrieveCancelRequest, sizeof(ns1__RetrieveCancelRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__RetrieveCancelRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__RetrieveCancelRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_responseId1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_responseId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:responseId", &a->ns1__RetrieveCancelRequest::responseId, "xsd:string"))
				{	soap_flag_responseId1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_responseId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__RetrieveCancelRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RetrieveCancelRequest, SOAP_TYPE_ns1__RetrieveCancelRequest, sizeof(ns1__RetrieveCancelRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__RetrieveCancelRequest * SOAP_FMAC2 soap_instantiate_ns1__RetrieveCancelRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RetrieveCancelRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__RetrieveCancelRequest *p;
	size_t k = sizeof(ns1__RetrieveCancelRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__RetrieveCancelRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__RetrieveCancelRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__RetrieveCancelRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__RetrieveCancelRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__RetrieveCancelRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__RetrieveCancelRequest(soap, tag ? tag : "ns1:RetrieveCancelRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__RetrieveCancelRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RetrieveCancelRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RetrieveCancelRequest * SOAP_FMAC4 soap_get_ns1__RetrieveCancelRequest(struct soap *soap, ns1__RetrieveCancelRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RetrieveCancelRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__SubmitCancelResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__PerSecurityResponse::soap_default(soap);
	soap_default_std__string(soap, &this->ns1__SubmitCancelResponse::responseId);
}

void ns1__SubmitCancelResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__SubmitCancelResponse::responseId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__SubmitCancelResponse::responseId);
	this->ns1__PerSecurityResponse::soap_serialize(soap);
#endif
}

int ns1__SubmitCancelResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SubmitCancelResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SubmitCancelResponse(struct soap *soap, const char *tag, int id, const ns1__SubmitCancelResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SubmitCancelResponse), type ? type : "ns1:SubmitCancelResponse"))
		return soap->error;
	if (!a->ns1__PerSecurityResponse::statusCode)
	{	if (soap_element_empty(soap, "ns1:statusCode", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__ResponseStatus(soap, "ns1:statusCode", -1, &a->ns1__PerSecurityResponse::statusCode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:requestId", -1, &a->ns1__PerSecurityResponse::requestId, ""))
		return soap->error;
	soap_element_result(soap, "ns1:responseId");
	if (soap_out_std__string(soap, "ns1:responseId", -1, &a->ns1__SubmitCancelResponse::responseId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SubmitCancelResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__SubmitCancelResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SubmitCancelResponse * SOAP_FMAC4 soap_in_ns1__SubmitCancelResponse(struct soap *soap, const char *tag, ns1__SubmitCancelResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SubmitCancelResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SubmitCancelResponse, sizeof(ns1__SubmitCancelResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__SubmitCancelResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__SubmitCancelResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_statusCode2 = 1;
	size_t soap_flag_requestId2 = 1;
	size_t soap_flag_responseId1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ResponseStatus(soap, "ns1:statusCode", &a->ns1__PerSecurityResponse::statusCode, "ns1:ResponseStatus"))
				{	soap_flag_statusCode2--;
					continue;
				}
			}
			if (soap_flag_requestId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:requestId", &a->ns1__PerSecurityResponse::requestId, "xsd:string"))
				{	soap_flag_requestId2--;
					continue;
				}
			}
			if (soap_flag_responseId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:responseId", &a->ns1__SubmitCancelResponse::responseId, "xsd:string"))
				{	soap_flag_responseId1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:responseId");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__PerSecurityResponse::statusCode || soap_flag_requestId2 > 0 || soap_flag_responseId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__SubmitCancelResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SubmitCancelResponse, SOAP_TYPE_ns1__SubmitCancelResponse, sizeof(ns1__SubmitCancelResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__SubmitCancelResponse * SOAP_FMAC2 soap_instantiate_ns1__SubmitCancelResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SubmitCancelResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__SubmitCancelResponse *p;
	size_t k = sizeof(ns1__SubmitCancelResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__SubmitCancelResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__SubmitCancelResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__SubmitCancelResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__SubmitCancelResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__SubmitCancelResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__SubmitCancelResponse(soap, tag ? tag : "ns1:SubmitCancelResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SubmitCancelResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SubmitCancelResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SubmitCancelResponse * SOAP_FMAC4 soap_get_ns1__SubmitCancelResponse(struct soap *soap, ns1__SubmitCancelResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SubmitCancelResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__SubmitCancelRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns1__SubmitCancelRequest::responseId);
	this->ns1__SubmitCancelRequest::headers = NULL;
}

void ns1__SubmitCancelRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns1__SubmitCancelRequest::responseId);
	soap_serialize_PointerTons1__CancelHeaders(soap, &this->ns1__SubmitCancelRequest::headers);
#endif
}

int ns1__SubmitCancelRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SubmitCancelRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SubmitCancelRequest(struct soap *soap, const char *tag, int id, const ns1__SubmitCancelRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SubmitCancelRequest), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "ns1:responseId", -1, &a->ns1__SubmitCancelRequest::responseId, ""))
		return soap->error;
	if (!a->ns1__SubmitCancelRequest::headers)
	{	if (soap_element_empty(soap, "ns1:headers", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__CancelHeaders(soap, "ns1:headers", -1, &a->ns1__SubmitCancelRequest::headers, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SubmitCancelRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__SubmitCancelRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SubmitCancelRequest * SOAP_FMAC4 soap_in_ns1__SubmitCancelRequest(struct soap *soap, const char *tag, ns1__SubmitCancelRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SubmitCancelRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SubmitCancelRequest, sizeof(ns1__SubmitCancelRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__SubmitCancelRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__SubmitCancelRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_headers1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfstd__string(soap, "ns1:responseId", &a->ns1__SubmitCancelRequest::responseId, "xsd:string"))
					continue;
			}
			if (soap_flag_headers1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__CancelHeaders(soap, "ns1:headers", &a->ns1__SubmitCancelRequest::headers, "ns1:CancelHeaders"))
				{	soap_flag_headers1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns1__SubmitCancelRequest::responseId.size() < 1 || !a->ns1__SubmitCancelRequest::headers))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__SubmitCancelRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SubmitCancelRequest, SOAP_TYPE_ns1__SubmitCancelRequest, sizeof(ns1__SubmitCancelRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__SubmitCancelRequest * SOAP_FMAC2 soap_instantiate_ns1__SubmitCancelRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SubmitCancelRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__SubmitCancelRequest *p;
	size_t k = sizeof(ns1__SubmitCancelRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__SubmitCancelRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__SubmitCancelRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__SubmitCancelRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__SubmitCancelRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__SubmitCancelRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__SubmitCancelRequest(soap, tag ? tag : "ns1:SubmitCancelRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SubmitCancelRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SubmitCancelRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SubmitCancelRequest * SOAP_FMAC4 soap_get_ns1__SubmitCancelRequest(struct soap *soap, ns1__SubmitCancelRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SubmitCancelRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__RetrieveGetHistoryResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__PerSecurityResponse::soap_default(soap);
	soap_default_std__string(soap, &this->ns1__RetrieveGetHistoryResponse::responseId);
	this->ns1__RetrieveGetHistoryResponse::headers = NULL;
	this->ns1__RetrieveGetHistoryResponse::fields = NULL;
	this->ns1__RetrieveGetHistoryResponse::timestarted = NULL;
	this->ns1__RetrieveGetHistoryResponse::instrumentDatas = NULL;
	this->ns1__RetrieveGetHistoryResponse::timefinished = NULL;
}

void ns1__RetrieveGetHistoryResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__RetrieveGetHistoryResponse::responseId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__RetrieveGetHistoryResponse::responseId);
	soap_serialize_PointerTons1__GetHistoryHeaders(soap, &this->ns1__RetrieveGetHistoryResponse::headers);
	soap_serialize_PointerTons1__Fields(soap, &this->ns1__RetrieveGetHistoryResponse::fields);
	soap_serialize_PointerTodateTime(soap, &this->ns1__RetrieveGetHistoryResponse::timestarted);
	soap_serialize_PointerTons1__HistInstrumentDatas(soap, &this->ns1__RetrieveGetHistoryResponse::instrumentDatas);
	soap_serialize_PointerTodateTime(soap, &this->ns1__RetrieveGetHistoryResponse::timefinished);
	this->ns1__PerSecurityResponse::soap_serialize(soap);
#endif
}

int ns1__RetrieveGetHistoryResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RetrieveGetHistoryResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RetrieveGetHistoryResponse(struct soap *soap, const char *tag, int id, const ns1__RetrieveGetHistoryResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RetrieveGetHistoryResponse), type ? type : "ns1:RetrieveGetHistoryResponse"))
		return soap->error;
	if (!a->ns1__PerSecurityResponse::statusCode)
	{	if (soap_element_empty(soap, "ns1:statusCode", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__ResponseStatus(soap, "ns1:statusCode", -1, &a->ns1__PerSecurityResponse::statusCode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:requestId", -1, &a->ns1__PerSecurityResponse::requestId, ""))
		return soap->error;
	soap_element_result(soap, "ns1:responseId");
	if (soap_out_std__string(soap, "ns1:responseId", -1, &a->ns1__RetrieveGetHistoryResponse::responseId, ""))
		return soap->error;
	if (soap_out_PointerTons1__GetHistoryHeaders(soap, "ns1:headers", -1, &a->ns1__RetrieveGetHistoryResponse::headers, ""))
		return soap->error;
	if (soap_out_PointerTons1__Fields(soap, "ns1:fields", -1, &a->ns1__RetrieveGetHistoryResponse::fields, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns1:timestarted", -1, &a->ns1__RetrieveGetHistoryResponse::timestarted, ""))
		return soap->error;
	if (soap_out_PointerTons1__HistInstrumentDatas(soap, "ns1:instrumentDatas", -1, &a->ns1__RetrieveGetHistoryResponse::instrumentDatas, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns1:timefinished", -1, &a->ns1__RetrieveGetHistoryResponse::timefinished, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__RetrieveGetHistoryResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__RetrieveGetHistoryResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RetrieveGetHistoryResponse * SOAP_FMAC4 soap_in_ns1__RetrieveGetHistoryResponse(struct soap *soap, const char *tag, ns1__RetrieveGetHistoryResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RetrieveGetHistoryResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RetrieveGetHistoryResponse, sizeof(ns1__RetrieveGetHistoryResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__RetrieveGetHistoryResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__RetrieveGetHistoryResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_statusCode2 = 1;
	size_t soap_flag_requestId2 = 1;
	size_t soap_flag_responseId1 = 1;
	size_t soap_flag_headers1 = 1;
	size_t soap_flag_fields1 = 1;
	size_t soap_flag_timestarted1 = 1;
	size_t soap_flag_instrumentDatas1 = 1;
	size_t soap_flag_timefinished1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ResponseStatus(soap, "ns1:statusCode", &a->ns1__PerSecurityResponse::statusCode, "ns1:ResponseStatus"))
				{	soap_flag_statusCode2--;
					continue;
				}
			}
			if (soap_flag_requestId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:requestId", &a->ns1__PerSecurityResponse::requestId, "xsd:string"))
				{	soap_flag_requestId2--;
					continue;
				}
			}
			if (soap_flag_responseId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:responseId", &a->ns1__RetrieveGetHistoryResponse::responseId, "xsd:string"))
				{	soap_flag_responseId1--;
					continue;
				}
			}
			if (soap_flag_headers1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GetHistoryHeaders(soap, "ns1:headers", &a->ns1__RetrieveGetHistoryResponse::headers, "ns1:GetHistoryHeaders"))
				{	soap_flag_headers1--;
					continue;
				}
			}
			if (soap_flag_fields1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Fields(soap, "ns1:fields", &a->ns1__RetrieveGetHistoryResponse::fields, "ns1:Fields"))
				{	soap_flag_fields1--;
					continue;
				}
			}
			if (soap_flag_timestarted1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns1:timestarted", &a->ns1__RetrieveGetHistoryResponse::timestarted, "xsd:dateTime"))
				{	soap_flag_timestarted1--;
					continue;
				}
			}
			if (soap_flag_instrumentDatas1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__HistInstrumentDatas(soap, "ns1:instrumentDatas", &a->ns1__RetrieveGetHistoryResponse::instrumentDatas, "ns1:HistInstrumentDatas"))
				{	soap_flag_instrumentDatas1--;
					continue;
				}
			}
			if (soap_flag_timefinished1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns1:timefinished", &a->ns1__RetrieveGetHistoryResponse::timefinished, "xsd:dateTime"))
				{	soap_flag_timefinished1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:responseId");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__PerSecurityResponse::statusCode || soap_flag_requestId2 > 0 || soap_flag_responseId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__RetrieveGetHistoryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RetrieveGetHistoryResponse, SOAP_TYPE_ns1__RetrieveGetHistoryResponse, sizeof(ns1__RetrieveGetHistoryResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__RetrieveGetHistoryResponse * SOAP_FMAC2 soap_instantiate_ns1__RetrieveGetHistoryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RetrieveGetHistoryResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__RetrieveGetHistoryResponse *p;
	size_t k = sizeof(ns1__RetrieveGetHistoryResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__RetrieveGetHistoryResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__RetrieveGetHistoryResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__RetrieveGetHistoryResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__RetrieveGetHistoryResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__RetrieveGetHistoryResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__RetrieveGetHistoryResponse(soap, tag ? tag : "ns1:RetrieveGetHistoryResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__RetrieveGetHistoryResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RetrieveGetHistoryResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RetrieveGetHistoryResponse * SOAP_FMAC4 soap_get_ns1__RetrieveGetHistoryResponse(struct soap *soap, ns1__RetrieveGetHistoryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RetrieveGetHistoryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__RetrieveGetHistoryRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__RetrieveGetHistoryRequest::responseId);
	this->ns1__RetrieveGetHistoryRequest::responseDate = NULL;
}

void ns1__RetrieveGetHistoryRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__RetrieveGetHistoryRequest::responseId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__RetrieveGetHistoryRequest::responseId);
	soap_serialize_PointerToxsd__date(soap, &this->ns1__RetrieveGetHistoryRequest::responseDate);
#endif
}

int ns1__RetrieveGetHistoryRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RetrieveGetHistoryRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RetrieveGetHistoryRequest(struct soap *soap, const char *tag, int id, const ns1__RetrieveGetHistoryRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RetrieveGetHistoryRequest), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:responseId", -1, &a->ns1__RetrieveGetHistoryRequest::responseId, ""))
		return soap->error;
	if (soap_out_PointerToxsd__date(soap, "ns1:responseDate", -1, &a->ns1__RetrieveGetHistoryRequest::responseDate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__RetrieveGetHistoryRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__RetrieveGetHistoryRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RetrieveGetHistoryRequest * SOAP_FMAC4 soap_in_ns1__RetrieveGetHistoryRequest(struct soap *soap, const char *tag, ns1__RetrieveGetHistoryRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RetrieveGetHistoryRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RetrieveGetHistoryRequest, sizeof(ns1__RetrieveGetHistoryRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__RetrieveGetHistoryRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__RetrieveGetHistoryRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_responseId1 = 1;
	size_t soap_flag_responseDate1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_responseId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:responseId", &a->ns1__RetrieveGetHistoryRequest::responseId, "xsd:string"))
				{	soap_flag_responseId1--;
					continue;
				}
			}
			if (soap_flag_responseDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__date(soap, "ns1:responseDate", &a->ns1__RetrieveGetHistoryRequest::responseDate, "xsd:date"))
				{	soap_flag_responseDate1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_responseId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__RetrieveGetHistoryRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RetrieveGetHistoryRequest, SOAP_TYPE_ns1__RetrieveGetHistoryRequest, sizeof(ns1__RetrieveGetHistoryRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__RetrieveGetHistoryRequest * SOAP_FMAC2 soap_instantiate_ns1__RetrieveGetHistoryRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RetrieveGetHistoryRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__RetrieveGetHistoryRequest *p;
	size_t k = sizeof(ns1__RetrieveGetHistoryRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__RetrieveGetHistoryRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__RetrieveGetHistoryRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__RetrieveGetHistoryRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__RetrieveGetHistoryRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__RetrieveGetHistoryRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__RetrieveGetHistoryRequest(soap, tag ? tag : "ns1:RetrieveGetHistoryRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__RetrieveGetHistoryRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RetrieveGetHistoryRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RetrieveGetHistoryRequest * SOAP_FMAC4 soap_get_ns1__RetrieveGetHistoryRequest(struct soap *soap, ns1__RetrieveGetHistoryRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RetrieveGetHistoryRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__SubmitGetHistoryResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__PerSecurityResponse::soap_default(soap);
	soap_default_std__string(soap, &this->ns1__SubmitGetHistoryResponse::responseId);
}

void ns1__SubmitGetHistoryResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__SubmitGetHistoryResponse::responseId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__SubmitGetHistoryResponse::responseId);
	this->ns1__PerSecurityResponse::soap_serialize(soap);
#endif
}

int ns1__SubmitGetHistoryResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SubmitGetHistoryResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SubmitGetHistoryResponse(struct soap *soap, const char *tag, int id, const ns1__SubmitGetHistoryResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SubmitGetHistoryResponse), type ? type : "ns1:SubmitGetHistoryResponse"))
		return soap->error;
	if (!a->ns1__PerSecurityResponse::statusCode)
	{	if (soap_element_empty(soap, "ns1:statusCode", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__ResponseStatus(soap, "ns1:statusCode", -1, &a->ns1__PerSecurityResponse::statusCode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:requestId", -1, &a->ns1__PerSecurityResponse::requestId, ""))
		return soap->error;
	soap_element_result(soap, "ns1:responseId");
	if (soap_out_std__string(soap, "ns1:responseId", -1, &a->ns1__SubmitGetHistoryResponse::responseId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SubmitGetHistoryResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__SubmitGetHistoryResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SubmitGetHistoryResponse * SOAP_FMAC4 soap_in_ns1__SubmitGetHistoryResponse(struct soap *soap, const char *tag, ns1__SubmitGetHistoryResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SubmitGetHistoryResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SubmitGetHistoryResponse, sizeof(ns1__SubmitGetHistoryResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__SubmitGetHistoryResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__SubmitGetHistoryResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_statusCode2 = 1;
	size_t soap_flag_requestId2 = 1;
	size_t soap_flag_responseId1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ResponseStatus(soap, "ns1:statusCode", &a->ns1__PerSecurityResponse::statusCode, "ns1:ResponseStatus"))
				{	soap_flag_statusCode2--;
					continue;
				}
			}
			if (soap_flag_requestId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:requestId", &a->ns1__PerSecurityResponse::requestId, "xsd:string"))
				{	soap_flag_requestId2--;
					continue;
				}
			}
			if (soap_flag_responseId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:responseId", &a->ns1__SubmitGetHistoryResponse::responseId, "xsd:string"))
				{	soap_flag_responseId1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:responseId");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__PerSecurityResponse::statusCode || soap_flag_requestId2 > 0 || soap_flag_responseId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__SubmitGetHistoryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SubmitGetHistoryResponse, SOAP_TYPE_ns1__SubmitGetHistoryResponse, sizeof(ns1__SubmitGetHistoryResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__SubmitGetHistoryResponse * SOAP_FMAC2 soap_instantiate_ns1__SubmitGetHistoryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SubmitGetHistoryResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__SubmitGetHistoryResponse *p;
	size_t k = sizeof(ns1__SubmitGetHistoryResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__SubmitGetHistoryResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__SubmitGetHistoryResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__SubmitGetHistoryResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__SubmitGetHistoryResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__SubmitGetHistoryResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__SubmitGetHistoryResponse(soap, tag ? tag : "ns1:SubmitGetHistoryResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SubmitGetHistoryResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SubmitGetHistoryResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SubmitGetHistoryResponse * SOAP_FMAC4 soap_get_ns1__SubmitGetHistoryResponse(struct soap *soap, ns1__SubmitGetHistoryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SubmitGetHistoryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__SubmitGetHistoryRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__SubmitGetHistoryRequest::headers = NULL;
	this->ns1__SubmitGetHistoryRequest::fields = NULL;
	this->ns1__SubmitGetHistoryRequest::instruments = NULL;
}

void ns1__SubmitGetHistoryRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__GetHistoryHeaders(soap, &this->ns1__SubmitGetHistoryRequest::headers);
	soap_serialize_PointerTons1__Fields(soap, &this->ns1__SubmitGetHistoryRequest::fields);
	soap_serialize_PointerTons1__Instruments(soap, &this->ns1__SubmitGetHistoryRequest::instruments);
#endif
}

int ns1__SubmitGetHistoryRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SubmitGetHistoryRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SubmitGetHistoryRequest(struct soap *soap, const char *tag, int id, const ns1__SubmitGetHistoryRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SubmitGetHistoryRequest), type))
		return soap->error;
	if (!a->ns1__SubmitGetHistoryRequest::headers)
	{	if (soap_element_empty(soap, "ns1:headers", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__GetHistoryHeaders(soap, "ns1:headers", -1, &a->ns1__SubmitGetHistoryRequest::headers, ""))
		return soap->error;
	if (!a->ns1__SubmitGetHistoryRequest::fields)
	{	if (soap_element_empty(soap, "ns1:fields", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__Fields(soap, "ns1:fields", -1, &a->ns1__SubmitGetHistoryRequest::fields, ""))
		return soap->error;
	if (!a->ns1__SubmitGetHistoryRequest::instruments)
	{	if (soap_element_empty(soap, "ns1:instruments", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__Instruments(soap, "ns1:instruments", -1, &a->ns1__SubmitGetHistoryRequest::instruments, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SubmitGetHistoryRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__SubmitGetHistoryRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SubmitGetHistoryRequest * SOAP_FMAC4 soap_in_ns1__SubmitGetHistoryRequest(struct soap *soap, const char *tag, ns1__SubmitGetHistoryRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SubmitGetHistoryRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SubmitGetHistoryRequest, sizeof(ns1__SubmitGetHistoryRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__SubmitGetHistoryRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__SubmitGetHistoryRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_headers1 = 1;
	size_t soap_flag_fields1 = 1;
	size_t soap_flag_instruments1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_headers1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GetHistoryHeaders(soap, "ns1:headers", &a->ns1__SubmitGetHistoryRequest::headers, "ns1:GetHistoryHeaders"))
				{	soap_flag_headers1--;
					continue;
				}
			}
			if (soap_flag_fields1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Fields(soap, "ns1:fields", &a->ns1__SubmitGetHistoryRequest::fields, "ns1:Fields"))
				{	soap_flag_fields1--;
					continue;
				}
			}
			if (soap_flag_instruments1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Instruments(soap, "ns1:instruments", &a->ns1__SubmitGetHistoryRequest::instruments, "ns1:Instruments"))
				{	soap_flag_instruments1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__SubmitGetHistoryRequest::headers || !a->ns1__SubmitGetHistoryRequest::fields || !a->ns1__SubmitGetHistoryRequest::instruments))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__SubmitGetHistoryRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SubmitGetHistoryRequest, SOAP_TYPE_ns1__SubmitGetHistoryRequest, sizeof(ns1__SubmitGetHistoryRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__SubmitGetHistoryRequest * SOAP_FMAC2 soap_instantiate_ns1__SubmitGetHistoryRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SubmitGetHistoryRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__SubmitGetHistoryRequest *p;
	size_t k = sizeof(ns1__SubmitGetHistoryRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__SubmitGetHistoryRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__SubmitGetHistoryRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__SubmitGetHistoryRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__SubmitGetHistoryRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__SubmitGetHistoryRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__SubmitGetHistoryRequest(soap, tag ? tag : "ns1:SubmitGetHistoryRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SubmitGetHistoryRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SubmitGetHistoryRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SubmitGetHistoryRequest * SOAP_FMAC4 soap_get_ns1__SubmitGetHistoryRequest(struct soap *soap, ns1__SubmitGetHistoryRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SubmitGetHistoryRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__RetrieveGetDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__PerSecurityResponse::soap_default(soap);
	soap_default_std__string(soap, &this->ns1__RetrieveGetDataResponse::responseId);
	this->ns1__RetrieveGetDataResponse::headers = NULL;
	this->ns1__RetrieveGetDataResponse::fields = NULL;
	this->ns1__RetrieveGetDataResponse::timestarted = NULL;
	this->ns1__RetrieveGetDataResponse::instrumentDatas = NULL;
	this->ns1__RetrieveGetDataResponse::timefinished = NULL;
}

void ns1__RetrieveGetDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__RetrieveGetDataResponse::responseId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__RetrieveGetDataResponse::responseId);
	soap_serialize_PointerTons1__GetDataHeaders(soap, &this->ns1__RetrieveGetDataResponse::headers);
	soap_serialize_PointerTons1__Fields(soap, &this->ns1__RetrieveGetDataResponse::fields);
	soap_serialize_PointerTodateTime(soap, &this->ns1__RetrieveGetDataResponse::timestarted);
	soap_serialize_PointerTons1__InstrumentDatas(soap, &this->ns1__RetrieveGetDataResponse::instrumentDatas);
	soap_serialize_PointerTodateTime(soap, &this->ns1__RetrieveGetDataResponse::timefinished);
	this->ns1__PerSecurityResponse::soap_serialize(soap);
#endif
}

int ns1__RetrieveGetDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RetrieveGetDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RetrieveGetDataResponse(struct soap *soap, const char *tag, int id, const ns1__RetrieveGetDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RetrieveGetDataResponse), type ? type : "ns1:RetrieveGetDataResponse"))
		return soap->error;
	if (!a->ns1__PerSecurityResponse::statusCode)
	{	if (soap_element_empty(soap, "ns1:statusCode", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__ResponseStatus(soap, "ns1:statusCode", -1, &a->ns1__PerSecurityResponse::statusCode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:requestId", -1, &a->ns1__PerSecurityResponse::requestId, ""))
		return soap->error;
	soap_element_result(soap, "ns1:responseId");
	if (soap_out_std__string(soap, "ns1:responseId", -1, &a->ns1__RetrieveGetDataResponse::responseId, ""))
		return soap->error;
	if (soap_out_PointerTons1__GetDataHeaders(soap, "ns1:headers", -1, &a->ns1__RetrieveGetDataResponse::headers, ""))
		return soap->error;
	if (soap_out_PointerTons1__Fields(soap, "ns1:fields", -1, &a->ns1__RetrieveGetDataResponse::fields, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns1:timestarted", -1, &a->ns1__RetrieveGetDataResponse::timestarted, ""))
		return soap->error;
	if (soap_out_PointerTons1__InstrumentDatas(soap, "ns1:instrumentDatas", -1, &a->ns1__RetrieveGetDataResponse::instrumentDatas, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns1:timefinished", -1, &a->ns1__RetrieveGetDataResponse::timefinished, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__RetrieveGetDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__RetrieveGetDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RetrieveGetDataResponse * SOAP_FMAC4 soap_in_ns1__RetrieveGetDataResponse(struct soap *soap, const char *tag, ns1__RetrieveGetDataResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RetrieveGetDataResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RetrieveGetDataResponse, sizeof(ns1__RetrieveGetDataResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__RetrieveGetDataResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__RetrieveGetDataResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_statusCode2 = 1;
	size_t soap_flag_requestId2 = 1;
	size_t soap_flag_responseId1 = 1;
	size_t soap_flag_headers1 = 1;
	size_t soap_flag_fields1 = 1;
	size_t soap_flag_timestarted1 = 1;
	size_t soap_flag_instrumentDatas1 = 1;
	size_t soap_flag_timefinished1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ResponseStatus(soap, "ns1:statusCode", &a->ns1__PerSecurityResponse::statusCode, "ns1:ResponseStatus"))
				{	soap_flag_statusCode2--;
					continue;
				}
			}
			if (soap_flag_requestId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:requestId", &a->ns1__PerSecurityResponse::requestId, "xsd:string"))
				{	soap_flag_requestId2--;
					continue;
				}
			}
			if (soap_flag_responseId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:responseId", &a->ns1__RetrieveGetDataResponse::responseId, "xsd:string"))
				{	soap_flag_responseId1--;
					continue;
				}
			}
			if (soap_flag_headers1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GetDataHeaders(soap, "ns1:headers", &a->ns1__RetrieveGetDataResponse::headers, "ns1:GetDataHeaders"))
				{	soap_flag_headers1--;
					continue;
				}
			}
			if (soap_flag_fields1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Fields(soap, "ns1:fields", &a->ns1__RetrieveGetDataResponse::fields, "ns1:Fields"))
				{	soap_flag_fields1--;
					continue;
				}
			}
			if (soap_flag_timestarted1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns1:timestarted", &a->ns1__RetrieveGetDataResponse::timestarted, "xsd:dateTime"))
				{	soap_flag_timestarted1--;
					continue;
				}
			}
			if (soap_flag_instrumentDatas1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__InstrumentDatas(soap, "ns1:instrumentDatas", &a->ns1__RetrieveGetDataResponse::instrumentDatas, "ns1:InstrumentDatas"))
				{	soap_flag_instrumentDatas1--;
					continue;
				}
			}
			if (soap_flag_timefinished1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns1:timefinished", &a->ns1__RetrieveGetDataResponse::timefinished, "xsd:dateTime"))
				{	soap_flag_timefinished1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:responseId");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__PerSecurityResponse::statusCode || soap_flag_requestId2 > 0 || soap_flag_responseId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__RetrieveGetDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RetrieveGetDataResponse, SOAP_TYPE_ns1__RetrieveGetDataResponse, sizeof(ns1__RetrieveGetDataResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__RetrieveGetDataResponse * SOAP_FMAC2 soap_instantiate_ns1__RetrieveGetDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RetrieveGetDataResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__RetrieveGetDataResponse *p;
	size_t k = sizeof(ns1__RetrieveGetDataResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__RetrieveGetDataResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__RetrieveGetDataResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__RetrieveGetDataResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__RetrieveGetDataResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__RetrieveGetDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__RetrieveGetDataResponse(soap, tag ? tag : "ns1:RetrieveGetDataResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__RetrieveGetDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RetrieveGetDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RetrieveGetDataResponse * SOAP_FMAC4 soap_get_ns1__RetrieveGetDataResponse(struct soap *soap, ns1__RetrieveGetDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RetrieveGetDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__RetrieveGetDataRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__RetrieveGetDataRequest::responseId);
	this->ns1__RetrieveGetDataRequest::responseDate = NULL;
}

void ns1__RetrieveGetDataRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__RetrieveGetDataRequest::responseId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__RetrieveGetDataRequest::responseId);
	soap_serialize_PointerToxsd__date(soap, &this->ns1__RetrieveGetDataRequest::responseDate);
#endif
}

int ns1__RetrieveGetDataRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RetrieveGetDataRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RetrieveGetDataRequest(struct soap *soap, const char *tag, int id, const ns1__RetrieveGetDataRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RetrieveGetDataRequest), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:responseId", -1, &a->ns1__RetrieveGetDataRequest::responseId, ""))
		return soap->error;
	if (soap_out_PointerToxsd__date(soap, "ns1:responseDate", -1, &a->ns1__RetrieveGetDataRequest::responseDate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__RetrieveGetDataRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__RetrieveGetDataRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RetrieveGetDataRequest * SOAP_FMAC4 soap_in_ns1__RetrieveGetDataRequest(struct soap *soap, const char *tag, ns1__RetrieveGetDataRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RetrieveGetDataRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RetrieveGetDataRequest, sizeof(ns1__RetrieveGetDataRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__RetrieveGetDataRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__RetrieveGetDataRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_responseId1 = 1;
	size_t soap_flag_responseDate1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_responseId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:responseId", &a->ns1__RetrieveGetDataRequest::responseId, "xsd:string"))
				{	soap_flag_responseId1--;
					continue;
				}
			}
			if (soap_flag_responseDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__date(soap, "ns1:responseDate", &a->ns1__RetrieveGetDataRequest::responseDate, "xsd:date"))
				{	soap_flag_responseDate1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_responseId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__RetrieveGetDataRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RetrieveGetDataRequest, SOAP_TYPE_ns1__RetrieveGetDataRequest, sizeof(ns1__RetrieveGetDataRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__RetrieveGetDataRequest * SOAP_FMAC2 soap_instantiate_ns1__RetrieveGetDataRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RetrieveGetDataRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__RetrieveGetDataRequest *p;
	size_t k = sizeof(ns1__RetrieveGetDataRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__RetrieveGetDataRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__RetrieveGetDataRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__RetrieveGetDataRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__RetrieveGetDataRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__RetrieveGetDataRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__RetrieveGetDataRequest(soap, tag ? tag : "ns1:RetrieveGetDataRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__RetrieveGetDataRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RetrieveGetDataRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RetrieveGetDataRequest * SOAP_FMAC4 soap_get_ns1__RetrieveGetDataRequest(struct soap *soap, ns1__RetrieveGetDataRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RetrieveGetDataRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__SubmitGetDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__PerSecurityResponse::soap_default(soap);
	soap_default_std__string(soap, &this->ns1__SubmitGetDataResponse::responseId);
}

void ns1__SubmitGetDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__SubmitGetDataResponse::responseId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__SubmitGetDataResponse::responseId);
	this->ns1__PerSecurityResponse::soap_serialize(soap);
#endif
}

int ns1__SubmitGetDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SubmitGetDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SubmitGetDataResponse(struct soap *soap, const char *tag, int id, const ns1__SubmitGetDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SubmitGetDataResponse), type ? type : "ns1:SubmitGetDataResponse"))
		return soap->error;
	if (!a->ns1__PerSecurityResponse::statusCode)
	{	if (soap_element_empty(soap, "ns1:statusCode", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__ResponseStatus(soap, "ns1:statusCode", -1, &a->ns1__PerSecurityResponse::statusCode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:requestId", -1, &a->ns1__PerSecurityResponse::requestId, ""))
		return soap->error;
	soap_element_result(soap, "ns1:responseId");
	if (soap_out_std__string(soap, "ns1:responseId", -1, &a->ns1__SubmitGetDataResponse::responseId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SubmitGetDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__SubmitGetDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SubmitGetDataResponse * SOAP_FMAC4 soap_in_ns1__SubmitGetDataResponse(struct soap *soap, const char *tag, ns1__SubmitGetDataResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SubmitGetDataResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SubmitGetDataResponse, sizeof(ns1__SubmitGetDataResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__SubmitGetDataResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__SubmitGetDataResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_statusCode2 = 1;
	size_t soap_flag_requestId2 = 1;
	size_t soap_flag_responseId1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ResponseStatus(soap, "ns1:statusCode", &a->ns1__PerSecurityResponse::statusCode, "ns1:ResponseStatus"))
				{	soap_flag_statusCode2--;
					continue;
				}
			}
			if (soap_flag_requestId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:requestId", &a->ns1__PerSecurityResponse::requestId, "xsd:string"))
				{	soap_flag_requestId2--;
					continue;
				}
			}
			if (soap_flag_responseId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:responseId", &a->ns1__SubmitGetDataResponse::responseId, "xsd:string"))
				{	soap_flag_responseId1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:responseId");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__PerSecurityResponse::statusCode || soap_flag_requestId2 > 0 || soap_flag_responseId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__SubmitGetDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SubmitGetDataResponse, SOAP_TYPE_ns1__SubmitGetDataResponse, sizeof(ns1__SubmitGetDataResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__SubmitGetDataResponse * SOAP_FMAC2 soap_instantiate_ns1__SubmitGetDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SubmitGetDataResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__SubmitGetDataResponse *p;
	size_t k = sizeof(ns1__SubmitGetDataResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__SubmitGetDataResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__SubmitGetDataResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__SubmitGetDataResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__SubmitGetDataResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__SubmitGetDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__SubmitGetDataResponse(soap, tag ? tag : "ns1:SubmitGetDataResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SubmitGetDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SubmitGetDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SubmitGetDataResponse * SOAP_FMAC4 soap_get_ns1__SubmitGetDataResponse(struct soap *soap, ns1__SubmitGetDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SubmitGetDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__SubmitGetDataRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__SubmitGetDataRequest::headers = NULL;
	this->ns1__SubmitGetDataRequest::fieldsets = NULL;
	this->ns1__SubmitGetDataRequest::fields = NULL;
	this->ns1__SubmitGetDataRequest::instruments = NULL;
}

void ns1__SubmitGetDataRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__GetDataHeaders(soap, &this->ns1__SubmitGetDataRequest::headers);
	soap_serialize_PointerTons1__BvalFieldSets(soap, &this->ns1__SubmitGetDataRequest::fieldsets);
	soap_serialize_PointerTons1__Fields(soap, &this->ns1__SubmitGetDataRequest::fields);
	soap_serialize_PointerTons1__Instruments(soap, &this->ns1__SubmitGetDataRequest::instruments);
#endif
}

int ns1__SubmitGetDataRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SubmitGetDataRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SubmitGetDataRequest(struct soap *soap, const char *tag, int id, const ns1__SubmitGetDataRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SubmitGetDataRequest), type))
		return soap->error;
	if (!a->ns1__SubmitGetDataRequest::headers)
	{	if (soap_element_empty(soap, "ns1:headers", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__GetDataHeaders(soap, "ns1:headers", -1, &a->ns1__SubmitGetDataRequest::headers, ""))
		return soap->error;
	if (soap_out_PointerTons1__BvalFieldSets(soap, "ns1:fieldsets", -1, &a->ns1__SubmitGetDataRequest::fieldsets, ""))
		return soap->error;
	if (soap_out_PointerTons1__Fields(soap, "ns1:fields", -1, &a->ns1__SubmitGetDataRequest::fields, ""))
		return soap->error;
	if (!a->ns1__SubmitGetDataRequest::instruments)
	{	if (soap_element_empty(soap, "ns1:instruments", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__Instruments(soap, "ns1:instruments", -1, &a->ns1__SubmitGetDataRequest::instruments, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SubmitGetDataRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__SubmitGetDataRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SubmitGetDataRequest * SOAP_FMAC4 soap_in_ns1__SubmitGetDataRequest(struct soap *soap, const char *tag, ns1__SubmitGetDataRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SubmitGetDataRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SubmitGetDataRequest, sizeof(ns1__SubmitGetDataRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__SubmitGetDataRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__SubmitGetDataRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_headers1 = 1;
	size_t soap_flag_fieldsets1 = 1;
	size_t soap_flag_fields1 = 1;
	size_t soap_flag_instruments1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_headers1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GetDataHeaders(soap, "ns1:headers", &a->ns1__SubmitGetDataRequest::headers, "ns1:GetDataHeaders"))
				{	soap_flag_headers1--;
					continue;
				}
			}
			if (soap_flag_fieldsets1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__BvalFieldSets(soap, "ns1:fieldsets", &a->ns1__SubmitGetDataRequest::fieldsets, "ns1:BvalFieldSets"))
				{	soap_flag_fieldsets1--;
					continue;
				}
			}
			if (soap_flag_fields1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Fields(soap, "ns1:fields", &a->ns1__SubmitGetDataRequest::fields, "ns1:Fields"))
				{	soap_flag_fields1--;
					continue;
				}
			}
			if (soap_flag_instruments1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Instruments(soap, "ns1:instruments", &a->ns1__SubmitGetDataRequest::instruments, "ns1:Instruments"))
				{	soap_flag_instruments1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__SubmitGetDataRequest::headers || !a->ns1__SubmitGetDataRequest::instruments))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__SubmitGetDataRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SubmitGetDataRequest, SOAP_TYPE_ns1__SubmitGetDataRequest, sizeof(ns1__SubmitGetDataRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__SubmitGetDataRequest * SOAP_FMAC2 soap_instantiate_ns1__SubmitGetDataRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SubmitGetDataRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__SubmitGetDataRequest *p;
	size_t k = sizeof(ns1__SubmitGetDataRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__SubmitGetDataRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__SubmitGetDataRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__SubmitGetDataRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__SubmitGetDataRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__SubmitGetDataRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__SubmitGetDataRequest(soap, tag ? tag : "ns1:SubmitGetDataRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SubmitGetDataRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SubmitGetDataRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SubmitGetDataRequest * SOAP_FMAC4 soap_get_ns1__SubmitGetDataRequest(struct soap *soap, ns1__SubmitGetDataRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SubmitGetDataRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__PerSecurityResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__PerSecurityResponse::statusCode = NULL;
	soap_default_std__string(soap, &this->ns1__PerSecurityResponse::requestId);
}

void ns1__PerSecurityResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ResponseStatus(soap, &this->ns1__PerSecurityResponse::statusCode);
	soap_embedded(soap, &this->ns1__PerSecurityResponse::requestId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__PerSecurityResponse::requestId);
#endif
}

int ns1__PerSecurityResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__PerSecurityResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PerSecurityResponse(struct soap *soap, const char *tag, int id, const ns1__PerSecurityResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PerSecurityResponse), type))
		return soap->error;
	if (!a->ns1__PerSecurityResponse::statusCode)
	{	if (soap_element_empty(soap, "ns1:statusCode", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__ResponseStatus(soap, "ns1:statusCode", -1, &a->ns1__PerSecurityResponse::statusCode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:requestId", -1, &a->ns1__PerSecurityResponse::requestId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__PerSecurityResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__PerSecurityResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__PerSecurityResponse * SOAP_FMAC4 soap_in_ns1__PerSecurityResponse(struct soap *soap, const char *tag, ns1__PerSecurityResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__PerSecurityResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PerSecurityResponse, sizeof(ns1__PerSecurityResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__PerSecurityResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__PerSecurityResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_statusCode1 = 1;
	size_t soap_flag_requestId1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusCode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ResponseStatus(soap, "ns1:statusCode", &a->ns1__PerSecurityResponse::statusCode, "ns1:ResponseStatus"))
				{	soap_flag_statusCode1--;
					continue;
				}
			}
			if (soap_flag_requestId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:requestId", &a->ns1__PerSecurityResponse::requestId, "xsd:string"))
				{	soap_flag_requestId1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__PerSecurityResponse::statusCode || soap_flag_requestId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__PerSecurityResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PerSecurityResponse, SOAP_TYPE_ns1__PerSecurityResponse, sizeof(ns1__PerSecurityResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__PerSecurityResponse * SOAP_FMAC2 soap_instantiate_ns1__PerSecurityResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__PerSecurityResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "ns1:SubmitGetDataResponse"))
		return soap_instantiate_ns1__SubmitGetDataResponse(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:RetrieveGetDataResponse"))
		return soap_instantiate_ns1__RetrieveGetDataResponse(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:SubmitGetHistoryResponse"))
		return soap_instantiate_ns1__SubmitGetHistoryResponse(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:RetrieveGetHistoryResponse"))
		return soap_instantiate_ns1__RetrieveGetHistoryResponse(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:SubmitCancelResponse"))
		return soap_instantiate_ns1__SubmitCancelResponse(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:RetrieveCancelResponse"))
		return soap_instantiate_ns1__RetrieveCancelResponse(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:GetCorrectionsResponse"))
		return soap_instantiate_ns1__GetCorrectionsResponse(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:SubmitScheduledResponse"))
		return soap_instantiate_ns1__SubmitScheduledResponse(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:RetrieveScheduledResponse"))
		return soap_instantiate_ns1__RetrieveScheduledResponse(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:SubmitGetFundamentalsResponse"))
		return soap_instantiate_ns1__SubmitGetFundamentalsResponse(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:RetrieveGetFundamentalsResponse"))
		return soap_instantiate_ns1__RetrieveGetFundamentalsResponse(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:SubmitGetCompanyResponse"))
		return soap_instantiate_ns1__SubmitGetCompanyResponse(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:RetrieveGetCompanyResponse"))
		return soap_instantiate_ns1__RetrieveGetCompanyResponse(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:GetPortfolioValidationResponse"))
		return soap_instantiate_ns1__GetPortfolioValidationResponse(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:SubmitGetActionsResponse"))
		return soap_instantiate_ns1__SubmitGetActionsResponse(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:RetrieveGetActionsResponse"))
		return soap_instantiate_ns1__RetrieveGetActionsResponse(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:SubmitGetQuotesResponse"))
		return soap_instantiate_ns1__SubmitGetQuotesResponse(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:RetrieveGetQuotesResponse"))
		return soap_instantiate_ns1__RetrieveGetQuotesResponse(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:SubmitGetAllQuotesResponse"))
		return soap_instantiate_ns1__SubmitGetAllQuotesResponse(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:RetrieveGetAllQuotesResponse"))
		return soap_instantiate_ns1__RetrieveGetAllQuotesResponse(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:SubmitOtcbvalUploadResponse"))
		return soap_instantiate_ns1__SubmitOtcbvalUploadResponse(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:RetrieveOtcbvalUploadResponse"))
		return soap_instantiate_ns1__RetrieveOtcbvalUploadResponse(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:SubmitOtcBvalDealsUploadResponse"))
		return soap_instantiate_ns1__SubmitOtcBvalDealsUploadResponse(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:RetrieveOtcBvalDealsUploadResponse"))
		return soap_instantiate_ns1__RetrieveOtcBvalDealsUploadResponse(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:GetFieldsResponse"))
		return soap_instantiate_ns1__GetFieldsResponse(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:SubmitMmktBvalDealsUploadResponse"))
		return soap_instantiate_ns1__SubmitMmktBvalDealsUploadResponse(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:RetrieveMmktBvalDealsUploadResponse"))
		return soap_instantiate_ns1__RetrieveMmktBvalDealsUploadResponse(soap, n, NULL, NULL, size);
	ns1__PerSecurityResponse *p;
	size_t k = sizeof(ns1__PerSecurityResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__PerSecurityResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__PerSecurityResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__PerSecurityResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__PerSecurityResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__PerSecurityResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__PerSecurityResponse(soap, tag ? tag : "ns1:PerSecurityResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__PerSecurityResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__PerSecurityResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__PerSecurityResponse * SOAP_FMAC4 soap_get_ns1__PerSecurityResponse(struct soap *soap, ns1__PerSecurityResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PerSecurityResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__OtcDealInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__OtcDealInformation(soap, &this->ns1__OtcDealInfos::deal);
}

void ns1__OtcDealInfos::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__OtcDealInformation(soap, &this->ns1__OtcDealInfos::deal);
#endif
}

int ns1__OtcDealInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__OtcDealInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__OtcDealInfos(struct soap *soap, const char *tag, int id, const ns1__OtcDealInfos *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__OtcDealInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__OtcDealInformation(soap, "ns1:deal", -1, &a->ns1__OtcDealInfos::deal, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__OtcDealInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__OtcDealInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns1__OtcDealInfos * SOAP_FMAC4 soap_in_ns1__OtcDealInfos(struct soap *soap, const char *tag, ns1__OtcDealInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__OtcDealInfos*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__OtcDealInfos, sizeof(ns1__OtcDealInfos), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__OtcDealInfos)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__OtcDealInfos *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__OtcDealInformation(soap, "ns1:deal", &a->ns1__OtcDealInfos::deal, "ns1:OtcDealInformation"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__OtcDealInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__OtcDealInfos, SOAP_TYPE_ns1__OtcDealInfos, sizeof(ns1__OtcDealInfos), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__OtcDealInfos * SOAP_FMAC2 soap_instantiate_ns1__OtcDealInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__OtcDealInfos(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__OtcDealInfos *p;
	size_t k = sizeof(ns1__OtcDealInfos);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__OtcDealInfos, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__OtcDealInfos);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__OtcDealInfos, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__OtcDealInfos location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__OtcDealInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__OtcDealInfos(soap, tag ? tag : "ns1:OtcDealInfos", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__OtcDealInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__OtcDealInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns1__OtcDealInfos * SOAP_FMAC4 soap_get_ns1__OtcDealInfos(struct soap *soap, ns1__OtcDealInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__OtcDealInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__OtcDealInformation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__OtcDealInformation::statusCode = NULL;
	this->ns1__OtcDealInformation::customId = NULL;
	this->ns1__OtcDealInformation::dealId = NULL;
	this->ns1__OtcDealInformation::dealType = NULL;
	this->ns1__OtcDealInformation::action = NULL;
	this->ns1__OtcDealInformation::portfolioId = NULL;
}

void ns1__OtcDealInformation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ResponseStatus(soap, &this->ns1__OtcDealInformation::statusCode);
	soap_serialize_PointerTostd__string(soap, &this->ns1__OtcDealInformation::customId);
	soap_serialize_PointerTostd__string(soap, &this->ns1__OtcDealInformation::dealId);
	soap_serialize_PointerTostd__string(soap, &this->ns1__OtcDealInformation::dealType);
	soap_serialize_PointerTons1__OtcBvalAction(soap, &this->ns1__OtcDealInformation::action);
	soap_serialize_PointerTostd__string(soap, &this->ns1__OtcDealInformation::portfolioId);
#endif
}

int ns1__OtcDealInformation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__OtcDealInformation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__OtcDealInformation(struct soap *soap, const char *tag, int id, const ns1__OtcDealInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__OtcDealInformation), type))
		return soap->error;
	if (!a->ns1__OtcDealInformation::statusCode)
	{	if (soap_element_empty(soap, "ns1:statusCode", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__ResponseStatus(soap, "ns1:statusCode", -1, &a->ns1__OtcDealInformation::statusCode, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:customId", -1, &a->ns1__OtcDealInformation::customId, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:dealId", -1, &a->ns1__OtcDealInformation::dealId, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:dealType", -1, &a->ns1__OtcDealInformation::dealType, ""))
		return soap->error;
	if (soap_out_PointerTons1__OtcBvalAction(soap, "ns1:action", -1, &a->ns1__OtcDealInformation::action, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:portfolioId", -1, &a->ns1__OtcDealInformation::portfolioId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__OtcDealInformation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__OtcDealInformation(soap, tag, this, type);
}

SOAP_FMAC3 ns1__OtcDealInformation * SOAP_FMAC4 soap_in_ns1__OtcDealInformation(struct soap *soap, const char *tag, ns1__OtcDealInformation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__OtcDealInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__OtcDealInformation, sizeof(ns1__OtcDealInformation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__OtcDealInformation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__OtcDealInformation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_statusCode1 = 1;
	size_t soap_flag_customId1 = 1;
	size_t soap_flag_dealId1 = 1;
	size_t soap_flag_dealType1 = 1;
	size_t soap_flag_action1 = 1;
	size_t soap_flag_portfolioId1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusCode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ResponseStatus(soap, "ns1:statusCode", &a->ns1__OtcDealInformation::statusCode, "ns1:ResponseStatus"))
				{	soap_flag_statusCode1--;
					continue;
				}
			}
			if (soap_flag_customId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:customId", &a->ns1__OtcDealInformation::customId, "xsd:string"))
				{	soap_flag_customId1--;
					continue;
				}
			}
			if (soap_flag_dealId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:dealId", &a->ns1__OtcDealInformation::dealId, "xsd:string"))
				{	soap_flag_dealId1--;
					continue;
				}
			}
			if (soap_flag_dealType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:dealType", &a->ns1__OtcDealInformation::dealType, "xsd:string"))
				{	soap_flag_dealType1--;
					continue;
				}
			}
			if (soap_flag_action1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__OtcBvalAction(soap, "ns1:action", &a->ns1__OtcDealInformation::action, "ns1:OtcBvalAction"))
				{	soap_flag_action1--;
					continue;
				}
			}
			if (soap_flag_portfolioId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:portfolioId", &a->ns1__OtcDealInformation::portfolioId, "xsd:string"))
				{	soap_flag_portfolioId1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__OtcDealInformation::statusCode))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__OtcDealInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__OtcDealInformation, SOAP_TYPE_ns1__OtcDealInformation, sizeof(ns1__OtcDealInformation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__OtcDealInformation * SOAP_FMAC2 soap_instantiate_ns1__OtcDealInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__OtcDealInformation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__OtcDealInformation *p;
	size_t k = sizeof(ns1__OtcDealInformation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__OtcDealInformation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__OtcDealInformation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__OtcDealInformation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__OtcDealInformation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__OtcDealInformation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__OtcDealInformation(soap, tag ? tag : "ns1:OtcDealInformation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__OtcDealInformation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__OtcDealInformation(soap, this, tag, type);
}

SOAP_FMAC3 ns1__OtcDealInformation * SOAP_FMAC4 soap_get_ns1__OtcDealInformation(struct soap *soap, ns1__OtcDealInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__OtcDealInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__OtcBvalHeaders::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__OtcBvalHeaders::contentType);
	soap_default_std__string(soap, &this->ns1__OtcBvalHeaders::mimeVersion);
	soap_default_std__string(soap, &this->ns1__OtcBvalHeaders::contentEncoding);
	soap_default_std__string(soap, &this->ns1__OtcBvalHeaders::contentDisposition);
	soap_default_std__string(soap, &this->ns1__OtcBvalHeaders::fileName);
}

void ns1__OtcBvalHeaders::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__OtcBvalHeaders::contentType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__OtcBvalHeaders::contentType);
	soap_embedded(soap, &this->ns1__OtcBvalHeaders::mimeVersion, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__OtcBvalHeaders::mimeVersion);
	soap_embedded(soap, &this->ns1__OtcBvalHeaders::contentEncoding, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__OtcBvalHeaders::contentEncoding);
	soap_embedded(soap, &this->ns1__OtcBvalHeaders::contentDisposition, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__OtcBvalHeaders::contentDisposition);
	soap_embedded(soap, &this->ns1__OtcBvalHeaders::fileName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__OtcBvalHeaders::fileName);
#endif
}

int ns1__OtcBvalHeaders::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__OtcBvalHeaders(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__OtcBvalHeaders(struct soap *soap, const char *tag, int id, const ns1__OtcBvalHeaders *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__OtcBvalHeaders), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:contentType", -1, &a->ns1__OtcBvalHeaders::contentType, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:mimeVersion", -1, &a->ns1__OtcBvalHeaders::mimeVersion, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:contentEncoding", -1, &a->ns1__OtcBvalHeaders::contentEncoding, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:contentDisposition", -1, &a->ns1__OtcBvalHeaders::contentDisposition, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:fileName", -1, &a->ns1__OtcBvalHeaders::fileName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__OtcBvalHeaders::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__OtcBvalHeaders(soap, tag, this, type);
}

SOAP_FMAC3 ns1__OtcBvalHeaders * SOAP_FMAC4 soap_in_ns1__OtcBvalHeaders(struct soap *soap, const char *tag, ns1__OtcBvalHeaders *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__OtcBvalHeaders*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__OtcBvalHeaders, sizeof(ns1__OtcBvalHeaders), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__OtcBvalHeaders)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__OtcBvalHeaders *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_contentType1 = 1;
	size_t soap_flag_mimeVersion1 = 1;
	size_t soap_flag_contentEncoding1 = 1;
	size_t soap_flag_contentDisposition1 = 1;
	size_t soap_flag_fileName1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_contentType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:contentType", &a->ns1__OtcBvalHeaders::contentType, "xsd:string"))
				{	soap_flag_contentType1--;
					continue;
				}
			}
			if (soap_flag_mimeVersion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:mimeVersion", &a->ns1__OtcBvalHeaders::mimeVersion, "xsd:string"))
				{	soap_flag_mimeVersion1--;
					continue;
				}
			}
			if (soap_flag_contentEncoding1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:contentEncoding", &a->ns1__OtcBvalHeaders::contentEncoding, "xsd:string"))
				{	soap_flag_contentEncoding1--;
					continue;
				}
			}
			if (soap_flag_contentDisposition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:contentDisposition", &a->ns1__OtcBvalHeaders::contentDisposition, "xsd:string"))
				{	soap_flag_contentDisposition1--;
					continue;
				}
			}
			if (soap_flag_fileName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:fileName", &a->ns1__OtcBvalHeaders::fileName, "xsd:string"))
				{	soap_flag_fileName1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_contentType1 > 0 || soap_flag_mimeVersion1 > 0 || soap_flag_contentEncoding1 > 0 || soap_flag_contentDisposition1 > 0 || soap_flag_fileName1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__OtcBvalHeaders *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__OtcBvalHeaders, SOAP_TYPE_ns1__OtcBvalHeaders, sizeof(ns1__OtcBvalHeaders), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__OtcBvalHeaders * SOAP_FMAC2 soap_instantiate_ns1__OtcBvalHeaders(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__OtcBvalHeaders(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__OtcBvalHeaders *p;
	size_t k = sizeof(ns1__OtcBvalHeaders);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__OtcBvalHeaders, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__OtcBvalHeaders);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__OtcBvalHeaders, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__OtcBvalHeaders location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__OtcBvalHeaders::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__OtcBvalHeaders(soap, tag ? tag : "ns1:OtcBvalHeaders", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__OtcBvalHeaders::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__OtcBvalHeaders(soap, this, tag, type);
}

SOAP_FMAC3 ns1__OtcBvalHeaders * SOAP_FMAC4 soap_get_ns1__OtcBvalHeaders(struct soap *soap, ns1__OtcBvalHeaders *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__OtcBvalHeaders(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__FieldInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__FieldInfo::id = NULL;
	this->ns1__FieldInfo::mnemonic = NULL;
	this->ns1__FieldInfo::description = NULL;
	this->ns1__FieldInfo::dlCategory = NULL;
	this->ns1__FieldInfo::definition = NULL;
	soap_default_std__vectorTemplateOfns1__MarketSector(soap, &this->ns1__FieldInfo::marketsectors);
	this->ns1__FieldInfo::standardWidth = NULL;
	this->ns1__FieldInfo::standardDecimalPlaces = NULL;
	this->ns1__FieldInfo::fieldType = NULL;
	this->ns1__FieldInfo::backoffice = NULL;
	this->ns1__FieldInfo::extendedBackoffice = NULL;
	this->ns1__FieldInfo::productionDate = NULL;
	this->ns1__FieldInfo::dlCategory2 = NULL;
	this->ns1__FieldInfo::psBoOpt = NULL;
	this->ns1__FieldInfo::getHistory = NULL;
	this->ns1__FieldInfo::getCompany = NULL;
	this->ns1__FieldInfo::bval = NULL;
	this->ns1__FieldInfo::bvalBlocked = NULL;
	this->ns1__FieldInfo::dsBvalMetered = NULL;
	this->ns1__FieldInfo::sapiOMS = NULL;
	this->ns1__FieldInfo::oldMnemonic = NULL;
	this->ns1__FieldInfo::currentMaximumWidth = NULL;
	this->ns1__FieldInfo::dlBoOptFundamentals = NULL;
	this->ns1__FieldInfo::dlBoOptBDVD = NULL;
	this->ns1__FieldInfo::dlBoOptBEST = NULL;
	this->ns1__FieldInfo::dlBoOptCreditRisk = NULL;
	this->ns1__FieldInfo::dlBoOptCapStruct = NULL;
	this->ns1__FieldInfo::dlBoOptCreditRiskGetCompany = NULL;
	this->ns1__FieldInfo::dlBoOptCapStructGetCompany = NULL;
	this->ns1__FieldInfo::dlBoOptRegCompliance = NULL;
	this->ns1__FieldInfo::dlBoOptIssuerRatings = NULL;
}

void ns1__FieldInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns1__FieldInfo::id);
	soap_serialize_PointerTostd__string(soap, &this->ns1__FieldInfo::mnemonic);
	soap_serialize_PointerTostd__string(soap, &this->ns1__FieldInfo::description);
	soap_serialize_PointerTons1__DLCategory(soap, &this->ns1__FieldInfo::dlCategory);
	soap_serialize_PointerTostd__string(soap, &this->ns1__FieldInfo::definition);
	soap_serialize_std__vectorTemplateOfns1__MarketSector(soap, &this->ns1__FieldInfo::marketsectors);
	soap_serialize_PointerToint(soap, &this->ns1__FieldInfo::standardWidth);
	soap_serialize_PointerToint(soap, &this->ns1__FieldInfo::standardDecimalPlaces);
	soap_serialize_PointerTostd__string(soap, &this->ns1__FieldInfo::fieldType);
	soap_serialize_PointerTobool(soap, &this->ns1__FieldInfo::backoffice);
	soap_serialize_PointerTobool(soap, &this->ns1__FieldInfo::extendedBackoffice);
	soap_serialize_PointerToxsd__date(soap, &this->ns1__FieldInfo::productionDate);
	soap_serialize_PointerTons1__DLCategory2(soap, &this->ns1__FieldInfo::dlCategory2);
	soap_serialize_PointerTobool(soap, &this->ns1__FieldInfo::psBoOpt);
	soap_serialize_PointerTobool(soap, &this->ns1__FieldInfo::getHistory);
	soap_serialize_PointerTobool(soap, &this->ns1__FieldInfo::getCompany);
	soap_serialize_PointerTobool(soap, &this->ns1__FieldInfo::bval);
	soap_serialize_PointerTobool(soap, &this->ns1__FieldInfo::bvalBlocked);
	soap_serialize_PointerTobool(soap, &this->ns1__FieldInfo::dsBvalMetered);
	soap_serialize_PointerTobool(soap, &this->ns1__FieldInfo::sapiOMS);
	soap_serialize_PointerTostd__string(soap, &this->ns1__FieldInfo::oldMnemonic);
	soap_serialize_PointerToint(soap, &this->ns1__FieldInfo::currentMaximumWidth);
	soap_serialize_PointerTobool(soap, &this->ns1__FieldInfo::dlBoOptFundamentals);
	soap_serialize_PointerTobool(soap, &this->ns1__FieldInfo::dlBoOptBDVD);
	soap_serialize_PointerTobool(soap, &this->ns1__FieldInfo::dlBoOptBEST);
	soap_serialize_PointerTobool(soap, &this->ns1__FieldInfo::dlBoOptCreditRisk);
	soap_serialize_PointerTobool(soap, &this->ns1__FieldInfo::dlBoOptCapStruct);
	soap_serialize_PointerTobool(soap, &this->ns1__FieldInfo::dlBoOptCreditRiskGetCompany);
	soap_serialize_PointerTobool(soap, &this->ns1__FieldInfo::dlBoOptCapStructGetCompany);
	soap_serialize_PointerTobool(soap, &this->ns1__FieldInfo::dlBoOptRegCompliance);
	soap_serialize_PointerTobool(soap, &this->ns1__FieldInfo::dlBoOptIssuerRatings);
#endif
}

int ns1__FieldInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__FieldInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__FieldInfo(struct soap *soap, const char *tag, int id, const ns1__FieldInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__FieldInfo), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:id", -1, &a->ns1__FieldInfo::id, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:mnemonic", -1, &a->ns1__FieldInfo::mnemonic, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:description", -1, &a->ns1__FieldInfo::description, ""))
		return soap->error;
	if (soap_out_PointerTons1__DLCategory(soap, "ns1:dlCategory", -1, &a->ns1__FieldInfo::dlCategory, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:definition", -1, &a->ns1__FieldInfo::definition, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns1__MarketSector(soap, "ns1:marketsectors", -1, &a->ns1__FieldInfo::marketsectors, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:standardWidth", -1, &a->ns1__FieldInfo::standardWidth, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:standardDecimalPlaces", -1, &a->ns1__FieldInfo::standardDecimalPlaces, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:fieldType", -1, &a->ns1__FieldInfo::fieldType, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:backoffice", -1, &a->ns1__FieldInfo::backoffice, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:extendedBackoffice", -1, &a->ns1__FieldInfo::extendedBackoffice, ""))
		return soap->error;
	if (soap_out_PointerToxsd__date(soap, "ns1:productionDate", -1, &a->ns1__FieldInfo::productionDate, ""))
		return soap->error;
	if (soap_out_PointerTons1__DLCategory2(soap, "ns1:dlCategory2", -1, &a->ns1__FieldInfo::dlCategory2, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:psBoOpt", -1, &a->ns1__FieldInfo::psBoOpt, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:getHistory", -1, &a->ns1__FieldInfo::getHistory, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:getCompany", -1, &a->ns1__FieldInfo::getCompany, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:bval", -1, &a->ns1__FieldInfo::bval, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:bvalBlocked", -1, &a->ns1__FieldInfo::bvalBlocked, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:dsBvalMetered", -1, &a->ns1__FieldInfo::dsBvalMetered, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:sapiOMS", -1, &a->ns1__FieldInfo::sapiOMS, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:oldMnemonic", -1, &a->ns1__FieldInfo::oldMnemonic, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:currentMaximumWidth", -1, &a->ns1__FieldInfo::currentMaximumWidth, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:dlBoOptFundamentals", -1, &a->ns1__FieldInfo::dlBoOptFundamentals, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:dlBoOptBDVD", -1, &a->ns1__FieldInfo::dlBoOptBDVD, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:dlBoOptBEST", -1, &a->ns1__FieldInfo::dlBoOptBEST, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:dlBoOptCreditRisk", -1, &a->ns1__FieldInfo::dlBoOptCreditRisk, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:dlBoOptCapStruct", -1, &a->ns1__FieldInfo::dlBoOptCapStruct, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:dlBoOptCreditRiskGetCompany", -1, &a->ns1__FieldInfo::dlBoOptCreditRiskGetCompany, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:dlBoOptCapStructGetCompany", -1, &a->ns1__FieldInfo::dlBoOptCapStructGetCompany, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:dlBoOptRegCompliance", -1, &a->ns1__FieldInfo::dlBoOptRegCompliance, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:dlBoOptIssuerRatings", -1, &a->ns1__FieldInfo::dlBoOptIssuerRatings, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__FieldInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__FieldInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__FieldInfo * SOAP_FMAC4 soap_in_ns1__FieldInfo(struct soap *soap, const char *tag, ns1__FieldInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__FieldInfo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FieldInfo, sizeof(ns1__FieldInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__FieldInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__FieldInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_id1 = 1;
	size_t soap_flag_mnemonic1 = 1;
	size_t soap_flag_description1 = 1;
	size_t soap_flag_dlCategory1 = 1;
	size_t soap_flag_definition1 = 1;
	size_t soap_flag_standardWidth1 = 1;
	size_t soap_flag_standardDecimalPlaces1 = 1;
	size_t soap_flag_fieldType1 = 1;
	size_t soap_flag_backoffice1 = 1;
	size_t soap_flag_extendedBackoffice1 = 1;
	size_t soap_flag_productionDate1 = 1;
	size_t soap_flag_dlCategory21 = 1;
	size_t soap_flag_psBoOpt1 = 1;
	size_t soap_flag_getHistory1 = 1;
	size_t soap_flag_getCompany1 = 1;
	size_t soap_flag_bval1 = 1;
	size_t soap_flag_bvalBlocked1 = 1;
	size_t soap_flag_dsBvalMetered1 = 1;
	size_t soap_flag_sapiOMS1 = 1;
	size_t soap_flag_oldMnemonic1 = 1;
	size_t soap_flag_currentMaximumWidth1 = 1;
	size_t soap_flag_dlBoOptFundamentals1 = 1;
	size_t soap_flag_dlBoOptBDVD1 = 1;
	size_t soap_flag_dlBoOptBEST1 = 1;
	size_t soap_flag_dlBoOptCreditRisk1 = 1;
	size_t soap_flag_dlBoOptCapStruct1 = 1;
	size_t soap_flag_dlBoOptCreditRiskGetCompany1 = 1;
	size_t soap_flag_dlBoOptCapStructGetCompany1 = 1;
	size_t soap_flag_dlBoOptRegCompliance1 = 1;
	size_t soap_flag_dlBoOptIssuerRatings1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:id", &a->ns1__FieldInfo::id, "xsd:string"))
				{	soap_flag_id1--;
					continue;
				}
			}
			if (soap_flag_mnemonic1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:mnemonic", &a->ns1__FieldInfo::mnemonic, "xsd:string"))
				{	soap_flag_mnemonic1--;
					continue;
				}
			}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:description", &a->ns1__FieldInfo::description, "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			}
			if (soap_flag_dlCategory1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__DLCategory(soap, "ns1:dlCategory", &a->ns1__FieldInfo::dlCategory, "ns1:DLCategory"))
				{	soap_flag_dlCategory1--;
					continue;
				}
			}
			if (soap_flag_definition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:definition", &a->ns1__FieldInfo::definition, "xsd:string"))
				{	soap_flag_definition1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfns1__MarketSector(soap, "ns1:marketsectors", &a->ns1__FieldInfo::marketsectors, "ns1:MarketSector"))
					continue;
			}
			if (soap_flag_standardWidth1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns1:standardWidth", &a->ns1__FieldInfo::standardWidth, "xsd:int"))
				{	soap_flag_standardWidth1--;
					continue;
				}
			}
			if (soap_flag_standardDecimalPlaces1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns1:standardDecimalPlaces", &a->ns1__FieldInfo::standardDecimalPlaces, "xsd:int"))
				{	soap_flag_standardDecimalPlaces1--;
					continue;
				}
			}
			if (soap_flag_fieldType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:fieldType", &a->ns1__FieldInfo::fieldType, "xsd:string"))
				{	soap_flag_fieldType1--;
					continue;
				}
			}
			if (soap_flag_backoffice1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:backoffice", &a->ns1__FieldInfo::backoffice, "xsd:boolean"))
				{	soap_flag_backoffice1--;
					continue;
				}
			}
			if (soap_flag_extendedBackoffice1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:extendedBackoffice", &a->ns1__FieldInfo::extendedBackoffice, "xsd:boolean"))
				{	soap_flag_extendedBackoffice1--;
					continue;
				}
			}
			if (soap_flag_productionDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__date(soap, "ns1:productionDate", &a->ns1__FieldInfo::productionDate, "xsd:date"))
				{	soap_flag_productionDate1--;
					continue;
				}
			}
			if (soap_flag_dlCategory21 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__DLCategory2(soap, "ns1:dlCategory2", &a->ns1__FieldInfo::dlCategory2, "ns1:DLCategory2"))
				{	soap_flag_dlCategory21--;
					continue;
				}
			}
			if (soap_flag_psBoOpt1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:psBoOpt", &a->ns1__FieldInfo::psBoOpt, "xsd:boolean"))
				{	soap_flag_psBoOpt1--;
					continue;
				}
			}
			if (soap_flag_getHistory1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:getHistory", &a->ns1__FieldInfo::getHistory, "xsd:boolean"))
				{	soap_flag_getHistory1--;
					continue;
				}
			}
			if (soap_flag_getCompany1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:getCompany", &a->ns1__FieldInfo::getCompany, "xsd:boolean"))
				{	soap_flag_getCompany1--;
					continue;
				}
			}
			if (soap_flag_bval1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:bval", &a->ns1__FieldInfo::bval, "xsd:boolean"))
				{	soap_flag_bval1--;
					continue;
				}
			}
			if (soap_flag_bvalBlocked1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:bvalBlocked", &a->ns1__FieldInfo::bvalBlocked, "xsd:boolean"))
				{	soap_flag_bvalBlocked1--;
					continue;
				}
			}
			if (soap_flag_dsBvalMetered1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:dsBvalMetered", &a->ns1__FieldInfo::dsBvalMetered, "xsd:boolean"))
				{	soap_flag_dsBvalMetered1--;
					continue;
				}
			}
			if (soap_flag_sapiOMS1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:sapiOMS", &a->ns1__FieldInfo::sapiOMS, "xsd:boolean"))
				{	soap_flag_sapiOMS1--;
					continue;
				}
			}
			if (soap_flag_oldMnemonic1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:oldMnemonic", &a->ns1__FieldInfo::oldMnemonic, "xsd:string"))
				{	soap_flag_oldMnemonic1--;
					continue;
				}
			}
			if (soap_flag_currentMaximumWidth1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns1:currentMaximumWidth", &a->ns1__FieldInfo::currentMaximumWidth, "xsd:int"))
				{	soap_flag_currentMaximumWidth1--;
					continue;
				}
			}
			if (soap_flag_dlBoOptFundamentals1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:dlBoOptFundamentals", &a->ns1__FieldInfo::dlBoOptFundamentals, "xsd:boolean"))
				{	soap_flag_dlBoOptFundamentals1--;
					continue;
				}
			}
			if (soap_flag_dlBoOptBDVD1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:dlBoOptBDVD", &a->ns1__FieldInfo::dlBoOptBDVD, "xsd:boolean"))
				{	soap_flag_dlBoOptBDVD1--;
					continue;
				}
			}
			if (soap_flag_dlBoOptBEST1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:dlBoOptBEST", &a->ns1__FieldInfo::dlBoOptBEST, "xsd:boolean"))
				{	soap_flag_dlBoOptBEST1--;
					continue;
				}
			}
			if (soap_flag_dlBoOptCreditRisk1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:dlBoOptCreditRisk", &a->ns1__FieldInfo::dlBoOptCreditRisk, "xsd:boolean"))
				{	soap_flag_dlBoOptCreditRisk1--;
					continue;
				}
			}
			if (soap_flag_dlBoOptCapStruct1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:dlBoOptCapStruct", &a->ns1__FieldInfo::dlBoOptCapStruct, "xsd:boolean"))
				{	soap_flag_dlBoOptCapStruct1--;
					continue;
				}
			}
			if (soap_flag_dlBoOptCreditRiskGetCompany1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:dlBoOptCreditRiskGetCompany", &a->ns1__FieldInfo::dlBoOptCreditRiskGetCompany, "xsd:boolean"))
				{	soap_flag_dlBoOptCreditRiskGetCompany1--;
					continue;
				}
			}
			if (soap_flag_dlBoOptCapStructGetCompany1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:dlBoOptCapStructGetCompany", &a->ns1__FieldInfo::dlBoOptCapStructGetCompany, "xsd:boolean"))
				{	soap_flag_dlBoOptCapStructGetCompany1--;
					continue;
				}
			}
			if (soap_flag_dlBoOptRegCompliance1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:dlBoOptRegCompliance", &a->ns1__FieldInfo::dlBoOptRegCompliance, "xsd:boolean"))
				{	soap_flag_dlBoOptRegCompliance1--;
					continue;
				}
			}
			if (soap_flag_dlBoOptIssuerRatings1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:dlBoOptIssuerRatings", &a->ns1__FieldInfo::dlBoOptIssuerRatings, "xsd:boolean"))
				{	soap_flag_dlBoOptIssuerRatings1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns1__FieldInfo::marketsectors.size() > 10))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (ns1__FieldInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__FieldInfo, SOAP_TYPE_ns1__FieldInfo, sizeof(ns1__FieldInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__FieldInfo * SOAP_FMAC2 soap_instantiate_ns1__FieldInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__FieldInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__FieldInfo *p;
	size_t k = sizeof(ns1__FieldInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__FieldInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__FieldInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__FieldInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__FieldInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__FieldInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__FieldInfo(soap, tag ? tag : "ns1:FieldInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__FieldInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__FieldInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__FieldInfo * SOAP_FMAC4 soap_get_ns1__FieldInfo(struct soap *soap, ns1__FieldInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__FieldInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__FieldInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__FieldInfo(soap, &this->ns1__FieldInfos::field);
}

void ns1__FieldInfos::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__FieldInfo(soap, &this->ns1__FieldInfos::field);
#endif
}

int ns1__FieldInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__FieldInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__FieldInfos(struct soap *soap, const char *tag, int id, const ns1__FieldInfos *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__FieldInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__FieldInfo(soap, "ns1:field", -1, &a->ns1__FieldInfos::field, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__FieldInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__FieldInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns1__FieldInfos * SOAP_FMAC4 soap_in_ns1__FieldInfos(struct soap *soap, const char *tag, ns1__FieldInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__FieldInfos*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FieldInfos, sizeof(ns1__FieldInfos), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__FieldInfos)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__FieldInfos *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__FieldInfo(soap, "ns1:field", &a->ns1__FieldInfos::field, "ns1:FieldInfo"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__FieldInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__FieldInfos, SOAP_TYPE_ns1__FieldInfos, sizeof(ns1__FieldInfos), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__FieldInfos * SOAP_FMAC2 soap_instantiate_ns1__FieldInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__FieldInfos(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__FieldInfos *p;
	size_t k = sizeof(ns1__FieldInfos);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__FieldInfos, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__FieldInfos);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__FieldInfos, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__FieldInfos location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__FieldInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__FieldInfos(soap, tag ? tag : "ns1:FieldInfos", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__FieldInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__FieldInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns1__FieldInfos * SOAP_FMAC4 soap_get_ns1__FieldInfos(struct soap *soap, ns1__FieldInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__FieldInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__FieldSearchCriteria::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__FieldSearchCriteria::keyword = NULL;
	this->ns1__FieldSearchCriteria::mnemonic = NULL;
	soap_default_std__vectorTemplateOfns1__DLCategory(soap, &this->ns1__FieldSearchCriteria::dlCategories);
	this->ns1__FieldSearchCriteria::overridable = NULL;
	soap_default_std__vectorTemplateOfns1__MarketSector(soap, &this->ns1__FieldSearchCriteria::marketsectors);
	soap_default_std__vectorTemplateOfns1__DLCategory2(soap, &this->ns1__FieldSearchCriteria::dlCategories2);
}

void ns1__FieldSearchCriteria::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns1__FieldSearchCriteria::keyword);
	soap_serialize_PointerTostd__string(soap, &this->ns1__FieldSearchCriteria::mnemonic);
	soap_serialize_std__vectorTemplateOfns1__DLCategory(soap, &this->ns1__FieldSearchCriteria::dlCategories);
	soap_serialize_PointerTobool(soap, &this->ns1__FieldSearchCriteria::overridable);
	soap_serialize_std__vectorTemplateOfns1__MarketSector(soap, &this->ns1__FieldSearchCriteria::marketsectors);
	soap_serialize_std__vectorTemplateOfns1__DLCategory2(soap, &this->ns1__FieldSearchCriteria::dlCategories2);
#endif
}

int ns1__FieldSearchCriteria::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__FieldSearchCriteria(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__FieldSearchCriteria(struct soap *soap, const char *tag, int id, const ns1__FieldSearchCriteria *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__FieldSearchCriteria), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:keyword", -1, &a->ns1__FieldSearchCriteria::keyword, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:mnemonic", -1, &a->ns1__FieldSearchCriteria::mnemonic, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns1__DLCategory(soap, "ns1:dlCategories", -1, &a->ns1__FieldSearchCriteria::dlCategories, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:overridable", -1, &a->ns1__FieldSearchCriteria::overridable, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns1__MarketSector(soap, "ns1:marketsectors", -1, &a->ns1__FieldSearchCriteria::marketsectors, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns1__DLCategory2(soap, "ns1:dlCategories2", -1, &a->ns1__FieldSearchCriteria::dlCategories2, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__FieldSearchCriteria::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__FieldSearchCriteria(soap, tag, this, type);
}

SOAP_FMAC3 ns1__FieldSearchCriteria * SOAP_FMAC4 soap_in_ns1__FieldSearchCriteria(struct soap *soap, const char *tag, ns1__FieldSearchCriteria *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__FieldSearchCriteria*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FieldSearchCriteria, sizeof(ns1__FieldSearchCriteria), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__FieldSearchCriteria)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__FieldSearchCriteria *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_keyword1 = 1;
	size_t soap_flag_mnemonic1 = 1;
	size_t soap_flag_overridable1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_keyword1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:keyword", &a->ns1__FieldSearchCriteria::keyword, "xsd:string"))
				{	soap_flag_keyword1--;
					continue;
				}
			}
			if (soap_flag_mnemonic1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:mnemonic", &a->ns1__FieldSearchCriteria::mnemonic, "xsd:string"))
				{	soap_flag_mnemonic1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfns1__DLCategory(soap, "ns1:dlCategories", &a->ns1__FieldSearchCriteria::dlCategories, "ns1:DLCategory"))
					continue;
			}
			if (soap_flag_overridable1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:overridable", &a->ns1__FieldSearchCriteria::overridable, "xsd:boolean"))
				{	soap_flag_overridable1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfns1__MarketSector(soap, "ns1:marketsectors", &a->ns1__FieldSearchCriteria::marketsectors, "ns1:MarketSector"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfns1__DLCategory2(soap, "ns1:dlCategories2", &a->ns1__FieldSearchCriteria::dlCategories2, "ns1:DLCategory2"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns1__FieldSearchCriteria::dlCategories.size() > 5 || a->ns1__FieldSearchCriteria::marketsectors.size() > 10 || a->ns1__FieldSearchCriteria::dlCategories2.size() > 5))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (ns1__FieldSearchCriteria *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__FieldSearchCriteria, SOAP_TYPE_ns1__FieldSearchCriteria, sizeof(ns1__FieldSearchCriteria), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__FieldSearchCriteria * SOAP_FMAC2 soap_instantiate_ns1__FieldSearchCriteria(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__FieldSearchCriteria(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__FieldSearchCriteria *p;
	size_t k = sizeof(ns1__FieldSearchCriteria);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__FieldSearchCriteria, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__FieldSearchCriteria);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__FieldSearchCriteria, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__FieldSearchCriteria location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__FieldSearchCriteria::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__FieldSearchCriteria(soap, tag ? tag : "ns1:FieldSearchCriteria", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__FieldSearchCriteria::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__FieldSearchCriteria(soap, this, tag, type);
}

SOAP_FMAC3 ns1__FieldSearchCriteria * SOAP_FMAC4 soap_get_ns1__FieldSearchCriteria(struct soap *soap, ns1__FieldSearchCriteria *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__FieldSearchCriteria(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__CancelResponseStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__CancelResponseStatus::responseId);
	soap_default_ns1__CancelStatus(soap, &this->ns1__CancelResponseStatus::cancelStatus);
}

void ns1__CancelResponseStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__CancelResponseStatus::responseId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__CancelResponseStatus::responseId);
#endif
}

int ns1__CancelResponseStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CancelResponseStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CancelResponseStatus(struct soap *soap, const char *tag, int id, const ns1__CancelResponseStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CancelResponseStatus), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:responseId", -1, &a->ns1__CancelResponseStatus::responseId, ""))
		return soap->error;
	if (soap_out_ns1__CancelStatus(soap, "ns1:cancelStatus", -1, &a->ns1__CancelResponseStatus::cancelStatus, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CancelResponseStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__CancelResponseStatus(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CancelResponseStatus * SOAP_FMAC4 soap_in_ns1__CancelResponseStatus(struct soap *soap, const char *tag, ns1__CancelResponseStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CancelResponseStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CancelResponseStatus, sizeof(ns1__CancelResponseStatus), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__CancelResponseStatus)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__CancelResponseStatus *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_responseId1 = 1;
	size_t soap_flag_cancelStatus1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_responseId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:responseId", &a->ns1__CancelResponseStatus::responseId, "xsd:string"))
				{	soap_flag_responseId1--;
					continue;
				}
			}
			if (soap_flag_cancelStatus1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns1__CancelStatus(soap, "ns1:cancelStatus", &a->ns1__CancelResponseStatus::cancelStatus, "ns1:CancelStatus"))
				{	soap_flag_cancelStatus1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_responseId1 > 0 || soap_flag_cancelStatus1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__CancelResponseStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CancelResponseStatus, SOAP_TYPE_ns1__CancelResponseStatus, sizeof(ns1__CancelResponseStatus), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__CancelResponseStatus * SOAP_FMAC2 soap_instantiate_ns1__CancelResponseStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CancelResponseStatus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__CancelResponseStatus *p;
	size_t k = sizeof(ns1__CancelResponseStatus);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__CancelResponseStatus, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__CancelResponseStatus);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__CancelResponseStatus, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__CancelResponseStatus location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__CancelResponseStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__CancelResponseStatus(soap, tag ? tag : "ns1:CancelResponseStatus", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CancelResponseStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CancelResponseStatus(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CancelResponseStatus * SOAP_FMAC4 soap_get_ns1__CancelResponseStatus(struct soap *soap, ns1__CancelResponseStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CancelResponseStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ResponseStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__ResponseStatus::code);
	soap_default_std__string(soap, &this->ns1__ResponseStatus::description);
}

void ns1__ResponseStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__ResponseStatus::code, SOAP_TYPE_int);
	soap_embedded(soap, &this->ns1__ResponseStatus::description, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ResponseStatus::description);
#endif
}

int ns1__ResponseStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ResponseStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ResponseStatus(struct soap *soap, const char *tag, int id, const ns1__ResponseStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ResponseStatus), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:code", -1, &a->ns1__ResponseStatus::code, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:description", -1, &a->ns1__ResponseStatus::description, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ResponseStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ResponseStatus(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ResponseStatus * SOAP_FMAC4 soap_in_ns1__ResponseStatus(struct soap *soap, const char *tag, ns1__ResponseStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ResponseStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ResponseStatus, sizeof(ns1__ResponseStatus), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ResponseStatus)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ResponseStatus *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_code1 = 1;
	size_t soap_flag_description1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_code1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:code", &a->ns1__ResponseStatus::code, "xsd:int"))
				{	soap_flag_code1--;
					continue;
				}
			}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:description", &a->ns1__ResponseStatus::description, "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_code1 > 0 || soap_flag_description1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__ResponseStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ResponseStatus, SOAP_TYPE_ns1__ResponseStatus, sizeof(ns1__ResponseStatus), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ResponseStatus * SOAP_FMAC2 soap_instantiate_ns1__ResponseStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ResponseStatus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ResponseStatus *p;
	size_t k = sizeof(ns1__ResponseStatus);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ResponseStatus, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ResponseStatus);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ResponseStatus, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ResponseStatus location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ResponseStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ResponseStatus(soap, tag ? tag : "ns1:ResponseStatus", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ResponseStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ResponseStatus(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ResponseStatus * SOAP_FMAC4 soap_get_ns1__ResponseStatus(struct soap *soap, ns1__ResponseStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ResponseStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__BulkArrayEntry::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__BulkArrayEntry::value = NULL;
	this->ns1__BulkArrayEntry::type = NULL;
}

void ns1__BulkArrayEntry::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns1__BulkArrayEntry::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__BulkArrayEntry(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__BulkArrayEntry(struct soap *soap, const char *tag, int id, const ns1__BulkArrayEntry *a, const char *type)
{
	if (((ns1__BulkArrayEntry*)a)->value)
	{	soap_set_attr(soap, "value", soap_std__string2s(soap, *((ns1__BulkArrayEntry*)a)->value), 1);
	}
	if (((ns1__BulkArrayEntry*)a)->type)
	{	soap_set_attr(soap, "type", soap_ns1__FieldType2s(soap, *((ns1__BulkArrayEntry*)a)->type), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__BulkArrayEntry), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__BulkArrayEntry::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__BulkArrayEntry(soap, tag, this, type);
}

SOAP_FMAC3 ns1__BulkArrayEntry * SOAP_FMAC4 soap_in_ns1__BulkArrayEntry(struct soap *soap, const char *tag, ns1__BulkArrayEntry *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__BulkArrayEntry*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__BulkArrayEntry, sizeof(ns1__BulkArrayEntry), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__BulkArrayEntry)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__BulkArrayEntry *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "value", 1, 0);
		if (t)
		{
			if (!(((ns1__BulkArrayEntry*)a)->value = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__BulkArrayEntry*)a)->value))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "type", 5, 0);
		if (t)
		{
			if (!(((ns1__BulkArrayEntry*)a)->type = (enum ns1__FieldType *)soap_malloc(soap, sizeof(enum ns1__FieldType))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2ns1__FieldType(soap, t, ((ns1__BulkArrayEntry*)a)->type))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__BulkArrayEntry *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__BulkArrayEntry, SOAP_TYPE_ns1__BulkArrayEntry, sizeof(ns1__BulkArrayEntry), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__BulkArrayEntry * SOAP_FMAC2 soap_instantiate_ns1__BulkArrayEntry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__BulkArrayEntry(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__BulkArrayEntry *p;
	size_t k = sizeof(ns1__BulkArrayEntry);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__BulkArrayEntry, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__BulkArrayEntry);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__BulkArrayEntry, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__BulkArrayEntry location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__BulkArrayEntry::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__BulkArrayEntry(soap, tag ? tag : "ns1:BulkArrayEntry", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__BulkArrayEntry::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__BulkArrayEntry(soap, this, tag, type);
}

SOAP_FMAC3 ns1__BulkArrayEntry * SOAP_FMAC4 soap_get_ns1__BulkArrayEntry(struct soap *soap, ns1__BulkArrayEntry *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__BulkArrayEntry(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__BulkArray::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__BulkArrayEntry(soap, &this->ns1__BulkArray::data);
	this->ns1__BulkArray::columns = NULL;
}

void ns1__BulkArray::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__BulkArrayEntry(soap, &this->ns1__BulkArray::data);
#endif
}

int ns1__BulkArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__BulkArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__BulkArray(struct soap *soap, const char *tag, int id, const ns1__BulkArray *a, const char *type)
{
	if (((ns1__BulkArray*)a)->columns)
	{	soap_set_attr(soap, "columns", soap_int2s(soap, *((ns1__BulkArray*)a)->columns), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__BulkArray), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__BulkArrayEntry(soap, "ns1:data", -1, &a->ns1__BulkArray::data, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__BulkArray::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__BulkArray(soap, tag, this, type);
}

SOAP_FMAC3 ns1__BulkArray * SOAP_FMAC4 soap_in_ns1__BulkArray(struct soap *soap, const char *tag, ns1__BulkArray *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__BulkArray*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__BulkArray, sizeof(ns1__BulkArray), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__BulkArray)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__BulkArray *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "columns", 5, 0);
		if (t)
		{
			if (!(((ns1__BulkArray*)a)->columns = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, ((ns1__BulkArray*)a)->columns))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__BulkArrayEntry(soap, "ns1:data", &a->ns1__BulkArray::data, "ns1:BulkArrayEntry"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__BulkArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__BulkArray, SOAP_TYPE_ns1__BulkArray, sizeof(ns1__BulkArray), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__BulkArray * SOAP_FMAC2 soap_instantiate_ns1__BulkArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__BulkArray(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__BulkArray *p;
	size_t k = sizeof(ns1__BulkArray);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__BulkArray, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__BulkArray);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__BulkArray, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__BulkArray location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__BulkArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__BulkArray(soap, tag ? tag : "ns1:BulkArray", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__BulkArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__BulkArray(soap, this, tag, type);
}

SOAP_FMAC3 ns1__BulkArray * SOAP_FMAC4 soap_get_ns1__BulkArray(struct soap *soap, ns1__BulkArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__BulkArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ActionStandardFields::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ActionStandardFields::companyId = NULL;
	this->ns1__ActionStandardFields::securityId = NULL;
	this->ns1__ActionStandardFields::actionId = NULL;
	this->ns1__ActionStandardFields::mnemonic = NULL;
	this->ns1__ActionStandardFields::flag = NULL;
	this->ns1__ActionStandardFields::companyName = NULL;
	this->ns1__ActionStandardFields::secIdType = NULL;
	this->ns1__ActionStandardFields::secId = NULL;
	this->ns1__ActionStandardFields::currency = NULL;
	this->ns1__ActionStandardFields::marketSectorDes = NULL;
	this->ns1__ActionStandardFields::bbUnique = NULL;
	this->ns1__ActionStandardFields::announceDate = NULL;
	this->ns1__ActionStandardFields::effectiveDate = NULL;
	this->ns1__ActionStandardFields::amendDate = NULL;
	this->ns1__ActionStandardFields::bbGlobal = NULL;
	this->ns1__ActionStandardFields::bbGlobalCompany = NULL;
	this->ns1__ActionStandardFields::bbSecNumDes = NULL;
	this->ns1__ActionStandardFields::feedSource = NULL;
}

void ns1__ActionStandardFields::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &this->ns1__ActionStandardFields::companyId);
	soap_serialize_PointerToint(soap, &this->ns1__ActionStandardFields::securityId);
	soap_serialize_PointerToint(soap, &this->ns1__ActionStandardFields::actionId);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ActionStandardFields::mnemonic);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ActionStandardFields::flag);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ActionStandardFields::companyName);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ActionStandardFields::secIdType);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ActionStandardFields::secId);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ActionStandardFields::currency);
	soap_serialize_PointerTons1__MarketSector(soap, &this->ns1__ActionStandardFields::marketSectorDes);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ActionStandardFields::bbUnique);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ActionStandardFields::announceDate);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ActionStandardFields::effectiveDate);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ActionStandardFields::amendDate);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ActionStandardFields::bbGlobal);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ActionStandardFields::bbGlobalCompany);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ActionStandardFields::bbSecNumDes);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ActionStandardFields::feedSource);
#endif
}

int ns1__ActionStandardFields::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ActionStandardFields(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ActionStandardFields(struct soap *soap, const char *tag, int id, const ns1__ActionStandardFields *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ActionStandardFields), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:companyId", -1, &a->ns1__ActionStandardFields::companyId, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:securityId", -1, &a->ns1__ActionStandardFields::securityId, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:actionId", -1, &a->ns1__ActionStandardFields::actionId, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:mnemonic", -1, &a->ns1__ActionStandardFields::mnemonic, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:flag", -1, &a->ns1__ActionStandardFields::flag, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:companyName", -1, &a->ns1__ActionStandardFields::companyName, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:secIdType", -1, &a->ns1__ActionStandardFields::secIdType, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:secId", -1, &a->ns1__ActionStandardFields::secId, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:currency", -1, &a->ns1__ActionStandardFields::currency, ""))
		return soap->error;
	if (soap_out_PointerTons1__MarketSector(soap, "ns1:marketSectorDes", -1, &a->ns1__ActionStandardFields::marketSectorDes, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:bbUnique", -1, &a->ns1__ActionStandardFields::bbUnique, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:announceDate", -1, &a->ns1__ActionStandardFields::announceDate, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:effectiveDate", -1, &a->ns1__ActionStandardFields::effectiveDate, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:amendDate", -1, &a->ns1__ActionStandardFields::amendDate, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:bbGlobal", -1, &a->ns1__ActionStandardFields::bbGlobal, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:bbGlobalCompany", -1, &a->ns1__ActionStandardFields::bbGlobalCompany, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:bbSecNumDes", -1, &a->ns1__ActionStandardFields::bbSecNumDes, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:feedSource", -1, &a->ns1__ActionStandardFields::feedSource, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ActionStandardFields::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ActionStandardFields(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ActionStandardFields * SOAP_FMAC4 soap_in_ns1__ActionStandardFields(struct soap *soap, const char *tag, ns1__ActionStandardFields *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ActionStandardFields*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ActionStandardFields, sizeof(ns1__ActionStandardFields), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ActionStandardFields)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ActionStandardFields *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_companyId1 = 1;
	size_t soap_flag_securityId1 = 1;
	size_t soap_flag_actionId1 = 1;
	size_t soap_flag_mnemonic1 = 1;
	size_t soap_flag_flag1 = 1;
	size_t soap_flag_companyName1 = 1;
	size_t soap_flag_secIdType1 = 1;
	size_t soap_flag_secId1 = 1;
	size_t soap_flag_currency1 = 1;
	size_t soap_flag_marketSectorDes1 = 1;
	size_t soap_flag_bbUnique1 = 1;
	size_t soap_flag_announceDate1 = 1;
	size_t soap_flag_effectiveDate1 = 1;
	size_t soap_flag_amendDate1 = 1;
	size_t soap_flag_bbGlobal1 = 1;
	size_t soap_flag_bbGlobalCompany1 = 1;
	size_t soap_flag_bbSecNumDes1 = 1;
	size_t soap_flag_feedSource1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_companyId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns1:companyId", &a->ns1__ActionStandardFields::companyId, "xsd:int"))
				{	soap_flag_companyId1--;
					continue;
				}
			}
			if (soap_flag_securityId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns1:securityId", &a->ns1__ActionStandardFields::securityId, "xsd:int"))
				{	soap_flag_securityId1--;
					continue;
				}
			}
			if (soap_flag_actionId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns1:actionId", &a->ns1__ActionStandardFields::actionId, "xsd:int"))
				{	soap_flag_actionId1--;
					continue;
				}
			}
			if (soap_flag_mnemonic1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:mnemonic", &a->ns1__ActionStandardFields::mnemonic, "xsd:string"))
				{	soap_flag_mnemonic1--;
					continue;
				}
			}
			if (soap_flag_flag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:flag", &a->ns1__ActionStandardFields::flag, "xsd:string"))
				{	soap_flag_flag1--;
					continue;
				}
			}
			if (soap_flag_companyName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:companyName", &a->ns1__ActionStandardFields::companyName, "xsd:string"))
				{	soap_flag_companyName1--;
					continue;
				}
			}
			if (soap_flag_secIdType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:secIdType", &a->ns1__ActionStandardFields::secIdType, "xsd:string"))
				{	soap_flag_secIdType1--;
					continue;
				}
			}
			if (soap_flag_secId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:secId", &a->ns1__ActionStandardFields::secId, "xsd:string"))
				{	soap_flag_secId1--;
					continue;
				}
			}
			if (soap_flag_currency1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:currency", &a->ns1__ActionStandardFields::currency, "xsd:string"))
				{	soap_flag_currency1--;
					continue;
				}
			}
			if (soap_flag_marketSectorDes1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__MarketSector(soap, "ns1:marketSectorDes", &a->ns1__ActionStandardFields::marketSectorDes, "ns1:MarketSector"))
				{	soap_flag_marketSectorDes1--;
					continue;
				}
			}
			if (soap_flag_bbUnique1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:bbUnique", &a->ns1__ActionStandardFields::bbUnique, "xsd:string"))
				{	soap_flag_bbUnique1--;
					continue;
				}
			}
			if (soap_flag_announceDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:announceDate", &a->ns1__ActionStandardFields::announceDate, "xsd:string"))
				{	soap_flag_announceDate1--;
					continue;
				}
			}
			if (soap_flag_effectiveDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:effectiveDate", &a->ns1__ActionStandardFields::effectiveDate, "xsd:string"))
				{	soap_flag_effectiveDate1--;
					continue;
				}
			}
			if (soap_flag_amendDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:amendDate", &a->ns1__ActionStandardFields::amendDate, "xsd:string"))
				{	soap_flag_amendDate1--;
					continue;
				}
			}
			if (soap_flag_bbGlobal1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:bbGlobal", &a->ns1__ActionStandardFields::bbGlobal, "xsd:string"))
				{	soap_flag_bbGlobal1--;
					continue;
				}
			}
			if (soap_flag_bbGlobalCompany1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:bbGlobalCompany", &a->ns1__ActionStandardFields::bbGlobalCompany, "xsd:string"))
				{	soap_flag_bbGlobalCompany1--;
					continue;
				}
			}
			if (soap_flag_bbSecNumDes1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:bbSecNumDes", &a->ns1__ActionStandardFields::bbSecNumDes, "xsd:string"))
				{	soap_flag_bbSecNumDes1--;
					continue;
				}
			}
			if (soap_flag_feedSource1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:feedSource", &a->ns1__ActionStandardFields::feedSource, "xsd:string"))
				{	soap_flag_feedSource1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ActionStandardFields *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ActionStandardFields, SOAP_TYPE_ns1__ActionStandardFields, sizeof(ns1__ActionStandardFields), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ActionStandardFields * SOAP_FMAC2 soap_instantiate_ns1__ActionStandardFields(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ActionStandardFields(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ActionStandardFields *p;
	size_t k = sizeof(ns1__ActionStandardFields);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ActionStandardFields, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ActionStandardFields);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ActionStandardFields, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ActionStandardFields location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ActionStandardFields::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ActionStandardFields(soap, tag ? tag : "ns1:ActionStandardFields", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ActionStandardFields::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ActionStandardFields(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ActionStandardFields * SOAP_FMAC4 soap_get_ns1__ActionStandardFields(struct soap *soap, ns1__ActionStandardFields *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ActionStandardFields(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__HistData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__HistData::value = NULL;
}

void ns1__HistData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns1__HistData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__HistData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__HistData(struct soap *soap, const char *tag, int id, const ns1__HistData *a, const char *type)
{
	if (((ns1__HistData*)a)->value)
	{	soap_set_attr(soap, "value", soap_std__string2s(soap, *((ns1__HistData*)a)->value), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__HistData), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__HistData::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__HistData(soap, tag, this, type);
}

SOAP_FMAC3 ns1__HistData * SOAP_FMAC4 soap_in_ns1__HistData(struct soap *soap, const char *tag, ns1__HistData *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__HistData*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__HistData, sizeof(ns1__HistData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__HistData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__HistData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "value", 1, 0);
		if (t)
		{
			if (!(((ns1__HistData*)a)->value = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__HistData*)a)->value))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__HistData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__HistData, SOAP_TYPE_ns1__HistData, sizeof(ns1__HistData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__HistData * SOAP_FMAC2 soap_instantiate_ns1__HistData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__HistData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__HistData *p;
	size_t k = sizeof(ns1__HistData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__HistData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__HistData);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__HistData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__HistData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__HistData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__HistData(soap, tag ? tag : "ns1:HistData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__HistData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__HistData(soap, this, tag, type);
}

SOAP_FMAC3 ns1__HistData * SOAP_FMAC4 soap_get_ns1__HistData(struct soap *soap, ns1__HistData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__HistData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__QRMQuote::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__QRMQuoteData(soap, &this->ns1__QRMQuote::matchedQuote);
	this->ns1__QRMQuote::dateTime = NULL;
	this->ns1__QRMQuote::condCode = NULL;
}

void ns1__QRMQuote::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__QRMQuoteData(soap, &this->ns1__QRMQuote::matchedQuote);
#endif
}

int ns1__QRMQuote::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__QRMQuote(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__QRMQuote(struct soap *soap, const char *tag, int id, const ns1__QRMQuote *a, const char *type)
{
	if (((ns1__QRMQuote*)a)->dateTime)
	{	soap_set_attr(soap, "dateTime", soap_dateTime2s(soap, *((ns1__QRMQuote*)a)->dateTime), 1);
	}
	if (((ns1__QRMQuote*)a)->condCode)
	{	soap_set_attr(soap, "condCode", soap_std__string2s(soap, *((ns1__QRMQuote*)a)->condCode), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__QRMQuote), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__QRMQuoteData(soap, "ns1:matchedQuote", -1, &a->ns1__QRMQuote::matchedQuote, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__QRMQuote::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__QRMQuote(soap, tag, this, type);
}

SOAP_FMAC3 ns1__QRMQuote * SOAP_FMAC4 soap_in_ns1__QRMQuote(struct soap *soap, const char *tag, ns1__QRMQuote *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__QRMQuote*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__QRMQuote, sizeof(ns1__QRMQuote), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__QRMQuote)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__QRMQuote *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "dateTime", 5, 0);
		if (t)
		{
			if (!(((ns1__QRMQuote*)a)->dateTime = (time_t *)soap_malloc(soap, sizeof(time_t))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2dateTime(soap, t, ((ns1__QRMQuote*)a)->dateTime))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "condCode", 1, 0);
		if (t)
		{
			if (!(((ns1__QRMQuote*)a)->condCode = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__QRMQuote*)a)->condCode))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__QRMQuoteData(soap, "ns1:matchedQuote", &a->ns1__QRMQuote::matchedQuote, "ns1:QRMQuoteData"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns1__QRMQuote::matchedQuote.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__QRMQuote *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__QRMQuote, SOAP_TYPE_ns1__QRMQuote, sizeof(ns1__QRMQuote), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__QRMQuote * SOAP_FMAC2 soap_instantiate_ns1__QRMQuote(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__QRMQuote(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__QRMQuote *p;
	size_t k = sizeof(ns1__QRMQuote);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__QRMQuote, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__QRMQuote);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__QRMQuote, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__QRMQuote location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__QRMQuote::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__QRMQuote(soap, tag ? tag : "ns1:QRMQuote", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__QRMQuote::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__QRMQuote(soap, this, tag, type);
}

SOAP_FMAC3 ns1__QRMQuote * SOAP_FMAC4 soap_get_ns1__QRMQuote(struct soap *soap, ns1__QRMQuote *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__QRMQuote(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__QRMQuoteData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__QRMQuoteData::type = NULL;
	this->ns1__QRMQuoteData::price = NULL;
	this->ns1__QRMQuoteData::volume = NULL;
	this->ns1__QRMQuoteData::mm = NULL;
	this->ns1__QRMQuoteData::exCode = NULL;
}

void ns1__QRMQuoteData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns1__QRMQuoteData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__QRMQuoteData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__QRMQuoteData(struct soap *soap, const char *tag, int id, const ns1__QRMQuoteData *a, const char *type)
{
	if (((ns1__QRMQuoteData*)a)->type)
	{	soap_set_attr(soap, "type", soap_std__string2s(soap, *((ns1__QRMQuoteData*)a)->type), 1);
	}
	if (((ns1__QRMQuoteData*)a)->price)
	{	soap_set_attr(soap, "price", soap_std__string2s(soap, *((ns1__QRMQuoteData*)a)->price), 1);
	}
	if (((ns1__QRMQuoteData*)a)->volume)
	{	soap_set_attr(soap, "volume", soap_std__string2s(soap, *((ns1__QRMQuoteData*)a)->volume), 1);
	}
	if (((ns1__QRMQuoteData*)a)->mm)
	{	soap_set_attr(soap, "mm", soap_std__string2s(soap, *((ns1__QRMQuoteData*)a)->mm), 1);
	}
	if (((ns1__QRMQuoteData*)a)->exCode)
	{	soap_set_attr(soap, "exCode", soap_std__string2s(soap, *((ns1__QRMQuoteData*)a)->exCode), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__QRMQuoteData), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__QRMQuoteData::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__QRMQuoteData(soap, tag, this, type);
}

SOAP_FMAC3 ns1__QRMQuoteData * SOAP_FMAC4 soap_in_ns1__QRMQuoteData(struct soap *soap, const char *tag, ns1__QRMQuoteData *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__QRMQuoteData*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__QRMQuoteData, sizeof(ns1__QRMQuoteData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__QRMQuoteData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__QRMQuoteData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "type", 1, 0);
		if (t)
		{
			if (!(((ns1__QRMQuoteData*)a)->type = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__QRMQuoteData*)a)->type))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "price", 1, 0);
		if (t)
		{
			if (!(((ns1__QRMQuoteData*)a)->price = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__QRMQuoteData*)a)->price))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "volume", 1, 0);
		if (t)
		{
			if (!(((ns1__QRMQuoteData*)a)->volume = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__QRMQuoteData*)a)->volume))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "mm", 1, 0);
		if (t)
		{
			if (!(((ns1__QRMQuoteData*)a)->mm = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__QRMQuoteData*)a)->mm))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "exCode", 1, 0);
		if (t)
		{
			if (!(((ns1__QRMQuoteData*)a)->exCode = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__QRMQuoteData*)a)->exCode))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__QRMQuoteData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__QRMQuoteData, SOAP_TYPE_ns1__QRMQuoteData, sizeof(ns1__QRMQuoteData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__QRMQuoteData * SOAP_FMAC2 soap_instantiate_ns1__QRMQuoteData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__QRMQuoteData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__QRMQuoteData *p;
	size_t k = sizeof(ns1__QRMQuoteData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__QRMQuoteData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__QRMQuoteData);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__QRMQuoteData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__QRMQuoteData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__QRMQuoteData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__QRMQuoteData(soap, tag ? tag : "ns1:QRMQuoteData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__QRMQuoteData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__QRMQuoteData(soap, this, tag, type);
}

SOAP_FMAC3 ns1__QRMQuoteData * SOAP_FMAC4 soap_get_ns1__QRMQuoteData(struct soap *soap, ns1__QRMQuoteData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__QRMQuoteData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__QRQuote::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__QRQuote::dateTime = NULL;
	this->ns1__QRQuote::price = NULL;
	this->ns1__QRQuote::volume = NULL;
	this->ns1__QRQuote::exCode = NULL;
	this->ns1__QRQuote::condCode = NULL;
}

void ns1__QRQuote::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns1__QRQuote::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__QRQuote(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__QRQuote(struct soap *soap, const char *tag, int id, const ns1__QRQuote *a, const char *type)
{
	if (((ns1__QRQuote*)a)->dateTime)
	{	soap_set_attr(soap, "dateTime", soap_dateTime2s(soap, *((ns1__QRQuote*)a)->dateTime), 1);
	}
	if (((ns1__QRQuote*)a)->price)
	{	soap_set_attr(soap, "price", soap_std__string2s(soap, *((ns1__QRQuote*)a)->price), 1);
	}
	if (((ns1__QRQuote*)a)->volume)
	{	soap_set_attr(soap, "volume", soap_std__string2s(soap, *((ns1__QRQuote*)a)->volume), 1);
	}
	if (((ns1__QRQuote*)a)->exCode)
	{	soap_set_attr(soap, "exCode", soap_std__string2s(soap, *((ns1__QRQuote*)a)->exCode), 1);
	}
	if (((ns1__QRQuote*)a)->condCode)
	{	soap_set_attr(soap, "condCode", soap_std__string2s(soap, *((ns1__QRQuote*)a)->condCode), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__QRQuote), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__QRQuote::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__QRQuote(soap, tag, this, type);
}

SOAP_FMAC3 ns1__QRQuote * SOAP_FMAC4 soap_in_ns1__QRQuote(struct soap *soap, const char *tag, ns1__QRQuote *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__QRQuote*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__QRQuote, sizeof(ns1__QRQuote), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__QRQuote)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__QRQuote *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "dateTime", 5, 0);
		if (t)
		{
			if (!(((ns1__QRQuote*)a)->dateTime = (time_t *)soap_malloc(soap, sizeof(time_t))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2dateTime(soap, t, ((ns1__QRQuote*)a)->dateTime))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "price", 1, 0);
		if (t)
		{
			if (!(((ns1__QRQuote*)a)->price = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__QRQuote*)a)->price))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "volume", 1, 0);
		if (t)
		{
			if (!(((ns1__QRQuote*)a)->volume = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__QRQuote*)a)->volume))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "exCode", 1, 0);
		if (t)
		{
			if (!(((ns1__QRQuote*)a)->exCode = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__QRQuote*)a)->exCode))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "condCode", 1, 0);
		if (t)
		{
			if (!(((ns1__QRQuote*)a)->condCode = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__QRQuote*)a)->condCode))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__QRQuote *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__QRQuote, SOAP_TYPE_ns1__QRQuote, sizeof(ns1__QRQuote), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__QRQuote * SOAP_FMAC2 soap_instantiate_ns1__QRQuote(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__QRQuote(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__QRQuote *p;
	size_t k = sizeof(ns1__QRQuote);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__QRQuote, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__QRQuote);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__QRQuote, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__QRQuote location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__QRQuote::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__QRQuote(soap, tag ? tag : "ns1:QRQuote", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__QRQuote::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__QRQuote(soap, this, tag, type);
}

SOAP_FMAC3 ns1__QRQuote * SOAP_FMAC4 soap_get_ns1__QRQuote(struct soap *soap, ns1__QRQuote *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__QRQuote(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__QRMQuotes::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__QRMQuote(soap, &this->ns1__QRMQuotes::quote);
}

void ns1__QRMQuotes::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__QRMQuote(soap, &this->ns1__QRMQuotes::quote);
#endif
}

int ns1__QRMQuotes::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__QRMQuotes(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__QRMQuotes(struct soap *soap, const char *tag, int id, const ns1__QRMQuotes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__QRMQuotes), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__QRMQuote(soap, "ns1:quote", -1, &a->ns1__QRMQuotes::quote, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__QRMQuotes::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__QRMQuotes(soap, tag, this, type);
}

SOAP_FMAC3 ns1__QRMQuotes * SOAP_FMAC4 soap_in_ns1__QRMQuotes(struct soap *soap, const char *tag, ns1__QRMQuotes *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__QRMQuotes*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__QRMQuotes, sizeof(ns1__QRMQuotes), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__QRMQuotes)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__QRMQuotes *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__QRMQuote(soap, "ns1:quote", &a->ns1__QRMQuotes::quote, "ns1:QRMQuote"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__QRMQuotes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__QRMQuotes, SOAP_TYPE_ns1__QRMQuotes, sizeof(ns1__QRMQuotes), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__QRMQuotes * SOAP_FMAC2 soap_instantiate_ns1__QRMQuotes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__QRMQuotes(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__QRMQuotes *p;
	size_t k = sizeof(ns1__QRMQuotes);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__QRMQuotes, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__QRMQuotes);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__QRMQuotes, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__QRMQuotes location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__QRMQuotes::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__QRMQuotes(soap, tag ? tag : "ns1:QRMQuotes", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__QRMQuotes::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__QRMQuotes(soap, this, tag, type);
}

SOAP_FMAC3 ns1__QRMQuotes * SOAP_FMAC4 soap_get_ns1__QRMQuotes(struct soap *soap, ns1__QRMQuotes *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__QRMQuotes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__QRQuotes::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__QRQuote(soap, &this->ns1__QRQuotes::quote);
}

void ns1__QRQuotes::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__QRQuote(soap, &this->ns1__QRQuotes::quote);
#endif
}

int ns1__QRQuotes::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__QRQuotes(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__QRQuotes(struct soap *soap, const char *tag, int id, const ns1__QRQuotes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__QRQuotes), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__QRQuote(soap, "ns1:quote", -1, &a->ns1__QRQuotes::quote, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__QRQuotes::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__QRQuotes(soap, tag, this, type);
}

SOAP_FMAC3 ns1__QRQuotes * SOAP_FMAC4 soap_in_ns1__QRQuotes(struct soap *soap, const char *tag, ns1__QRQuotes *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__QRQuotes*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__QRQuotes, sizeof(ns1__QRQuotes), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__QRQuotes)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__QRQuotes *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__QRQuote(soap, "ns1:quote", &a->ns1__QRQuotes::quote, "ns1:QRQuote"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__QRQuotes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__QRQuotes, SOAP_TYPE_ns1__QRQuotes, sizeof(ns1__QRQuotes), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__QRQuotes * SOAP_FMAC2 soap_instantiate_ns1__QRQuotes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__QRQuotes(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__QRQuotes *p;
	size_t k = sizeof(ns1__QRQuotes);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__QRQuotes, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__QRQuotes);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__QRQuotes, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__QRQuotes location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__QRQuotes::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__QRQuotes(soap, tag ? tag : "ns1:QRQuotes", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__QRQuotes::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__QRQuotes(soap, this, tag, type);
}

SOAP_FMAC3 ns1__QRQuotes * SOAP_FMAC4 soap_get_ns1__QRQuotes(struct soap *soap, ns1__QRQuotes *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__QRQuotes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__Data::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__BulkArray(soap, &this->ns1__Data::bulkarray);
	this->ns1__Data::field = NULL;
	this->ns1__Data::value = NULL;
	this->ns1__Data::isArray = NULL;
	this->ns1__Data::rows = NULL;
}

void ns1__Data::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__BulkArray(soap, &this->ns1__Data::bulkarray);
#endif
}

int ns1__Data::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Data(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Data(struct soap *soap, const char *tag, int id, const ns1__Data *a, const char *type)
{
	if (((ns1__Data*)a)->field)
	{	soap_set_attr(soap, "field", soap_std__string2s(soap, *((ns1__Data*)a)->field), 1);
	}
	if (((ns1__Data*)a)->value)
	{	soap_set_attr(soap, "value", soap_std__string2s(soap, *((ns1__Data*)a)->value), 1);
	}
	if (((ns1__Data*)a)->isArray)
	{	soap_set_attr(soap, "isArray", soap_bool2s(soap, *((ns1__Data*)a)->isArray), 1);
	}
	if (((ns1__Data*)a)->rows)
	{	soap_set_attr(soap, "rows", soap_int2s(soap, *((ns1__Data*)a)->rows), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Data), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__BulkArray(soap, "ns1:bulkarray", -1, &a->ns1__Data::bulkarray, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__Data::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__Data(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Data * SOAP_FMAC4 soap_in_ns1__Data(struct soap *soap, const char *tag, ns1__Data *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Data*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Data, sizeof(ns1__Data), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__Data)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__Data *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "field", 1, 0);
		if (t)
		{
			if (!(((ns1__Data*)a)->field = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__Data*)a)->field))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "value", 1, 0);
		if (t)
		{
			if (!(((ns1__Data*)a)->value = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__Data*)a)->value))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "isArray", 5, 0);
		if (t)
		{
			if (!(((ns1__Data*)a)->isArray = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((ns1__Data*)a)->isArray))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "rows", 5, 0);
		if (t)
		{
			if (!(((ns1__Data*)a)->rows = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, ((ns1__Data*)a)->rows))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__BulkArray(soap, "ns1:bulkarray", &a->ns1__Data::bulkarray, "ns1:BulkArray"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Data *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Data, SOAP_TYPE_ns1__Data, sizeof(ns1__Data), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__Data * SOAP_FMAC2 soap_instantiate_ns1__Data(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Data(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__Data *p;
	size_t k = sizeof(ns1__Data);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__Data, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__Data);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__Data, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__Data location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__Data::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__Data(soap, tag ? tag : "ns1:Data", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Data::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Data(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Data * SOAP_FMAC4 soap_get_ns1__Data(struct soap *soap, ns1__Data *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Data(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__CorrectionRecord::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__CorrectionRecord::instrument = NULL;
	soap_default_std__string(soap, &this->ns1__CorrectionRecord::field);
	soap_default_std__string(soap, &this->ns1__CorrectionRecord::oldValue);
	soap_default_std__string(soap, &this->ns1__CorrectionRecord::oldDateEntered);
	soap_default_std__string(soap, &this->ns1__CorrectionRecord::newValue);
	soap_default_std__string(soap, &this->ns1__CorrectionRecord::newDateEntered);
	soap_default_std__string(soap, &this->ns1__CorrectionRecord::timeEntered);
	soap_default_std__string(soap, &this->ns1__CorrectionRecord::exchangeIndicator);
}

void ns1__CorrectionRecord::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__Instrument(soap, &this->ns1__CorrectionRecord::instrument);
	soap_embedded(soap, &this->ns1__CorrectionRecord::field, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__CorrectionRecord::field);
	soap_embedded(soap, &this->ns1__CorrectionRecord::oldValue, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__CorrectionRecord::oldValue);
	soap_embedded(soap, &this->ns1__CorrectionRecord::oldDateEntered, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__CorrectionRecord::oldDateEntered);
	soap_embedded(soap, &this->ns1__CorrectionRecord::newValue, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__CorrectionRecord::newValue);
	soap_embedded(soap, &this->ns1__CorrectionRecord::newDateEntered, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__CorrectionRecord::newDateEntered);
	soap_embedded(soap, &this->ns1__CorrectionRecord::timeEntered, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__CorrectionRecord::timeEntered);
	soap_embedded(soap, &this->ns1__CorrectionRecord::exchangeIndicator, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__CorrectionRecord::exchangeIndicator);
#endif
}

int ns1__CorrectionRecord::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CorrectionRecord(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CorrectionRecord(struct soap *soap, const char *tag, int id, const ns1__CorrectionRecord *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CorrectionRecord), type))
		return soap->error;
	if (!a->ns1__CorrectionRecord::instrument)
	{	if (soap_element_empty(soap, "ns1:instrument", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__Instrument(soap, "ns1:instrument", -1, &a->ns1__CorrectionRecord::instrument, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:field", -1, &a->ns1__CorrectionRecord::field, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:oldValue", -1, &a->ns1__CorrectionRecord::oldValue, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:oldDateEntered", -1, &a->ns1__CorrectionRecord::oldDateEntered, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:newValue", -1, &a->ns1__CorrectionRecord::newValue, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:newDateEntered", -1, &a->ns1__CorrectionRecord::newDateEntered, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:timeEntered", -1, &a->ns1__CorrectionRecord::timeEntered, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:exchangeIndicator", -1, &a->ns1__CorrectionRecord::exchangeIndicator, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CorrectionRecord::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__CorrectionRecord(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CorrectionRecord * SOAP_FMAC4 soap_in_ns1__CorrectionRecord(struct soap *soap, const char *tag, ns1__CorrectionRecord *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CorrectionRecord*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CorrectionRecord, sizeof(ns1__CorrectionRecord), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__CorrectionRecord)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__CorrectionRecord *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_instrument1 = 1;
	size_t soap_flag_field1 = 1;
	size_t soap_flag_oldValue1 = 1;
	size_t soap_flag_oldDateEntered1 = 1;
	size_t soap_flag_newValue1 = 1;
	size_t soap_flag_newDateEntered1 = 1;
	size_t soap_flag_timeEntered1 = 1;
	size_t soap_flag_exchangeIndicator1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_instrument1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Instrument(soap, "ns1:instrument", &a->ns1__CorrectionRecord::instrument, "ns1:Instrument"))
				{	soap_flag_instrument1--;
					continue;
				}
			}
			if (soap_flag_field1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:field", &a->ns1__CorrectionRecord::field, "xsd:string"))
				{	soap_flag_field1--;
					continue;
				}
			}
			if (soap_flag_oldValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:oldValue", &a->ns1__CorrectionRecord::oldValue, "xsd:string"))
				{	soap_flag_oldValue1--;
					continue;
				}
			}
			if (soap_flag_oldDateEntered1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:oldDateEntered", &a->ns1__CorrectionRecord::oldDateEntered, "xsd:string"))
				{	soap_flag_oldDateEntered1--;
					continue;
				}
			}
			if (soap_flag_newValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:newValue", &a->ns1__CorrectionRecord::newValue, "xsd:string"))
				{	soap_flag_newValue1--;
					continue;
				}
			}
			if (soap_flag_newDateEntered1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:newDateEntered", &a->ns1__CorrectionRecord::newDateEntered, "xsd:string"))
				{	soap_flag_newDateEntered1--;
					continue;
				}
			}
			if (soap_flag_timeEntered1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:timeEntered", &a->ns1__CorrectionRecord::timeEntered, "xsd:string"))
				{	soap_flag_timeEntered1--;
					continue;
				}
			}
			if (soap_flag_exchangeIndicator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:exchangeIndicator", &a->ns1__CorrectionRecord::exchangeIndicator, "xsd:string"))
				{	soap_flag_exchangeIndicator1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__CorrectionRecord::instrument || soap_flag_field1 > 0 || soap_flag_oldValue1 > 0 || soap_flag_oldDateEntered1 > 0 || soap_flag_newValue1 > 0 || soap_flag_newDateEntered1 > 0 || soap_flag_timeEntered1 > 0 || soap_flag_exchangeIndicator1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__CorrectionRecord *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CorrectionRecord, SOAP_TYPE_ns1__CorrectionRecord, sizeof(ns1__CorrectionRecord), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__CorrectionRecord * SOAP_FMAC2 soap_instantiate_ns1__CorrectionRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CorrectionRecord(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__CorrectionRecord *p;
	size_t k = sizeof(ns1__CorrectionRecord);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__CorrectionRecord, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__CorrectionRecord);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__CorrectionRecord, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__CorrectionRecord location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__CorrectionRecord::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__CorrectionRecord(soap, tag ? tag : "ns1:CorrectionRecord", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CorrectionRecord::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CorrectionRecord(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CorrectionRecord * SOAP_FMAC4 soap_get_ns1__CorrectionRecord(struct soap *soap, ns1__CorrectionRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CorrectionRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ActionsInstrumentData::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__ActionsInstrumentData::code);
	this->ns1__ActionsInstrumentData::instrument = NULL;
	this->ns1__ActionsInstrumentData::macro = NULL;
	this->ns1__ActionsInstrumentData::standardFields = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__Data(soap, &this->ns1__ActionsInstrumentData::data);
}

void ns1__ActionsInstrumentData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__ActionsInstrumentData::code, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ActionsInstrumentData::code);
	soap_serialize_PointerTons1__Instrument(soap, &this->ns1__ActionsInstrumentData::instrument);
	soap_serialize_PointerTons1__Macro(soap, &this->ns1__ActionsInstrumentData::macro);
	soap_serialize_PointerTons1__ActionStandardFields(soap, &this->ns1__ActionsInstrumentData::standardFields);
	soap_serialize_std__vectorTemplateOfPointerTons1__Data(soap, &this->ns1__ActionsInstrumentData::data);
#endif
}

int ns1__ActionsInstrumentData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ActionsInstrumentData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ActionsInstrumentData(struct soap *soap, const char *tag, int id, const ns1__ActionsInstrumentData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ActionsInstrumentData), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:code", -1, &a->ns1__ActionsInstrumentData::code, ""))
		return soap->error;
	if (soap_out_PointerTons1__Instrument(soap, "ns1:instrument", -1, &a->ns1__ActionsInstrumentData::instrument, ""))
		return soap->error;
	if (soap_out_PointerTons1__Macro(soap, "ns1:macro", -1, &a->ns1__ActionsInstrumentData::macro, ""))
		return soap->error;
	if (soap_out_PointerTons1__ActionStandardFields(soap, "ns1:standardFields", -1, &a->ns1__ActionsInstrumentData::standardFields, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__Data(soap, "ns1:data", -1, &a->ns1__ActionsInstrumentData::data, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ActionsInstrumentData::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ActionsInstrumentData(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ActionsInstrumentData * SOAP_FMAC4 soap_in_ns1__ActionsInstrumentData(struct soap *soap, const char *tag, ns1__ActionsInstrumentData *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ActionsInstrumentData*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ActionsInstrumentData, sizeof(ns1__ActionsInstrumentData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ActionsInstrumentData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ActionsInstrumentData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_code1 = 1;
	size_t soap_flag_instrument1 = 1;
	size_t soap_flag_macro1 = 1;
	size_t soap_flag_standardFields1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:code", &a->ns1__ActionsInstrumentData::code, "xsd:string"))
				{	soap_flag_code1--;
					continue;
				}
			}
			if (soap_flag_instrument1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Instrument(soap, "ns1:instrument", &a->ns1__ActionsInstrumentData::instrument, "ns1:Instrument"))
				{	soap_flag_instrument1--;
					continue;
				}
			}
			if (soap_flag_macro1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Macro(soap, "ns1:macro", &a->ns1__ActionsInstrumentData::macro, "ns1:Macro"))
				{	soap_flag_macro1--;
					continue;
				}
			}
			if (soap_flag_standardFields1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ActionStandardFields(soap, "ns1:standardFields", &a->ns1__ActionsInstrumentData::standardFields, "ns1:ActionStandardFields"))
				{	soap_flag_standardFields1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__Data(soap, "ns1:data", &a->ns1__ActionsInstrumentData::data, "ns1:Data"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_code1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__ActionsInstrumentData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ActionsInstrumentData, SOAP_TYPE_ns1__ActionsInstrumentData, sizeof(ns1__ActionsInstrumentData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ActionsInstrumentData * SOAP_FMAC2 soap_instantiate_ns1__ActionsInstrumentData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ActionsInstrumentData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ActionsInstrumentData *p;
	size_t k = sizeof(ns1__ActionsInstrumentData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ActionsInstrumentData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ActionsInstrumentData);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ActionsInstrumentData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ActionsInstrumentData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ActionsInstrumentData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ActionsInstrumentData(soap, tag ? tag : "ns1:ActionsInstrumentData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ActionsInstrumentData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ActionsInstrumentData(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ActionsInstrumentData * SOAP_FMAC4 soap_get_ns1__ActionsInstrumentData(struct soap *soap, ns1__ActionsInstrumentData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ActionsInstrumentData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__AllQuotesInstrumentData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__AllQuotesInstrumentData::instrument = NULL;
	this->ns1__AllQuotesInstrumentData::macro = NULL;
	this->ns1__AllQuotesInstrumentData::pcs = NULL;
	this->ns1__AllQuotesInstrumentData::quotes = NULL;
	soap_default_std__string(soap, &this->ns1__AllQuotesInstrumentData::code);
}

void ns1__AllQuotesInstrumentData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__Instrument(soap, &this->ns1__AllQuotesInstrumentData::instrument);
	soap_serialize_PointerTons1__Macro(soap, &this->ns1__AllQuotesInstrumentData::macro);
	soap_serialize_PointerTostd__string(soap, &this->ns1__AllQuotesInstrumentData::pcs);
	soap_serialize_PointerTons1__QRMQuotes(soap, &this->ns1__AllQuotesInstrumentData::quotes);
	soap_embedded(soap, &this->ns1__AllQuotesInstrumentData::code, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__AllQuotesInstrumentData::code);
#endif
}

int ns1__AllQuotesInstrumentData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AllQuotesInstrumentData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AllQuotesInstrumentData(struct soap *soap, const char *tag, int id, const ns1__AllQuotesInstrumentData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AllQuotesInstrumentData), type))
		return soap->error;
	if (soap_out_PointerTons1__Instrument(soap, "ns1:instrument", -1, &a->ns1__AllQuotesInstrumentData::instrument, ""))
		return soap->error;
	if (soap_out_PointerTons1__Macro(soap, "ns1:macro", -1, &a->ns1__AllQuotesInstrumentData::macro, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:pcs", -1, &a->ns1__AllQuotesInstrumentData::pcs, ""))
		return soap->error;
	if (soap_out_PointerTons1__QRMQuotes(soap, "ns1:quotes", -1, &a->ns1__AllQuotesInstrumentData::quotes, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:code", -1, &a->ns1__AllQuotesInstrumentData::code, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__AllQuotesInstrumentData::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__AllQuotesInstrumentData(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AllQuotesInstrumentData * SOAP_FMAC4 soap_in_ns1__AllQuotesInstrumentData(struct soap *soap, const char *tag, ns1__AllQuotesInstrumentData *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__AllQuotesInstrumentData*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AllQuotesInstrumentData, sizeof(ns1__AllQuotesInstrumentData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__AllQuotesInstrumentData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__AllQuotesInstrumentData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_instrument1 = 1;
	size_t soap_flag_macro1 = 1;
	size_t soap_flag_pcs1 = 1;
	size_t soap_flag_quotes1 = 1;
	size_t soap_flag_code1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_instrument1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Instrument(soap, "ns1:instrument", &a->ns1__AllQuotesInstrumentData::instrument, "ns1:Instrument"))
				{	soap_flag_instrument1--;
					continue;
				}
			}
			if (soap_flag_macro1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Macro(soap, "ns1:macro", &a->ns1__AllQuotesInstrumentData::macro, "ns1:Macro"))
				{	soap_flag_macro1--;
					continue;
				}
			}
			if (soap_flag_pcs1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:pcs", &a->ns1__AllQuotesInstrumentData::pcs, "xsd:string"))
				{	soap_flag_pcs1--;
					continue;
				}
			}
			if (soap_flag_quotes1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__QRMQuotes(soap, "ns1:quotes", &a->ns1__AllQuotesInstrumentData::quotes, "ns1:QRMQuotes"))
				{	soap_flag_quotes1--;
					continue;
				}
			}
			if (soap_flag_code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:code", &a->ns1__AllQuotesInstrumentData::code, "xsd:string"))
				{	soap_flag_code1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_code1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__AllQuotesInstrumentData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AllQuotesInstrumentData, SOAP_TYPE_ns1__AllQuotesInstrumentData, sizeof(ns1__AllQuotesInstrumentData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__AllQuotesInstrumentData * SOAP_FMAC2 soap_instantiate_ns1__AllQuotesInstrumentData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AllQuotesInstrumentData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__AllQuotesInstrumentData *p;
	size_t k = sizeof(ns1__AllQuotesInstrumentData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__AllQuotesInstrumentData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__AllQuotesInstrumentData);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__AllQuotesInstrumentData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__AllQuotesInstrumentData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__AllQuotesInstrumentData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__AllQuotesInstrumentData(soap, tag ? tag : "ns1:AllQuotesInstrumentData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__AllQuotesInstrumentData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AllQuotesInstrumentData(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AllQuotesInstrumentData * SOAP_FMAC4 soap_get_ns1__AllQuotesInstrumentData(struct soap *soap, ns1__AllQuotesInstrumentData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AllQuotesInstrumentData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__QuotesInstrumentData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__QuotesInstrumentData::instrument = NULL;
	this->ns1__QuotesInstrumentData::macro = NULL;
	this->ns1__QuotesInstrumentData::pcs = NULL;
	this->ns1__QuotesInstrumentData::quotes = NULL;
	soap_default_std__string(soap, &this->ns1__QuotesInstrumentData::code);
}

void ns1__QuotesInstrumentData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__Instrument(soap, &this->ns1__QuotesInstrumentData::instrument);
	soap_serialize_PointerTons1__Macro(soap, &this->ns1__QuotesInstrumentData::macro);
	soap_serialize_PointerTostd__string(soap, &this->ns1__QuotesInstrumentData::pcs);
	soap_serialize_PointerTons1__QRQuotes(soap, &this->ns1__QuotesInstrumentData::quotes);
	soap_embedded(soap, &this->ns1__QuotesInstrumentData::code, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__QuotesInstrumentData::code);
#endif
}

int ns1__QuotesInstrumentData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__QuotesInstrumentData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__QuotesInstrumentData(struct soap *soap, const char *tag, int id, const ns1__QuotesInstrumentData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__QuotesInstrumentData), type))
		return soap->error;
	if (soap_out_PointerTons1__Instrument(soap, "ns1:instrument", -1, &a->ns1__QuotesInstrumentData::instrument, ""))
		return soap->error;
	if (soap_out_PointerTons1__Macro(soap, "ns1:macro", -1, &a->ns1__QuotesInstrumentData::macro, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:pcs", -1, &a->ns1__QuotesInstrumentData::pcs, ""))
		return soap->error;
	if (soap_out_PointerTons1__QRQuotes(soap, "ns1:quotes", -1, &a->ns1__QuotesInstrumentData::quotes, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:code", -1, &a->ns1__QuotesInstrumentData::code, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__QuotesInstrumentData::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__QuotesInstrumentData(soap, tag, this, type);
}

SOAP_FMAC3 ns1__QuotesInstrumentData * SOAP_FMAC4 soap_in_ns1__QuotesInstrumentData(struct soap *soap, const char *tag, ns1__QuotesInstrumentData *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__QuotesInstrumentData*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__QuotesInstrumentData, sizeof(ns1__QuotesInstrumentData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__QuotesInstrumentData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__QuotesInstrumentData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_instrument1 = 1;
	size_t soap_flag_macro1 = 1;
	size_t soap_flag_pcs1 = 1;
	size_t soap_flag_quotes1 = 1;
	size_t soap_flag_code1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_instrument1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Instrument(soap, "ns1:instrument", &a->ns1__QuotesInstrumentData::instrument, "ns1:Instrument"))
				{	soap_flag_instrument1--;
					continue;
				}
			}
			if (soap_flag_macro1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Macro(soap, "ns1:macro", &a->ns1__QuotesInstrumentData::macro, "ns1:Macro"))
				{	soap_flag_macro1--;
					continue;
				}
			}
			if (soap_flag_pcs1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:pcs", &a->ns1__QuotesInstrumentData::pcs, "xsd:string"))
				{	soap_flag_pcs1--;
					continue;
				}
			}
			if (soap_flag_quotes1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__QRQuotes(soap, "ns1:quotes", &a->ns1__QuotesInstrumentData::quotes, "ns1:QRQuotes"))
				{	soap_flag_quotes1--;
					continue;
				}
			}
			if (soap_flag_code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:code", &a->ns1__QuotesInstrumentData::code, "xsd:string"))
				{	soap_flag_code1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_code1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__QuotesInstrumentData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__QuotesInstrumentData, SOAP_TYPE_ns1__QuotesInstrumentData, sizeof(ns1__QuotesInstrumentData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__QuotesInstrumentData * SOAP_FMAC2 soap_instantiate_ns1__QuotesInstrumentData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__QuotesInstrumentData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__QuotesInstrumentData *p;
	size_t k = sizeof(ns1__QuotesInstrumentData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__QuotesInstrumentData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__QuotesInstrumentData);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__QuotesInstrumentData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__QuotesInstrumentData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__QuotesInstrumentData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__QuotesInstrumentData(soap, tag ? tag : "ns1:QuotesInstrumentData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__QuotesInstrumentData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__QuotesInstrumentData(soap, this, tag, type);
}

SOAP_FMAC3 ns1__QuotesInstrumentData * SOAP_FMAC4 soap_get_ns1__QuotesInstrumentData(struct soap *soap, ns1__QuotesInstrumentData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__QuotesInstrumentData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__FundInstrumentData::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__FundInstrumentData::code);
	this->ns1__FundInstrumentData::instrument = NULL;
	this->ns1__FundInstrumentData::macro = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__Data(soap, &this->ns1__FundInstrumentData::data);
}

void ns1__FundInstrumentData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__FundInstrumentData::code, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__FundInstrumentData::code);
	soap_serialize_PointerTons1__FundInstrument(soap, &this->ns1__FundInstrumentData::instrument);
	soap_serialize_PointerTons1__Macro(soap, &this->ns1__FundInstrumentData::macro);
	soap_serialize_std__vectorTemplateOfPointerTons1__Data(soap, &this->ns1__FundInstrumentData::data);
#endif
}

int ns1__FundInstrumentData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__FundInstrumentData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__FundInstrumentData(struct soap *soap, const char *tag, int id, const ns1__FundInstrumentData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__FundInstrumentData), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:code", -1, &a->ns1__FundInstrumentData::code, ""))
		return soap->error;
	if (soap_out_PointerTons1__FundInstrument(soap, "ns1:instrument", -1, &a->ns1__FundInstrumentData::instrument, ""))
		return soap->error;
	if (soap_out_PointerTons1__Macro(soap, "ns1:macro", -1, &a->ns1__FundInstrumentData::macro, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__Data(soap, "ns1:data", -1, &a->ns1__FundInstrumentData::data, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__FundInstrumentData::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__FundInstrumentData(soap, tag, this, type);
}

SOAP_FMAC3 ns1__FundInstrumentData * SOAP_FMAC4 soap_in_ns1__FundInstrumentData(struct soap *soap, const char *tag, ns1__FundInstrumentData *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__FundInstrumentData*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FundInstrumentData, sizeof(ns1__FundInstrumentData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__FundInstrumentData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__FundInstrumentData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_code1 = 1;
	size_t soap_flag_instrument1 = 1;
	size_t soap_flag_macro1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:code", &a->ns1__FundInstrumentData::code, "xsd:string"))
				{	soap_flag_code1--;
					continue;
				}
			}
			if (soap_flag_instrument1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__FundInstrument(soap, "ns1:instrument", &a->ns1__FundInstrumentData::instrument, "ns1:FundInstrument"))
				{	soap_flag_instrument1--;
					continue;
				}
			}
			if (soap_flag_macro1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Macro(soap, "ns1:macro", &a->ns1__FundInstrumentData::macro, "ns1:Macro"))
				{	soap_flag_macro1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__Data(soap, "ns1:data", &a->ns1__FundInstrumentData::data, "ns1:Data"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_code1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__FundInstrumentData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__FundInstrumentData, SOAP_TYPE_ns1__FundInstrumentData, sizeof(ns1__FundInstrumentData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__FundInstrumentData * SOAP_FMAC2 soap_instantiate_ns1__FundInstrumentData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__FundInstrumentData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__FundInstrumentData *p;
	size_t k = sizeof(ns1__FundInstrumentData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__FundInstrumentData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__FundInstrumentData);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__FundInstrumentData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__FundInstrumentData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__FundInstrumentData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__FundInstrumentData(soap, tag ? tag : "ns1:FundInstrumentData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__FundInstrumentData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__FundInstrumentData(soap, this, tag, type);
}

SOAP_FMAC3 ns1__FundInstrumentData * SOAP_FMAC4 soap_get_ns1__FundInstrumentData(struct soap *soap, ns1__FundInstrumentData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__FundInstrumentData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__HistInstrumentData::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__HistInstrumentData::code);
	this->ns1__HistInstrumentData::instrument = NULL;
	this->ns1__HistInstrumentData::macro = NULL;
	this->ns1__HistInstrumentData::pricingSource = NULL;
	this->ns1__HistInstrumentData::date = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__HistData(soap, &this->ns1__HistInstrumentData::data);
}

void ns1__HistInstrumentData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__HistInstrumentData::code, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__HistInstrumentData::code);
	soap_serialize_PointerTons1__Instrument(soap, &this->ns1__HistInstrumentData::instrument);
	soap_serialize_PointerTons1__Macro(soap, &this->ns1__HistInstrumentData::macro);
	soap_serialize_PointerTostd__string(soap, &this->ns1__HistInstrumentData::pricingSource);
	soap_serialize_PointerToxsd__date(soap, &this->ns1__HistInstrumentData::date);
	soap_serialize_std__vectorTemplateOfPointerTons1__HistData(soap, &this->ns1__HistInstrumentData::data);
#endif
}

int ns1__HistInstrumentData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__HistInstrumentData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__HistInstrumentData(struct soap *soap, const char *tag, int id, const ns1__HistInstrumentData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__HistInstrumentData), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:code", -1, &a->ns1__HistInstrumentData::code, ""))
		return soap->error;
	if (soap_out_PointerTons1__Instrument(soap, "ns1:instrument", -1, &a->ns1__HistInstrumentData::instrument, ""))
		return soap->error;
	if (soap_out_PointerTons1__Macro(soap, "ns1:macro", -1, &a->ns1__HistInstrumentData::macro, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:pricingSource", -1, &a->ns1__HistInstrumentData::pricingSource, ""))
		return soap->error;
	if (soap_out_PointerToxsd__date(soap, "ns1:date", -1, &a->ns1__HistInstrumentData::date, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__HistData(soap, "ns1:data", -1, &a->ns1__HistInstrumentData::data, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__HistInstrumentData::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__HistInstrumentData(soap, tag, this, type);
}

SOAP_FMAC3 ns1__HistInstrumentData * SOAP_FMAC4 soap_in_ns1__HistInstrumentData(struct soap *soap, const char *tag, ns1__HistInstrumentData *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__HistInstrumentData*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__HistInstrumentData, sizeof(ns1__HistInstrumentData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__HistInstrumentData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__HistInstrumentData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_code1 = 1;
	size_t soap_flag_instrument1 = 1;
	size_t soap_flag_macro1 = 1;
	size_t soap_flag_pricingSource1 = 1;
	size_t soap_flag_date1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:code", &a->ns1__HistInstrumentData::code, "xsd:string"))
				{	soap_flag_code1--;
					continue;
				}
			}
			if (soap_flag_instrument1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Instrument(soap, "ns1:instrument", &a->ns1__HistInstrumentData::instrument, "ns1:Instrument"))
				{	soap_flag_instrument1--;
					continue;
				}
			}
			if (soap_flag_macro1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Macro(soap, "ns1:macro", &a->ns1__HistInstrumentData::macro, "ns1:Macro"))
				{	soap_flag_macro1--;
					continue;
				}
			}
			if (soap_flag_pricingSource1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:pricingSource", &a->ns1__HistInstrumentData::pricingSource, "xsd:string"))
				{	soap_flag_pricingSource1--;
					continue;
				}
			}
			if (soap_flag_date1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__date(soap, "ns1:date", &a->ns1__HistInstrumentData::date, "xsd:date"))
				{	soap_flag_date1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__HistData(soap, "ns1:data", &a->ns1__HistInstrumentData::data, "ns1:HistData"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_code1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__HistInstrumentData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__HistInstrumentData, SOAP_TYPE_ns1__HistInstrumentData, sizeof(ns1__HistInstrumentData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__HistInstrumentData * SOAP_FMAC2 soap_instantiate_ns1__HistInstrumentData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__HistInstrumentData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__HistInstrumentData *p;
	size_t k = sizeof(ns1__HistInstrumentData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__HistInstrumentData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__HistInstrumentData);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__HistInstrumentData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__HistInstrumentData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__HistInstrumentData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__HistInstrumentData(soap, tag ? tag : "ns1:HistInstrumentData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__HistInstrumentData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__HistInstrumentData(soap, this, tag, type);
}

SOAP_FMAC3 ns1__HistInstrumentData * SOAP_FMAC4 soap_get_ns1__HistInstrumentData(struct soap *soap, ns1__HistInstrumentData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__HistInstrumentData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__InstrumentData::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__InstrumentData::code);
	this->ns1__InstrumentData::instrument = NULL;
	this->ns1__InstrumentData::macro = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__Data(soap, &this->ns1__InstrumentData::data);
}

void ns1__InstrumentData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__InstrumentData::code, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__InstrumentData::code);
	soap_serialize_PointerTons1__Instrument(soap, &this->ns1__InstrumentData::instrument);
	soap_serialize_PointerTons1__Macro(soap, &this->ns1__InstrumentData::macro);
	soap_serialize_std__vectorTemplateOfPointerTons1__Data(soap, &this->ns1__InstrumentData::data);
#endif
}

int ns1__InstrumentData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__InstrumentData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__InstrumentData(struct soap *soap, const char *tag, int id, const ns1__InstrumentData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__InstrumentData), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:code", -1, &a->ns1__InstrumentData::code, ""))
		return soap->error;
	if (soap_out_PointerTons1__Instrument(soap, "ns1:instrument", -1, &a->ns1__InstrumentData::instrument, ""))
		return soap->error;
	if (soap_out_PointerTons1__Macro(soap, "ns1:macro", -1, &a->ns1__InstrumentData::macro, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__Data(soap, "ns1:data", -1, &a->ns1__InstrumentData::data, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__InstrumentData::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__InstrumentData(soap, tag, this, type);
}

SOAP_FMAC3 ns1__InstrumentData * SOAP_FMAC4 soap_in_ns1__InstrumentData(struct soap *soap, const char *tag, ns1__InstrumentData *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__InstrumentData*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__InstrumentData, sizeof(ns1__InstrumentData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__InstrumentData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__InstrumentData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_code1 = 1;
	size_t soap_flag_instrument1 = 1;
	size_t soap_flag_macro1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:code", &a->ns1__InstrumentData::code, "xsd:string"))
				{	soap_flag_code1--;
					continue;
				}
			}
			if (soap_flag_instrument1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Instrument(soap, "ns1:instrument", &a->ns1__InstrumentData::instrument, "ns1:Instrument"))
				{	soap_flag_instrument1--;
					continue;
				}
			}
			if (soap_flag_macro1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Macro(soap, "ns1:macro", &a->ns1__InstrumentData::macro, "ns1:Macro"))
				{	soap_flag_macro1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__Data(soap, "ns1:data", &a->ns1__InstrumentData::data, "ns1:Data"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_code1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__InstrumentData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__InstrumentData, SOAP_TYPE_ns1__InstrumentData, sizeof(ns1__InstrumentData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__InstrumentData * SOAP_FMAC2 soap_instantiate_ns1__InstrumentData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__InstrumentData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__InstrumentData *p;
	size_t k = sizeof(ns1__InstrumentData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__InstrumentData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__InstrumentData);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__InstrumentData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__InstrumentData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__InstrumentData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__InstrumentData(soap, tag ? tag : "ns1:InstrumentData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__InstrumentData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__InstrumentData(soap, this, tag, type);
}

SOAP_FMAC3 ns1__InstrumentData * SOAP_FMAC4 soap_get_ns1__InstrumentData(struct soap *soap, ns1__InstrumentData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__InstrumentData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__DataItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__DataItem::value);
}

void ns1__DataItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__DataItem::value, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__DataItem::value);
#endif
}

int ns1__DataItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__DataItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DataItem(struct soap *soap, const char *tag, int id, const ns1__DataItem *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DataItem), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:value", -1, &a->ns1__DataItem::value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__DataItem::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__DataItem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__DataItem * SOAP_FMAC4 soap_in_ns1__DataItem(struct soap *soap, const char *tag, ns1__DataItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__DataItem*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DataItem, sizeof(ns1__DataItem), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__DataItem)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__DataItem *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_value1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:value", &a->ns1__DataItem::value, "xsd:string"))
				{	soap_flag_value1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_value1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__DataItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DataItem, SOAP_TYPE_ns1__DataItem, sizeof(ns1__DataItem), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__DataItem * SOAP_FMAC2 soap_instantiate_ns1__DataItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DataItem(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__DataItem *p;
	size_t k = sizeof(ns1__DataItem);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__DataItem, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__DataItem);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__DataItem, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__DataItem location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__DataItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__DataItem(soap, tag ? tag : "ns1:DataItem", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__DataItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__DataItem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__DataItem * SOAP_FMAC4 soap_get_ns1__DataItem(struct soap *soap, ns1__DataItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DataItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__Actions::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns1__Actions::action);
}

void ns1__Actions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns1__Actions::action);
#endif
}

int ns1__Actions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Actions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Actions(struct soap *soap, const char *tag, int id, const ns1__Actions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Actions), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "ns1:action", -1, &a->ns1__Actions::action, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__Actions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__Actions(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Actions * SOAP_FMAC4 soap_in_ns1__Actions(struct soap *soap, const char *tag, ns1__Actions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Actions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Actions, sizeof(ns1__Actions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__Actions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__Actions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfstd__string(soap, "ns1:action", &a->ns1__Actions::action, "xsd:string"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Actions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Actions, SOAP_TYPE_ns1__Actions, sizeof(ns1__Actions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__Actions * SOAP_FMAC2 soap_instantiate_ns1__Actions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Actions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__Actions *p;
	size_t k = sizeof(ns1__Actions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__Actions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__Actions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__Actions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__Actions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__Actions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__Actions(soap, tag ? tag : "ns1:Actions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Actions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Actions(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Actions * SOAP_FMAC4 soap_get_ns1__Actions(struct soap *soap, ns1__Actions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Actions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__Override::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__Override::field);
	soap_default_std__string(soap, &this->ns1__Override::value);
}

void ns1__Override::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__Override::field, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__Override::field);
	soap_embedded(soap, &this->ns1__Override::value, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__Override::value);
#endif
}

int ns1__Override::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Override(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Override(struct soap *soap, const char *tag, int id, const ns1__Override *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Override), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:field", -1, &a->ns1__Override::field, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:value", -1, &a->ns1__Override::value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__Override::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__Override(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Override * SOAP_FMAC4 soap_in_ns1__Override(struct soap *soap, const char *tag, ns1__Override *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Override*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Override, sizeof(ns1__Override), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__Override)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__Override *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_field1 = 1;
	size_t soap_flag_value1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_field1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:field", &a->ns1__Override::field, "xsd:string"))
				{	soap_flag_field1--;
					continue;
				}
			}
			if (soap_flag_value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:value", &a->ns1__Override::value, "xsd:string"))
				{	soap_flag_value1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_field1 > 0 || soap_flag_value1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__Override *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Override, SOAP_TYPE_ns1__Override, sizeof(ns1__Override), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__Override * SOAP_FMAC2 soap_instantiate_ns1__Override(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Override(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__Override *p;
	size_t k = sizeof(ns1__Override);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__Override, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__Override);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__Override, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__Override location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__Override::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__Override(soap, tag ? tag : "ns1:Override", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Override::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Override(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Override * SOAP_FMAC4 soap_get_ns1__Override(struct soap *soap, ns1__Override *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Override(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__SecondaryQualifier::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__SecondaryQualifierType(soap, &this->ns1__SecondaryQualifier::secondaryQualifierType);
	soap_default_ns1__SecondaryQualifierOperator(soap, &this->ns1__SecondaryQualifier::secondaryQualifierOperator);
	soap_default_std__string(soap, &this->ns1__SecondaryQualifier::secondaryQualifierValue);
}

void ns1__SecondaryQualifier::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__SecondaryQualifier::secondaryQualifierValue, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__SecondaryQualifier::secondaryQualifierValue);
#endif
}

int ns1__SecondaryQualifier::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SecondaryQualifier(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SecondaryQualifier(struct soap *soap, const char *tag, int id, const ns1__SecondaryQualifier *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SecondaryQualifier), type))
		return soap->error;
	if (soap_out_ns1__SecondaryQualifierType(soap, "ns1:secondaryQualifierType", -1, &a->ns1__SecondaryQualifier::secondaryQualifierType, ""))
		return soap->error;
	if (soap_out_ns1__SecondaryQualifierOperator(soap, "ns1:secondaryQualifierOperator", -1, &a->ns1__SecondaryQualifier::secondaryQualifierOperator, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:secondaryQualifierValue", -1, &a->ns1__SecondaryQualifier::secondaryQualifierValue, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SecondaryQualifier::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__SecondaryQualifier(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SecondaryQualifier * SOAP_FMAC4 soap_in_ns1__SecondaryQualifier(struct soap *soap, const char *tag, ns1__SecondaryQualifier *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SecondaryQualifier*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SecondaryQualifier, sizeof(ns1__SecondaryQualifier), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__SecondaryQualifier)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__SecondaryQualifier *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_secondaryQualifierType1 = 1;
	size_t soap_flag_secondaryQualifierOperator1 = 1;
	size_t soap_flag_secondaryQualifierValue1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_secondaryQualifierType1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns1__SecondaryQualifierType(soap, "ns1:secondaryQualifierType", &a->ns1__SecondaryQualifier::secondaryQualifierType, "ns1:SecondaryQualifierType"))
				{	soap_flag_secondaryQualifierType1--;
					continue;
				}
			}
			if (soap_flag_secondaryQualifierOperator1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns1__SecondaryQualifierOperator(soap, "ns1:secondaryQualifierOperator", &a->ns1__SecondaryQualifier::secondaryQualifierOperator, "ns1:SecondaryQualifierOperator"))
				{	soap_flag_secondaryQualifierOperator1--;
					continue;
				}
			}
			if (soap_flag_secondaryQualifierValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:secondaryQualifierValue", &a->ns1__SecondaryQualifier::secondaryQualifierValue, "xsd:string"))
				{	soap_flag_secondaryQualifierValue1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_secondaryQualifierType1 > 0 || soap_flag_secondaryQualifierOperator1 > 0 || soap_flag_secondaryQualifierValue1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__SecondaryQualifier *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SecondaryQualifier, SOAP_TYPE_ns1__SecondaryQualifier, sizeof(ns1__SecondaryQualifier), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__SecondaryQualifier * SOAP_FMAC2 soap_instantiate_ns1__SecondaryQualifier(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SecondaryQualifier(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__SecondaryQualifier *p;
	size_t k = sizeof(ns1__SecondaryQualifier);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__SecondaryQualifier, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__SecondaryQualifier);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__SecondaryQualifier, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__SecondaryQualifier location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__SecondaryQualifier::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__SecondaryQualifier(soap, tag ? tag : "ns1:SecondaryQualifier", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SecondaryQualifier::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SecondaryQualifier(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SecondaryQualifier * SOAP_FMAC4 soap_get_ns1__SecondaryQualifier(struct soap *soap, ns1__SecondaryQualifier *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SecondaryQualifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__PrimaryQualifier::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MacroType(soap, &this->ns1__PrimaryQualifier::primaryQualifierType);
	soap_default_std__string(soap, &this->ns1__PrimaryQualifier::primaryQualifierValue);
}

void ns1__PrimaryQualifier::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__PrimaryQualifier::primaryQualifierValue, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__PrimaryQualifier::primaryQualifierValue);
#endif
}

int ns1__PrimaryQualifier::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__PrimaryQualifier(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PrimaryQualifier(struct soap *soap, const char *tag, int id, const ns1__PrimaryQualifier *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PrimaryQualifier), type))
		return soap->error;
	if (soap_out_ns1__MacroType(soap, "ns1:primaryQualifierType", -1, &a->ns1__PrimaryQualifier::primaryQualifierType, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:primaryQualifierValue", -1, &a->ns1__PrimaryQualifier::primaryQualifierValue, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__PrimaryQualifier::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__PrimaryQualifier(soap, tag, this, type);
}

SOAP_FMAC3 ns1__PrimaryQualifier * SOAP_FMAC4 soap_in_ns1__PrimaryQualifier(struct soap *soap, const char *tag, ns1__PrimaryQualifier *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__PrimaryQualifier*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PrimaryQualifier, sizeof(ns1__PrimaryQualifier), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__PrimaryQualifier)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__PrimaryQualifier *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_primaryQualifierType1 = 1;
	size_t soap_flag_primaryQualifierValue1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_primaryQualifierType1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns1__MacroType(soap, "ns1:primaryQualifierType", &a->ns1__PrimaryQualifier::primaryQualifierType, "ns1:MacroType"))
				{	soap_flag_primaryQualifierType1--;
					continue;
				}
			}
			if (soap_flag_primaryQualifierValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:primaryQualifierValue", &a->ns1__PrimaryQualifier::primaryQualifierValue, "xsd:string"))
				{	soap_flag_primaryQualifierValue1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_primaryQualifierType1 > 0 || soap_flag_primaryQualifierValue1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__PrimaryQualifier *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PrimaryQualifier, SOAP_TYPE_ns1__PrimaryQualifier, sizeof(ns1__PrimaryQualifier), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__PrimaryQualifier * SOAP_FMAC2 soap_instantiate_ns1__PrimaryQualifier(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__PrimaryQualifier(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__PrimaryQualifier *p;
	size_t k = sizeof(ns1__PrimaryQualifier);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__PrimaryQualifier, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__PrimaryQualifier);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__PrimaryQualifier, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__PrimaryQualifier location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__PrimaryQualifier::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__PrimaryQualifier(soap, tag ? tag : "ns1:PrimaryQualifier", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__PrimaryQualifier::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__PrimaryQualifier(soap, this, tag, type);
}

SOAP_FMAC3 ns1__PrimaryQualifier * SOAP_FMAC4 soap_get_ns1__PrimaryQualifier(struct soap *soap, ns1__PrimaryQualifier *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PrimaryQualifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__Macro::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__Macro::primaryQualifier = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__SecondaryQualifier(soap, &this->ns1__Macro::secondaryQualifier);
	this->ns1__Macro::overrides = NULL;
}

void ns1__Macro::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__PrimaryQualifier(soap, &this->ns1__Macro::primaryQualifier);
	soap_serialize_std__vectorTemplateOfPointerTons1__SecondaryQualifier(soap, &this->ns1__Macro::secondaryQualifier);
	soap_serialize_PointerTons1__Overrides(soap, &this->ns1__Macro::overrides);
#endif
}

int ns1__Macro::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Macro(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Macro(struct soap *soap, const char *tag, int id, const ns1__Macro *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Macro), type))
		return soap->error;
	if (!a->ns1__Macro::primaryQualifier)
	{	if (soap_element_empty(soap, "ns1:primaryQualifier", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__PrimaryQualifier(soap, "ns1:primaryQualifier", -1, &a->ns1__Macro::primaryQualifier, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__SecondaryQualifier(soap, "ns1:secondaryQualifier", -1, &a->ns1__Macro::secondaryQualifier, ""))
		return soap->error;
	if (soap_out_PointerTons1__Overrides(soap, "ns1:overrides", -1, &a->ns1__Macro::overrides, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__Macro::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__Macro(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Macro * SOAP_FMAC4 soap_in_ns1__Macro(struct soap *soap, const char *tag, ns1__Macro *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Macro*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Macro, sizeof(ns1__Macro), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__Macro)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__Macro *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_primaryQualifier1 = 1;
	size_t soap_flag_overrides1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_primaryQualifier1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__PrimaryQualifier(soap, "ns1:primaryQualifier", &a->ns1__Macro::primaryQualifier, "ns1:PrimaryQualifier"))
				{	soap_flag_primaryQualifier1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__SecondaryQualifier(soap, "ns1:secondaryQualifier", &a->ns1__Macro::secondaryQualifier, "ns1:SecondaryQualifier"))
					continue;
			}
			if (soap_flag_overrides1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Overrides(soap, "ns1:overrides", &a->ns1__Macro::overrides, "ns1:Overrides"))
				{	soap_flag_overrides1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__Macro::primaryQualifier || a->ns1__Macro::secondaryQualifier.size() > 7))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__Macro *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Macro, SOAP_TYPE_ns1__Macro, sizeof(ns1__Macro), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__Macro * SOAP_FMAC2 soap_instantiate_ns1__Macro(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Macro(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__Macro *p;
	size_t k = sizeof(ns1__Macro);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__Macro, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__Macro);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__Macro, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__Macro location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__Macro::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__Macro(soap, tag ? tag : "ns1:Macro", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Macro::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Macro(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Macro * SOAP_FMAC4 soap_get_ns1__Macro(struct soap *soap, ns1__Macro *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Macro(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__FundInstrument::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__FundInstrument::id);
	this->ns1__FundInstrument::yellowkey = NULL;
	this->ns1__FundInstrument::type = NULL;
	this->ns1__FundInstrument::overrides = NULL;
	this->ns1__FundInstrument::period = NULL;
}

void ns1__FundInstrument::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__FundInstrument::id, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__FundInstrument::id);
	soap_serialize_PointerTons1__MarketSector(soap, &this->ns1__FundInstrument::yellowkey);
	soap_serialize_PointerTons1__InstrumentType(soap, &this->ns1__FundInstrument::type);
	soap_serialize_PointerTons1__Overrides(soap, &this->ns1__FundInstrument::overrides);
	soap_serialize_PointerTons1__Period(soap, &this->ns1__FundInstrument::period);
#endif
}

int ns1__FundInstrument::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__FundInstrument(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__FundInstrument(struct soap *soap, const char *tag, int id, const ns1__FundInstrument *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__FundInstrument), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:id", -1, &a->ns1__FundInstrument::id, ""))
		return soap->error;
	if (soap_out_PointerTons1__MarketSector(soap, "ns1:yellowkey", -1, &a->ns1__FundInstrument::yellowkey, ""))
		return soap->error;
	if (soap_out_PointerTons1__InstrumentType(soap, "ns1:type", -1, &a->ns1__FundInstrument::type, ""))
		return soap->error;
	if (soap_out_PointerTons1__Overrides(soap, "ns1:overrides", -1, &a->ns1__FundInstrument::overrides, ""))
		return soap->error;
	if (soap_out_PointerTons1__Period(soap, "ns1:period", -1, &a->ns1__FundInstrument::period, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__FundInstrument::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__FundInstrument(soap, tag, this, type);
}

SOAP_FMAC3 ns1__FundInstrument * SOAP_FMAC4 soap_in_ns1__FundInstrument(struct soap *soap, const char *tag, ns1__FundInstrument *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__FundInstrument*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FundInstrument, sizeof(ns1__FundInstrument), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__FundInstrument)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__FundInstrument *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_id1 = 1;
	size_t soap_flag_yellowkey1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_overrides1 = 1;
	size_t soap_flag_period1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:id", &a->ns1__FundInstrument::id, "xsd:string"))
				{	soap_flag_id1--;
					continue;
				}
			}
			if (soap_flag_yellowkey1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__MarketSector(soap, "ns1:yellowkey", &a->ns1__FundInstrument::yellowkey, "ns1:MarketSector"))
				{	soap_flag_yellowkey1--;
					continue;
				}
			}
			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__InstrumentType(soap, "ns1:type", &a->ns1__FundInstrument::type, "ns1:InstrumentType"))
				{	soap_flag_type1--;
					continue;
				}
			}
			if (soap_flag_overrides1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Overrides(soap, "ns1:overrides", &a->ns1__FundInstrument::overrides, "ns1:Overrides"))
				{	soap_flag_overrides1--;
					continue;
				}
			}
			if (soap_flag_period1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Period(soap, "ns1:period", &a->ns1__FundInstrument::period, "ns1:Period"))
				{	soap_flag_period1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__FundInstrument *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__FundInstrument, SOAP_TYPE_ns1__FundInstrument, sizeof(ns1__FundInstrument), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__FundInstrument * SOAP_FMAC2 soap_instantiate_ns1__FundInstrument(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__FundInstrument(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__FundInstrument *p;
	size_t k = sizeof(ns1__FundInstrument);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__FundInstrument, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__FundInstrument);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__FundInstrument, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__FundInstrument location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__FundInstrument::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__FundInstrument(soap, tag ? tag : "ns1:FundInstrument", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__FundInstrument::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__FundInstrument(soap, this, tag, type);
}

SOAP_FMAC3 ns1__FundInstrument * SOAP_FMAC4 soap_get_ns1__FundInstrument(struct soap *soap, ns1__FundInstrument *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__FundInstrument(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__Instrument::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__Instrument::id);
	this->ns1__Instrument::yellowkey = NULL;
	this->ns1__Instrument::type = NULL;
	this->ns1__Instrument::overrides = NULL;
}

void ns1__Instrument::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__Instrument::id, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__Instrument::id);
	soap_serialize_PointerTons1__MarketSector(soap, &this->ns1__Instrument::yellowkey);
	soap_serialize_PointerTons1__InstrumentType(soap, &this->ns1__Instrument::type);
	soap_serialize_PointerTons1__Overrides(soap, &this->ns1__Instrument::overrides);
#endif
}

int ns1__Instrument::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Instrument(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Instrument(struct soap *soap, const char *tag, int id, const ns1__Instrument *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Instrument), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:id", -1, &a->ns1__Instrument::id, ""))
		return soap->error;
	if (soap_out_PointerTons1__MarketSector(soap, "ns1:yellowkey", -1, &a->ns1__Instrument::yellowkey, ""))
		return soap->error;
	if (soap_out_PointerTons1__InstrumentType(soap, "ns1:type", -1, &a->ns1__Instrument::type, ""))
		return soap->error;
	if (soap_out_PointerTons1__Overrides(soap, "ns1:overrides", -1, &a->ns1__Instrument::overrides, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__Instrument::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__Instrument(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Instrument * SOAP_FMAC4 soap_in_ns1__Instrument(struct soap *soap, const char *tag, ns1__Instrument *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Instrument*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Instrument, sizeof(ns1__Instrument), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__Instrument)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__Instrument *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_id1 = 1;
	size_t soap_flag_yellowkey1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_overrides1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:id", &a->ns1__Instrument::id, "xsd:string"))
				{	soap_flag_id1--;
					continue;
				}
			}
			if (soap_flag_yellowkey1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__MarketSector(soap, "ns1:yellowkey", &a->ns1__Instrument::yellowkey, "ns1:MarketSector"))
				{	soap_flag_yellowkey1--;
					continue;
				}
			}
			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__InstrumentType(soap, "ns1:type", &a->ns1__Instrument::type, "ns1:InstrumentType"))
				{	soap_flag_type1--;
					continue;
				}
			}
			if (soap_flag_overrides1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Overrides(soap, "ns1:overrides", &a->ns1__Instrument::overrides, "ns1:Overrides"))
				{	soap_flag_overrides1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__Instrument *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Instrument, SOAP_TYPE_ns1__Instrument, sizeof(ns1__Instrument), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__Instrument * SOAP_FMAC2 soap_instantiate_ns1__Instrument(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Instrument(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__Instrument *p;
	size_t k = sizeof(ns1__Instrument);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__Instrument, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__Instrument);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__Instrument, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__Instrument location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__Instrument::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__Instrument(soap, tag ? tag : "ns1:Instrument", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Instrument::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Instrument(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Instrument * SOAP_FMAC4 soap_get_ns1__Instrument(struct soap *soap, ns1__Instrument *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Instrument(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__AllQuotesInstrumentDatas::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__AllQuotesInstrumentData(soap, &this->ns1__AllQuotesInstrumentDatas::instrumentData);
}

void ns1__AllQuotesInstrumentDatas::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__AllQuotesInstrumentData(soap, &this->ns1__AllQuotesInstrumentDatas::instrumentData);
#endif
}

int ns1__AllQuotesInstrumentDatas::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AllQuotesInstrumentDatas(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AllQuotesInstrumentDatas(struct soap *soap, const char *tag, int id, const ns1__AllQuotesInstrumentDatas *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AllQuotesInstrumentDatas), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__AllQuotesInstrumentData(soap, "ns1:instrumentData", -1, &a->ns1__AllQuotesInstrumentDatas::instrumentData, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__AllQuotesInstrumentDatas::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__AllQuotesInstrumentDatas(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AllQuotesInstrumentDatas * SOAP_FMAC4 soap_in_ns1__AllQuotesInstrumentDatas(struct soap *soap, const char *tag, ns1__AllQuotesInstrumentDatas *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__AllQuotesInstrumentDatas*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AllQuotesInstrumentDatas, sizeof(ns1__AllQuotesInstrumentDatas), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__AllQuotesInstrumentDatas)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__AllQuotesInstrumentDatas *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__AllQuotesInstrumentData(soap, "ns1:instrumentData", &a->ns1__AllQuotesInstrumentDatas::instrumentData, "ns1:AllQuotesInstrumentData"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__AllQuotesInstrumentDatas *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AllQuotesInstrumentDatas, SOAP_TYPE_ns1__AllQuotesInstrumentDatas, sizeof(ns1__AllQuotesInstrumentDatas), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__AllQuotesInstrumentDatas * SOAP_FMAC2 soap_instantiate_ns1__AllQuotesInstrumentDatas(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AllQuotesInstrumentDatas(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__AllQuotesInstrumentDatas *p;
	size_t k = sizeof(ns1__AllQuotesInstrumentDatas);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__AllQuotesInstrumentDatas, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__AllQuotesInstrumentDatas);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__AllQuotesInstrumentDatas, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__AllQuotesInstrumentDatas location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__AllQuotesInstrumentDatas::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__AllQuotesInstrumentDatas(soap, tag ? tag : "ns1:AllQuotesInstrumentDatas", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__AllQuotesInstrumentDatas::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AllQuotesInstrumentDatas(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AllQuotesInstrumentDatas * SOAP_FMAC4 soap_get_ns1__AllQuotesInstrumentDatas(struct soap *soap, ns1__AllQuotesInstrumentDatas *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AllQuotesInstrumentDatas(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__QuotesInstrumentDatas::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__QuotesInstrumentData(soap, &this->ns1__QuotesInstrumentDatas::instrumentData);
}

void ns1__QuotesInstrumentDatas::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__QuotesInstrumentData(soap, &this->ns1__QuotesInstrumentDatas::instrumentData);
#endif
}

int ns1__QuotesInstrumentDatas::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__QuotesInstrumentDatas(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__QuotesInstrumentDatas(struct soap *soap, const char *tag, int id, const ns1__QuotesInstrumentDatas *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__QuotesInstrumentDatas), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__QuotesInstrumentData(soap, "ns1:instrumentData", -1, &a->ns1__QuotesInstrumentDatas::instrumentData, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__QuotesInstrumentDatas::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__QuotesInstrumentDatas(soap, tag, this, type);
}

SOAP_FMAC3 ns1__QuotesInstrumentDatas * SOAP_FMAC4 soap_in_ns1__QuotesInstrumentDatas(struct soap *soap, const char *tag, ns1__QuotesInstrumentDatas *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__QuotesInstrumentDatas*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__QuotesInstrumentDatas, sizeof(ns1__QuotesInstrumentDatas), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__QuotesInstrumentDatas)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__QuotesInstrumentDatas *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__QuotesInstrumentData(soap, "ns1:instrumentData", &a->ns1__QuotesInstrumentDatas::instrumentData, "ns1:QuotesInstrumentData"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__QuotesInstrumentDatas *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__QuotesInstrumentDatas, SOAP_TYPE_ns1__QuotesInstrumentDatas, sizeof(ns1__QuotesInstrumentDatas), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__QuotesInstrumentDatas * SOAP_FMAC2 soap_instantiate_ns1__QuotesInstrumentDatas(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__QuotesInstrumentDatas(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__QuotesInstrumentDatas *p;
	size_t k = sizeof(ns1__QuotesInstrumentDatas);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__QuotesInstrumentDatas, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__QuotesInstrumentDatas);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__QuotesInstrumentDatas, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__QuotesInstrumentDatas location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__QuotesInstrumentDatas::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__QuotesInstrumentDatas(soap, tag ? tag : "ns1:QuotesInstrumentDatas", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__QuotesInstrumentDatas::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__QuotesInstrumentDatas(soap, this, tag, type);
}

SOAP_FMAC3 ns1__QuotesInstrumentDatas * SOAP_FMAC4 soap_get_ns1__QuotesInstrumentDatas(struct soap *soap, ns1__QuotesInstrumentDatas *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__QuotesInstrumentDatas(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__CorrectionRecords::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__CorrectionRecord(soap, &this->ns1__CorrectionRecords::correctionRecord);
}

void ns1__CorrectionRecords::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__CorrectionRecord(soap, &this->ns1__CorrectionRecords::correctionRecord);
#endif
}

int ns1__CorrectionRecords::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CorrectionRecords(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CorrectionRecords(struct soap *soap, const char *tag, int id, const ns1__CorrectionRecords *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CorrectionRecords), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__CorrectionRecord(soap, "ns1:correctionRecord", -1, &a->ns1__CorrectionRecords::correctionRecord, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CorrectionRecords::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__CorrectionRecords(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CorrectionRecords * SOAP_FMAC4 soap_in_ns1__CorrectionRecords(struct soap *soap, const char *tag, ns1__CorrectionRecords *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CorrectionRecords*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CorrectionRecords, sizeof(ns1__CorrectionRecords), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__CorrectionRecords)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__CorrectionRecords *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__CorrectionRecord(soap, "ns1:correctionRecord", &a->ns1__CorrectionRecords::correctionRecord, "ns1:CorrectionRecord"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CorrectionRecords *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CorrectionRecords, SOAP_TYPE_ns1__CorrectionRecords, sizeof(ns1__CorrectionRecords), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__CorrectionRecords * SOAP_FMAC2 soap_instantiate_ns1__CorrectionRecords(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CorrectionRecords(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__CorrectionRecords *p;
	size_t k = sizeof(ns1__CorrectionRecords);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__CorrectionRecords, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__CorrectionRecords);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__CorrectionRecords, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__CorrectionRecords location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__CorrectionRecords::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__CorrectionRecords(soap, tag ? tag : "ns1:CorrectionRecords", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CorrectionRecords::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CorrectionRecords(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CorrectionRecords * SOAP_FMAC4 soap_get_ns1__CorrectionRecords(struct soap *soap, ns1__CorrectionRecords *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CorrectionRecords(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ActionsInstrumentDatas::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__ActionsInstrumentData(soap, &this->ns1__ActionsInstrumentDatas::instrumentData);
}

void ns1__ActionsInstrumentDatas::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__ActionsInstrumentData(soap, &this->ns1__ActionsInstrumentDatas::instrumentData);
#endif
}

int ns1__ActionsInstrumentDatas::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ActionsInstrumentDatas(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ActionsInstrumentDatas(struct soap *soap, const char *tag, int id, const ns1__ActionsInstrumentDatas *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ActionsInstrumentDatas), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__ActionsInstrumentData(soap, "ns1:instrumentData", -1, &a->ns1__ActionsInstrumentDatas::instrumentData, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ActionsInstrumentDatas::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ActionsInstrumentDatas(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ActionsInstrumentDatas * SOAP_FMAC4 soap_in_ns1__ActionsInstrumentDatas(struct soap *soap, const char *tag, ns1__ActionsInstrumentDatas *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ActionsInstrumentDatas*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ActionsInstrumentDatas, sizeof(ns1__ActionsInstrumentDatas), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ActionsInstrumentDatas)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ActionsInstrumentDatas *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__ActionsInstrumentData(soap, "ns1:instrumentData", &a->ns1__ActionsInstrumentDatas::instrumentData, "ns1:ActionsInstrumentData"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ActionsInstrumentDatas *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ActionsInstrumentDatas, SOAP_TYPE_ns1__ActionsInstrumentDatas, sizeof(ns1__ActionsInstrumentDatas), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ActionsInstrumentDatas * SOAP_FMAC2 soap_instantiate_ns1__ActionsInstrumentDatas(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ActionsInstrumentDatas(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ActionsInstrumentDatas *p;
	size_t k = sizeof(ns1__ActionsInstrumentDatas);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ActionsInstrumentDatas, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ActionsInstrumentDatas);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ActionsInstrumentDatas, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ActionsInstrumentDatas location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ActionsInstrumentDatas::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ActionsInstrumentDatas(soap, tag ? tag : "ns1:ActionsInstrumentDatas", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ActionsInstrumentDatas::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ActionsInstrumentDatas(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ActionsInstrumentDatas * SOAP_FMAC4 soap_get_ns1__ActionsInstrumentDatas(struct soap *soap, ns1__ActionsInstrumentDatas *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ActionsInstrumentDatas(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__FundInstrumentDatas::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__FundInstrumentData(soap, &this->ns1__FundInstrumentDatas::instrumentData);
}

void ns1__FundInstrumentDatas::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__FundInstrumentData(soap, &this->ns1__FundInstrumentDatas::instrumentData);
#endif
}

int ns1__FundInstrumentDatas::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__FundInstrumentDatas(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__FundInstrumentDatas(struct soap *soap, const char *tag, int id, const ns1__FundInstrumentDatas *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__FundInstrumentDatas), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__FundInstrumentData(soap, "ns1:instrumentData", -1, &a->ns1__FundInstrumentDatas::instrumentData, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__FundInstrumentDatas::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__FundInstrumentDatas(soap, tag, this, type);
}

SOAP_FMAC3 ns1__FundInstrumentDatas * SOAP_FMAC4 soap_in_ns1__FundInstrumentDatas(struct soap *soap, const char *tag, ns1__FundInstrumentDatas *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__FundInstrumentDatas*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FundInstrumentDatas, sizeof(ns1__FundInstrumentDatas), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__FundInstrumentDatas)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__FundInstrumentDatas *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__FundInstrumentData(soap, "ns1:instrumentData", &a->ns1__FundInstrumentDatas::instrumentData, "ns1:FundInstrumentData"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__FundInstrumentDatas *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__FundInstrumentDatas, SOAP_TYPE_ns1__FundInstrumentDatas, sizeof(ns1__FundInstrumentDatas), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__FundInstrumentDatas * SOAP_FMAC2 soap_instantiate_ns1__FundInstrumentDatas(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__FundInstrumentDatas(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__FundInstrumentDatas *p;
	size_t k = sizeof(ns1__FundInstrumentDatas);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__FundInstrumentDatas, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__FundInstrumentDatas);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__FundInstrumentDatas, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__FundInstrumentDatas location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__FundInstrumentDatas::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__FundInstrumentDatas(soap, tag ? tag : "ns1:FundInstrumentDatas", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__FundInstrumentDatas::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__FundInstrumentDatas(soap, this, tag, type);
}

SOAP_FMAC3 ns1__FundInstrumentDatas * SOAP_FMAC4 soap_get_ns1__FundInstrumentDatas(struct soap *soap, ns1__FundInstrumentDatas *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__FundInstrumentDatas(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__HistInstrumentDatas::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__HistInstrumentData(soap, &this->ns1__HistInstrumentDatas::instrumentData);
}

void ns1__HistInstrumentDatas::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__HistInstrumentData(soap, &this->ns1__HistInstrumentDatas::instrumentData);
#endif
}

int ns1__HistInstrumentDatas::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__HistInstrumentDatas(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__HistInstrumentDatas(struct soap *soap, const char *tag, int id, const ns1__HistInstrumentDatas *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__HistInstrumentDatas), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__HistInstrumentData(soap, "ns1:instrumentData", -1, &a->ns1__HistInstrumentDatas::instrumentData, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__HistInstrumentDatas::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__HistInstrumentDatas(soap, tag, this, type);
}

SOAP_FMAC3 ns1__HistInstrumentDatas * SOAP_FMAC4 soap_in_ns1__HistInstrumentDatas(struct soap *soap, const char *tag, ns1__HistInstrumentDatas *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__HistInstrumentDatas*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__HistInstrumentDatas, sizeof(ns1__HistInstrumentDatas), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__HistInstrumentDatas)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__HistInstrumentDatas *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__HistInstrumentData(soap, "ns1:instrumentData", &a->ns1__HistInstrumentDatas::instrumentData, "ns1:HistInstrumentData"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__HistInstrumentDatas *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__HistInstrumentDatas, SOAP_TYPE_ns1__HistInstrumentDatas, sizeof(ns1__HistInstrumentDatas), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__HistInstrumentDatas * SOAP_FMAC2 soap_instantiate_ns1__HistInstrumentDatas(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__HistInstrumentDatas(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__HistInstrumentDatas *p;
	size_t k = sizeof(ns1__HistInstrumentDatas);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__HistInstrumentDatas, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__HistInstrumentDatas);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__HistInstrumentDatas, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__HistInstrumentDatas location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__HistInstrumentDatas::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__HistInstrumentDatas(soap, tag ? tag : "ns1:HistInstrumentDatas", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__HistInstrumentDatas::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__HistInstrumentDatas(soap, this, tag, type);
}

SOAP_FMAC3 ns1__HistInstrumentDatas * SOAP_FMAC4 soap_get_ns1__HistInstrumentDatas(struct soap *soap, ns1__HistInstrumentDatas *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__HistInstrumentDatas(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__InstrumentDatas::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__InstrumentData(soap, &this->ns1__InstrumentDatas::instrumentData);
}

void ns1__InstrumentDatas::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__InstrumentData(soap, &this->ns1__InstrumentDatas::instrumentData);
#endif
}

int ns1__InstrumentDatas::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__InstrumentDatas(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__InstrumentDatas(struct soap *soap, const char *tag, int id, const ns1__InstrumentDatas *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__InstrumentDatas), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__InstrumentData(soap, "ns1:instrumentData", -1, &a->ns1__InstrumentDatas::instrumentData, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__InstrumentDatas::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__InstrumentDatas(soap, tag, this, type);
}

SOAP_FMAC3 ns1__InstrumentDatas * SOAP_FMAC4 soap_in_ns1__InstrumentDatas(struct soap *soap, const char *tag, ns1__InstrumentDatas *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__InstrumentDatas*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__InstrumentDatas, sizeof(ns1__InstrumentDatas), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__InstrumentDatas)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__InstrumentDatas *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__InstrumentData(soap, "ns1:instrumentData", &a->ns1__InstrumentDatas::instrumentData, "ns1:InstrumentData"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__InstrumentDatas *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__InstrumentDatas, SOAP_TYPE_ns1__InstrumentDatas, sizeof(ns1__InstrumentDatas), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__InstrumentDatas * SOAP_FMAC2 soap_instantiate_ns1__InstrumentDatas(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__InstrumentDatas(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__InstrumentDatas *p;
	size_t k = sizeof(ns1__InstrumentDatas);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__InstrumentDatas, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__InstrumentDatas);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__InstrumentDatas, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__InstrumentDatas location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__InstrumentDatas::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__InstrumentDatas(soap, tag ? tag : "ns1:InstrumentDatas", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__InstrumentDatas::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__InstrumentDatas(soap, this, tag, type);
}

SOAP_FMAC3 ns1__InstrumentDatas * SOAP_FMAC4 soap_get_ns1__InstrumentDatas(struct soap *soap, ns1__InstrumentDatas *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__InstrumentDatas(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__FundInstruments::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__FundInstrument(soap, &this->ns1__FundInstruments::instrument);
	soap_default_std__vectorTemplateOfPointerTons1__Macro(soap, &this->ns1__FundInstruments::macro);
}

void ns1__FundInstruments::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__FundInstrument(soap, &this->ns1__FundInstruments::instrument);
	soap_serialize_std__vectorTemplateOfPointerTons1__Macro(soap, &this->ns1__FundInstruments::macro);
#endif
}

int ns1__FundInstruments::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__FundInstruments(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__FundInstruments(struct soap *soap, const char *tag, int id, const ns1__FundInstruments *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__FundInstruments), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__FundInstrument(soap, "ns1:instrument", -1, &a->ns1__FundInstruments::instrument, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__Macro(soap, "ns1:macro", -1, &a->ns1__FundInstruments::macro, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__FundInstruments::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__FundInstruments(soap, tag, this, type);
}

SOAP_FMAC3 ns1__FundInstruments * SOAP_FMAC4 soap_in_ns1__FundInstruments(struct soap *soap, const char *tag, ns1__FundInstruments *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__FundInstruments*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FundInstruments, sizeof(ns1__FundInstruments), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__FundInstruments)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__FundInstruments *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__FundInstrument(soap, "ns1:instrument", &a->ns1__FundInstruments::instrument, "ns1:FundInstrument"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__Macro(soap, "ns1:macro", &a->ns1__FundInstruments::macro, "ns1:Macro"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__FundInstruments *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__FundInstruments, SOAP_TYPE_ns1__FundInstruments, sizeof(ns1__FundInstruments), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__FundInstruments * SOAP_FMAC2 soap_instantiate_ns1__FundInstruments(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__FundInstruments(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__FundInstruments *p;
	size_t k = sizeof(ns1__FundInstruments);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__FundInstruments, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__FundInstruments);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__FundInstruments, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__FundInstruments location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__FundInstruments::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__FundInstruments(soap, tag ? tag : "ns1:FundInstruments", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__FundInstruments::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__FundInstruments(soap, this, tag, type);
}

SOAP_FMAC3 ns1__FundInstruments * SOAP_FMAC4 soap_get_ns1__FundInstruments(struct soap *soap, ns1__FundInstruments *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__FundInstruments(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__Instruments::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__Instrument(soap, &this->ns1__Instruments::instrument);
	soap_default_std__vectorTemplateOfPointerTons1__Macro(soap, &this->ns1__Instruments::macro);
}

void ns1__Instruments::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__Instrument(soap, &this->ns1__Instruments::instrument);
	soap_serialize_std__vectorTemplateOfPointerTons1__Macro(soap, &this->ns1__Instruments::macro);
#endif
}

int ns1__Instruments::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Instruments(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Instruments(struct soap *soap, const char *tag, int id, const ns1__Instruments *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Instruments), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__Instrument(soap, "ns1:instrument", -1, &a->ns1__Instruments::instrument, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__Macro(soap, "ns1:macro", -1, &a->ns1__Instruments::macro, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__Instruments::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__Instruments(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Instruments * SOAP_FMAC4 soap_in_ns1__Instruments(struct soap *soap, const char *tag, ns1__Instruments *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Instruments*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Instruments, sizeof(ns1__Instruments), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__Instruments)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__Instruments *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__Instrument(soap, "ns1:instrument", &a->ns1__Instruments::instrument, "ns1:Instrument"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__Macro(soap, "ns1:macro", &a->ns1__Instruments::macro, "ns1:Macro"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Instruments *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Instruments, SOAP_TYPE_ns1__Instruments, sizeof(ns1__Instruments), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__Instruments * SOAP_FMAC2 soap_instantiate_ns1__Instruments(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Instruments(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__Instruments *p;
	size_t k = sizeof(ns1__Instruments);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__Instruments, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__Instruments);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__Instruments, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__Instruments location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__Instruments::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__Instruments(soap, tag ? tag : "ns1:Instruments", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Instruments::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Instruments(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Instruments * SOAP_FMAC4 soap_get_ns1__Instruments(struct soap *soap, ns1__Instruments *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Instruments(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__Overrides::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__Override(soap, &this->ns1__Overrides::override_);
}

void ns1__Overrides::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__Override(soap, &this->ns1__Overrides::override_);
#endif
}

int ns1__Overrides::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Overrides(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Overrides(struct soap *soap, const char *tag, int id, const ns1__Overrides *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Overrides), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__Override(soap, "ns1:override", -1, &a->ns1__Overrides::override_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__Overrides::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__Overrides(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Overrides * SOAP_FMAC4 soap_in_ns1__Overrides(struct soap *soap, const char *tag, ns1__Overrides *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Overrides*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Overrides, sizeof(ns1__Overrides), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__Overrides)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__Overrides *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__Override(soap, "ns1:override", &a->ns1__Overrides::override_, "ns1:Override"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Overrides *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Overrides, SOAP_TYPE_ns1__Overrides, sizeof(ns1__Overrides), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__Overrides * SOAP_FMAC2 soap_instantiate_ns1__Overrides(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Overrides(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__Overrides *p;
	size_t k = sizeof(ns1__Overrides);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__Overrides, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__Overrides);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__Overrides, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__Overrides location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__Overrides::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__Overrides(soap, tag ? tag : "ns1:Overrides", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Overrides::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Overrides(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Overrides * SOAP_FMAC4 soap_get_ns1__Overrides(struct soap *soap, ns1__Overrides *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Overrides(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__Fields::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns1__Fields::field);
}

void ns1__Fields::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns1__Fields::field);
#endif
}

int ns1__Fields::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Fields(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Fields(struct soap *soap, const char *tag, int id, const ns1__Fields *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Fields), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "ns1:field", -1, &a->ns1__Fields::field, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__Fields::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__Fields(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Fields * SOAP_FMAC4 soap_in_ns1__Fields(struct soap *soap, const char *tag, ns1__Fields *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Fields*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Fields, sizeof(ns1__Fields), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__Fields)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__Fields *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfstd__string(soap, "ns1:field", &a->ns1__Fields::field, "xsd:string"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns1__Fields::field.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__Fields *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Fields, SOAP_TYPE_ns1__Fields, sizeof(ns1__Fields), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__Fields * SOAP_FMAC2 soap_instantiate_ns1__Fields(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Fields(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__Fields *p;
	size_t k = sizeof(ns1__Fields);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__Fields, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__Fields);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__Fields, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__Fields location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__Fields::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__Fields(soap, tag ? tag : "ns1:Fields", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Fields::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Fields(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Fields * SOAP_FMAC4 soap_get_ns1__Fields(struct soap *soap, ns1__Fields *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Fields(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ScheduledHeaders::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ScheduledHeaders::getdataHeaders = NULL;
	this->ns1__ScheduledHeaders::gethistoryHeaders = NULL;
	this->ns1__ScheduledHeaders::getfundamentalsHeaders = NULL;
	this->ns1__ScheduledHeaders::getcompanyHeaders = NULL;
	this->ns1__ScheduledHeaders::getactionsHeaders = NULL;
	this->ns1__ScheduledHeaders::getquotesHeaders = NULL;
	this->ns1__ScheduledHeaders::getallquotesHeaders = NULL;
}

void ns1__ScheduledHeaders::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__GetDataHeaders(soap, &this->ns1__ScheduledHeaders::getdataHeaders);
	soap_serialize_PointerTons1__GetHistoryHeaders(soap, &this->ns1__ScheduledHeaders::gethistoryHeaders);
	soap_serialize_PointerTons1__GetFundamentalsHeaders(soap, &this->ns1__ScheduledHeaders::getfundamentalsHeaders);
	soap_serialize_PointerTons1__GetCompanyHeaders(soap, &this->ns1__ScheduledHeaders::getcompanyHeaders);
	soap_serialize_PointerTons1__GetActionsHeaders(soap, &this->ns1__ScheduledHeaders::getactionsHeaders);
	soap_serialize_PointerTons1__QuotesHeaders(soap, &this->ns1__ScheduledHeaders::getquotesHeaders);
	soap_serialize_PointerTons1__QuotesHeaders(soap, &this->ns1__ScheduledHeaders::getallquotesHeaders);
#endif
}

int ns1__ScheduledHeaders::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ScheduledHeaders(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ScheduledHeaders(struct soap *soap, const char *tag, int id, const ns1__ScheduledHeaders *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ScheduledHeaders), type))
		return soap->error;
	if (soap_out_PointerTons1__GetDataHeaders(soap, "ns1:getdataHeaders", -1, &a->ns1__ScheduledHeaders::getdataHeaders, ""))
		return soap->error;
	if (soap_out_PointerTons1__GetHistoryHeaders(soap, "ns1:gethistoryHeaders", -1, &a->ns1__ScheduledHeaders::gethistoryHeaders, ""))
		return soap->error;
	if (soap_out_PointerTons1__GetFundamentalsHeaders(soap, "ns1:getfundamentalsHeaders", -1, &a->ns1__ScheduledHeaders::getfundamentalsHeaders, ""))
		return soap->error;
	if (soap_out_PointerTons1__GetCompanyHeaders(soap, "ns1:getcompanyHeaders", -1, &a->ns1__ScheduledHeaders::getcompanyHeaders, ""))
		return soap->error;
	if (soap_out_PointerTons1__GetActionsHeaders(soap, "ns1:getactionsHeaders", -1, &a->ns1__ScheduledHeaders::getactionsHeaders, ""))
		return soap->error;
	if (soap_out_PointerTons1__QuotesHeaders(soap, "ns1:getquotesHeaders", -1, &a->ns1__ScheduledHeaders::getquotesHeaders, ""))
		return soap->error;
	if (soap_out_PointerTons1__QuotesHeaders(soap, "ns1:getallquotesHeaders", -1, &a->ns1__ScheduledHeaders::getallquotesHeaders, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ScheduledHeaders::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ScheduledHeaders(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ScheduledHeaders * SOAP_FMAC4 soap_in_ns1__ScheduledHeaders(struct soap *soap, const char *tag, ns1__ScheduledHeaders *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ScheduledHeaders*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ScheduledHeaders, sizeof(ns1__ScheduledHeaders), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ScheduledHeaders)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ScheduledHeaders *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_getdataHeaders1 = 1;
	size_t soap_flag_gethistoryHeaders1 = 1;
	size_t soap_flag_getfundamentalsHeaders1 = 1;
	size_t soap_flag_getcompanyHeaders1 = 1;
	size_t soap_flag_getactionsHeaders1 = 1;
	size_t soap_flag_getquotesHeaders1 = 1;
	size_t soap_flag_getallquotesHeaders1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getdataHeaders1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GetDataHeaders(soap, "ns1:getdataHeaders", &a->ns1__ScheduledHeaders::getdataHeaders, "ns1:GetDataHeaders"))
				{	soap_flag_getdataHeaders1--;
					continue;
				}
			}
			if (soap_flag_gethistoryHeaders1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GetHistoryHeaders(soap, "ns1:gethistoryHeaders", &a->ns1__ScheduledHeaders::gethistoryHeaders, "ns1:GetHistoryHeaders"))
				{	soap_flag_gethistoryHeaders1--;
					continue;
				}
			}
			if (soap_flag_getfundamentalsHeaders1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GetFundamentalsHeaders(soap, "ns1:getfundamentalsHeaders", &a->ns1__ScheduledHeaders::getfundamentalsHeaders, "ns1:GetFundamentalsHeaders"))
				{	soap_flag_getfundamentalsHeaders1--;
					continue;
				}
			}
			if (soap_flag_getcompanyHeaders1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GetCompanyHeaders(soap, "ns1:getcompanyHeaders", &a->ns1__ScheduledHeaders::getcompanyHeaders, "ns1:GetCompanyHeaders"))
				{	soap_flag_getcompanyHeaders1--;
					continue;
				}
			}
			if (soap_flag_getactionsHeaders1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GetActionsHeaders(soap, "ns1:getactionsHeaders", &a->ns1__ScheduledHeaders::getactionsHeaders, "ns1:GetActionsHeaders"))
				{	soap_flag_getactionsHeaders1--;
					continue;
				}
			}
			if (soap_flag_getquotesHeaders1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__QuotesHeaders(soap, "ns1:getquotesHeaders", &a->ns1__ScheduledHeaders::getquotesHeaders, "ns1:QuotesHeaders"))
				{	soap_flag_getquotesHeaders1--;
					continue;
				}
			}
			if (soap_flag_getallquotesHeaders1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__QuotesHeaders(soap, "ns1:getallquotesHeaders", &a->ns1__ScheduledHeaders::getallquotesHeaders, "ns1:QuotesHeaders"))
				{	soap_flag_getallquotesHeaders1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ScheduledHeaders *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ScheduledHeaders, SOAP_TYPE_ns1__ScheduledHeaders, sizeof(ns1__ScheduledHeaders), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ScheduledHeaders * SOAP_FMAC2 soap_instantiate_ns1__ScheduledHeaders(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ScheduledHeaders(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ScheduledHeaders *p;
	size_t k = sizeof(ns1__ScheduledHeaders);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ScheduledHeaders, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ScheduledHeaders);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ScheduledHeaders, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ScheduledHeaders location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ScheduledHeaders::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ScheduledHeaders(soap, tag ? tag : "ns1:ScheduledHeaders", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ScheduledHeaders::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ScheduledHeaders(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ScheduledHeaders * SOAP_FMAC4 soap_get_ns1__ScheduledHeaders(struct soap *soap, ns1__ScheduledHeaders *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ScheduledHeaders(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__BvalFieldSet::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__BvalFieldMacro(soap, &this->ns1__BvalFieldSet::fieldmacro);
	this->ns1__BvalFieldSet::date = NULL;
}

void ns1__BvalFieldSet::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxsd__date(soap, &this->ns1__BvalFieldSet::date);
#endif
}

int ns1__BvalFieldSet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__BvalFieldSet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__BvalFieldSet(struct soap *soap, const char *tag, int id, const ns1__BvalFieldSet *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__BvalFieldSet), type))
		return soap->error;
	if (soap_out_ns1__BvalFieldMacro(soap, "ns1:fieldmacro", -1, &a->ns1__BvalFieldSet::fieldmacro, ""))
		return soap->error;
	if (soap_out_PointerToxsd__date(soap, "ns1:date", -1, &a->ns1__BvalFieldSet::date, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__BvalFieldSet::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__BvalFieldSet(soap, tag, this, type);
}

SOAP_FMAC3 ns1__BvalFieldSet * SOAP_FMAC4 soap_in_ns1__BvalFieldSet(struct soap *soap, const char *tag, ns1__BvalFieldSet *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__BvalFieldSet*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__BvalFieldSet, sizeof(ns1__BvalFieldSet), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__BvalFieldSet)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__BvalFieldSet *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_fieldmacro1 = 1;
	size_t soap_flag_date1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fieldmacro1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns1__BvalFieldMacro(soap, "ns1:fieldmacro", &a->ns1__BvalFieldSet::fieldmacro, "ns1:BvalFieldMacro"))
				{	soap_flag_fieldmacro1--;
					continue;
				}
			}
			if (soap_flag_date1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__date(soap, "ns1:date", &a->ns1__BvalFieldSet::date, "xsd:date"))
				{	soap_flag_date1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fieldmacro1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__BvalFieldSet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__BvalFieldSet, SOAP_TYPE_ns1__BvalFieldSet, sizeof(ns1__BvalFieldSet), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__BvalFieldSet * SOAP_FMAC2 soap_instantiate_ns1__BvalFieldSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__BvalFieldSet(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__BvalFieldSet *p;
	size_t k = sizeof(ns1__BvalFieldSet);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__BvalFieldSet, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__BvalFieldSet);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__BvalFieldSet, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__BvalFieldSet location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__BvalFieldSet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__BvalFieldSet(soap, tag ? tag : "ns1:BvalFieldSet", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__BvalFieldSet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__BvalFieldSet(soap, this, tag, type);
}

SOAP_FMAC3 ns1__BvalFieldSet * SOAP_FMAC4 soap_get_ns1__BvalFieldSet(struct soap *soap, ns1__BvalFieldSet *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__BvalFieldSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__BvalFieldSets::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__BvalFieldSet(soap, &this->ns1__BvalFieldSets::fieldset);
}

void ns1__BvalFieldSets::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__BvalFieldSet(soap, &this->ns1__BvalFieldSets::fieldset);
#endif
}

int ns1__BvalFieldSets::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__BvalFieldSets(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__BvalFieldSets(struct soap *soap, const char *tag, int id, const ns1__BvalFieldSets *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__BvalFieldSets), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__BvalFieldSet(soap, "ns1:fieldset", -1, &a->ns1__BvalFieldSets::fieldset, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__BvalFieldSets::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__BvalFieldSets(soap, tag, this, type);
}

SOAP_FMAC3 ns1__BvalFieldSets * SOAP_FMAC4 soap_in_ns1__BvalFieldSets(struct soap *soap, const char *tag, ns1__BvalFieldSets *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__BvalFieldSets*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__BvalFieldSets, sizeof(ns1__BvalFieldSets), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__BvalFieldSets)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__BvalFieldSets *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__BvalFieldSet(soap, "ns1:fieldset", &a->ns1__BvalFieldSets::fieldset, "ns1:BvalFieldSet"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns1__BvalFieldSets::fieldset.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__BvalFieldSets *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__BvalFieldSets, SOAP_TYPE_ns1__BvalFieldSets, sizeof(ns1__BvalFieldSets), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__BvalFieldSets * SOAP_FMAC2 soap_instantiate_ns1__BvalFieldSets(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__BvalFieldSets(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__BvalFieldSets *p;
	size_t k = sizeof(ns1__BvalFieldSets);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__BvalFieldSets, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__BvalFieldSets);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__BvalFieldSets, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__BvalFieldSets location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__BvalFieldSets::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__BvalFieldSets(soap, tag ? tag : "ns1:BvalFieldSets", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__BvalFieldSets::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__BvalFieldSets(soap, this, tag, type);
}

SOAP_FMAC3 ns1__BvalFieldSets * SOAP_FMAC4 soap_get_ns1__BvalFieldSets(struct soap *soap, ns1__BvalFieldSets *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__BvalFieldSets(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__FieldSet::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__FieldMacro(soap, &this->ns1__FieldSet::fieldmacro);
	this->ns1__FieldSet::date = NULL;
}

void ns1__FieldSet::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxsd__date(soap, &this->ns1__FieldSet::date);
#endif
}

int ns1__FieldSet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__FieldSet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__FieldSet(struct soap *soap, const char *tag, int id, const ns1__FieldSet *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__FieldSet), type))
		return soap->error;
	if (soap_out_ns1__FieldMacro(soap, "ns1:fieldmacro", -1, &a->ns1__FieldSet::fieldmacro, ""))
		return soap->error;
	if (soap_out_PointerToxsd__date(soap, "ns1:date", -1, &a->ns1__FieldSet::date, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__FieldSet::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__FieldSet(soap, tag, this, type);
}

SOAP_FMAC3 ns1__FieldSet * SOAP_FMAC4 soap_in_ns1__FieldSet(struct soap *soap, const char *tag, ns1__FieldSet *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__FieldSet*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FieldSet, sizeof(ns1__FieldSet), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__FieldSet)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__FieldSet *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_fieldmacro1 = 1;
	size_t soap_flag_date1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fieldmacro1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns1__FieldMacro(soap, "ns1:fieldmacro", &a->ns1__FieldSet::fieldmacro, "ns1:FieldMacro"))
				{	soap_flag_fieldmacro1--;
					continue;
				}
			}
			if (soap_flag_date1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__date(soap, "ns1:date", &a->ns1__FieldSet::date, "xsd:date"))
				{	soap_flag_date1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fieldmacro1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__FieldSet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__FieldSet, SOAP_TYPE_ns1__FieldSet, sizeof(ns1__FieldSet), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__FieldSet * SOAP_FMAC2 soap_instantiate_ns1__FieldSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__FieldSet(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__FieldSet *p;
	size_t k = sizeof(ns1__FieldSet);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__FieldSet, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__FieldSet);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__FieldSet, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__FieldSet location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__FieldSet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__FieldSet(soap, tag ? tag : "ns1:FieldSet", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__FieldSet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__FieldSet(soap, this, tag, type);
}

SOAP_FMAC3 ns1__FieldSet * SOAP_FMAC4 soap_get_ns1__FieldSet(struct soap *soap, ns1__FieldSet *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__FieldSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__FieldSets::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__FieldSet(soap, &this->ns1__FieldSets::fieldset);
}

void ns1__FieldSets::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__FieldSet(soap, &this->ns1__FieldSets::fieldset);
#endif
}

int ns1__FieldSets::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__FieldSets(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__FieldSets(struct soap *soap, const char *tag, int id, const ns1__FieldSets *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__FieldSets), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__FieldSet(soap, "ns1:fieldset", -1, &a->ns1__FieldSets::fieldset, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__FieldSets::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__FieldSets(soap, tag, this, type);
}

SOAP_FMAC3 ns1__FieldSets * SOAP_FMAC4 soap_in_ns1__FieldSets(struct soap *soap, const char *tag, ns1__FieldSets *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__FieldSets*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FieldSets, sizeof(ns1__FieldSets), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__FieldSets)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__FieldSets *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__FieldSet(soap, "ns1:fieldset", &a->ns1__FieldSets::fieldset, "ns1:FieldSet"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns1__FieldSets::fieldset.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__FieldSets *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__FieldSets, SOAP_TYPE_ns1__FieldSets, sizeof(ns1__FieldSets), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__FieldSets * SOAP_FMAC2 soap_instantiate_ns1__FieldSets(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__FieldSets(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__FieldSets *p;
	size_t k = sizeof(ns1__FieldSets);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__FieldSets, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__FieldSets);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__FieldSets, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__FieldSets location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__FieldSets::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__FieldSets(soap, tag ? tag : "ns1:FieldSets", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__FieldSets::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__FieldSets(soap, this, tag, type);
}

SOAP_FMAC3 ns1__FieldSets * SOAP_FMAC4 soap_get_ns1__FieldSets(struct soap *soap, ns1__FieldSets *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__FieldSets(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__TickOutputTz::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__TickOutputTz::timezone);
	this->ns1__TickOutputTz::dst = NULL;
}

void ns1__TickOutputTz::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__TickOutputTz::timezone, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__TickOutputTz::timezone);
	soap_serialize_PointerTobool(soap, &this->ns1__TickOutputTz::dst);
#endif
}

int ns1__TickOutputTz::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__TickOutputTz(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TickOutputTz(struct soap *soap, const char *tag, int id, const ns1__TickOutputTz *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TickOutputTz), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:timezone", -1, &a->ns1__TickOutputTz::timezone, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:dst", -1, &a->ns1__TickOutputTz::dst, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__TickOutputTz::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__TickOutputTz(soap, tag, this, type);
}

SOAP_FMAC3 ns1__TickOutputTz * SOAP_FMAC4 soap_in_ns1__TickOutputTz(struct soap *soap, const char *tag, ns1__TickOutputTz *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__TickOutputTz*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TickOutputTz, sizeof(ns1__TickOutputTz), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__TickOutputTz)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__TickOutputTz *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_timezone1 = 1;
	size_t soap_flag_dst1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_timezone1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:timezone", &a->ns1__TickOutputTz::timezone, "xsd:string"))
				{	soap_flag_timezone1--;
					continue;
				}
			}
			if (soap_flag_dst1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:dst", &a->ns1__TickOutputTz::dst, "xsd:boolean"))
				{	soap_flag_dst1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_timezone1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__TickOutputTz *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TickOutputTz, SOAP_TYPE_ns1__TickOutputTz, sizeof(ns1__TickOutputTz), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__TickOutputTz * SOAP_FMAC2 soap_instantiate_ns1__TickOutputTz(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__TickOutputTz(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__TickOutputTz *p;
	size_t k = sizeof(ns1__TickOutputTz);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__TickOutputTz, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__TickOutputTz);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__TickOutputTz, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__TickOutputTz location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__TickOutputTz::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__TickOutputTz(soap, tag ? tag : "ns1:TickOutputTz", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__TickOutputTz::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__TickOutputTz(soap, this, tag, type);
}

SOAP_FMAC3 ns1__TickOutputTz * SOAP_FMAC4 soap_get_ns1__TickOutputTz(struct soap *soap, ns1__TickOutputTz *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TickOutputTz(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__DateTimeRange::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_dateTime(soap, &this->ns1__DateTimeRange::startDateTime);
	soap_default_dateTime(soap, &this->ns1__DateTimeRange::endDateTime);
	soap_default_std__string(soap, &this->ns1__DateTimeRange::region);
	this->ns1__DateTimeRange::dst = NULL;
}

void ns1__DateTimeRange::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__DateTimeRange::startDateTime, SOAP_TYPE_dateTime);
	soap_embedded(soap, &this->ns1__DateTimeRange::endDateTime, SOAP_TYPE_dateTime);
	soap_embedded(soap, &this->ns1__DateTimeRange::region, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__DateTimeRange::region);
	soap_serialize_PointerTobool(soap, &this->ns1__DateTimeRange::dst);
#endif
}

int ns1__DateTimeRange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__DateTimeRange(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DateTimeRange(struct soap *soap, const char *tag, int id, const ns1__DateTimeRange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DateTimeRange), type))
		return soap->error;
	if (soap_out_dateTime(soap, "ns1:startDateTime", -1, &a->ns1__DateTimeRange::startDateTime, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns1:endDateTime", -1, &a->ns1__DateTimeRange::endDateTime, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:region", -1, &a->ns1__DateTimeRange::region, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:dst", -1, &a->ns1__DateTimeRange::dst, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__DateTimeRange::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__DateTimeRange(soap, tag, this, type);
}

SOAP_FMAC3 ns1__DateTimeRange * SOAP_FMAC4 soap_in_ns1__DateTimeRange(struct soap *soap, const char *tag, ns1__DateTimeRange *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__DateTimeRange*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DateTimeRange, sizeof(ns1__DateTimeRange), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__DateTimeRange)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__DateTimeRange *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_startDateTime1 = 1;
	size_t soap_flag_endDateTime1 = 1;
	size_t soap_flag_region1 = 1;
	size_t soap_flag_dst1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_startDateTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns1:startDateTime", &a->ns1__DateTimeRange::startDateTime, "xsd:dateTime"))
				{	soap_flag_startDateTime1--;
					continue;
				}
			}
			if (soap_flag_endDateTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns1:endDateTime", &a->ns1__DateTimeRange::endDateTime, "xsd:dateTime"))
				{	soap_flag_endDateTime1--;
					continue;
				}
			}
			if (soap_flag_region1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:region", &a->ns1__DateTimeRange::region, "xsd:string"))
				{	soap_flag_region1--;
					continue;
				}
			}
			if (soap_flag_dst1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:dst", &a->ns1__DateTimeRange::dst, "xsd:boolean"))
				{	soap_flag_dst1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_startDateTime1 > 0 || soap_flag_endDateTime1 > 0 || soap_flag_region1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__DateTimeRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DateTimeRange, SOAP_TYPE_ns1__DateTimeRange, sizeof(ns1__DateTimeRange), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__DateTimeRange * SOAP_FMAC2 soap_instantiate_ns1__DateTimeRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DateTimeRange(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__DateTimeRange *p;
	size_t k = sizeof(ns1__DateTimeRange);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__DateTimeRange, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__DateTimeRange);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__DateTimeRange, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__DateTimeRange location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__DateTimeRange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__DateTimeRange(soap, tag ? tag : "ns1:DateTimeRange", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__DateTimeRange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__DateTimeRange(soap, this, tag, type);
}

SOAP_FMAC3 ns1__DateTimeRange * SOAP_FMAC4 soap_get_ns1__DateTimeRange(struct soap *soap, ns1__DateTimeRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DateTimeRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__QuotesHeaders::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__QuotesHeaders::daterange = NULL;
	this->ns1__QuotesHeaders::datetimerange = NULL;
	this->ns1__QuotesHeaders::displayqrmdate = NULL;
	this->ns1__QuotesHeaders::login = NULL;
	this->ns1__QuotesHeaders::portsecdes = NULL;
	this->ns1__QuotesHeaders::pricing_USCOREsource = NULL;
	this->ns1__QuotesHeaders::programflag = NULL;
	this->ns1__QuotesHeaders::prp = NULL;
	this->ns1__QuotesHeaders::rundate = NULL;
	this->ns1__QuotesHeaders::secid = NULL;
	this->ns1__QuotesHeaders::sn = NULL;
	this->ns1__QuotesHeaders::tickexchlength = NULL;
	this->ns1__QuotesHeaders::ticklocaltz = NULL;
	this->ns1__QuotesHeaders::tickoutputtz = NULL;
	this->ns1__QuotesHeaders::time = NULL;
	this->ns1__QuotesHeaders::usernumber = NULL;
	this->ns1__QuotesHeaders::version = NULL;
	this->ns1__QuotesHeaders::ws = NULL;
	this->ns1__QuotesHeaders::yellowkey = NULL;
}

void ns1__QuotesHeaders::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__DateRange(soap, &this->ns1__QuotesHeaders::daterange);
	soap_serialize_PointerTons1__DateTimeRange(soap, &this->ns1__QuotesHeaders::datetimerange);
	soap_serialize_PointerTobool(soap, &this->ns1__QuotesHeaders::displayqrmdate);
	soap_serialize_PointerTostd__string(soap, &this->ns1__QuotesHeaders::login);
	soap_serialize_PointerTons1__PortSecDes(soap, &this->ns1__QuotesHeaders::portsecdes);
	soap_serialize_PointerTostd__string(soap, &this->ns1__QuotesHeaders::pricing_USCOREsource);
	soap_serialize_PointerTons1__ProgramFlag(soap, &this->ns1__QuotesHeaders::programflag);
	soap_serialize_PointerToint(soap, &this->ns1__QuotesHeaders::prp);
	soap_serialize_PointerTostd__string(soap, &this->ns1__QuotesHeaders::rundate);
	soap_serialize_PointerTons1__InstrumentType(soap, &this->ns1__QuotesHeaders::secid);
	soap_serialize_PointerToint(soap, &this->ns1__QuotesHeaders::sn);
	soap_serialize_PointerToint(soap, &this->ns1__QuotesHeaders::tickexchlength);
	soap_serialize_PointerTobool(soap, &this->ns1__QuotesHeaders::ticklocaltz);
	soap_serialize_PointerTons1__TickOutputTz(soap, &this->ns1__QuotesHeaders::tickoutputtz);
	soap_serialize_PointerTostd__string(soap, &this->ns1__QuotesHeaders::time);
	soap_serialize_PointerToint(soap, &this->ns1__QuotesHeaders::usernumber);
	soap_serialize_PointerTons1__Version(soap, &this->ns1__QuotesHeaders::version);
	soap_serialize_PointerToint(soap, &this->ns1__QuotesHeaders::ws);
	soap_serialize_PointerTons1__MarketSector(soap, &this->ns1__QuotesHeaders::yellowkey);
#endif
}

int ns1__QuotesHeaders::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__QuotesHeaders(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__QuotesHeaders(struct soap *soap, const char *tag, int id, const ns1__QuotesHeaders *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__QuotesHeaders), type))
		return soap->error;
	if (soap_out_PointerTons1__DateRange(soap, "ns1:daterange", -1, &a->ns1__QuotesHeaders::daterange, ""))
		return soap->error;
	if (soap_out_PointerTons1__DateTimeRange(soap, "ns1:datetimerange", -1, &a->ns1__QuotesHeaders::datetimerange, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:displayqrmdate", -1, &a->ns1__QuotesHeaders::displayqrmdate, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:login", -1, &a->ns1__QuotesHeaders::login, ""))
		return soap->error;
	if (soap_out_PointerTons1__PortSecDes(soap, "ns1:portsecdes", -1, &a->ns1__QuotesHeaders::portsecdes, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:pricing_source", -1, &a->ns1__QuotesHeaders::pricing_USCOREsource, ""))
		return soap->error;
	if (soap_out_PointerTons1__ProgramFlag(soap, "ns1:programflag", -1, &a->ns1__QuotesHeaders::programflag, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:prp", -1, &a->ns1__QuotesHeaders::prp, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:rundate", -1, &a->ns1__QuotesHeaders::rundate, ""))
		return soap->error;
	if (soap_out_PointerTons1__InstrumentType(soap, "ns1:secid", -1, &a->ns1__QuotesHeaders::secid, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:sn", -1, &a->ns1__QuotesHeaders::sn, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:tickexchlength", -1, &a->ns1__QuotesHeaders::tickexchlength, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:ticklocaltz", -1, &a->ns1__QuotesHeaders::ticklocaltz, ""))
		return soap->error;
	if (soap_out_PointerTons1__TickOutputTz(soap, "ns1:tickoutputtz", -1, &a->ns1__QuotesHeaders::tickoutputtz, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:time", -1, &a->ns1__QuotesHeaders::time, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:usernumber", -1, &a->ns1__QuotesHeaders::usernumber, ""))
		return soap->error;
	if (soap_out_PointerTons1__Version(soap, "ns1:version", -1, &a->ns1__QuotesHeaders::version, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:ws", -1, &a->ns1__QuotesHeaders::ws, ""))
		return soap->error;
	if (soap_out_PointerTons1__MarketSector(soap, "ns1:yellowkey", -1, &a->ns1__QuotesHeaders::yellowkey, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__QuotesHeaders::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__QuotesHeaders(soap, tag, this, type);
}

SOAP_FMAC3 ns1__QuotesHeaders * SOAP_FMAC4 soap_in_ns1__QuotesHeaders(struct soap *soap, const char *tag, ns1__QuotesHeaders *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__QuotesHeaders*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__QuotesHeaders, sizeof(ns1__QuotesHeaders), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__QuotesHeaders)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__QuotesHeaders *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_daterange1 = 1;
	size_t soap_flag_datetimerange1 = 1;
	size_t soap_flag_displayqrmdate1 = 1;
	size_t soap_flag_login1 = 1;
	size_t soap_flag_portsecdes1 = 1;
	size_t soap_flag_pricing_USCOREsource1 = 1;
	size_t soap_flag_programflag1 = 1;
	size_t soap_flag_prp1 = 1;
	size_t soap_flag_rundate1 = 1;
	size_t soap_flag_secid1 = 1;
	size_t soap_flag_sn1 = 1;
	size_t soap_flag_tickexchlength1 = 1;
	size_t soap_flag_ticklocaltz1 = 1;
	size_t soap_flag_tickoutputtz1 = 1;
	size_t soap_flag_time1 = 1;
	size_t soap_flag_usernumber1 = 1;
	size_t soap_flag_version1 = 1;
	size_t soap_flag_ws1 = 1;
	size_t soap_flag_yellowkey1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_daterange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__DateRange(soap, "ns1:daterange", &a->ns1__QuotesHeaders::daterange, "ns1:DateRange"))
				{	soap_flag_daterange1--;
					continue;
				}
			}
			if (soap_flag_datetimerange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__DateTimeRange(soap, "ns1:datetimerange", &a->ns1__QuotesHeaders::datetimerange, "ns1:DateTimeRange"))
				{	soap_flag_datetimerange1--;
					continue;
				}
			}
			if (soap_flag_displayqrmdate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:displayqrmdate", &a->ns1__QuotesHeaders::displayqrmdate, "xsd:boolean"))
				{	soap_flag_displayqrmdate1--;
					continue;
				}
			}
			if (soap_flag_login1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:login", &a->ns1__QuotesHeaders::login, "xsd:string"))
				{	soap_flag_login1--;
					continue;
				}
			}
			if (soap_flag_portsecdes1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__PortSecDes(soap, "ns1:portsecdes", &a->ns1__QuotesHeaders::portsecdes, "ns1:PortSecDes"))
				{	soap_flag_portsecdes1--;
					continue;
				}
			}
			if (soap_flag_pricing_USCOREsource1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:pricing_source", &a->ns1__QuotesHeaders::pricing_USCOREsource, "xsd:string"))
				{	soap_flag_pricing_USCOREsource1--;
					continue;
				}
			}
			if (soap_flag_programflag1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ProgramFlag(soap, "ns1:programflag", &a->ns1__QuotesHeaders::programflag, "ns1:ProgramFlag"))
				{	soap_flag_programflag1--;
					continue;
				}
			}
			if (soap_flag_prp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns1:prp", &a->ns1__QuotesHeaders::prp, "xsd:int"))
				{	soap_flag_prp1--;
					continue;
				}
			}
			if (soap_flag_rundate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:rundate", &a->ns1__QuotesHeaders::rundate, "xsd:string"))
				{	soap_flag_rundate1--;
					continue;
				}
			}
			if (soap_flag_secid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__InstrumentType(soap, "ns1:secid", &a->ns1__QuotesHeaders::secid, "ns1:InstrumentType"))
				{	soap_flag_secid1--;
					continue;
				}
			}
			if (soap_flag_sn1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns1:sn", &a->ns1__QuotesHeaders::sn, "xsd:int"))
				{	soap_flag_sn1--;
					continue;
				}
			}
			if (soap_flag_tickexchlength1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns1:tickexchlength", &a->ns1__QuotesHeaders::tickexchlength, "xsd:int"))
				{	soap_flag_tickexchlength1--;
					continue;
				}
			}
			if (soap_flag_ticklocaltz1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:ticklocaltz", &a->ns1__QuotesHeaders::ticklocaltz, "xsd:boolean"))
				{	soap_flag_ticklocaltz1--;
					continue;
				}
			}
			if (soap_flag_tickoutputtz1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__TickOutputTz(soap, "ns1:tickoutputtz", &a->ns1__QuotesHeaders::tickoutputtz, "ns1:TickOutputTz"))
				{	soap_flag_tickoutputtz1--;
					continue;
				}
			}
			if (soap_flag_time1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:time", &a->ns1__QuotesHeaders::time, "xsd:string"))
				{	soap_flag_time1--;
					continue;
				}
			}
			if (soap_flag_usernumber1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns1:usernumber", &a->ns1__QuotesHeaders::usernumber, "xsd:int"))
				{	soap_flag_usernumber1--;
					continue;
				}
			}
			if (soap_flag_version1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Version(soap, "ns1:version", &a->ns1__QuotesHeaders::version, "ns1:Version"))
				{	soap_flag_version1--;
					continue;
				}
			}
			if (soap_flag_ws1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns1:ws", &a->ns1__QuotesHeaders::ws, "xsd:int"))
				{	soap_flag_ws1--;
					continue;
				}
			}
			if (soap_flag_yellowkey1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__MarketSector(soap, "ns1:yellowkey", &a->ns1__QuotesHeaders::yellowkey, "ns1:MarketSector"))
				{	soap_flag_yellowkey1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__QuotesHeaders *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__QuotesHeaders, SOAP_TYPE_ns1__QuotesHeaders, sizeof(ns1__QuotesHeaders), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__QuotesHeaders * SOAP_FMAC2 soap_instantiate_ns1__QuotesHeaders(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__QuotesHeaders(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__QuotesHeaders *p;
	size_t k = sizeof(ns1__QuotesHeaders);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__QuotesHeaders, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__QuotesHeaders);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__QuotesHeaders, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__QuotesHeaders location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__QuotesHeaders::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__QuotesHeaders(soap, tag ? tag : "ns1:QuotesHeaders", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__QuotesHeaders::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__QuotesHeaders(soap, this, tag, type);
}

SOAP_FMAC3 ns1__QuotesHeaders * SOAP_FMAC4 soap_get_ns1__QuotesHeaders(struct soap *soap, ns1__QuotesHeaders *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__QuotesHeaders(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__GetPortfolioValidationHeaders::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__GetPortfolioValidationHeaders::closingvalues = NULL;
	this->ns1__GetPortfolioValidationHeaders::dateformat = NULL;
	this->ns1__GetPortfolioValidationHeaders::derived = NULL;
	this->ns1__GetPortfolioValidationHeaders::diffflag = NULL;
	this->ns1__GetPortfolioValidationHeaders::hist_USCOREcrncy = NULL;
	this->ns1__GetPortfolioValidationHeaders::historical = NULL;
	this->ns1__GetPortfolioValidationHeaders::programflag = NULL;
	this->ns1__GetPortfolioValidationHeaders::rundate = NULL;
	this->ns1__GetPortfolioValidationHeaders::secid = NULL;
	this->ns1__GetPortfolioValidationHeaders::secmaster = NULL;
	this->ns1__GetPortfolioValidationHeaders::sn = NULL;
	this->ns1__GetPortfolioValidationHeaders::specialchar = NULL;
	this->ns1__GetPortfolioValidationHeaders::time = NULL;
	this->ns1__GetPortfolioValidationHeaders::login = NULL;
	this->ns1__GetPortfolioValidationHeaders::usernumber = NULL;
	this->ns1__GetPortfolioValidationHeaders::version = NULL;
	this->ns1__GetPortfolioValidationHeaders::ws = NULL;
	this->ns1__GetPortfolioValidationHeaders::yellowkey = NULL;
	this->ns1__GetPortfolioValidationHeaders::exclusive_USCOREpricing_USCOREsrc = NULL;
	this->ns1__GetPortfolioValidationHeaders::bvaltier = NULL;
	this->ns1__GetPortfolioValidationHeaders::bvalsnapshot = NULL;
	this->ns1__GetPortfolioValidationHeaders::bvalsnapshotdate = NULL;
	this->ns1__GetPortfolioValidationHeaders::bvalbeta = NULL;
	this->ns1__GetPortfolioValidationHeaders::pricing_USCOREsource = NULL;
	this->ns1__GetPortfolioValidationHeaders::portsecdes = NULL;
	this->ns1__GetPortfolioValidationHeaders::prp = NULL;
}

void ns1__GetPortfolioValidationHeaders::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->ns1__GetPortfolioValidationHeaders::closingvalues);
	soap_serialize_PointerTons1__DateFormat(soap, &this->ns1__GetPortfolioValidationHeaders::dateformat);
	soap_serialize_PointerTobool(soap, &this->ns1__GetPortfolioValidationHeaders::derived);
	soap_serialize_PointerTons1__DiffFlag(soap, &this->ns1__GetPortfolioValidationHeaders::diffflag);
	soap_serialize_PointerTostd__string(soap, &this->ns1__GetPortfolioValidationHeaders::hist_USCOREcrncy);
	soap_serialize_PointerTobool(soap, &this->ns1__GetPortfolioValidationHeaders::historical);
	soap_serialize_PointerTons1__ProgramFlag(soap, &this->ns1__GetPortfolioValidationHeaders::programflag);
	soap_serialize_PointerTostd__string(soap, &this->ns1__GetPortfolioValidationHeaders::rundate);
	soap_serialize_PointerTons1__InstrumentType(soap, &this->ns1__GetPortfolioValidationHeaders::secid);
	soap_serialize_PointerTobool(soap, &this->ns1__GetPortfolioValidationHeaders::secmaster);
	soap_serialize_PointerToint(soap, &this->ns1__GetPortfolioValidationHeaders::sn);
	soap_serialize_PointerTons1__SpecialChar(soap, &this->ns1__GetPortfolioValidationHeaders::specialchar);
	soap_serialize_PointerTostd__string(soap, &this->ns1__GetPortfolioValidationHeaders::time);
	soap_serialize_PointerTostd__string(soap, &this->ns1__GetPortfolioValidationHeaders::login);
	soap_serialize_PointerToint(soap, &this->ns1__GetPortfolioValidationHeaders::usernumber);
	soap_serialize_PointerTons1__Version(soap, &this->ns1__GetPortfolioValidationHeaders::version);
	soap_serialize_PointerToint(soap, &this->ns1__GetPortfolioValidationHeaders::ws);
	soap_serialize_PointerTons1__MarketSector(soap, &this->ns1__GetPortfolioValidationHeaders::yellowkey);
	soap_serialize_PointerTobool(soap, &this->ns1__GetPortfolioValidationHeaders::exclusive_USCOREpricing_USCOREsrc);
	soap_serialize_PointerTons1__BvalTier(soap, &this->ns1__GetPortfolioValidationHeaders::bvaltier);
	soap_serialize_PointerTons1__BvalSnapshot(soap, &this->ns1__GetPortfolioValidationHeaders::bvalsnapshot);
	soap_serialize_PointerTostd__string(soap, &this->ns1__GetPortfolioValidationHeaders::bvalsnapshotdate);
	soap_serialize_PointerTobool(soap, &this->ns1__GetPortfolioValidationHeaders::bvalbeta);
	soap_serialize_PointerTostd__string(soap, &this->ns1__GetPortfolioValidationHeaders::pricing_USCOREsource);
	soap_serialize_PointerTons1__PortSecDes(soap, &this->ns1__GetPortfolioValidationHeaders::portsecdes);
	soap_serialize_PointerToint(soap, &this->ns1__GetPortfolioValidationHeaders::prp);
#endif
}

int ns1__GetPortfolioValidationHeaders::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__GetPortfolioValidationHeaders(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetPortfolioValidationHeaders(struct soap *soap, const char *tag, int id, const ns1__GetPortfolioValidationHeaders *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetPortfolioValidationHeaders), type))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:closingvalues", -1, &a->ns1__GetPortfolioValidationHeaders::closingvalues, ""))
		return soap->error;
	if (soap_out_PointerTons1__DateFormat(soap, "ns1:dateformat", -1, &a->ns1__GetPortfolioValidationHeaders::dateformat, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:derived", -1, &a->ns1__GetPortfolioValidationHeaders::derived, ""))
		return soap->error;
	if (soap_out_PointerTons1__DiffFlag(soap, "ns1:diffflag", -1, &a->ns1__GetPortfolioValidationHeaders::diffflag, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:hist_crncy", -1, &a->ns1__GetPortfolioValidationHeaders::hist_USCOREcrncy, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:historical", -1, &a->ns1__GetPortfolioValidationHeaders::historical, ""))
		return soap->error;
	if (soap_out_PointerTons1__ProgramFlag(soap, "ns1:programflag", -1, &a->ns1__GetPortfolioValidationHeaders::programflag, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:rundate", -1, &a->ns1__GetPortfolioValidationHeaders::rundate, ""))
		return soap->error;
	if (soap_out_PointerTons1__InstrumentType(soap, "ns1:secid", -1, &a->ns1__GetPortfolioValidationHeaders::secid, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:secmaster", -1, &a->ns1__GetPortfolioValidationHeaders::secmaster, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:sn", -1, &a->ns1__GetPortfolioValidationHeaders::sn, ""))
		return soap->error;
	if (soap_out_PointerTons1__SpecialChar(soap, "ns1:specialchar", -1, &a->ns1__GetPortfolioValidationHeaders::specialchar, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:time", -1, &a->ns1__GetPortfolioValidationHeaders::time, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:login", -1, &a->ns1__GetPortfolioValidationHeaders::login, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:usernumber", -1, &a->ns1__GetPortfolioValidationHeaders::usernumber, ""))
		return soap->error;
	if (soap_out_PointerTons1__Version(soap, "ns1:version", -1, &a->ns1__GetPortfolioValidationHeaders::version, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:ws", -1, &a->ns1__GetPortfolioValidationHeaders::ws, ""))
		return soap->error;
	if (soap_out_PointerTons1__MarketSector(soap, "ns1:yellowkey", -1, &a->ns1__GetPortfolioValidationHeaders::yellowkey, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:exclusive_pricing_src", -1, &a->ns1__GetPortfolioValidationHeaders::exclusive_USCOREpricing_USCOREsrc, ""))
		return soap->error;
	if (soap_out_PointerTons1__BvalTier(soap, "ns1:bvaltier", -1, &a->ns1__GetPortfolioValidationHeaders::bvaltier, ""))
		return soap->error;
	if (soap_out_PointerTons1__BvalSnapshot(soap, "ns1:bvalsnapshot", -1, &a->ns1__GetPortfolioValidationHeaders::bvalsnapshot, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:bvalsnapshotdate", -1, &a->ns1__GetPortfolioValidationHeaders::bvalsnapshotdate, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:bvalbeta", -1, &a->ns1__GetPortfolioValidationHeaders::bvalbeta, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:pricing_source", -1, &a->ns1__GetPortfolioValidationHeaders::pricing_USCOREsource, ""))
		return soap->error;
	if (soap_out_PointerTons1__PortSecDes(soap, "ns1:portsecdes", -1, &a->ns1__GetPortfolioValidationHeaders::portsecdes, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:prp", -1, &a->ns1__GetPortfolioValidationHeaders::prp, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__GetPortfolioValidationHeaders::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__GetPortfolioValidationHeaders(soap, tag, this, type);
}

SOAP_FMAC3 ns1__GetPortfolioValidationHeaders * SOAP_FMAC4 soap_in_ns1__GetPortfolioValidationHeaders(struct soap *soap, const char *tag, ns1__GetPortfolioValidationHeaders *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__GetPortfolioValidationHeaders*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetPortfolioValidationHeaders, sizeof(ns1__GetPortfolioValidationHeaders), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__GetPortfolioValidationHeaders)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__GetPortfolioValidationHeaders *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_closingvalues1 = 1;
	size_t soap_flag_dateformat1 = 1;
	size_t soap_flag_derived1 = 1;
	size_t soap_flag_diffflag1 = 1;
	size_t soap_flag_hist_USCOREcrncy1 = 1;
	size_t soap_flag_historical1 = 1;
	size_t soap_flag_programflag1 = 1;
	size_t soap_flag_rundate1 = 1;
	size_t soap_flag_secid1 = 1;
	size_t soap_flag_secmaster1 = 1;
	size_t soap_flag_sn1 = 1;
	size_t soap_flag_specialchar1 = 1;
	size_t soap_flag_time1 = 1;
	size_t soap_flag_login1 = 1;
	size_t soap_flag_usernumber1 = 1;
	size_t soap_flag_version1 = 1;
	size_t soap_flag_ws1 = 1;
	size_t soap_flag_yellowkey1 = 1;
	size_t soap_flag_exclusive_USCOREpricing_USCOREsrc1 = 1;
	size_t soap_flag_bvaltier1 = 1;
	size_t soap_flag_bvalsnapshot1 = 1;
	size_t soap_flag_bvalsnapshotdate1 = 1;
	size_t soap_flag_bvalbeta1 = 1;
	size_t soap_flag_pricing_USCOREsource1 = 1;
	size_t soap_flag_portsecdes1 = 1;
	size_t soap_flag_prp1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_closingvalues1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:closingvalues", &a->ns1__GetPortfolioValidationHeaders::closingvalues, "xsd:boolean"))
				{	soap_flag_closingvalues1--;
					continue;
				}
			}
			if (soap_flag_dateformat1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__DateFormat(soap, "ns1:dateformat", &a->ns1__GetPortfolioValidationHeaders::dateformat, "ns1:DateFormat"))
				{	soap_flag_dateformat1--;
					continue;
				}
			}
			if (soap_flag_derived1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:derived", &a->ns1__GetPortfolioValidationHeaders::derived, "xsd:boolean"))
				{	soap_flag_derived1--;
					continue;
				}
			}
			if (soap_flag_diffflag1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__DiffFlag(soap, "ns1:diffflag", &a->ns1__GetPortfolioValidationHeaders::diffflag, "ns1:DiffFlag"))
				{	soap_flag_diffflag1--;
					continue;
				}
			}
			if (soap_flag_hist_USCOREcrncy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:hist_crncy", &a->ns1__GetPortfolioValidationHeaders::hist_USCOREcrncy, "xsd:string"))
				{	soap_flag_hist_USCOREcrncy1--;
					continue;
				}
			}
			if (soap_flag_historical1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:historical", &a->ns1__GetPortfolioValidationHeaders::historical, "xsd:boolean"))
				{	soap_flag_historical1--;
					continue;
				}
			}
			if (soap_flag_programflag1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ProgramFlag(soap, "ns1:programflag", &a->ns1__GetPortfolioValidationHeaders::programflag, "ns1:ProgramFlag"))
				{	soap_flag_programflag1--;
					continue;
				}
			}
			if (soap_flag_rundate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:rundate", &a->ns1__GetPortfolioValidationHeaders::rundate, "xsd:string"))
				{	soap_flag_rundate1--;
					continue;
				}
			}
			if (soap_flag_secid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__InstrumentType(soap, "ns1:secid", &a->ns1__GetPortfolioValidationHeaders::secid, "ns1:InstrumentType"))
				{	soap_flag_secid1--;
					continue;
				}
			}
			if (soap_flag_secmaster1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:secmaster", &a->ns1__GetPortfolioValidationHeaders::secmaster, "xsd:boolean"))
				{	soap_flag_secmaster1--;
					continue;
				}
			}
			if (soap_flag_sn1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns1:sn", &a->ns1__GetPortfolioValidationHeaders::sn, "xsd:int"))
				{	soap_flag_sn1--;
					continue;
				}
			}
			if (soap_flag_specialchar1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__SpecialChar(soap, "ns1:specialchar", &a->ns1__GetPortfolioValidationHeaders::specialchar, "ns1:SpecialChar"))
				{	soap_flag_specialchar1--;
					continue;
				}
			}
			if (soap_flag_time1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:time", &a->ns1__GetPortfolioValidationHeaders::time, "xsd:string"))
				{	soap_flag_time1--;
					continue;
				}
			}
			if (soap_flag_login1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:login", &a->ns1__GetPortfolioValidationHeaders::login, "xsd:string"))
				{	soap_flag_login1--;
					continue;
				}
			}
			if (soap_flag_usernumber1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns1:usernumber", &a->ns1__GetPortfolioValidationHeaders::usernumber, "xsd:int"))
				{	soap_flag_usernumber1--;
					continue;
				}
			}
			if (soap_flag_version1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Version(soap, "ns1:version", &a->ns1__GetPortfolioValidationHeaders::version, "ns1:Version"))
				{	soap_flag_version1--;
					continue;
				}
			}
			if (soap_flag_ws1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns1:ws", &a->ns1__GetPortfolioValidationHeaders::ws, "xsd:int"))
				{	soap_flag_ws1--;
					continue;
				}
			}
			if (soap_flag_yellowkey1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__MarketSector(soap, "ns1:yellowkey", &a->ns1__GetPortfolioValidationHeaders::yellowkey, "ns1:MarketSector"))
				{	soap_flag_yellowkey1--;
					continue;
				}
			}
			if (soap_flag_exclusive_USCOREpricing_USCOREsrc1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:exclusive_pricing_src", &a->ns1__GetPortfolioValidationHeaders::exclusive_USCOREpricing_USCOREsrc, "xsd:boolean"))
				{	soap_flag_exclusive_USCOREpricing_USCOREsrc1--;
					continue;
				}
			}
			if (soap_flag_bvaltier1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__BvalTier(soap, "ns1:bvaltier", &a->ns1__GetPortfolioValidationHeaders::bvaltier, "ns1:BvalTier"))
				{	soap_flag_bvaltier1--;
					continue;
				}
			}
			if (soap_flag_bvalsnapshot1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__BvalSnapshot(soap, "ns1:bvalsnapshot", &a->ns1__GetPortfolioValidationHeaders::bvalsnapshot, "ns1:BvalSnapshot"))
				{	soap_flag_bvalsnapshot1--;
					continue;
				}
			}
			if (soap_flag_bvalsnapshotdate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:bvalsnapshotdate", &a->ns1__GetPortfolioValidationHeaders::bvalsnapshotdate, "xsd:string"))
				{	soap_flag_bvalsnapshotdate1--;
					continue;
				}
			}
			if (soap_flag_bvalbeta1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:bvalbeta", &a->ns1__GetPortfolioValidationHeaders::bvalbeta, "xsd:boolean"))
				{	soap_flag_bvalbeta1--;
					continue;
				}
			}
			if (soap_flag_pricing_USCOREsource1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:pricing_source", &a->ns1__GetPortfolioValidationHeaders::pricing_USCOREsource, "xsd:string"))
				{	soap_flag_pricing_USCOREsource1--;
					continue;
				}
			}
			if (soap_flag_portsecdes1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__PortSecDes(soap, "ns1:portsecdes", &a->ns1__GetPortfolioValidationHeaders::portsecdes, "ns1:PortSecDes"))
				{	soap_flag_portsecdes1--;
					continue;
				}
			}
			if (soap_flag_prp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns1:prp", &a->ns1__GetPortfolioValidationHeaders::prp, "xsd:int"))
				{	soap_flag_prp1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__GetPortfolioValidationHeaders *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetPortfolioValidationHeaders, SOAP_TYPE_ns1__GetPortfolioValidationHeaders, sizeof(ns1__GetPortfolioValidationHeaders), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__GetPortfolioValidationHeaders * SOAP_FMAC2 soap_instantiate_ns1__GetPortfolioValidationHeaders(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetPortfolioValidationHeaders(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__GetPortfolioValidationHeaders *p;
	size_t k = sizeof(ns1__GetPortfolioValidationHeaders);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetPortfolioValidationHeaders, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__GetPortfolioValidationHeaders);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__GetPortfolioValidationHeaders, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__GetPortfolioValidationHeaders location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__GetPortfolioValidationHeaders::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__GetPortfolioValidationHeaders(soap, tag ? tag : "ns1:GetPortfolioValidationHeaders", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__GetPortfolioValidationHeaders::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__GetPortfolioValidationHeaders(soap, this, tag, type);
}

SOAP_FMAC3 ns1__GetPortfolioValidationHeaders * SOAP_FMAC4 soap_get_ns1__GetPortfolioValidationHeaders(struct soap *soap, ns1__GetPortfolioValidationHeaders *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetPortfolioValidationHeaders(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__GetActionsHeaders::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__GetActionsHeaders::actions = NULL;
	this->ns1__GetActionsHeaders::actions_USCOREdate = NULL;
	this->ns1__GetActionsHeaders::daterange = NULL;
	this->ns1__GetActionsHeaders::dateformat = NULL;
	this->ns1__GetActionsHeaders::programflag = NULL;
	this->ns1__GetActionsHeaders::rundate = NULL;
	this->ns1__GetActionsHeaders::time = NULL;
	this->ns1__GetActionsHeaders::secid = NULL;
	this->ns1__GetActionsHeaders::sn = NULL;
	this->ns1__GetActionsHeaders::usernumber = NULL;
	this->ns1__GetActionsHeaders::version = NULL;
	this->ns1__GetActionsHeaders::ws = NULL;
	this->ns1__GetActionsHeaders::yellowkey = NULL;
}

void ns1__GetActionsHeaders::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__Actions(soap, &this->ns1__GetActionsHeaders::actions);
	soap_serialize_PointerTons1__ActionsDate(soap, &this->ns1__GetActionsHeaders::actions_USCOREdate);
	soap_serialize_PointerTons1__DateRange(soap, &this->ns1__GetActionsHeaders::daterange);
	soap_serialize_PointerTons1__DateFormat(soap, &this->ns1__GetActionsHeaders::dateformat);
	soap_serialize_PointerTons1__ProgramFlag(soap, &this->ns1__GetActionsHeaders::programflag);
	soap_serialize_PointerTostd__string(soap, &this->ns1__GetActionsHeaders::rundate);
	soap_serialize_PointerTostd__string(soap, &this->ns1__GetActionsHeaders::time);
	soap_serialize_PointerTons1__InstrumentType(soap, &this->ns1__GetActionsHeaders::secid);
	soap_serialize_PointerToint(soap, &this->ns1__GetActionsHeaders::sn);
	soap_serialize_PointerToint(soap, &this->ns1__GetActionsHeaders::usernumber);
	soap_serialize_PointerTons1__Version(soap, &this->ns1__GetActionsHeaders::version);
	soap_serialize_PointerToint(soap, &this->ns1__GetActionsHeaders::ws);
	soap_serialize_PointerTons1__MarketSector(soap, &this->ns1__GetActionsHeaders::yellowkey);
#endif
}

int ns1__GetActionsHeaders::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__GetActionsHeaders(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetActionsHeaders(struct soap *soap, const char *tag, int id, const ns1__GetActionsHeaders *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetActionsHeaders), type))
		return soap->error;
	if (soap_out_PointerTons1__Actions(soap, "ns1:actions", -1, &a->ns1__GetActionsHeaders::actions, ""))
		return soap->error;
	if (soap_out_PointerTons1__ActionsDate(soap, "ns1:actions_date", -1, &a->ns1__GetActionsHeaders::actions_USCOREdate, ""))
		return soap->error;
	if (soap_out_PointerTons1__DateRange(soap, "ns1:daterange", -1, &a->ns1__GetActionsHeaders::daterange, ""))
		return soap->error;
	if (soap_out_PointerTons1__DateFormat(soap, "ns1:dateformat", -1, &a->ns1__GetActionsHeaders::dateformat, ""))
		return soap->error;
	if (soap_out_PointerTons1__ProgramFlag(soap, "ns1:programflag", -1, &a->ns1__GetActionsHeaders::programflag, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:rundate", -1, &a->ns1__GetActionsHeaders::rundate, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:time", -1, &a->ns1__GetActionsHeaders::time, ""))
		return soap->error;
	if (soap_out_PointerTons1__InstrumentType(soap, "ns1:secid", -1, &a->ns1__GetActionsHeaders::secid, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:sn", -1, &a->ns1__GetActionsHeaders::sn, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:usernumber", -1, &a->ns1__GetActionsHeaders::usernumber, ""))
		return soap->error;
	if (soap_out_PointerTons1__Version(soap, "ns1:version", -1, &a->ns1__GetActionsHeaders::version, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:ws", -1, &a->ns1__GetActionsHeaders::ws, ""))
		return soap->error;
	if (soap_out_PointerTons1__MarketSector(soap, "ns1:yellowkey", -1, &a->ns1__GetActionsHeaders::yellowkey, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__GetActionsHeaders::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__GetActionsHeaders(soap, tag, this, type);
}

SOAP_FMAC3 ns1__GetActionsHeaders * SOAP_FMAC4 soap_in_ns1__GetActionsHeaders(struct soap *soap, const char *tag, ns1__GetActionsHeaders *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__GetActionsHeaders*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetActionsHeaders, sizeof(ns1__GetActionsHeaders), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__GetActionsHeaders)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__GetActionsHeaders *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_actions1 = 1;
	size_t soap_flag_actions_USCOREdate1 = 1;
	size_t soap_flag_daterange1 = 1;
	size_t soap_flag_dateformat1 = 1;
	size_t soap_flag_programflag1 = 1;
	size_t soap_flag_rundate1 = 1;
	size_t soap_flag_time1 = 1;
	size_t soap_flag_secid1 = 1;
	size_t soap_flag_sn1 = 1;
	size_t soap_flag_usernumber1 = 1;
	size_t soap_flag_version1 = 1;
	size_t soap_flag_ws1 = 1;
	size_t soap_flag_yellowkey1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_actions1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Actions(soap, "ns1:actions", &a->ns1__GetActionsHeaders::actions, "ns1:Actions"))
				{	soap_flag_actions1--;
					continue;
				}
			}
			if (soap_flag_actions_USCOREdate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ActionsDate(soap, "ns1:actions_date", &a->ns1__GetActionsHeaders::actions_USCOREdate, "ns1:ActionsDate"))
				{	soap_flag_actions_USCOREdate1--;
					continue;
				}
			}
			if (soap_flag_daterange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__DateRange(soap, "ns1:daterange", &a->ns1__GetActionsHeaders::daterange, "ns1:DateRange"))
				{	soap_flag_daterange1--;
					continue;
				}
			}
			if (soap_flag_dateformat1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__DateFormat(soap, "ns1:dateformat", &a->ns1__GetActionsHeaders::dateformat, "ns1:DateFormat"))
				{	soap_flag_dateformat1--;
					continue;
				}
			}
			if (soap_flag_programflag1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ProgramFlag(soap, "ns1:programflag", &a->ns1__GetActionsHeaders::programflag, "ns1:ProgramFlag"))
				{	soap_flag_programflag1--;
					continue;
				}
			}
			if (soap_flag_rundate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:rundate", &a->ns1__GetActionsHeaders::rundate, "xsd:string"))
				{	soap_flag_rundate1--;
					continue;
				}
			}
			if (soap_flag_time1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:time", &a->ns1__GetActionsHeaders::time, "xsd:string"))
				{	soap_flag_time1--;
					continue;
				}
			}
			if (soap_flag_secid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__InstrumentType(soap, "ns1:secid", &a->ns1__GetActionsHeaders::secid, "ns1:InstrumentType"))
				{	soap_flag_secid1--;
					continue;
				}
			}
			if (soap_flag_sn1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns1:sn", &a->ns1__GetActionsHeaders::sn, "xsd:int"))
				{	soap_flag_sn1--;
					continue;
				}
			}
			if (soap_flag_usernumber1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns1:usernumber", &a->ns1__GetActionsHeaders::usernumber, "xsd:int"))
				{	soap_flag_usernumber1--;
					continue;
				}
			}
			if (soap_flag_version1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Version(soap, "ns1:version", &a->ns1__GetActionsHeaders::version, "ns1:Version"))
				{	soap_flag_version1--;
					continue;
				}
			}
			if (soap_flag_ws1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns1:ws", &a->ns1__GetActionsHeaders::ws, "xsd:int"))
				{	soap_flag_ws1--;
					continue;
				}
			}
			if (soap_flag_yellowkey1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__MarketSector(soap, "ns1:yellowkey", &a->ns1__GetActionsHeaders::yellowkey, "ns1:MarketSector"))
				{	soap_flag_yellowkey1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__GetActionsHeaders *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetActionsHeaders, SOAP_TYPE_ns1__GetActionsHeaders, sizeof(ns1__GetActionsHeaders), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__GetActionsHeaders * SOAP_FMAC2 soap_instantiate_ns1__GetActionsHeaders(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetActionsHeaders(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__GetActionsHeaders *p;
	size_t k = sizeof(ns1__GetActionsHeaders);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetActionsHeaders, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__GetActionsHeaders);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__GetActionsHeaders, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__GetActionsHeaders location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__GetActionsHeaders::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__GetActionsHeaders(soap, tag ? tag : "ns1:GetActionsHeaders", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__GetActionsHeaders::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__GetActionsHeaders(soap, this, tag, type);
}

SOAP_FMAC3 ns1__GetActionsHeaders * SOAP_FMAC4 soap_get_ns1__GetActionsHeaders(struct soap *soap, ns1__GetActionsHeaders *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetActionsHeaders(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__GetCompanyHeaders::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns1__GetCompanyHeaders::creditrisk);
	this->ns1__GetCompanyHeaders::dateformat = NULL;
	this->ns1__GetCompanyHeaders::programflag = NULL;
	this->ns1__GetCompanyHeaders::rundate = NULL;
	this->ns1__GetCompanyHeaders::secid = NULL;
	this->ns1__GetCompanyHeaders::sn = NULL;
	this->ns1__GetCompanyHeaders::specialchar = NULL;
	this->ns1__GetCompanyHeaders::time = NULL;
	this->ns1__GetCompanyHeaders::usernumber = NULL;
	this->ns1__GetCompanyHeaders::version = NULL;
	this->ns1__GetCompanyHeaders::ws = NULL;
	this->ns1__GetCompanyHeaders::yellowkey = NULL;
}

void ns1__GetCompanyHeaders::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__GetCompanyHeaders::creditrisk, SOAP_TYPE_bool);
	soap_serialize_PointerTons1__DateFormat(soap, &this->ns1__GetCompanyHeaders::dateformat);
	soap_serialize_PointerTons1__ProgramFlag(soap, &this->ns1__GetCompanyHeaders::programflag);
	soap_serialize_PointerTostd__string(soap, &this->ns1__GetCompanyHeaders::rundate);
	soap_serialize_PointerTons1__InstrumentType(soap, &this->ns1__GetCompanyHeaders::secid);
	soap_serialize_PointerToint(soap, &this->ns1__GetCompanyHeaders::sn);
	soap_serialize_PointerTons1__SpecialChar(soap, &this->ns1__GetCompanyHeaders::specialchar);
	soap_serialize_PointerTostd__string(soap, &this->ns1__GetCompanyHeaders::time);
	soap_serialize_PointerToint(soap, &this->ns1__GetCompanyHeaders::usernumber);
	soap_serialize_PointerTons1__Version(soap, &this->ns1__GetCompanyHeaders::version);
	soap_serialize_PointerToint(soap, &this->ns1__GetCompanyHeaders::ws);
	soap_serialize_PointerTons1__MarketSector(soap, &this->ns1__GetCompanyHeaders::yellowkey);
#endif
}

int ns1__GetCompanyHeaders::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__GetCompanyHeaders(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetCompanyHeaders(struct soap *soap, const char *tag, int id, const ns1__GetCompanyHeaders *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetCompanyHeaders), type))
		return soap->error;
	if (soap_out_bool(soap, "ns1:creditrisk", -1, &a->ns1__GetCompanyHeaders::creditrisk, ""))
		return soap->error;
	if (soap_out_PointerTons1__DateFormat(soap, "ns1:dateformat", -1, &a->ns1__GetCompanyHeaders::dateformat, ""))
		return soap->error;
	if (soap_out_PointerTons1__ProgramFlag(soap, "ns1:programflag", -1, &a->ns1__GetCompanyHeaders::programflag, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:rundate", -1, &a->ns1__GetCompanyHeaders::rundate, ""))
		return soap->error;
	if (soap_out_PointerTons1__InstrumentType(soap, "ns1:secid", -1, &a->ns1__GetCompanyHeaders::secid, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:sn", -1, &a->ns1__GetCompanyHeaders::sn, ""))
		return soap->error;
	if (soap_out_PointerTons1__SpecialChar(soap, "ns1:specialchar", -1, &a->ns1__GetCompanyHeaders::specialchar, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:time", -1, &a->ns1__GetCompanyHeaders::time, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:usernumber", -1, &a->ns1__GetCompanyHeaders::usernumber, ""))
		return soap->error;
	if (soap_out_PointerTons1__Version(soap, "ns1:version", -1, &a->ns1__GetCompanyHeaders::version, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:ws", -1, &a->ns1__GetCompanyHeaders::ws, ""))
		return soap->error;
	if (soap_out_PointerTons1__MarketSector(soap, "ns1:yellowkey", -1, &a->ns1__GetCompanyHeaders::yellowkey, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__GetCompanyHeaders::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__GetCompanyHeaders(soap, tag, this, type);
}

SOAP_FMAC3 ns1__GetCompanyHeaders * SOAP_FMAC4 soap_in_ns1__GetCompanyHeaders(struct soap *soap, const char *tag, ns1__GetCompanyHeaders *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__GetCompanyHeaders*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetCompanyHeaders, sizeof(ns1__GetCompanyHeaders), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__GetCompanyHeaders)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__GetCompanyHeaders *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_creditrisk1 = 1;
	size_t soap_flag_dateformat1 = 1;
	size_t soap_flag_programflag1 = 1;
	size_t soap_flag_rundate1 = 1;
	size_t soap_flag_secid1 = 1;
	size_t soap_flag_sn1 = 1;
	size_t soap_flag_specialchar1 = 1;
	size_t soap_flag_time1 = 1;
	size_t soap_flag_usernumber1 = 1;
	size_t soap_flag_version1 = 1;
	size_t soap_flag_ws1 = 1;
	size_t soap_flag_yellowkey1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_creditrisk1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "ns1:creditrisk", &a->ns1__GetCompanyHeaders::creditrisk, "xsd:boolean"))
				{	soap_flag_creditrisk1--;
					continue;
				}
			}
			if (soap_flag_dateformat1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__DateFormat(soap, "ns1:dateformat", &a->ns1__GetCompanyHeaders::dateformat, "ns1:DateFormat"))
				{	soap_flag_dateformat1--;
					continue;
				}
			}
			if (soap_flag_programflag1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ProgramFlag(soap, "ns1:programflag", &a->ns1__GetCompanyHeaders::programflag, "ns1:ProgramFlag"))
				{	soap_flag_programflag1--;
					continue;
				}
			}
			if (soap_flag_rundate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:rundate", &a->ns1__GetCompanyHeaders::rundate, "xsd:string"))
				{	soap_flag_rundate1--;
					continue;
				}
			}
			if (soap_flag_secid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__InstrumentType(soap, "ns1:secid", &a->ns1__GetCompanyHeaders::secid, "ns1:InstrumentType"))
				{	soap_flag_secid1--;
					continue;
				}
			}
			if (soap_flag_sn1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns1:sn", &a->ns1__GetCompanyHeaders::sn, "xsd:int"))
				{	soap_flag_sn1--;
					continue;
				}
			}
			if (soap_flag_specialchar1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__SpecialChar(soap, "ns1:specialchar", &a->ns1__GetCompanyHeaders::specialchar, "ns1:SpecialChar"))
				{	soap_flag_specialchar1--;
					continue;
				}
			}
			if (soap_flag_time1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:time", &a->ns1__GetCompanyHeaders::time, "xsd:string"))
				{	soap_flag_time1--;
					continue;
				}
			}
			if (soap_flag_usernumber1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns1:usernumber", &a->ns1__GetCompanyHeaders::usernumber, "xsd:int"))
				{	soap_flag_usernumber1--;
					continue;
				}
			}
			if (soap_flag_version1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Version(soap, "ns1:version", &a->ns1__GetCompanyHeaders::version, "ns1:Version"))
				{	soap_flag_version1--;
					continue;
				}
			}
			if (soap_flag_ws1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns1:ws", &a->ns1__GetCompanyHeaders::ws, "xsd:int"))
				{	soap_flag_ws1--;
					continue;
				}
			}
			if (soap_flag_yellowkey1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__MarketSector(soap, "ns1:yellowkey", &a->ns1__GetCompanyHeaders::yellowkey, "ns1:MarketSector"))
				{	soap_flag_yellowkey1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_creditrisk1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__GetCompanyHeaders *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetCompanyHeaders, SOAP_TYPE_ns1__GetCompanyHeaders, sizeof(ns1__GetCompanyHeaders), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__GetCompanyHeaders * SOAP_FMAC2 soap_instantiate_ns1__GetCompanyHeaders(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetCompanyHeaders(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__GetCompanyHeaders *p;
	size_t k = sizeof(ns1__GetCompanyHeaders);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetCompanyHeaders, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__GetCompanyHeaders);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__GetCompanyHeaders, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__GetCompanyHeaders location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__GetCompanyHeaders::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__GetCompanyHeaders(soap, tag ? tag : "ns1:GetCompanyHeaders", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__GetCompanyHeaders::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__GetCompanyHeaders(soap, this, tag, type);
}

SOAP_FMAC3 ns1__GetCompanyHeaders * SOAP_FMAC4 soap_get_ns1__GetCompanyHeaders(struct soap *soap, ns1__GetCompanyHeaders *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetCompanyHeaders(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__GetFundamentalsHeaders::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__GetFundamentalsHeaders::filingstatus = NULL;
	this->ns1__GetFundamentalsHeaders::currency = NULL;
	this->ns1__GetFundamentalsHeaders::daterange = NULL;
	this->ns1__GetFundamentalsHeaders::periodicity = NULL;
	this->ns1__GetFundamentalsHeaders::consolidated = NULL;
	this->ns1__GetFundamentalsHeaders::adjusted = NULL;
	this->ns1__GetFundamentalsHeaders::programflag = NULL;
	this->ns1__GetFundamentalsHeaders::rundate = NULL;
	this->ns1__GetFundamentalsHeaders::time = NULL;
	this->ns1__GetFundamentalsHeaders::secid = NULL;
	this->ns1__GetFundamentalsHeaders::sn = NULL;
	this->ns1__GetFundamentalsHeaders::usernumber = NULL;
	this->ns1__GetFundamentalsHeaders::version = NULL;
	this->ns1__GetFundamentalsHeaders::ws = NULL;
	this->ns1__GetFundamentalsHeaders::yellowkey = NULL;
}

void ns1__GetFundamentalsHeaders::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__FilingStatus(soap, &this->ns1__GetFundamentalsHeaders::filingstatus);
	soap_serialize_PointerTostd__string(soap, &this->ns1__GetFundamentalsHeaders::currency);
	soap_serialize_PointerTons1__DateRange(soap, &this->ns1__GetFundamentalsHeaders::daterange);
	soap_serialize_PointerTons1__Periodicity(soap, &this->ns1__GetFundamentalsHeaders::periodicity);
	soap_serialize_PointerTobool(soap, &this->ns1__GetFundamentalsHeaders::consolidated);
	soap_serialize_PointerTobool(soap, &this->ns1__GetFundamentalsHeaders::adjusted);
	soap_serialize_PointerTons1__ProgramFlag(soap, &this->ns1__GetFundamentalsHeaders::programflag);
	soap_serialize_PointerTostd__string(soap, &this->ns1__GetFundamentalsHeaders::rundate);
	soap_serialize_PointerTostd__string(soap, &this->ns1__GetFundamentalsHeaders::time);
	soap_serialize_PointerTons1__InstrumentType(soap, &this->ns1__GetFundamentalsHeaders::secid);
	soap_serialize_PointerToint(soap, &this->ns1__GetFundamentalsHeaders::sn);
	soap_serialize_PointerToint(soap, &this->ns1__GetFundamentalsHeaders::usernumber);
	soap_serialize_PointerTons1__Version(soap, &this->ns1__GetFundamentalsHeaders::version);
	soap_serialize_PointerToint(soap, &this->ns1__GetFundamentalsHeaders::ws);
	soap_serialize_PointerTons1__MarketSector(soap, &this->ns1__GetFundamentalsHeaders::yellowkey);
#endif
}

int ns1__GetFundamentalsHeaders::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__GetFundamentalsHeaders(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetFundamentalsHeaders(struct soap *soap, const char *tag, int id, const ns1__GetFundamentalsHeaders *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetFundamentalsHeaders), type))
		return soap->error;
	if (soap_out_PointerTons1__FilingStatus(soap, "ns1:filingstatus", -1, &a->ns1__GetFundamentalsHeaders::filingstatus, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:currency", -1, &a->ns1__GetFundamentalsHeaders::currency, ""))
		return soap->error;
	if (!a->ns1__GetFundamentalsHeaders::daterange)
	{	if (soap_element_empty(soap, "ns1:daterange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__DateRange(soap, "ns1:daterange", -1, &a->ns1__GetFundamentalsHeaders::daterange, ""))
		return soap->error;
	if (soap_out_PointerTons1__Periodicity(soap, "ns1:periodicity", -1, &a->ns1__GetFundamentalsHeaders::periodicity, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:consolidated", -1, &a->ns1__GetFundamentalsHeaders::consolidated, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:adjusted", -1, &a->ns1__GetFundamentalsHeaders::adjusted, ""))
		return soap->error;
	if (soap_out_PointerTons1__ProgramFlag(soap, "ns1:programflag", -1, &a->ns1__GetFundamentalsHeaders::programflag, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:rundate", -1, &a->ns1__GetFundamentalsHeaders::rundate, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:time", -1, &a->ns1__GetFundamentalsHeaders::time, ""))
		return soap->error;
	if (soap_out_PointerTons1__InstrumentType(soap, "ns1:secid", -1, &a->ns1__GetFundamentalsHeaders::secid, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:sn", -1, &a->ns1__GetFundamentalsHeaders::sn, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:usernumber", -1, &a->ns1__GetFundamentalsHeaders::usernumber, ""))
		return soap->error;
	if (soap_out_PointerTons1__Version(soap, "ns1:version", -1, &a->ns1__GetFundamentalsHeaders::version, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:ws", -1, &a->ns1__GetFundamentalsHeaders::ws, ""))
		return soap->error;
	if (soap_out_PointerTons1__MarketSector(soap, "ns1:yellowkey", -1, &a->ns1__GetFundamentalsHeaders::yellowkey, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__GetFundamentalsHeaders::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__GetFundamentalsHeaders(soap, tag, this, type);
}

SOAP_FMAC3 ns1__GetFundamentalsHeaders * SOAP_FMAC4 soap_in_ns1__GetFundamentalsHeaders(struct soap *soap, const char *tag, ns1__GetFundamentalsHeaders *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__GetFundamentalsHeaders*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetFundamentalsHeaders, sizeof(ns1__GetFundamentalsHeaders), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__GetFundamentalsHeaders)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__GetFundamentalsHeaders *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_filingstatus1 = 1;
	size_t soap_flag_currency1 = 1;
	size_t soap_flag_daterange1 = 1;
	size_t soap_flag_periodicity1 = 1;
	size_t soap_flag_consolidated1 = 1;
	size_t soap_flag_adjusted1 = 1;
	size_t soap_flag_programflag1 = 1;
	size_t soap_flag_rundate1 = 1;
	size_t soap_flag_time1 = 1;
	size_t soap_flag_secid1 = 1;
	size_t soap_flag_sn1 = 1;
	size_t soap_flag_usernumber1 = 1;
	size_t soap_flag_version1 = 1;
	size_t soap_flag_ws1 = 1;
	size_t soap_flag_yellowkey1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_filingstatus1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__FilingStatus(soap, "ns1:filingstatus", &a->ns1__GetFundamentalsHeaders::filingstatus, "ns1:FilingStatus"))
				{	soap_flag_filingstatus1--;
					continue;
				}
			}
			if (soap_flag_currency1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:currency", &a->ns1__GetFundamentalsHeaders::currency, "xsd:string"))
				{	soap_flag_currency1--;
					continue;
				}
			}
			if (soap_flag_daterange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__DateRange(soap, "ns1:daterange", &a->ns1__GetFundamentalsHeaders::daterange, "ns1:DateRange"))
				{	soap_flag_daterange1--;
					continue;
				}
			}
			if (soap_flag_periodicity1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Periodicity(soap, "ns1:periodicity", &a->ns1__GetFundamentalsHeaders::periodicity, "ns1:Periodicity"))
				{	soap_flag_periodicity1--;
					continue;
				}
			}
			if (soap_flag_consolidated1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:consolidated", &a->ns1__GetFundamentalsHeaders::consolidated, "xsd:boolean"))
				{	soap_flag_consolidated1--;
					continue;
				}
			}
			if (soap_flag_adjusted1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:adjusted", &a->ns1__GetFundamentalsHeaders::adjusted, "xsd:boolean"))
				{	soap_flag_adjusted1--;
					continue;
				}
			}
			if (soap_flag_programflag1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ProgramFlag(soap, "ns1:programflag", &a->ns1__GetFundamentalsHeaders::programflag, "ns1:ProgramFlag"))
				{	soap_flag_programflag1--;
					continue;
				}
			}
			if (soap_flag_rundate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:rundate", &a->ns1__GetFundamentalsHeaders::rundate, "xsd:string"))
				{	soap_flag_rundate1--;
					continue;
				}
			}
			if (soap_flag_time1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:time", &a->ns1__GetFundamentalsHeaders::time, "xsd:string"))
				{	soap_flag_time1--;
					continue;
				}
			}
			if (soap_flag_secid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__InstrumentType(soap, "ns1:secid", &a->ns1__GetFundamentalsHeaders::secid, "ns1:InstrumentType"))
				{	soap_flag_secid1--;
					continue;
				}
			}
			if (soap_flag_sn1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns1:sn", &a->ns1__GetFundamentalsHeaders::sn, "xsd:int"))
				{	soap_flag_sn1--;
					continue;
				}
			}
			if (soap_flag_usernumber1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns1:usernumber", &a->ns1__GetFundamentalsHeaders::usernumber, "xsd:int"))
				{	soap_flag_usernumber1--;
					continue;
				}
			}
			if (soap_flag_version1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Version(soap, "ns1:version", &a->ns1__GetFundamentalsHeaders::version, "ns1:Version"))
				{	soap_flag_version1--;
					continue;
				}
			}
			if (soap_flag_ws1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns1:ws", &a->ns1__GetFundamentalsHeaders::ws, "xsd:int"))
				{	soap_flag_ws1--;
					continue;
				}
			}
			if (soap_flag_yellowkey1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__MarketSector(soap, "ns1:yellowkey", &a->ns1__GetFundamentalsHeaders::yellowkey, "ns1:MarketSector"))
				{	soap_flag_yellowkey1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__GetFundamentalsHeaders::daterange))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__GetFundamentalsHeaders *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetFundamentalsHeaders, SOAP_TYPE_ns1__GetFundamentalsHeaders, sizeof(ns1__GetFundamentalsHeaders), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__GetFundamentalsHeaders * SOAP_FMAC2 soap_instantiate_ns1__GetFundamentalsHeaders(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetFundamentalsHeaders(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__GetFundamentalsHeaders *p;
	size_t k = sizeof(ns1__GetFundamentalsHeaders);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetFundamentalsHeaders, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__GetFundamentalsHeaders);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__GetFundamentalsHeaders, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__GetFundamentalsHeaders location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__GetFundamentalsHeaders::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__GetFundamentalsHeaders(soap, tag ? tag : "ns1:GetFundamentalsHeaders", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__GetFundamentalsHeaders::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__GetFundamentalsHeaders(soap, this, tag, type);
}

SOAP_FMAC3 ns1__GetFundamentalsHeaders * SOAP_FMAC4 soap_get_ns1__GetFundamentalsHeaders(struct soap *soap, ns1__GetFundamentalsHeaders *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetFundamentalsHeaders(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__GetHistoryHeaders::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__GetHistoryHeaders::daterange = NULL;
	this->ns1__GetHistoryHeaders::hist_USCOREcrncy = NULL;
	this->ns1__GetHistoryHeaders::hist_USCOREperiod = NULL;
	this->ns1__GetHistoryHeaders::hist_USCOREoption = NULL;
	this->ns1__GetHistoryHeaders::programflag = NULL;
	this->ns1__GetHistoryHeaders::pricing_USCOREsource = NULL;
	this->ns1__GetHistoryHeaders::display_USCOREpricing_USCOREsrc = NULL;
	this->ns1__GetHistoryHeaders::rundate = NULL;
	this->ns1__GetHistoryHeaders::time = NULL;
	this->ns1__GetHistoryHeaders::secid = NULL;
	this->ns1__GetHistoryHeaders::sn = NULL;
	this->ns1__GetHistoryHeaders::login = NULL;
	this->ns1__GetHistoryHeaders::usernumber = NULL;
	this->ns1__GetHistoryHeaders::version = NULL;
	this->ns1__GetHistoryHeaders::ws = NULL;
	this->ns1__GetHistoryHeaders::yellowkey = NULL;
	this->ns1__GetHistoryHeaders::portsecdes = NULL;
	this->ns1__GetHistoryHeaders::prp = NULL;
	this->ns1__GetHistoryHeaders::exclusive_USCOREpricing_USCOREsrc = NULL;
	this->ns1__GetHistoryHeaders::bvalbeta = NULL;
	this->ns1__GetHistoryHeaders::regfvhl = NULL;
	this->ns1__GetHistoryHeaders::regtransparency = NULL;
}

void ns1__GetHistoryHeaders::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__DateRange(soap, &this->ns1__GetHistoryHeaders::daterange);
	soap_serialize_PointerTostd__string(soap, &this->ns1__GetHistoryHeaders::hist_USCOREcrncy);
	soap_serialize_PointerTons1__HistPeriod(soap, &this->ns1__GetHistoryHeaders::hist_USCOREperiod);
	soap_serialize_PointerTons1__HistOption(soap, &this->ns1__GetHistoryHeaders::hist_USCOREoption);
	soap_serialize_PointerTons1__ProgramFlag(soap, &this->ns1__GetHistoryHeaders::programflag);
	soap_serialize_PointerTostd__string(soap, &this->ns1__GetHistoryHeaders::pricing_USCOREsource);
	soap_serialize_PointerTobool(soap, &this->ns1__GetHistoryHeaders::display_USCOREpricing_USCOREsrc);
	soap_serialize_PointerTostd__string(soap, &this->ns1__GetHistoryHeaders::rundate);
	soap_serialize_PointerTostd__string(soap, &this->ns1__GetHistoryHeaders::time);
	soap_serialize_PointerTons1__InstrumentType(soap, &this->ns1__GetHistoryHeaders::secid);
	soap_serialize_PointerToint(soap, &this->ns1__GetHistoryHeaders::sn);
	soap_serialize_PointerTostd__string(soap, &this->ns1__GetHistoryHeaders::login);
	soap_serialize_PointerToint(soap, &this->ns1__GetHistoryHeaders::usernumber);
	soap_serialize_PointerTons1__Version(soap, &this->ns1__GetHistoryHeaders::version);
	soap_serialize_PointerToint(soap, &this->ns1__GetHistoryHeaders::ws);
	soap_serialize_PointerTons1__MarketSector(soap, &this->ns1__GetHistoryHeaders::yellowkey);
	soap_serialize_PointerTons1__PortSecDes(soap, &this->ns1__GetHistoryHeaders::portsecdes);
	soap_serialize_PointerToint(soap, &this->ns1__GetHistoryHeaders::prp);
	soap_serialize_PointerTobool(soap, &this->ns1__GetHistoryHeaders::exclusive_USCOREpricing_USCOREsrc);
	soap_serialize_PointerTobool(soap, &this->ns1__GetHistoryHeaders::bvalbeta);
	soap_serialize_PointerTobool(soap, &this->ns1__GetHistoryHeaders::regfvhl);
	soap_serialize_PointerTobool(soap, &this->ns1__GetHistoryHeaders::regtransparency);
#endif
}

int ns1__GetHistoryHeaders::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__GetHistoryHeaders(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetHistoryHeaders(struct soap *soap, const char *tag, int id, const ns1__GetHistoryHeaders *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetHistoryHeaders), type))
		return soap->error;
	if (soap_out_PointerTons1__DateRange(soap, "ns1:daterange", -1, &a->ns1__GetHistoryHeaders::daterange, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:hist_crncy", -1, &a->ns1__GetHistoryHeaders::hist_USCOREcrncy, ""))
		return soap->error;
	if (soap_out_PointerTons1__HistPeriod(soap, "ns1:hist_period", -1, &a->ns1__GetHistoryHeaders::hist_USCOREperiod, ""))
		return soap->error;
	if (soap_out_PointerTons1__HistOption(soap, "ns1:hist_option", -1, &a->ns1__GetHistoryHeaders::hist_USCOREoption, ""))
		return soap->error;
	if (soap_out_PointerTons1__ProgramFlag(soap, "ns1:programflag", -1, &a->ns1__GetHistoryHeaders::programflag, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:pricing_source", -1, &a->ns1__GetHistoryHeaders::pricing_USCOREsource, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:display_pricing_src", -1, &a->ns1__GetHistoryHeaders::display_USCOREpricing_USCOREsrc, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:rundate", -1, &a->ns1__GetHistoryHeaders::rundate, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:time", -1, &a->ns1__GetHistoryHeaders::time, ""))
		return soap->error;
	if (soap_out_PointerTons1__InstrumentType(soap, "ns1:secid", -1, &a->ns1__GetHistoryHeaders::secid, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:sn", -1, &a->ns1__GetHistoryHeaders::sn, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:login", -1, &a->ns1__GetHistoryHeaders::login, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:usernumber", -1, &a->ns1__GetHistoryHeaders::usernumber, ""))
		return soap->error;
	if (soap_out_PointerTons1__Version(soap, "ns1:version", -1, &a->ns1__GetHistoryHeaders::version, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:ws", -1, &a->ns1__GetHistoryHeaders::ws, ""))
		return soap->error;
	if (soap_out_PointerTons1__MarketSector(soap, "ns1:yellowkey", -1, &a->ns1__GetHistoryHeaders::yellowkey, ""))
		return soap->error;
	if (soap_out_PointerTons1__PortSecDes(soap, "ns1:portsecdes", -1, &a->ns1__GetHistoryHeaders::portsecdes, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:prp", -1, &a->ns1__GetHistoryHeaders::prp, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:exclusive_pricing_src", -1, &a->ns1__GetHistoryHeaders::exclusive_USCOREpricing_USCOREsrc, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:bvalbeta", -1, &a->ns1__GetHistoryHeaders::bvalbeta, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:regfvhl", -1, &a->ns1__GetHistoryHeaders::regfvhl, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:regtransparency", -1, &a->ns1__GetHistoryHeaders::regtransparency, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__GetHistoryHeaders::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__GetHistoryHeaders(soap, tag, this, type);
}

SOAP_FMAC3 ns1__GetHistoryHeaders * SOAP_FMAC4 soap_in_ns1__GetHistoryHeaders(struct soap *soap, const char *tag, ns1__GetHistoryHeaders *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__GetHistoryHeaders*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetHistoryHeaders, sizeof(ns1__GetHistoryHeaders), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__GetHistoryHeaders)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__GetHistoryHeaders *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_daterange1 = 1;
	size_t soap_flag_hist_USCOREcrncy1 = 1;
	size_t soap_flag_hist_USCOREperiod1 = 1;
	size_t soap_flag_hist_USCOREoption1 = 1;
	size_t soap_flag_programflag1 = 1;
	size_t soap_flag_pricing_USCOREsource1 = 1;
	size_t soap_flag_display_USCOREpricing_USCOREsrc1 = 1;
	size_t soap_flag_rundate1 = 1;
	size_t soap_flag_time1 = 1;
	size_t soap_flag_secid1 = 1;
	size_t soap_flag_sn1 = 1;
	size_t soap_flag_login1 = 1;
	size_t soap_flag_usernumber1 = 1;
	size_t soap_flag_version1 = 1;
	size_t soap_flag_ws1 = 1;
	size_t soap_flag_yellowkey1 = 1;
	size_t soap_flag_portsecdes1 = 1;
	size_t soap_flag_prp1 = 1;
	size_t soap_flag_exclusive_USCOREpricing_USCOREsrc1 = 1;
	size_t soap_flag_bvalbeta1 = 1;
	size_t soap_flag_regfvhl1 = 1;
	size_t soap_flag_regtransparency1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_daterange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__DateRange(soap, "ns1:daterange", &a->ns1__GetHistoryHeaders::daterange, "ns1:DateRange"))
				{	soap_flag_daterange1--;
					continue;
				}
			}
			if (soap_flag_hist_USCOREcrncy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:hist_crncy", &a->ns1__GetHistoryHeaders::hist_USCOREcrncy, "xsd:string"))
				{	soap_flag_hist_USCOREcrncy1--;
					continue;
				}
			}
			if (soap_flag_hist_USCOREperiod1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__HistPeriod(soap, "ns1:hist_period", &a->ns1__GetHistoryHeaders::hist_USCOREperiod, "ns1:HistPeriod"))
				{	soap_flag_hist_USCOREperiod1--;
					continue;
				}
			}
			if (soap_flag_hist_USCOREoption1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__HistOption(soap, "ns1:hist_option", &a->ns1__GetHistoryHeaders::hist_USCOREoption, "ns1:HistOption"))
				{	soap_flag_hist_USCOREoption1--;
					continue;
				}
			}
			if (soap_flag_programflag1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ProgramFlag(soap, "ns1:programflag", &a->ns1__GetHistoryHeaders::programflag, "ns1:ProgramFlag"))
				{	soap_flag_programflag1--;
					continue;
				}
			}
			if (soap_flag_pricing_USCOREsource1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:pricing_source", &a->ns1__GetHistoryHeaders::pricing_USCOREsource, "xsd:string"))
				{	soap_flag_pricing_USCOREsource1--;
					continue;
				}
			}
			if (soap_flag_display_USCOREpricing_USCOREsrc1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:display_pricing_src", &a->ns1__GetHistoryHeaders::display_USCOREpricing_USCOREsrc, "xsd:boolean"))
				{	soap_flag_display_USCOREpricing_USCOREsrc1--;
					continue;
				}
			}
			if (soap_flag_rundate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:rundate", &a->ns1__GetHistoryHeaders::rundate, "xsd:string"))
				{	soap_flag_rundate1--;
					continue;
				}
			}
			if (soap_flag_time1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:time", &a->ns1__GetHistoryHeaders::time, "xsd:string"))
				{	soap_flag_time1--;
					continue;
				}
			}
			if (soap_flag_secid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__InstrumentType(soap, "ns1:secid", &a->ns1__GetHistoryHeaders::secid, "ns1:InstrumentType"))
				{	soap_flag_secid1--;
					continue;
				}
			}
			if (soap_flag_sn1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns1:sn", &a->ns1__GetHistoryHeaders::sn, "xsd:int"))
				{	soap_flag_sn1--;
					continue;
				}
			}
			if (soap_flag_login1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:login", &a->ns1__GetHistoryHeaders::login, "xsd:string"))
				{	soap_flag_login1--;
					continue;
				}
			}
			if (soap_flag_usernumber1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns1:usernumber", &a->ns1__GetHistoryHeaders::usernumber, "xsd:int"))
				{	soap_flag_usernumber1--;
					continue;
				}
			}
			if (soap_flag_version1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Version(soap, "ns1:version", &a->ns1__GetHistoryHeaders::version, "ns1:Version"))
				{	soap_flag_version1--;
					continue;
				}
			}
			if (soap_flag_ws1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns1:ws", &a->ns1__GetHistoryHeaders::ws, "xsd:int"))
				{	soap_flag_ws1--;
					continue;
				}
			}
			if (soap_flag_yellowkey1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__MarketSector(soap, "ns1:yellowkey", &a->ns1__GetHistoryHeaders::yellowkey, "ns1:MarketSector"))
				{	soap_flag_yellowkey1--;
					continue;
				}
			}
			if (soap_flag_portsecdes1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__PortSecDes(soap, "ns1:portsecdes", &a->ns1__GetHistoryHeaders::portsecdes, "ns1:PortSecDes"))
				{	soap_flag_portsecdes1--;
					continue;
				}
			}
			if (soap_flag_prp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns1:prp", &a->ns1__GetHistoryHeaders::prp, "xsd:int"))
				{	soap_flag_prp1--;
					continue;
				}
			}
			if (soap_flag_exclusive_USCOREpricing_USCOREsrc1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:exclusive_pricing_src", &a->ns1__GetHistoryHeaders::exclusive_USCOREpricing_USCOREsrc, "xsd:boolean"))
				{	soap_flag_exclusive_USCOREpricing_USCOREsrc1--;
					continue;
				}
			}
			if (soap_flag_bvalbeta1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:bvalbeta", &a->ns1__GetHistoryHeaders::bvalbeta, "xsd:boolean"))
				{	soap_flag_bvalbeta1--;
					continue;
				}
			}
			if (soap_flag_regfvhl1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:regfvhl", &a->ns1__GetHistoryHeaders::regfvhl, "xsd:boolean"))
				{	soap_flag_regfvhl1--;
					continue;
				}
			}
			if (soap_flag_regtransparency1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:regtransparency", &a->ns1__GetHistoryHeaders::regtransparency, "xsd:boolean"))
				{	soap_flag_regtransparency1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__GetHistoryHeaders *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetHistoryHeaders, SOAP_TYPE_ns1__GetHistoryHeaders, sizeof(ns1__GetHistoryHeaders), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__GetHistoryHeaders * SOAP_FMAC2 soap_instantiate_ns1__GetHistoryHeaders(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetHistoryHeaders(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__GetHistoryHeaders *p;
	size_t k = sizeof(ns1__GetHistoryHeaders);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetHistoryHeaders, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__GetHistoryHeaders);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__GetHistoryHeaders, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__GetHistoryHeaders location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__GetHistoryHeaders::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__GetHistoryHeaders(soap, tag ? tag : "ns1:GetHistoryHeaders", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__GetHistoryHeaders::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__GetHistoryHeaders(soap, this, tag, type);
}

SOAP_FMAC3 ns1__GetHistoryHeaders * SOAP_FMAC4 soap_get_ns1__GetHistoryHeaders(struct soap *soap, ns1__GetHistoryHeaders *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetHistoryHeaders(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__DateRange::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__DateRange::period = NULL;
	this->ns1__DateRange::duration = NULL;
}

void ns1__DateRange::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__Period(soap, &this->ns1__DateRange::period);
	soap_serialize_PointerTons1__Duration(soap, &this->ns1__DateRange::duration);
#endif
}

int ns1__DateRange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__DateRange(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DateRange(struct soap *soap, const char *tag, int id, const ns1__DateRange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DateRange), type))
		return soap->error;
	if (soap_out_PointerTons1__Period(soap, "ns1:period", -1, &a->ns1__DateRange::period, ""))
		return soap->error;
	if (soap_out_PointerTons1__Duration(soap, "ns1:duration", -1, &a->ns1__DateRange::duration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__DateRange::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__DateRange(soap, tag, this, type);
}

SOAP_FMAC3 ns1__DateRange * SOAP_FMAC4 soap_in_ns1__DateRange(struct soap *soap, const char *tag, ns1__DateRange *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__DateRange*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DateRange, sizeof(ns1__DateRange), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__DateRange)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__DateRange *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_period1 = 1;
	size_t soap_flag_duration1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_period1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Period(soap, "ns1:period", &a->ns1__DateRange::period, "ns1:Period"))
				{	soap_flag_period1--;
					continue;
				}
			}
			if (soap_flag_duration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Duration(soap, "ns1:duration", &a->ns1__DateRange::duration, "ns1:Duration"))
				{	soap_flag_duration1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__DateRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DateRange, SOAP_TYPE_ns1__DateRange, sizeof(ns1__DateRange), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__DateRange * SOAP_FMAC2 soap_instantiate_ns1__DateRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DateRange(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__DateRange *p;
	size_t k = sizeof(ns1__DateRange);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__DateRange, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__DateRange);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__DateRange, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__DateRange location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__DateRange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__DateRange(soap, tag ? tag : "ns1:DateRange", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__DateRange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__DateRange(soap, this, tag, type);
}

SOAP_FMAC3 ns1__DateRange * SOAP_FMAC4 soap_get_ns1__DateRange(struct soap *soap, ns1__DateRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DateRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__Duration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__Duration::days);
}

void ns1__Duration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__Duration::days, SOAP_TYPE_int);
#endif
}

int ns1__Duration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Duration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Duration(struct soap *soap, const char *tag, int id, const ns1__Duration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Duration), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:days", -1, &a->ns1__Duration::days, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__Duration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__Duration(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Duration * SOAP_FMAC4 soap_in_ns1__Duration(struct soap *soap, const char *tag, ns1__Duration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Duration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Duration, sizeof(ns1__Duration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__Duration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__Duration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_days1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_days1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:days", &a->ns1__Duration::days, "xsd:int"))
				{	soap_flag_days1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_days1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__Duration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Duration, SOAP_TYPE_ns1__Duration, sizeof(ns1__Duration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__Duration * SOAP_FMAC2 soap_instantiate_ns1__Duration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Duration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__Duration *p;
	size_t k = sizeof(ns1__Duration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__Duration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__Duration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__Duration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__Duration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__Duration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__Duration(soap, tag ? tag : "ns1:Duration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Duration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Duration(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Duration * SOAP_FMAC4 soap_get_ns1__Duration(struct soap *soap, ns1__Duration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Duration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__Period::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__date(soap, &this->ns1__Period::start);
	soap_default_xsd__date(soap, &this->ns1__Period::end);
}

void ns1__Period::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__Period::start, SOAP_TYPE_xsd__date);
	soap_serialize_xsd__date(soap, &this->ns1__Period::start);
	soap_embedded(soap, &this->ns1__Period::end, SOAP_TYPE_xsd__date);
	soap_serialize_xsd__date(soap, &this->ns1__Period::end);
#endif
}

int ns1__Period::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Period(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Period(struct soap *soap, const char *tag, int id, const ns1__Period *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Period), type))
		return soap->error;
	if (soap_out_xsd__date(soap, "ns1:start", -1, &a->ns1__Period::start, ""))
		return soap->error;
	if (soap_out_xsd__date(soap, "ns1:end", -1, &a->ns1__Period::end, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__Period::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__Period(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Period * SOAP_FMAC4 soap_in_ns1__Period(struct soap *soap, const char *tag, ns1__Period *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Period*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Period, sizeof(ns1__Period), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__Period)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__Period *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_start1 = 1;
	size_t soap_flag_end1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_start1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__date(soap, "ns1:start", &a->ns1__Period::start, "xsd:date"))
				{	soap_flag_start1--;
					continue;
				}
			}
			if (soap_flag_end1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__date(soap, "ns1:end", &a->ns1__Period::end, "xsd:date"))
				{	soap_flag_end1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_start1 > 0 || soap_flag_end1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__Period *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Period, SOAP_TYPE_ns1__Period, sizeof(ns1__Period), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__Period * SOAP_FMAC2 soap_instantiate_ns1__Period(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Period(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__Period *p;
	size_t k = sizeof(ns1__Period);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__Period, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__Period);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__Period, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__Period location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__Period::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__Period(soap, tag ? tag : "ns1:Period", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Period::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Period(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Period * SOAP_FMAC4 soap_get_ns1__Period(struct soap *soap, ns1__Period *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Period(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__GetDataHeaders::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__GetDataHeaders::closingvalues = NULL;
	this->ns1__GetDataHeaders::dateformat = NULL;
	this->ns1__GetDataHeaders::derived = NULL;
	this->ns1__GetDataHeaders::diffflag = NULL;
	this->ns1__GetDataHeaders::hist_USCOREcrncy = NULL;
	this->ns1__GetDataHeaders::historical = NULL;
	this->ns1__GetDataHeaders::programflag = NULL;
	this->ns1__GetDataHeaders::rundate = NULL;
	this->ns1__GetDataHeaders::secid = NULL;
	this->ns1__GetDataHeaders::secmaster = NULL;
	this->ns1__GetDataHeaders::sn = NULL;
	this->ns1__GetDataHeaders::specialchar = NULL;
	this->ns1__GetDataHeaders::time = NULL;
	this->ns1__GetDataHeaders::login = NULL;
	this->ns1__GetDataHeaders::usernumber = NULL;
	this->ns1__GetDataHeaders::version = NULL;
	this->ns1__GetDataHeaders::ws = NULL;
	this->ns1__GetDataHeaders::yellowkey = NULL;
	this->ns1__GetDataHeaders::quotecomposite = NULL;
	this->ns1__GetDataHeaders::creditrisk = NULL;
	this->ns1__GetDataHeaders::quotecompositehist = NULL;
	this->ns1__GetDataHeaders::exclusive_USCOREpricing_USCOREsrc = NULL;
	this->ns1__GetDataHeaders::estimates = NULL;
	this->ns1__GetDataHeaders::bvaltier = NULL;
	this->ns1__GetDataHeaders::bvalsnapshot = NULL;
	this->ns1__GetDataHeaders::bvalsnapshotdate = NULL;
	this->ns1__GetDataHeaders::bvalbeta = NULL;
	this->ns1__GetDataHeaders::pricing_USCOREsource = NULL;
	this->ns1__GetDataHeaders::portsecdes = NULL;
	this->ns1__GetDataHeaders::prp = NULL;
	this->ns1__GetDataHeaders::fundamentals = NULL;
	this->ns1__GetDataHeaders::pricing = NULL;
	this->ns1__GetDataHeaders::skip_USCOREpcs = NULL;
	this->ns1__GetDataHeaders::vol_USCOREsurface = NULL;
	this->ns1__GetDataHeaders::regssfa = NULL;
	this->ns1__GetDataHeaders::regfvhl = NULL;
	this->ns1__GetDataHeaders::regtransparency = NULL;
	this->ns1__GetDataHeaders::regcomp = NULL;
	this->ns1__GetDataHeaders::corpstruct = NULL;
	this->ns1__GetDataHeaders::capstruct = NULL;
	this->ns1__GetDataHeaders::regsolvency = NULL;
	this->ns1__GetDataHeaders::reghqla = NULL;
	this->ns1__GetDataHeaders::reghqlaamer = NULL;
	this->ns1__GetDataHeaders::reghqlaeuro = NULL;
	this->ns1__GetDataHeaders::reghqlaasia = NULL;
	this->ns1__GetDataHeaders::regcbe = NULL;
	this->ns1__GetDataHeaders::regcfid = NULL;
	this->ns1__GetDataHeaders::reglqa = NULL;
	this->ns1__GetDataHeaders::mifir = NULL;
	this->ns1__GetDataHeaders::defaultrisk = NULL;
	this->ns1__GetDataHeaders::ifrs9sppi = NULL;
	this->ns1__GetDataHeaders::coltag = NULL;
	this->ns1__GetDataHeaders::uswhldtax = NULL;
	this->ns1__GetDataHeaders::regecl = NULL;
	this->ns1__GetDataHeaders::basictax = NULL;
	this->ns1__GetDataHeaders::invstprot = NULL;
	this->ns1__GetDataHeaders::encoding = NULL;
}

void ns1__GetDataHeaders::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->ns1__GetDataHeaders::closingvalues);
	soap_serialize_PointerTons1__DateFormat(soap, &this->ns1__GetDataHeaders::dateformat);
	soap_serialize_PointerTobool(soap, &this->ns1__GetDataHeaders::derived);
	soap_serialize_PointerTons1__DiffFlag(soap, &this->ns1__GetDataHeaders::diffflag);
	soap_serialize_PointerTostd__string(soap, &this->ns1__GetDataHeaders::hist_USCOREcrncy);
	soap_serialize_PointerTobool(soap, &this->ns1__GetDataHeaders::historical);
	soap_serialize_PointerTons1__ProgramFlag(soap, &this->ns1__GetDataHeaders::programflag);
	soap_serialize_PointerTostd__string(soap, &this->ns1__GetDataHeaders::rundate);
	soap_serialize_PointerTons1__InstrumentType(soap, &this->ns1__GetDataHeaders::secid);
	soap_serialize_PointerTobool(soap, &this->ns1__GetDataHeaders::secmaster);
	soap_serialize_PointerToint(soap, &this->ns1__GetDataHeaders::sn);
	soap_serialize_PointerTons1__SpecialChar(soap, &this->ns1__GetDataHeaders::specialchar);
	soap_serialize_PointerTostd__string(soap, &this->ns1__GetDataHeaders::time);
	soap_serialize_PointerTostd__string(soap, &this->ns1__GetDataHeaders::login);
	soap_serialize_PointerToint(soap, &this->ns1__GetDataHeaders::usernumber);
	soap_serialize_PointerTons1__Version(soap, &this->ns1__GetDataHeaders::version);
	soap_serialize_PointerToint(soap, &this->ns1__GetDataHeaders::ws);
	soap_serialize_PointerTons1__MarketSector(soap, &this->ns1__GetDataHeaders::yellowkey);
	soap_serialize_PointerTobool(soap, &this->ns1__GetDataHeaders::quotecomposite);
	soap_serialize_PointerTobool(soap, &this->ns1__GetDataHeaders::creditrisk);
	soap_serialize_PointerTobool(soap, &this->ns1__GetDataHeaders::quotecompositehist);
	soap_serialize_PointerTobool(soap, &this->ns1__GetDataHeaders::exclusive_USCOREpricing_USCOREsrc);
	soap_serialize_PointerTobool(soap, &this->ns1__GetDataHeaders::estimates);
	soap_serialize_PointerTons1__BvalTier(soap, &this->ns1__GetDataHeaders::bvaltier);
	soap_serialize_PointerTons1__BvalSnapshot(soap, &this->ns1__GetDataHeaders::bvalsnapshot);
	soap_serialize_PointerTostd__string(soap, &this->ns1__GetDataHeaders::bvalsnapshotdate);
	soap_serialize_PointerTobool(soap, &this->ns1__GetDataHeaders::bvalbeta);
	soap_serialize_PointerTostd__string(soap, &this->ns1__GetDataHeaders::pricing_USCOREsource);
	soap_serialize_PointerTons1__PortSecDes(soap, &this->ns1__GetDataHeaders::portsecdes);
	soap_serialize_PointerToint(soap, &this->ns1__GetDataHeaders::prp);
	soap_serialize_PointerTobool(soap, &this->ns1__GetDataHeaders::fundamentals);
	soap_serialize_PointerTobool(soap, &this->ns1__GetDataHeaders::pricing);
	soap_serialize_PointerTostd__string(soap, &this->ns1__GetDataHeaders::skip_USCOREpcs);
	soap_serialize_PointerTobool(soap, &this->ns1__GetDataHeaders::vol_USCOREsurface);
	soap_serialize_PointerTobool(soap, &this->ns1__GetDataHeaders::regssfa);
	soap_serialize_PointerTobool(soap, &this->ns1__GetDataHeaders::regfvhl);
	soap_serialize_PointerTobool(soap, &this->ns1__GetDataHeaders::regtransparency);
	soap_serialize_PointerTobool(soap, &this->ns1__GetDataHeaders::regcomp);
	soap_serialize_PointerTobool(soap, &this->ns1__GetDataHeaders::corpstruct);
	soap_serialize_PointerTobool(soap, &this->ns1__GetDataHeaders::capstruct);
	soap_serialize_PointerTons1__RegSolvency(soap, &this->ns1__GetDataHeaders::regsolvency);
	soap_serialize_PointerTobool(soap, &this->ns1__GetDataHeaders::reghqla);
	soap_serialize_PointerTobool(soap, &this->ns1__GetDataHeaders::reghqlaamer);
	soap_serialize_PointerTobool(soap, &this->ns1__GetDataHeaders::reghqlaeuro);
	soap_serialize_PointerTobool(soap, &this->ns1__GetDataHeaders::reghqlaasia);
	soap_serialize_PointerTobool(soap, &this->ns1__GetDataHeaders::regcbe);
	soap_serialize_PointerTobool(soap, &this->ns1__GetDataHeaders::regcfid);
	soap_serialize_PointerTobool(soap, &this->ns1__GetDataHeaders::reglqa);
	soap_serialize_PointerTobool(soap, &this->ns1__GetDataHeaders::mifir);
	soap_serialize_PointerTobool(soap, &this->ns1__GetDataHeaders::defaultrisk);
	soap_serialize_PointerTobool(soap, &this->ns1__GetDataHeaders::ifrs9sppi);
	soap_serialize_PointerTobool(soap, &this->ns1__GetDataHeaders::coltag);
	soap_serialize_PointerTobool(soap, &this->ns1__GetDataHeaders::uswhldtax);
	soap_serialize_PointerTobool(soap, &this->ns1__GetDataHeaders::regecl);
	soap_serialize_PointerTobool(soap, &this->ns1__GetDataHeaders::basictax);
	soap_serialize_PointerTobool(soap, &this->ns1__GetDataHeaders::invstprot);
	soap_serialize_PointerTostd__string(soap, &this->ns1__GetDataHeaders::encoding);
#endif
}

int ns1__GetDataHeaders::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__GetDataHeaders(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetDataHeaders(struct soap *soap, const char *tag, int id, const ns1__GetDataHeaders *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetDataHeaders), type))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:closingvalues", -1, &a->ns1__GetDataHeaders::closingvalues, ""))
		return soap->error;
	if (soap_out_PointerTons1__DateFormat(soap, "ns1:dateformat", -1, &a->ns1__GetDataHeaders::dateformat, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:derived", -1, &a->ns1__GetDataHeaders::derived, ""))
		return soap->error;
	if (soap_out_PointerTons1__DiffFlag(soap, "ns1:diffflag", -1, &a->ns1__GetDataHeaders::diffflag, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:hist_crncy", -1, &a->ns1__GetDataHeaders::hist_USCOREcrncy, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:historical", -1, &a->ns1__GetDataHeaders::historical, ""))
		return soap->error;
	if (soap_out_PointerTons1__ProgramFlag(soap, "ns1:programflag", -1, &a->ns1__GetDataHeaders::programflag, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:rundate", -1, &a->ns1__GetDataHeaders::rundate, ""))
		return soap->error;
	if (soap_out_PointerTons1__InstrumentType(soap, "ns1:secid", -1, &a->ns1__GetDataHeaders::secid, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:secmaster", -1, &a->ns1__GetDataHeaders::secmaster, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:sn", -1, &a->ns1__GetDataHeaders::sn, ""))
		return soap->error;
	if (soap_out_PointerTons1__SpecialChar(soap, "ns1:specialchar", -1, &a->ns1__GetDataHeaders::specialchar, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:time", -1, &a->ns1__GetDataHeaders::time, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:login", -1, &a->ns1__GetDataHeaders::login, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:usernumber", -1, &a->ns1__GetDataHeaders::usernumber, ""))
		return soap->error;
	if (soap_out_PointerTons1__Version(soap, "ns1:version", -1, &a->ns1__GetDataHeaders::version, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:ws", -1, &a->ns1__GetDataHeaders::ws, ""))
		return soap->error;
	if (soap_out_PointerTons1__MarketSector(soap, "ns1:yellowkey", -1, &a->ns1__GetDataHeaders::yellowkey, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:quotecomposite", -1, &a->ns1__GetDataHeaders::quotecomposite, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:creditrisk", -1, &a->ns1__GetDataHeaders::creditrisk, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:quotecompositehist", -1, &a->ns1__GetDataHeaders::quotecompositehist, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:exclusive_pricing_src", -1, &a->ns1__GetDataHeaders::exclusive_USCOREpricing_USCOREsrc, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:estimates", -1, &a->ns1__GetDataHeaders::estimates, ""))
		return soap->error;
	if (soap_out_PointerTons1__BvalTier(soap, "ns1:bvaltier", -1, &a->ns1__GetDataHeaders::bvaltier, ""))
		return soap->error;
	if (soap_out_PointerTons1__BvalSnapshot(soap, "ns1:bvalsnapshot", -1, &a->ns1__GetDataHeaders::bvalsnapshot, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:bvalsnapshotdate", -1, &a->ns1__GetDataHeaders::bvalsnapshotdate, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:bvalbeta", -1, &a->ns1__GetDataHeaders::bvalbeta, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:pricing_source", -1, &a->ns1__GetDataHeaders::pricing_USCOREsource, ""))
		return soap->error;
	if (soap_out_PointerTons1__PortSecDes(soap, "ns1:portsecdes", -1, &a->ns1__GetDataHeaders::portsecdes, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:prp", -1, &a->ns1__GetDataHeaders::prp, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:fundamentals", -1, &a->ns1__GetDataHeaders::fundamentals, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:pricing", -1, &a->ns1__GetDataHeaders::pricing, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:skip_pcs", -1, &a->ns1__GetDataHeaders::skip_USCOREpcs, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:vol_surface", -1, &a->ns1__GetDataHeaders::vol_USCOREsurface, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:regssfa", -1, &a->ns1__GetDataHeaders::regssfa, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:regfvhl", -1, &a->ns1__GetDataHeaders::regfvhl, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:regtransparency", -1, &a->ns1__GetDataHeaders::regtransparency, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:regcomp", -1, &a->ns1__GetDataHeaders::regcomp, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:corpstruct", -1, &a->ns1__GetDataHeaders::corpstruct, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:capstruct", -1, &a->ns1__GetDataHeaders::capstruct, ""))
		return soap->error;
	if (soap_out_PointerTons1__RegSolvency(soap, "ns1:regsolvency", -1, &a->ns1__GetDataHeaders::regsolvency, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:reghqla", -1, &a->ns1__GetDataHeaders::reghqla, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:reghqlaamer", -1, &a->ns1__GetDataHeaders::reghqlaamer, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:reghqlaeuro", -1, &a->ns1__GetDataHeaders::reghqlaeuro, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:reghqlaasia", -1, &a->ns1__GetDataHeaders::reghqlaasia, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:regcbe", -1, &a->ns1__GetDataHeaders::regcbe, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:regcfid", -1, &a->ns1__GetDataHeaders::regcfid, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:reglqa", -1, &a->ns1__GetDataHeaders::reglqa, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:mifir", -1, &a->ns1__GetDataHeaders::mifir, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:defaultrisk", -1, &a->ns1__GetDataHeaders::defaultrisk, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:ifrs9sppi", -1, &a->ns1__GetDataHeaders::ifrs9sppi, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:coltag", -1, &a->ns1__GetDataHeaders::coltag, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:uswhldtax", -1, &a->ns1__GetDataHeaders::uswhldtax, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:regecl", -1, &a->ns1__GetDataHeaders::regecl, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:basictax", -1, &a->ns1__GetDataHeaders::basictax, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:invstprot", -1, &a->ns1__GetDataHeaders::invstprot, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:encoding", -1, &a->ns1__GetDataHeaders::encoding, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__GetDataHeaders::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__GetDataHeaders(soap, tag, this, type);
}

SOAP_FMAC3 ns1__GetDataHeaders * SOAP_FMAC4 soap_in_ns1__GetDataHeaders(struct soap *soap, const char *tag, ns1__GetDataHeaders *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__GetDataHeaders*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetDataHeaders, sizeof(ns1__GetDataHeaders), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__GetDataHeaders)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__GetDataHeaders *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_closingvalues1 = 1;
	size_t soap_flag_dateformat1 = 1;
	size_t soap_flag_derived1 = 1;
	size_t soap_flag_diffflag1 = 1;
	size_t soap_flag_hist_USCOREcrncy1 = 1;
	size_t soap_flag_historical1 = 1;
	size_t soap_flag_programflag1 = 1;
	size_t soap_flag_rundate1 = 1;
	size_t soap_flag_secid1 = 1;
	size_t soap_flag_secmaster1 = 1;
	size_t soap_flag_sn1 = 1;
	size_t soap_flag_specialchar1 = 1;
	size_t soap_flag_time1 = 1;
	size_t soap_flag_login1 = 1;
	size_t soap_flag_usernumber1 = 1;
	size_t soap_flag_version1 = 1;
	size_t soap_flag_ws1 = 1;
	size_t soap_flag_yellowkey1 = 1;
	size_t soap_flag_quotecomposite1 = 1;
	size_t soap_flag_creditrisk1 = 1;
	size_t soap_flag_quotecompositehist1 = 1;
	size_t soap_flag_exclusive_USCOREpricing_USCOREsrc1 = 1;
	size_t soap_flag_estimates1 = 1;
	size_t soap_flag_bvaltier1 = 1;
	size_t soap_flag_bvalsnapshot1 = 1;
	size_t soap_flag_bvalsnapshotdate1 = 1;
	size_t soap_flag_bvalbeta1 = 1;
	size_t soap_flag_pricing_USCOREsource1 = 1;
	size_t soap_flag_portsecdes1 = 1;
	size_t soap_flag_prp1 = 1;
	size_t soap_flag_fundamentals1 = 1;
	size_t soap_flag_pricing1 = 1;
	size_t soap_flag_skip_USCOREpcs1 = 1;
	size_t soap_flag_vol_USCOREsurface1 = 1;
	size_t soap_flag_regssfa1 = 1;
	size_t soap_flag_regfvhl1 = 1;
	size_t soap_flag_regtransparency1 = 1;
	size_t soap_flag_regcomp1 = 1;
	size_t soap_flag_corpstruct1 = 1;
	size_t soap_flag_capstruct1 = 1;
	size_t soap_flag_regsolvency1 = 1;
	size_t soap_flag_reghqla1 = 1;
	size_t soap_flag_reghqlaamer1 = 1;
	size_t soap_flag_reghqlaeuro1 = 1;
	size_t soap_flag_reghqlaasia1 = 1;
	size_t soap_flag_regcbe1 = 1;
	size_t soap_flag_regcfid1 = 1;
	size_t soap_flag_reglqa1 = 1;
	size_t soap_flag_mifir1 = 1;
	size_t soap_flag_defaultrisk1 = 1;
	size_t soap_flag_ifrs9sppi1 = 1;
	size_t soap_flag_coltag1 = 1;
	size_t soap_flag_uswhldtax1 = 1;
	size_t soap_flag_regecl1 = 1;
	size_t soap_flag_basictax1 = 1;
	size_t soap_flag_invstprot1 = 1;
	size_t soap_flag_encoding1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_closingvalues1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:closingvalues", &a->ns1__GetDataHeaders::closingvalues, "xsd:boolean"))
				{	soap_flag_closingvalues1--;
					continue;
				}
			}
			if (soap_flag_dateformat1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__DateFormat(soap, "ns1:dateformat", &a->ns1__GetDataHeaders::dateformat, "ns1:DateFormat"))
				{	soap_flag_dateformat1--;
					continue;
				}
			}
			if (soap_flag_derived1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:derived", &a->ns1__GetDataHeaders::derived, "xsd:boolean"))
				{	soap_flag_derived1--;
					continue;
				}
			}
			if (soap_flag_diffflag1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__DiffFlag(soap, "ns1:diffflag", &a->ns1__GetDataHeaders::diffflag, "ns1:DiffFlag"))
				{	soap_flag_diffflag1--;
					continue;
				}
			}
			if (soap_flag_hist_USCOREcrncy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:hist_crncy", &a->ns1__GetDataHeaders::hist_USCOREcrncy, "xsd:string"))
				{	soap_flag_hist_USCOREcrncy1--;
					continue;
				}
			}
			if (soap_flag_historical1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:historical", &a->ns1__GetDataHeaders::historical, "xsd:boolean"))
				{	soap_flag_historical1--;
					continue;
				}
			}
			if (soap_flag_programflag1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ProgramFlag(soap, "ns1:programflag", &a->ns1__GetDataHeaders::programflag, "ns1:ProgramFlag"))
				{	soap_flag_programflag1--;
					continue;
				}
			}
			if (soap_flag_rundate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:rundate", &a->ns1__GetDataHeaders::rundate, "xsd:string"))
				{	soap_flag_rundate1--;
					continue;
				}
			}
			if (soap_flag_secid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__InstrumentType(soap, "ns1:secid", &a->ns1__GetDataHeaders::secid, "ns1:InstrumentType"))
				{	soap_flag_secid1--;
					continue;
				}
			}
			if (soap_flag_secmaster1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:secmaster", &a->ns1__GetDataHeaders::secmaster, "xsd:boolean"))
				{	soap_flag_secmaster1--;
					continue;
				}
			}
			if (soap_flag_sn1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns1:sn", &a->ns1__GetDataHeaders::sn, "xsd:int"))
				{	soap_flag_sn1--;
					continue;
				}
			}
			if (soap_flag_specialchar1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__SpecialChar(soap, "ns1:specialchar", &a->ns1__GetDataHeaders::specialchar, "ns1:SpecialChar"))
				{	soap_flag_specialchar1--;
					continue;
				}
			}
			if (soap_flag_time1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:time", &a->ns1__GetDataHeaders::time, "xsd:string"))
				{	soap_flag_time1--;
					continue;
				}
			}
			if (soap_flag_login1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:login", &a->ns1__GetDataHeaders::login, "xsd:string"))
				{	soap_flag_login1--;
					continue;
				}
			}
			if (soap_flag_usernumber1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns1:usernumber", &a->ns1__GetDataHeaders::usernumber, "xsd:int"))
				{	soap_flag_usernumber1--;
					continue;
				}
			}
			if (soap_flag_version1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Version(soap, "ns1:version", &a->ns1__GetDataHeaders::version, "ns1:Version"))
				{	soap_flag_version1--;
					continue;
				}
			}
			if (soap_flag_ws1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns1:ws", &a->ns1__GetDataHeaders::ws, "xsd:int"))
				{	soap_flag_ws1--;
					continue;
				}
			}
			if (soap_flag_yellowkey1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__MarketSector(soap, "ns1:yellowkey", &a->ns1__GetDataHeaders::yellowkey, "ns1:MarketSector"))
				{	soap_flag_yellowkey1--;
					continue;
				}
			}
			if (soap_flag_quotecomposite1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:quotecomposite", &a->ns1__GetDataHeaders::quotecomposite, "xsd:boolean"))
				{	soap_flag_quotecomposite1--;
					continue;
				}
			}
			if (soap_flag_creditrisk1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:creditrisk", &a->ns1__GetDataHeaders::creditrisk, "xsd:boolean"))
				{	soap_flag_creditrisk1--;
					continue;
				}
			}
			if (soap_flag_quotecompositehist1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:quotecompositehist", &a->ns1__GetDataHeaders::quotecompositehist, "xsd:boolean"))
				{	soap_flag_quotecompositehist1--;
					continue;
				}
			}
			if (soap_flag_exclusive_USCOREpricing_USCOREsrc1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:exclusive_pricing_src", &a->ns1__GetDataHeaders::exclusive_USCOREpricing_USCOREsrc, "xsd:boolean"))
				{	soap_flag_exclusive_USCOREpricing_USCOREsrc1--;
					continue;
				}
			}
			if (soap_flag_estimates1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:estimates", &a->ns1__GetDataHeaders::estimates, "xsd:boolean"))
				{	soap_flag_estimates1--;
					continue;
				}
			}
			if (soap_flag_bvaltier1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__BvalTier(soap, "ns1:bvaltier", &a->ns1__GetDataHeaders::bvaltier, "ns1:BvalTier"))
				{	soap_flag_bvaltier1--;
					continue;
				}
			}
			if (soap_flag_bvalsnapshot1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__BvalSnapshot(soap, "ns1:bvalsnapshot", &a->ns1__GetDataHeaders::bvalsnapshot, "ns1:BvalSnapshot"))
				{	soap_flag_bvalsnapshot1--;
					continue;
				}
			}
			if (soap_flag_bvalsnapshotdate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:bvalsnapshotdate", &a->ns1__GetDataHeaders::bvalsnapshotdate, "xsd:string"))
				{	soap_flag_bvalsnapshotdate1--;
					continue;
				}
			}
			if (soap_flag_bvalbeta1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:bvalbeta", &a->ns1__GetDataHeaders::bvalbeta, "xsd:boolean"))
				{	soap_flag_bvalbeta1--;
					continue;
				}
			}
			if (soap_flag_pricing_USCOREsource1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:pricing_source", &a->ns1__GetDataHeaders::pricing_USCOREsource, "xsd:string"))
				{	soap_flag_pricing_USCOREsource1--;
					continue;
				}
			}
			if (soap_flag_portsecdes1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__PortSecDes(soap, "ns1:portsecdes", &a->ns1__GetDataHeaders::portsecdes, "ns1:PortSecDes"))
				{	soap_flag_portsecdes1--;
					continue;
				}
			}
			if (soap_flag_prp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns1:prp", &a->ns1__GetDataHeaders::prp, "xsd:int"))
				{	soap_flag_prp1--;
					continue;
				}
			}
			if (soap_flag_fundamentals1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:fundamentals", &a->ns1__GetDataHeaders::fundamentals, "xsd:boolean"))
				{	soap_flag_fundamentals1--;
					continue;
				}
			}
			if (soap_flag_pricing1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:pricing", &a->ns1__GetDataHeaders::pricing, "xsd:boolean"))
				{	soap_flag_pricing1--;
					continue;
				}
			}
			if (soap_flag_skip_USCOREpcs1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:skip_pcs", &a->ns1__GetDataHeaders::skip_USCOREpcs, "xsd:string"))
				{	soap_flag_skip_USCOREpcs1--;
					continue;
				}
			}
			if (soap_flag_vol_USCOREsurface1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:vol_surface", &a->ns1__GetDataHeaders::vol_USCOREsurface, "xsd:boolean"))
				{	soap_flag_vol_USCOREsurface1--;
					continue;
				}
			}
			if (soap_flag_regssfa1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:regssfa", &a->ns1__GetDataHeaders::regssfa, "xsd:boolean"))
				{	soap_flag_regssfa1--;
					continue;
				}
			}
			if (soap_flag_regfvhl1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:regfvhl", &a->ns1__GetDataHeaders::regfvhl, "xsd:boolean"))
				{	soap_flag_regfvhl1--;
					continue;
				}
			}
			if (soap_flag_regtransparency1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:regtransparency", &a->ns1__GetDataHeaders::regtransparency, "xsd:boolean"))
				{	soap_flag_regtransparency1--;
					continue;
				}
			}
			if (soap_flag_regcomp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:regcomp", &a->ns1__GetDataHeaders::regcomp, "xsd:boolean"))
				{	soap_flag_regcomp1--;
					continue;
				}
			}
			if (soap_flag_corpstruct1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:corpstruct", &a->ns1__GetDataHeaders::corpstruct, "xsd:boolean"))
				{	soap_flag_corpstruct1--;
					continue;
				}
			}
			if (soap_flag_capstruct1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:capstruct", &a->ns1__GetDataHeaders::capstruct, "xsd:boolean"))
				{	soap_flag_capstruct1--;
					continue;
				}
			}
			if (soap_flag_regsolvency1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__RegSolvency(soap, "ns1:regsolvency", &a->ns1__GetDataHeaders::regsolvency, "ns1:RegSolvency"))
				{	soap_flag_regsolvency1--;
					continue;
				}
			}
			if (soap_flag_reghqla1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:reghqla", &a->ns1__GetDataHeaders::reghqla, "xsd:boolean"))
				{	soap_flag_reghqla1--;
					continue;
				}
			}
			if (soap_flag_reghqlaamer1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:reghqlaamer", &a->ns1__GetDataHeaders::reghqlaamer, "xsd:boolean"))
				{	soap_flag_reghqlaamer1--;
					continue;
				}
			}
			if (soap_flag_reghqlaeuro1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:reghqlaeuro", &a->ns1__GetDataHeaders::reghqlaeuro, "xsd:boolean"))
				{	soap_flag_reghqlaeuro1--;
					continue;
				}
			}
			if (soap_flag_reghqlaasia1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:reghqlaasia", &a->ns1__GetDataHeaders::reghqlaasia, "xsd:boolean"))
				{	soap_flag_reghqlaasia1--;
					continue;
				}
			}
			if (soap_flag_regcbe1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:regcbe", &a->ns1__GetDataHeaders::regcbe, "xsd:boolean"))
				{	soap_flag_regcbe1--;
					continue;
				}
			}
			if (soap_flag_regcfid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:regcfid", &a->ns1__GetDataHeaders::regcfid, "xsd:boolean"))
				{	soap_flag_regcfid1--;
					continue;
				}
			}
			if (soap_flag_reglqa1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:reglqa", &a->ns1__GetDataHeaders::reglqa, "xsd:boolean"))
				{	soap_flag_reglqa1--;
					continue;
				}
			}
			if (soap_flag_mifir1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:mifir", &a->ns1__GetDataHeaders::mifir, "xsd:boolean"))
				{	soap_flag_mifir1--;
					continue;
				}
			}
			if (soap_flag_defaultrisk1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:defaultrisk", &a->ns1__GetDataHeaders::defaultrisk, "xsd:boolean"))
				{	soap_flag_defaultrisk1--;
					continue;
				}
			}
			if (soap_flag_ifrs9sppi1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:ifrs9sppi", &a->ns1__GetDataHeaders::ifrs9sppi, "xsd:boolean"))
				{	soap_flag_ifrs9sppi1--;
					continue;
				}
			}
			if (soap_flag_coltag1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:coltag", &a->ns1__GetDataHeaders::coltag, "xsd:boolean"))
				{	soap_flag_coltag1--;
					continue;
				}
			}
			if (soap_flag_uswhldtax1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:uswhldtax", &a->ns1__GetDataHeaders::uswhldtax, "xsd:boolean"))
				{	soap_flag_uswhldtax1--;
					continue;
				}
			}
			if (soap_flag_regecl1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:regecl", &a->ns1__GetDataHeaders::regecl, "xsd:boolean"))
				{	soap_flag_regecl1--;
					continue;
				}
			}
			if (soap_flag_basictax1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:basictax", &a->ns1__GetDataHeaders::basictax, "xsd:boolean"))
				{	soap_flag_basictax1--;
					continue;
				}
			}
			if (soap_flag_invstprot1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:invstprot", &a->ns1__GetDataHeaders::invstprot, "xsd:boolean"))
				{	soap_flag_invstprot1--;
					continue;
				}
			}
			if (soap_flag_encoding1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:encoding", &a->ns1__GetDataHeaders::encoding, "xsd:string"))
				{	soap_flag_encoding1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__GetDataHeaders *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetDataHeaders, SOAP_TYPE_ns1__GetDataHeaders, sizeof(ns1__GetDataHeaders), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__GetDataHeaders * SOAP_FMAC2 soap_instantiate_ns1__GetDataHeaders(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetDataHeaders(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__GetDataHeaders *p;
	size_t k = sizeof(ns1__GetDataHeaders);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetDataHeaders, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__GetDataHeaders);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__GetDataHeaders, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__GetDataHeaders location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__GetDataHeaders::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__GetDataHeaders(soap, tag ? tag : "ns1:GetDataHeaders", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__GetDataHeaders::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__GetDataHeaders(soap, this, tag, type);
}

SOAP_FMAC3 ns1__GetDataHeaders * SOAP_FMAC4 soap_get_ns1__GetDataHeaders(struct soap *soap, ns1__GetDataHeaders *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetDataHeaders(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__GetCorrectionsHeaders::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__GetCorrectionsHeaders::dateformat = NULL;
}

void ns1__GetCorrectionsHeaders::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__DateFormat(soap, &this->ns1__GetCorrectionsHeaders::dateformat);
#endif
}

int ns1__GetCorrectionsHeaders::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__GetCorrectionsHeaders(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetCorrectionsHeaders(struct soap *soap, const char *tag, int id, const ns1__GetCorrectionsHeaders *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetCorrectionsHeaders), type))
		return soap->error;
	if (soap_out_PointerTons1__DateFormat(soap, "ns1:dateformat", -1, &a->ns1__GetCorrectionsHeaders::dateformat, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__GetCorrectionsHeaders::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__GetCorrectionsHeaders(soap, tag, this, type);
}

SOAP_FMAC3 ns1__GetCorrectionsHeaders * SOAP_FMAC4 soap_in_ns1__GetCorrectionsHeaders(struct soap *soap, const char *tag, ns1__GetCorrectionsHeaders *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__GetCorrectionsHeaders*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetCorrectionsHeaders, sizeof(ns1__GetCorrectionsHeaders), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__GetCorrectionsHeaders)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__GetCorrectionsHeaders *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_dateformat1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dateformat1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__DateFormat(soap, "ns1:dateformat", &a->ns1__GetCorrectionsHeaders::dateformat, "ns1:DateFormat"))
				{	soap_flag_dateformat1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__GetCorrectionsHeaders *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetCorrectionsHeaders, SOAP_TYPE_ns1__GetCorrectionsHeaders, sizeof(ns1__GetCorrectionsHeaders), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__GetCorrectionsHeaders * SOAP_FMAC2 soap_instantiate_ns1__GetCorrectionsHeaders(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetCorrectionsHeaders(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__GetCorrectionsHeaders *p;
	size_t k = sizeof(ns1__GetCorrectionsHeaders);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetCorrectionsHeaders, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__GetCorrectionsHeaders);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__GetCorrectionsHeaders, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__GetCorrectionsHeaders location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__GetCorrectionsHeaders::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__GetCorrectionsHeaders(soap, tag ? tag : "ns1:GetCorrectionsHeaders", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__GetCorrectionsHeaders::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__GetCorrectionsHeaders(soap, this, tag, type);
}

SOAP_FMAC3 ns1__GetCorrectionsHeaders * SOAP_FMAC4 soap_get_ns1__GetCorrectionsHeaders(struct soap *soap, ns1__GetCorrectionsHeaders *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetCorrectionsHeaders(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__CancelHeaders::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__ProgramFlag(soap, &this->ns1__CancelHeaders::programflag);
}

void ns1__CancelHeaders::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__CancelHeaders::programflag, SOAP_TYPE_ns1__ProgramFlag);
#endif
}

int ns1__CancelHeaders::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CancelHeaders(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CancelHeaders(struct soap *soap, const char *tag, int id, const ns1__CancelHeaders *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CancelHeaders), type))
		return soap->error;
	if (soap_out_ns1__ProgramFlag(soap, "ns1:programflag", -1, &a->ns1__CancelHeaders::programflag, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CancelHeaders::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__CancelHeaders(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CancelHeaders * SOAP_FMAC4 soap_in_ns1__CancelHeaders(struct soap *soap, const char *tag, ns1__CancelHeaders *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CancelHeaders*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CancelHeaders, sizeof(ns1__CancelHeaders), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__CancelHeaders)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__CancelHeaders *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_programflag1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_programflag1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns1__ProgramFlag(soap, "ns1:programflag", &a->ns1__CancelHeaders::programflag, "ns1:ProgramFlag"))
				{	soap_flag_programflag1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_programflag1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__CancelHeaders *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CancelHeaders, SOAP_TYPE_ns1__CancelHeaders, sizeof(ns1__CancelHeaders), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__CancelHeaders * SOAP_FMAC2 soap_instantiate_ns1__CancelHeaders(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CancelHeaders(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__CancelHeaders *p;
	size_t k = sizeof(ns1__CancelHeaders);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__CancelHeaders, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__CancelHeaders);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__CancelHeaders, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__CancelHeaders location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__CancelHeaders::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__CancelHeaders(soap, tag ? tag : "ns1:CancelHeaders", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CancelHeaders::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CancelHeaders(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CancelHeaders * SOAP_FMAC4 soap_get_ns1__CancelHeaders(struct soap *soap, ns1__CancelHeaders *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CancelHeaders(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__time(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__time(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__time), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__time(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__time, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "\\d{2}:\\d{2}:\\d{2}(Z|[-+]\\d{2}:\\d{2})?")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__time, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__time, SOAP_TYPE_xsd__time, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__time(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__time(soap, tag ? tag : "xsd:time", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__time(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__date(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__date(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__date), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__date(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__date, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "[-+]?\\d{4,}-\\d{2}-\\d{2}(Z|[-+]\\d{2}:\\d{2})?")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__date, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__date, SOAP_TYPE_xsd__date, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__date(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__date(soap, tag ? tag : "xsd:date", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__date(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__date(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_std__string, SOAP_TYPE_std__string, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::string *p;
	size_t k = sizeof(std::string);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::string);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::string, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::string location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_std__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode;
	soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Fault*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Fault *p;
	size_t k = sizeof(struct SOAP_ENV__Fault);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Fault location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Reason*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Reason *p;
	size_t k = sizeof(struct SOAP_ENV__Reason);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Reason);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Reason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Reason location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Detail*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->fault = soap_getelement(soap, "fault", &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value;
	soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Code*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Code *p;
	size_t k = sizeof(struct SOAP_ENV__Code);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Code);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Code, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Code location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Header*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__retrieveMmktBvalDealsUploadResponse(struct soap *soap, struct __ns1__retrieveMmktBvalDealsUploadResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__retrieveMmktBvalDealsUploadRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__retrieveMmktBvalDealsUploadResponse(struct soap *soap, const struct __ns1__retrieveMmktBvalDealsUploadResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RetrieveMmktBvalDealsUploadRequest(soap, &a->ns1__retrieveMmktBvalDealsUploadRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__retrieveMmktBvalDealsUploadResponse(struct soap *soap, const char *tag, int id, const struct __ns1__retrieveMmktBvalDealsUploadResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__RetrieveMmktBvalDealsUploadRequest(soap, "ns1:retrieveMmktBvalDealsUploadRequest", -1, &a->ns1__retrieveMmktBvalDealsUploadRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__retrieveMmktBvalDealsUploadResponse * SOAP_FMAC4 soap_in___ns1__retrieveMmktBvalDealsUploadResponse(struct soap *soap, const char *tag, struct __ns1__retrieveMmktBvalDealsUploadResponse *a, const char *type)
{
	size_t soap_flag_ns1__retrieveMmktBvalDealsUploadRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__retrieveMmktBvalDealsUploadResponse*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__retrieveMmktBvalDealsUploadResponse, sizeof(struct __ns1__retrieveMmktBvalDealsUploadResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__retrieveMmktBvalDealsUploadResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__retrieveMmktBvalDealsUploadRequest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__RetrieveMmktBvalDealsUploadRequest(soap, "ns1:retrieveMmktBvalDealsUploadRequest", &a->ns1__retrieveMmktBvalDealsUploadRequest, "ns1:RetrieveMmktBvalDealsUploadRequest"))
				{	soap_flag_ns1__retrieveMmktBvalDealsUploadRequest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__retrieveMmktBvalDealsUploadResponse * SOAP_FMAC2 soap_instantiate___ns1__retrieveMmktBvalDealsUploadResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__retrieveMmktBvalDealsUploadResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__retrieveMmktBvalDealsUploadResponse *p;
	size_t k = sizeof(struct __ns1__retrieveMmktBvalDealsUploadResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__retrieveMmktBvalDealsUploadResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__retrieveMmktBvalDealsUploadResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__retrieveMmktBvalDealsUploadResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__retrieveMmktBvalDealsUploadResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__retrieveMmktBvalDealsUploadResponse(struct soap *soap, const struct __ns1__retrieveMmktBvalDealsUploadResponse *a, const char *tag, const char *type)
{
	if (soap_out___ns1__retrieveMmktBvalDealsUploadResponse(soap, tag ? tag : "-ns1:retrieveMmktBvalDealsUploadResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__retrieveMmktBvalDealsUploadResponse * SOAP_FMAC4 soap_get___ns1__retrieveMmktBvalDealsUploadResponse(struct soap *soap, struct __ns1__retrieveMmktBvalDealsUploadResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__retrieveMmktBvalDealsUploadResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__submitMmktBvalDealsUploadRequest(struct soap *soap, struct __ns1__submitMmktBvalDealsUploadRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__submitMmktBvalDealsUploadRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__submitMmktBvalDealsUploadRequest(struct soap *soap, const struct __ns1__submitMmktBvalDealsUploadRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SubmitMmktBvalDealsUploadRequest(soap, &a->ns1__submitMmktBvalDealsUploadRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__submitMmktBvalDealsUploadRequest(struct soap *soap, const char *tag, int id, const struct __ns1__submitMmktBvalDealsUploadRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SubmitMmktBvalDealsUploadRequest(soap, "ns1:submitMmktBvalDealsUploadRequest", -1, &a->ns1__submitMmktBvalDealsUploadRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__submitMmktBvalDealsUploadRequest * SOAP_FMAC4 soap_in___ns1__submitMmktBvalDealsUploadRequest(struct soap *soap, const char *tag, struct __ns1__submitMmktBvalDealsUploadRequest *a, const char *type)
{
	size_t soap_flag_ns1__submitMmktBvalDealsUploadRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__submitMmktBvalDealsUploadRequest*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__submitMmktBvalDealsUploadRequest, sizeof(struct __ns1__submitMmktBvalDealsUploadRequest), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__submitMmktBvalDealsUploadRequest(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__submitMmktBvalDealsUploadRequest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__SubmitMmktBvalDealsUploadRequest(soap, "ns1:submitMmktBvalDealsUploadRequest", &a->ns1__submitMmktBvalDealsUploadRequest, "ns1:SubmitMmktBvalDealsUploadRequest"))
				{	soap_flag_ns1__submitMmktBvalDealsUploadRequest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__submitMmktBvalDealsUploadRequest * SOAP_FMAC2 soap_instantiate___ns1__submitMmktBvalDealsUploadRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__submitMmktBvalDealsUploadRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__submitMmktBvalDealsUploadRequest *p;
	size_t k = sizeof(struct __ns1__submitMmktBvalDealsUploadRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__submitMmktBvalDealsUploadRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__submitMmktBvalDealsUploadRequest);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__submitMmktBvalDealsUploadRequest, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__submitMmktBvalDealsUploadRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__submitMmktBvalDealsUploadRequest(struct soap *soap, const struct __ns1__submitMmktBvalDealsUploadRequest *a, const char *tag, const char *type)
{
	if (soap_out___ns1__submitMmktBvalDealsUploadRequest(soap, tag ? tag : "-ns1:submitMmktBvalDealsUploadRequest", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__submitMmktBvalDealsUploadRequest * SOAP_FMAC4 soap_get___ns1__submitMmktBvalDealsUploadRequest(struct soap *soap, struct __ns1__submitMmktBvalDealsUploadRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__submitMmktBvalDealsUploadRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getFields(struct soap *soap, struct __ns1__getFields *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getFieldsRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getFields(struct soap *soap, const struct __ns1__getFields *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__GetFieldsRequest(soap, &a->ns1__getFieldsRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getFields(struct soap *soap, const char *tag, int id, const struct __ns1__getFields *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__GetFieldsRequest(soap, "ns1:getFieldsRequest", -1, &a->ns1__getFieldsRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getFields * SOAP_FMAC4 soap_in___ns1__getFields(struct soap *soap, const char *tag, struct __ns1__getFields *a, const char *type)
{
	size_t soap_flag_ns1__getFieldsRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getFields*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getFields, sizeof(struct __ns1__getFields), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getFields(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getFieldsRequest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GetFieldsRequest(soap, "ns1:getFieldsRequest", &a->ns1__getFieldsRequest, "ns1:GetFieldsRequest"))
				{	soap_flag_ns1__getFieldsRequest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getFields * SOAP_FMAC2 soap_instantiate___ns1__getFields(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getFields(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getFields *p;
	size_t k = sizeof(struct __ns1__getFields);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__getFields, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__getFields);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__getFields, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getFields location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getFields(struct soap *soap, const struct __ns1__getFields *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getFields(soap, tag ? tag : "-ns1:getFields", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getFields * SOAP_FMAC4 soap_get___ns1__getFields(struct soap *soap, struct __ns1__getFields *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getFields(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__retrieveOtcBvalDealsUploadResponse(struct soap *soap, struct __ns1__retrieveOtcBvalDealsUploadResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__retrieveOtcBvalDealsUploadRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__retrieveOtcBvalDealsUploadResponse(struct soap *soap, const struct __ns1__retrieveOtcBvalDealsUploadResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RetrieveOtcBvalDealsUploadRequest(soap, &a->ns1__retrieveOtcBvalDealsUploadRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__retrieveOtcBvalDealsUploadResponse(struct soap *soap, const char *tag, int id, const struct __ns1__retrieveOtcBvalDealsUploadResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__RetrieveOtcBvalDealsUploadRequest(soap, "ns1:retrieveOtcBvalDealsUploadRequest", -1, &a->ns1__retrieveOtcBvalDealsUploadRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__retrieveOtcBvalDealsUploadResponse * SOAP_FMAC4 soap_in___ns1__retrieveOtcBvalDealsUploadResponse(struct soap *soap, const char *tag, struct __ns1__retrieveOtcBvalDealsUploadResponse *a, const char *type)
{
	size_t soap_flag_ns1__retrieveOtcBvalDealsUploadRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__retrieveOtcBvalDealsUploadResponse*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__retrieveOtcBvalDealsUploadResponse, sizeof(struct __ns1__retrieveOtcBvalDealsUploadResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__retrieveOtcBvalDealsUploadResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__retrieveOtcBvalDealsUploadRequest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__RetrieveOtcBvalDealsUploadRequest(soap, "ns1:retrieveOtcBvalDealsUploadRequest", &a->ns1__retrieveOtcBvalDealsUploadRequest, "ns1:RetrieveOtcBvalDealsUploadRequest"))
				{	soap_flag_ns1__retrieveOtcBvalDealsUploadRequest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__retrieveOtcBvalDealsUploadResponse * SOAP_FMAC2 soap_instantiate___ns1__retrieveOtcBvalDealsUploadResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__retrieveOtcBvalDealsUploadResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__retrieveOtcBvalDealsUploadResponse *p;
	size_t k = sizeof(struct __ns1__retrieveOtcBvalDealsUploadResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__retrieveOtcBvalDealsUploadResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__retrieveOtcBvalDealsUploadResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__retrieveOtcBvalDealsUploadResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__retrieveOtcBvalDealsUploadResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__retrieveOtcBvalDealsUploadResponse(struct soap *soap, const struct __ns1__retrieveOtcBvalDealsUploadResponse *a, const char *tag, const char *type)
{
	if (soap_out___ns1__retrieveOtcBvalDealsUploadResponse(soap, tag ? tag : "-ns1:retrieveOtcBvalDealsUploadResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__retrieveOtcBvalDealsUploadResponse * SOAP_FMAC4 soap_get___ns1__retrieveOtcBvalDealsUploadResponse(struct soap *soap, struct __ns1__retrieveOtcBvalDealsUploadResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__retrieveOtcBvalDealsUploadResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__submitOtcBvalDealsUploadRequest(struct soap *soap, struct __ns1__submitOtcBvalDealsUploadRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__submitOtcBvalDealsUploadRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__submitOtcBvalDealsUploadRequest(struct soap *soap, const struct __ns1__submitOtcBvalDealsUploadRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SubmitOtcBvalDealsUploadRequest(soap, &a->ns1__submitOtcBvalDealsUploadRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__submitOtcBvalDealsUploadRequest(struct soap *soap, const char *tag, int id, const struct __ns1__submitOtcBvalDealsUploadRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SubmitOtcBvalDealsUploadRequest(soap, "ns1:submitOtcBvalDealsUploadRequest", -1, &a->ns1__submitOtcBvalDealsUploadRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__submitOtcBvalDealsUploadRequest * SOAP_FMAC4 soap_in___ns1__submitOtcBvalDealsUploadRequest(struct soap *soap, const char *tag, struct __ns1__submitOtcBvalDealsUploadRequest *a, const char *type)
{
	size_t soap_flag_ns1__submitOtcBvalDealsUploadRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__submitOtcBvalDealsUploadRequest*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__submitOtcBvalDealsUploadRequest, sizeof(struct __ns1__submitOtcBvalDealsUploadRequest), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__submitOtcBvalDealsUploadRequest(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__submitOtcBvalDealsUploadRequest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__SubmitOtcBvalDealsUploadRequest(soap, "ns1:submitOtcBvalDealsUploadRequest", &a->ns1__submitOtcBvalDealsUploadRequest, "ns1:SubmitOtcBvalDealsUploadRequest"))
				{	soap_flag_ns1__submitOtcBvalDealsUploadRequest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__submitOtcBvalDealsUploadRequest * SOAP_FMAC2 soap_instantiate___ns1__submitOtcBvalDealsUploadRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__submitOtcBvalDealsUploadRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__submitOtcBvalDealsUploadRequest *p;
	size_t k = sizeof(struct __ns1__submitOtcBvalDealsUploadRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__submitOtcBvalDealsUploadRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__submitOtcBvalDealsUploadRequest);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__submitOtcBvalDealsUploadRequest, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__submitOtcBvalDealsUploadRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__submitOtcBvalDealsUploadRequest(struct soap *soap, const struct __ns1__submitOtcBvalDealsUploadRequest *a, const char *tag, const char *type)
{
	if (soap_out___ns1__submitOtcBvalDealsUploadRequest(soap, tag ? tag : "-ns1:submitOtcBvalDealsUploadRequest", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__submitOtcBvalDealsUploadRequest * SOAP_FMAC4 soap_get___ns1__submitOtcBvalDealsUploadRequest(struct soap *soap, struct __ns1__submitOtcBvalDealsUploadRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__submitOtcBvalDealsUploadRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__retrieveOtcbvalUploadResponse(struct soap *soap, struct __ns1__retrieveOtcbvalUploadResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__retrieveOtcbvalUploadRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__retrieveOtcbvalUploadResponse(struct soap *soap, const struct __ns1__retrieveOtcbvalUploadResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RetrieveOtcbvalUploadRequest(soap, &a->ns1__retrieveOtcbvalUploadRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__retrieveOtcbvalUploadResponse(struct soap *soap, const char *tag, int id, const struct __ns1__retrieveOtcbvalUploadResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__RetrieveOtcbvalUploadRequest(soap, "ns1:retrieveOtcbvalUploadRequest", -1, &a->ns1__retrieveOtcbvalUploadRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__retrieveOtcbvalUploadResponse * SOAP_FMAC4 soap_in___ns1__retrieveOtcbvalUploadResponse(struct soap *soap, const char *tag, struct __ns1__retrieveOtcbvalUploadResponse *a, const char *type)
{
	size_t soap_flag_ns1__retrieveOtcbvalUploadRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__retrieveOtcbvalUploadResponse*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__retrieveOtcbvalUploadResponse, sizeof(struct __ns1__retrieveOtcbvalUploadResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__retrieveOtcbvalUploadResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__retrieveOtcbvalUploadRequest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__RetrieveOtcbvalUploadRequest(soap, "ns1:retrieveOtcbvalUploadRequest", &a->ns1__retrieveOtcbvalUploadRequest, "ns1:RetrieveOtcbvalUploadRequest"))
				{	soap_flag_ns1__retrieveOtcbvalUploadRequest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__retrieveOtcbvalUploadResponse * SOAP_FMAC2 soap_instantiate___ns1__retrieveOtcbvalUploadResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__retrieveOtcbvalUploadResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__retrieveOtcbvalUploadResponse *p;
	size_t k = sizeof(struct __ns1__retrieveOtcbvalUploadResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__retrieveOtcbvalUploadResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__retrieveOtcbvalUploadResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__retrieveOtcbvalUploadResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__retrieveOtcbvalUploadResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__retrieveOtcbvalUploadResponse(struct soap *soap, const struct __ns1__retrieveOtcbvalUploadResponse *a, const char *tag, const char *type)
{
	if (soap_out___ns1__retrieveOtcbvalUploadResponse(soap, tag ? tag : "-ns1:retrieveOtcbvalUploadResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__retrieveOtcbvalUploadResponse * SOAP_FMAC4 soap_get___ns1__retrieveOtcbvalUploadResponse(struct soap *soap, struct __ns1__retrieveOtcbvalUploadResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__retrieveOtcbvalUploadResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__submitOtcbvalUploadRequest(struct soap *soap, struct __ns1__submitOtcbvalUploadRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__submitOtcbvalUploadRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__submitOtcbvalUploadRequest(struct soap *soap, const struct __ns1__submitOtcbvalUploadRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SubmitOtcbvalUploadRequest(soap, &a->ns1__submitOtcbvalUploadRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__submitOtcbvalUploadRequest(struct soap *soap, const char *tag, int id, const struct __ns1__submitOtcbvalUploadRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SubmitOtcbvalUploadRequest(soap, "ns1:submitOtcbvalUploadRequest", -1, &a->ns1__submitOtcbvalUploadRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__submitOtcbvalUploadRequest * SOAP_FMAC4 soap_in___ns1__submitOtcbvalUploadRequest(struct soap *soap, const char *tag, struct __ns1__submitOtcbvalUploadRequest *a, const char *type)
{
	size_t soap_flag_ns1__submitOtcbvalUploadRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__submitOtcbvalUploadRequest*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__submitOtcbvalUploadRequest, sizeof(struct __ns1__submitOtcbvalUploadRequest), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__submitOtcbvalUploadRequest(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__submitOtcbvalUploadRequest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__SubmitOtcbvalUploadRequest(soap, "ns1:submitOtcbvalUploadRequest", &a->ns1__submitOtcbvalUploadRequest, "ns1:SubmitOtcbvalUploadRequest"))
				{	soap_flag_ns1__submitOtcbvalUploadRequest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__submitOtcbvalUploadRequest * SOAP_FMAC2 soap_instantiate___ns1__submitOtcbvalUploadRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__submitOtcbvalUploadRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__submitOtcbvalUploadRequest *p;
	size_t k = sizeof(struct __ns1__submitOtcbvalUploadRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__submitOtcbvalUploadRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__submitOtcbvalUploadRequest);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__submitOtcbvalUploadRequest, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__submitOtcbvalUploadRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__submitOtcbvalUploadRequest(struct soap *soap, const struct __ns1__submitOtcbvalUploadRequest *a, const char *tag, const char *type)
{
	if (soap_out___ns1__submitOtcbvalUploadRequest(soap, tag ? tag : "-ns1:submitOtcbvalUploadRequest", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__submitOtcbvalUploadRequest * SOAP_FMAC4 soap_get___ns1__submitOtcbvalUploadRequest(struct soap *soap, struct __ns1__submitOtcbvalUploadRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__submitOtcbvalUploadRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__retrieveGetAllQuotesResponse(struct soap *soap, struct __ns1__retrieveGetAllQuotesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__retrieveGetAllQuotesRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__retrieveGetAllQuotesResponse(struct soap *soap, const struct __ns1__retrieveGetAllQuotesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RetrieveGetAllQuotesRequest(soap, &a->ns1__retrieveGetAllQuotesRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__retrieveGetAllQuotesResponse(struct soap *soap, const char *tag, int id, const struct __ns1__retrieveGetAllQuotesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__RetrieveGetAllQuotesRequest(soap, "ns1:retrieveGetAllQuotesRequest", -1, &a->ns1__retrieveGetAllQuotesRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__retrieveGetAllQuotesResponse * SOAP_FMAC4 soap_in___ns1__retrieveGetAllQuotesResponse(struct soap *soap, const char *tag, struct __ns1__retrieveGetAllQuotesResponse *a, const char *type)
{
	size_t soap_flag_ns1__retrieveGetAllQuotesRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__retrieveGetAllQuotesResponse*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__retrieveGetAllQuotesResponse, sizeof(struct __ns1__retrieveGetAllQuotesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__retrieveGetAllQuotesResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__retrieveGetAllQuotesRequest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__RetrieveGetAllQuotesRequest(soap, "ns1:retrieveGetAllQuotesRequest", &a->ns1__retrieveGetAllQuotesRequest, "ns1:RetrieveGetAllQuotesRequest"))
				{	soap_flag_ns1__retrieveGetAllQuotesRequest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__retrieveGetAllQuotesResponse * SOAP_FMAC2 soap_instantiate___ns1__retrieveGetAllQuotesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__retrieveGetAllQuotesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__retrieveGetAllQuotesResponse *p;
	size_t k = sizeof(struct __ns1__retrieveGetAllQuotesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__retrieveGetAllQuotesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__retrieveGetAllQuotesResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__retrieveGetAllQuotesResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__retrieveGetAllQuotesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__retrieveGetAllQuotesResponse(struct soap *soap, const struct __ns1__retrieveGetAllQuotesResponse *a, const char *tag, const char *type)
{
	if (soap_out___ns1__retrieveGetAllQuotesResponse(soap, tag ? tag : "-ns1:retrieveGetAllQuotesResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__retrieveGetAllQuotesResponse * SOAP_FMAC4 soap_get___ns1__retrieveGetAllQuotesResponse(struct soap *soap, struct __ns1__retrieveGetAllQuotesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__retrieveGetAllQuotesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__submitGetAllQuotesRequest(struct soap *soap, struct __ns1__submitGetAllQuotesRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__submitGetAllQuotesRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__submitGetAllQuotesRequest(struct soap *soap, const struct __ns1__submitGetAllQuotesRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SubmitGetAllQuotesRequest(soap, &a->ns1__submitGetAllQuotesRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__submitGetAllQuotesRequest(struct soap *soap, const char *tag, int id, const struct __ns1__submitGetAllQuotesRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SubmitGetAllQuotesRequest(soap, "ns1:submitGetAllQuotesRequest", -1, &a->ns1__submitGetAllQuotesRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__submitGetAllQuotesRequest * SOAP_FMAC4 soap_in___ns1__submitGetAllQuotesRequest(struct soap *soap, const char *tag, struct __ns1__submitGetAllQuotesRequest *a, const char *type)
{
	size_t soap_flag_ns1__submitGetAllQuotesRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__submitGetAllQuotesRequest*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__submitGetAllQuotesRequest, sizeof(struct __ns1__submitGetAllQuotesRequest), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__submitGetAllQuotesRequest(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__submitGetAllQuotesRequest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__SubmitGetAllQuotesRequest(soap, "ns1:submitGetAllQuotesRequest", &a->ns1__submitGetAllQuotesRequest, "ns1:SubmitGetAllQuotesRequest"))
				{	soap_flag_ns1__submitGetAllQuotesRequest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__submitGetAllQuotesRequest * SOAP_FMAC2 soap_instantiate___ns1__submitGetAllQuotesRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__submitGetAllQuotesRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__submitGetAllQuotesRequest *p;
	size_t k = sizeof(struct __ns1__submitGetAllQuotesRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__submitGetAllQuotesRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__submitGetAllQuotesRequest);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__submitGetAllQuotesRequest, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__submitGetAllQuotesRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__submitGetAllQuotesRequest(struct soap *soap, const struct __ns1__submitGetAllQuotesRequest *a, const char *tag, const char *type)
{
	if (soap_out___ns1__submitGetAllQuotesRequest(soap, tag ? tag : "-ns1:submitGetAllQuotesRequest", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__submitGetAllQuotesRequest * SOAP_FMAC4 soap_get___ns1__submitGetAllQuotesRequest(struct soap *soap, struct __ns1__submitGetAllQuotesRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__submitGetAllQuotesRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__retrieveGetQuotesResponse(struct soap *soap, struct __ns1__retrieveGetQuotesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__retrieveGetQuotesRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__retrieveGetQuotesResponse(struct soap *soap, const struct __ns1__retrieveGetQuotesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RetrieveGetQuotesRequest(soap, &a->ns1__retrieveGetQuotesRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__retrieveGetQuotesResponse(struct soap *soap, const char *tag, int id, const struct __ns1__retrieveGetQuotesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__RetrieveGetQuotesRequest(soap, "ns1:retrieveGetQuotesRequest", -1, &a->ns1__retrieveGetQuotesRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__retrieveGetQuotesResponse * SOAP_FMAC4 soap_in___ns1__retrieveGetQuotesResponse(struct soap *soap, const char *tag, struct __ns1__retrieveGetQuotesResponse *a, const char *type)
{
	size_t soap_flag_ns1__retrieveGetQuotesRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__retrieveGetQuotesResponse*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__retrieveGetQuotesResponse, sizeof(struct __ns1__retrieveGetQuotesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__retrieveGetQuotesResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__retrieveGetQuotesRequest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__RetrieveGetQuotesRequest(soap, "ns1:retrieveGetQuotesRequest", &a->ns1__retrieveGetQuotesRequest, "ns1:RetrieveGetQuotesRequest"))
				{	soap_flag_ns1__retrieveGetQuotesRequest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__retrieveGetQuotesResponse * SOAP_FMAC2 soap_instantiate___ns1__retrieveGetQuotesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__retrieveGetQuotesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__retrieveGetQuotesResponse *p;
	size_t k = sizeof(struct __ns1__retrieveGetQuotesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__retrieveGetQuotesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__retrieveGetQuotesResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__retrieveGetQuotesResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__retrieveGetQuotesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__retrieveGetQuotesResponse(struct soap *soap, const struct __ns1__retrieveGetQuotesResponse *a, const char *tag, const char *type)
{
	if (soap_out___ns1__retrieveGetQuotesResponse(soap, tag ? tag : "-ns1:retrieveGetQuotesResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__retrieveGetQuotesResponse * SOAP_FMAC4 soap_get___ns1__retrieveGetQuotesResponse(struct soap *soap, struct __ns1__retrieveGetQuotesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__retrieveGetQuotesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__submitGetQuotesRequest(struct soap *soap, struct __ns1__submitGetQuotesRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__submitGetQuotesRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__submitGetQuotesRequest(struct soap *soap, const struct __ns1__submitGetQuotesRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SubmitGetQuotesRequest(soap, &a->ns1__submitGetQuotesRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__submitGetQuotesRequest(struct soap *soap, const char *tag, int id, const struct __ns1__submitGetQuotesRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SubmitGetQuotesRequest(soap, "ns1:submitGetQuotesRequest", -1, &a->ns1__submitGetQuotesRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__submitGetQuotesRequest * SOAP_FMAC4 soap_in___ns1__submitGetQuotesRequest(struct soap *soap, const char *tag, struct __ns1__submitGetQuotesRequest *a, const char *type)
{
	size_t soap_flag_ns1__submitGetQuotesRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__submitGetQuotesRequest*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__submitGetQuotesRequest, sizeof(struct __ns1__submitGetQuotesRequest), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__submitGetQuotesRequest(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__submitGetQuotesRequest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__SubmitGetQuotesRequest(soap, "ns1:submitGetQuotesRequest", &a->ns1__submitGetQuotesRequest, "ns1:SubmitGetQuotesRequest"))
				{	soap_flag_ns1__submitGetQuotesRequest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__submitGetQuotesRequest * SOAP_FMAC2 soap_instantiate___ns1__submitGetQuotesRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__submitGetQuotesRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__submitGetQuotesRequest *p;
	size_t k = sizeof(struct __ns1__submitGetQuotesRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__submitGetQuotesRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__submitGetQuotesRequest);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__submitGetQuotesRequest, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__submitGetQuotesRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__submitGetQuotesRequest(struct soap *soap, const struct __ns1__submitGetQuotesRequest *a, const char *tag, const char *type)
{
	if (soap_out___ns1__submitGetQuotesRequest(soap, tag ? tag : "-ns1:submitGetQuotesRequest", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__submitGetQuotesRequest * SOAP_FMAC4 soap_get___ns1__submitGetQuotesRequest(struct soap *soap, struct __ns1__submitGetQuotesRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__submitGetQuotesRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getPortfolioValidation(struct soap *soap, struct __ns1__getPortfolioValidation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getPortfolioValidationRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getPortfolioValidation(struct soap *soap, const struct __ns1__getPortfolioValidation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__GetPortfolioValidationRequest(soap, &a->ns1__getPortfolioValidationRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getPortfolioValidation(struct soap *soap, const char *tag, int id, const struct __ns1__getPortfolioValidation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__GetPortfolioValidationRequest(soap, "ns1:getPortfolioValidationRequest", -1, &a->ns1__getPortfolioValidationRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPortfolioValidation * SOAP_FMAC4 soap_in___ns1__getPortfolioValidation(struct soap *soap, const char *tag, struct __ns1__getPortfolioValidation *a, const char *type)
{
	size_t soap_flag_ns1__getPortfolioValidationRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getPortfolioValidation*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getPortfolioValidation, sizeof(struct __ns1__getPortfolioValidation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getPortfolioValidation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getPortfolioValidationRequest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GetPortfolioValidationRequest(soap, "ns1:getPortfolioValidationRequest", &a->ns1__getPortfolioValidationRequest, "ns1:GetPortfolioValidationRequest"))
				{	soap_flag_ns1__getPortfolioValidationRequest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getPortfolioValidation * SOAP_FMAC2 soap_instantiate___ns1__getPortfolioValidation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getPortfolioValidation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getPortfolioValidation *p;
	size_t k = sizeof(struct __ns1__getPortfolioValidation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__getPortfolioValidation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__getPortfolioValidation);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__getPortfolioValidation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getPortfolioValidation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getPortfolioValidation(struct soap *soap, const struct __ns1__getPortfolioValidation *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getPortfolioValidation(soap, tag ? tag : "-ns1:getPortfolioValidation", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPortfolioValidation * SOAP_FMAC4 soap_get___ns1__getPortfolioValidation(struct soap *soap, struct __ns1__getPortfolioValidation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getPortfolioValidation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__retrieveGetActionsResponse(struct soap *soap, struct __ns1__retrieveGetActionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__retrieveGetActionsRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__retrieveGetActionsResponse(struct soap *soap, const struct __ns1__retrieveGetActionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RetrieveGetActionsRequest(soap, &a->ns1__retrieveGetActionsRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__retrieveGetActionsResponse(struct soap *soap, const char *tag, int id, const struct __ns1__retrieveGetActionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__RetrieveGetActionsRequest(soap, "ns1:retrieveGetActionsRequest", -1, &a->ns1__retrieveGetActionsRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__retrieveGetActionsResponse * SOAP_FMAC4 soap_in___ns1__retrieveGetActionsResponse(struct soap *soap, const char *tag, struct __ns1__retrieveGetActionsResponse *a, const char *type)
{
	size_t soap_flag_ns1__retrieveGetActionsRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__retrieveGetActionsResponse*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__retrieveGetActionsResponse, sizeof(struct __ns1__retrieveGetActionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__retrieveGetActionsResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__retrieveGetActionsRequest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__RetrieveGetActionsRequest(soap, "ns1:retrieveGetActionsRequest", &a->ns1__retrieveGetActionsRequest, "ns1:RetrieveGetActionsRequest"))
				{	soap_flag_ns1__retrieveGetActionsRequest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__retrieveGetActionsResponse * SOAP_FMAC2 soap_instantiate___ns1__retrieveGetActionsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__retrieveGetActionsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__retrieveGetActionsResponse *p;
	size_t k = sizeof(struct __ns1__retrieveGetActionsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__retrieveGetActionsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__retrieveGetActionsResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__retrieveGetActionsResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__retrieveGetActionsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__retrieveGetActionsResponse(struct soap *soap, const struct __ns1__retrieveGetActionsResponse *a, const char *tag, const char *type)
{
	if (soap_out___ns1__retrieveGetActionsResponse(soap, tag ? tag : "-ns1:retrieveGetActionsResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__retrieveGetActionsResponse * SOAP_FMAC4 soap_get___ns1__retrieveGetActionsResponse(struct soap *soap, struct __ns1__retrieveGetActionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__retrieveGetActionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__submitGetActionsRequest(struct soap *soap, struct __ns1__submitGetActionsRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__submitGetActionsRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__submitGetActionsRequest(struct soap *soap, const struct __ns1__submitGetActionsRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SubmitGetActionsRequest(soap, &a->ns1__submitGetActionsRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__submitGetActionsRequest(struct soap *soap, const char *tag, int id, const struct __ns1__submitGetActionsRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SubmitGetActionsRequest(soap, "ns1:submitGetActionsRequest", -1, &a->ns1__submitGetActionsRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__submitGetActionsRequest * SOAP_FMAC4 soap_in___ns1__submitGetActionsRequest(struct soap *soap, const char *tag, struct __ns1__submitGetActionsRequest *a, const char *type)
{
	size_t soap_flag_ns1__submitGetActionsRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__submitGetActionsRequest*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__submitGetActionsRequest, sizeof(struct __ns1__submitGetActionsRequest), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__submitGetActionsRequest(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__submitGetActionsRequest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__SubmitGetActionsRequest(soap, "ns1:submitGetActionsRequest", &a->ns1__submitGetActionsRequest, "ns1:SubmitGetActionsRequest"))
				{	soap_flag_ns1__submitGetActionsRequest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__submitGetActionsRequest * SOAP_FMAC2 soap_instantiate___ns1__submitGetActionsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__submitGetActionsRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__submitGetActionsRequest *p;
	size_t k = sizeof(struct __ns1__submitGetActionsRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__submitGetActionsRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__submitGetActionsRequest);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__submitGetActionsRequest, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__submitGetActionsRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__submitGetActionsRequest(struct soap *soap, const struct __ns1__submitGetActionsRequest *a, const char *tag, const char *type)
{
	if (soap_out___ns1__submitGetActionsRequest(soap, tag ? tag : "-ns1:submitGetActionsRequest", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__submitGetActionsRequest * SOAP_FMAC4 soap_get___ns1__submitGetActionsRequest(struct soap *soap, struct __ns1__submitGetActionsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__submitGetActionsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__retrieveGetCompanyResponse(struct soap *soap, struct __ns1__retrieveGetCompanyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__retrieveGetCompanyRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__retrieveGetCompanyResponse(struct soap *soap, const struct __ns1__retrieveGetCompanyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RetrieveGetCompanyRequest(soap, &a->ns1__retrieveGetCompanyRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__retrieveGetCompanyResponse(struct soap *soap, const char *tag, int id, const struct __ns1__retrieveGetCompanyResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__RetrieveGetCompanyRequest(soap, "ns1:retrieveGetCompanyRequest", -1, &a->ns1__retrieveGetCompanyRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__retrieveGetCompanyResponse * SOAP_FMAC4 soap_in___ns1__retrieveGetCompanyResponse(struct soap *soap, const char *tag, struct __ns1__retrieveGetCompanyResponse *a, const char *type)
{
	size_t soap_flag_ns1__retrieveGetCompanyRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__retrieveGetCompanyResponse*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__retrieveGetCompanyResponse, sizeof(struct __ns1__retrieveGetCompanyResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__retrieveGetCompanyResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__retrieveGetCompanyRequest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__RetrieveGetCompanyRequest(soap, "ns1:retrieveGetCompanyRequest", &a->ns1__retrieveGetCompanyRequest, "ns1:RetrieveGetCompanyRequest"))
				{	soap_flag_ns1__retrieveGetCompanyRequest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__retrieveGetCompanyResponse * SOAP_FMAC2 soap_instantiate___ns1__retrieveGetCompanyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__retrieveGetCompanyResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__retrieveGetCompanyResponse *p;
	size_t k = sizeof(struct __ns1__retrieveGetCompanyResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__retrieveGetCompanyResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__retrieveGetCompanyResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__retrieveGetCompanyResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__retrieveGetCompanyResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__retrieveGetCompanyResponse(struct soap *soap, const struct __ns1__retrieveGetCompanyResponse *a, const char *tag, const char *type)
{
	if (soap_out___ns1__retrieveGetCompanyResponse(soap, tag ? tag : "-ns1:retrieveGetCompanyResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__retrieveGetCompanyResponse * SOAP_FMAC4 soap_get___ns1__retrieveGetCompanyResponse(struct soap *soap, struct __ns1__retrieveGetCompanyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__retrieveGetCompanyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__submitGetCompanyRequest(struct soap *soap, struct __ns1__submitGetCompanyRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__submitGetCompanyRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__submitGetCompanyRequest(struct soap *soap, const struct __ns1__submitGetCompanyRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SubmitGetCompanyRequest(soap, &a->ns1__submitGetCompanyRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__submitGetCompanyRequest(struct soap *soap, const char *tag, int id, const struct __ns1__submitGetCompanyRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SubmitGetCompanyRequest(soap, "ns1:submitGetCompanyRequest", -1, &a->ns1__submitGetCompanyRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__submitGetCompanyRequest * SOAP_FMAC4 soap_in___ns1__submitGetCompanyRequest(struct soap *soap, const char *tag, struct __ns1__submitGetCompanyRequest *a, const char *type)
{
	size_t soap_flag_ns1__submitGetCompanyRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__submitGetCompanyRequest*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__submitGetCompanyRequest, sizeof(struct __ns1__submitGetCompanyRequest), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__submitGetCompanyRequest(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__submitGetCompanyRequest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__SubmitGetCompanyRequest(soap, "ns1:submitGetCompanyRequest", &a->ns1__submitGetCompanyRequest, "ns1:SubmitGetCompanyRequest"))
				{	soap_flag_ns1__submitGetCompanyRequest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__submitGetCompanyRequest * SOAP_FMAC2 soap_instantiate___ns1__submitGetCompanyRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__submitGetCompanyRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__submitGetCompanyRequest *p;
	size_t k = sizeof(struct __ns1__submitGetCompanyRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__submitGetCompanyRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__submitGetCompanyRequest);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__submitGetCompanyRequest, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__submitGetCompanyRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__submitGetCompanyRequest(struct soap *soap, const struct __ns1__submitGetCompanyRequest *a, const char *tag, const char *type)
{
	if (soap_out___ns1__submitGetCompanyRequest(soap, tag ? tag : "-ns1:submitGetCompanyRequest", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__submitGetCompanyRequest * SOAP_FMAC4 soap_get___ns1__submitGetCompanyRequest(struct soap *soap, struct __ns1__submitGetCompanyRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__submitGetCompanyRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__retrieveGetFundamentalsResponse(struct soap *soap, struct __ns1__retrieveGetFundamentalsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__retrieveGetFundamentalsRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__retrieveGetFundamentalsResponse(struct soap *soap, const struct __ns1__retrieveGetFundamentalsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RetrieveGetFundamentalsRequest(soap, &a->ns1__retrieveGetFundamentalsRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__retrieveGetFundamentalsResponse(struct soap *soap, const char *tag, int id, const struct __ns1__retrieveGetFundamentalsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__RetrieveGetFundamentalsRequest(soap, "ns1:retrieveGetFundamentalsRequest", -1, &a->ns1__retrieveGetFundamentalsRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__retrieveGetFundamentalsResponse * SOAP_FMAC4 soap_in___ns1__retrieveGetFundamentalsResponse(struct soap *soap, const char *tag, struct __ns1__retrieveGetFundamentalsResponse *a, const char *type)
{
	size_t soap_flag_ns1__retrieveGetFundamentalsRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__retrieveGetFundamentalsResponse*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__retrieveGetFundamentalsResponse, sizeof(struct __ns1__retrieveGetFundamentalsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__retrieveGetFundamentalsResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__retrieveGetFundamentalsRequest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__RetrieveGetFundamentalsRequest(soap, "ns1:retrieveGetFundamentalsRequest", &a->ns1__retrieveGetFundamentalsRequest, "ns1:RetrieveGetFundamentalsRequest"))
				{	soap_flag_ns1__retrieveGetFundamentalsRequest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__retrieveGetFundamentalsResponse * SOAP_FMAC2 soap_instantiate___ns1__retrieveGetFundamentalsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__retrieveGetFundamentalsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__retrieveGetFundamentalsResponse *p;
	size_t k = sizeof(struct __ns1__retrieveGetFundamentalsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__retrieveGetFundamentalsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__retrieveGetFundamentalsResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__retrieveGetFundamentalsResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__retrieveGetFundamentalsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__retrieveGetFundamentalsResponse(struct soap *soap, const struct __ns1__retrieveGetFundamentalsResponse *a, const char *tag, const char *type)
{
	if (soap_out___ns1__retrieveGetFundamentalsResponse(soap, tag ? tag : "-ns1:retrieveGetFundamentalsResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__retrieveGetFundamentalsResponse * SOAP_FMAC4 soap_get___ns1__retrieveGetFundamentalsResponse(struct soap *soap, struct __ns1__retrieveGetFundamentalsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__retrieveGetFundamentalsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__submitGetFundamentalsRequest(struct soap *soap, struct __ns1__submitGetFundamentalsRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__submitGetFundamentalsRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__submitGetFundamentalsRequest(struct soap *soap, const struct __ns1__submitGetFundamentalsRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SubmitGetFundamentalsRequest(soap, &a->ns1__submitGetFundamentalsRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__submitGetFundamentalsRequest(struct soap *soap, const char *tag, int id, const struct __ns1__submitGetFundamentalsRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SubmitGetFundamentalsRequest(soap, "ns1:submitGetFundamentalsRequest", -1, &a->ns1__submitGetFundamentalsRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__submitGetFundamentalsRequest * SOAP_FMAC4 soap_in___ns1__submitGetFundamentalsRequest(struct soap *soap, const char *tag, struct __ns1__submitGetFundamentalsRequest *a, const char *type)
{
	size_t soap_flag_ns1__submitGetFundamentalsRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__submitGetFundamentalsRequest*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__submitGetFundamentalsRequest, sizeof(struct __ns1__submitGetFundamentalsRequest), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__submitGetFundamentalsRequest(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__submitGetFundamentalsRequest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__SubmitGetFundamentalsRequest(soap, "ns1:submitGetFundamentalsRequest", &a->ns1__submitGetFundamentalsRequest, "ns1:SubmitGetFundamentalsRequest"))
				{	soap_flag_ns1__submitGetFundamentalsRequest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__submitGetFundamentalsRequest * SOAP_FMAC2 soap_instantiate___ns1__submitGetFundamentalsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__submitGetFundamentalsRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__submitGetFundamentalsRequest *p;
	size_t k = sizeof(struct __ns1__submitGetFundamentalsRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__submitGetFundamentalsRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__submitGetFundamentalsRequest);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__submitGetFundamentalsRequest, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__submitGetFundamentalsRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__submitGetFundamentalsRequest(struct soap *soap, const struct __ns1__submitGetFundamentalsRequest *a, const char *tag, const char *type)
{
	if (soap_out___ns1__submitGetFundamentalsRequest(soap, tag ? tag : "-ns1:submitGetFundamentalsRequest", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__submitGetFundamentalsRequest * SOAP_FMAC4 soap_get___ns1__submitGetFundamentalsRequest(struct soap *soap, struct __ns1__submitGetFundamentalsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__submitGetFundamentalsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getCorrections(struct soap *soap, struct __ns1__getCorrections *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getCorrectionsRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getCorrections(struct soap *soap, const struct __ns1__getCorrections *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__GetCorrectionsRequest(soap, &a->ns1__getCorrectionsRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getCorrections(struct soap *soap, const char *tag, int id, const struct __ns1__getCorrections *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__GetCorrectionsRequest(soap, "ns1:getCorrectionsRequest", -1, &a->ns1__getCorrectionsRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getCorrections * SOAP_FMAC4 soap_in___ns1__getCorrections(struct soap *soap, const char *tag, struct __ns1__getCorrections *a, const char *type)
{
	size_t soap_flag_ns1__getCorrectionsRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getCorrections*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getCorrections, sizeof(struct __ns1__getCorrections), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getCorrections(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getCorrectionsRequest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GetCorrectionsRequest(soap, "ns1:getCorrectionsRequest", &a->ns1__getCorrectionsRequest, "ns1:GetCorrectionsRequest"))
				{	soap_flag_ns1__getCorrectionsRequest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getCorrections * SOAP_FMAC2 soap_instantiate___ns1__getCorrections(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getCorrections(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getCorrections *p;
	size_t k = sizeof(struct __ns1__getCorrections);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__getCorrections, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__getCorrections);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__getCorrections, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getCorrections location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getCorrections(struct soap *soap, const struct __ns1__getCorrections *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getCorrections(soap, tag ? tag : "-ns1:getCorrections", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getCorrections * SOAP_FMAC4 soap_get___ns1__getCorrections(struct soap *soap, struct __ns1__getCorrections *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getCorrections(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__retrieveCancelResponse(struct soap *soap, struct __ns1__retrieveCancelResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__retrieveCancelRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__retrieveCancelResponse(struct soap *soap, const struct __ns1__retrieveCancelResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RetrieveCancelRequest(soap, &a->ns1__retrieveCancelRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__retrieveCancelResponse(struct soap *soap, const char *tag, int id, const struct __ns1__retrieveCancelResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__RetrieveCancelRequest(soap, "ns1:retrieveCancelRequest", -1, &a->ns1__retrieveCancelRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__retrieveCancelResponse * SOAP_FMAC4 soap_in___ns1__retrieveCancelResponse(struct soap *soap, const char *tag, struct __ns1__retrieveCancelResponse *a, const char *type)
{
	size_t soap_flag_ns1__retrieveCancelRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__retrieveCancelResponse*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__retrieveCancelResponse, sizeof(struct __ns1__retrieveCancelResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__retrieveCancelResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__retrieveCancelRequest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__RetrieveCancelRequest(soap, "ns1:retrieveCancelRequest", &a->ns1__retrieveCancelRequest, "ns1:RetrieveCancelRequest"))
				{	soap_flag_ns1__retrieveCancelRequest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__retrieveCancelResponse * SOAP_FMAC2 soap_instantiate___ns1__retrieveCancelResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__retrieveCancelResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__retrieveCancelResponse *p;
	size_t k = sizeof(struct __ns1__retrieveCancelResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__retrieveCancelResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__retrieveCancelResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__retrieveCancelResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__retrieveCancelResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__retrieveCancelResponse(struct soap *soap, const struct __ns1__retrieveCancelResponse *a, const char *tag, const char *type)
{
	if (soap_out___ns1__retrieveCancelResponse(soap, tag ? tag : "-ns1:retrieveCancelResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__retrieveCancelResponse * SOAP_FMAC4 soap_get___ns1__retrieveCancelResponse(struct soap *soap, struct __ns1__retrieveCancelResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__retrieveCancelResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__submitCancelRequest(struct soap *soap, struct __ns1__submitCancelRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__submitCancelRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__submitCancelRequest(struct soap *soap, const struct __ns1__submitCancelRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SubmitCancelRequest(soap, &a->ns1__submitCancelRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__submitCancelRequest(struct soap *soap, const char *tag, int id, const struct __ns1__submitCancelRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SubmitCancelRequest(soap, "ns1:submitCancelRequest", -1, &a->ns1__submitCancelRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__submitCancelRequest * SOAP_FMAC4 soap_in___ns1__submitCancelRequest(struct soap *soap, const char *tag, struct __ns1__submitCancelRequest *a, const char *type)
{
	size_t soap_flag_ns1__submitCancelRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__submitCancelRequest*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__submitCancelRequest, sizeof(struct __ns1__submitCancelRequest), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__submitCancelRequest(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__submitCancelRequest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__SubmitCancelRequest(soap, "ns1:submitCancelRequest", &a->ns1__submitCancelRequest, "ns1:SubmitCancelRequest"))
				{	soap_flag_ns1__submitCancelRequest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__submitCancelRequest * SOAP_FMAC2 soap_instantiate___ns1__submitCancelRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__submitCancelRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__submitCancelRequest *p;
	size_t k = sizeof(struct __ns1__submitCancelRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__submitCancelRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__submitCancelRequest);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__submitCancelRequest, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__submitCancelRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__submitCancelRequest(struct soap *soap, const struct __ns1__submitCancelRequest *a, const char *tag, const char *type)
{
	if (soap_out___ns1__submitCancelRequest(soap, tag ? tag : "-ns1:submitCancelRequest", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__submitCancelRequest * SOAP_FMAC4 soap_get___ns1__submitCancelRequest(struct soap *soap, struct __ns1__submitCancelRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__submitCancelRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__retrieveScheduledResponse(struct soap *soap, struct __ns1__retrieveScheduledResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__retrieveScheduledRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__retrieveScheduledResponse(struct soap *soap, const struct __ns1__retrieveScheduledResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RetrieveScheduledRequest(soap, &a->ns1__retrieveScheduledRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__retrieveScheduledResponse(struct soap *soap, const char *tag, int id, const struct __ns1__retrieveScheduledResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__RetrieveScheduledRequest(soap, "ns1:retrieveScheduledRequest", -1, &a->ns1__retrieveScheduledRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__retrieveScheduledResponse * SOAP_FMAC4 soap_in___ns1__retrieveScheduledResponse(struct soap *soap, const char *tag, struct __ns1__retrieveScheduledResponse *a, const char *type)
{
	size_t soap_flag_ns1__retrieveScheduledRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__retrieveScheduledResponse*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__retrieveScheduledResponse, sizeof(struct __ns1__retrieveScheduledResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__retrieveScheduledResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__retrieveScheduledRequest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__RetrieveScheduledRequest(soap, "ns1:retrieveScheduledRequest", &a->ns1__retrieveScheduledRequest, "ns1:RetrieveScheduledRequest"))
				{	soap_flag_ns1__retrieveScheduledRequest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__retrieveScheduledResponse * SOAP_FMAC2 soap_instantiate___ns1__retrieveScheduledResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__retrieveScheduledResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__retrieveScheduledResponse *p;
	size_t k = sizeof(struct __ns1__retrieveScheduledResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__retrieveScheduledResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__retrieveScheduledResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__retrieveScheduledResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__retrieveScheduledResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__retrieveScheduledResponse(struct soap *soap, const struct __ns1__retrieveScheduledResponse *a, const char *tag, const char *type)
{
	if (soap_out___ns1__retrieveScheduledResponse(soap, tag ? tag : "-ns1:retrieveScheduledResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__retrieveScheduledResponse * SOAP_FMAC4 soap_get___ns1__retrieveScheduledResponse(struct soap *soap, struct __ns1__retrieveScheduledResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__retrieveScheduledResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__submitScheduledRequest(struct soap *soap, struct __ns1__submitScheduledRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__submitScheduledRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__submitScheduledRequest(struct soap *soap, const struct __ns1__submitScheduledRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SubmitScheduledRequest(soap, &a->ns1__submitScheduledRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__submitScheduledRequest(struct soap *soap, const char *tag, int id, const struct __ns1__submitScheduledRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SubmitScheduledRequest(soap, "ns1:submitScheduledRequest", -1, &a->ns1__submitScheduledRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__submitScheduledRequest * SOAP_FMAC4 soap_in___ns1__submitScheduledRequest(struct soap *soap, const char *tag, struct __ns1__submitScheduledRequest *a, const char *type)
{
	size_t soap_flag_ns1__submitScheduledRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__submitScheduledRequest*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__submitScheduledRequest, sizeof(struct __ns1__submitScheduledRequest), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__submitScheduledRequest(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__submitScheduledRequest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__SubmitScheduledRequest(soap, "ns1:submitScheduledRequest", &a->ns1__submitScheduledRequest, "ns1:SubmitScheduledRequest"))
				{	soap_flag_ns1__submitScheduledRequest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__submitScheduledRequest * SOAP_FMAC2 soap_instantiate___ns1__submitScheduledRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__submitScheduledRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__submitScheduledRequest *p;
	size_t k = sizeof(struct __ns1__submitScheduledRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__submitScheduledRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__submitScheduledRequest);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__submitScheduledRequest, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__submitScheduledRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__submitScheduledRequest(struct soap *soap, const struct __ns1__submitScheduledRequest *a, const char *tag, const char *type)
{
	if (soap_out___ns1__submitScheduledRequest(soap, tag ? tag : "-ns1:submitScheduledRequest", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__submitScheduledRequest * SOAP_FMAC4 soap_get___ns1__submitScheduledRequest(struct soap *soap, struct __ns1__submitScheduledRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__submitScheduledRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__retrieveGetHistoryResponse(struct soap *soap, struct __ns1__retrieveGetHistoryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__retrieveGetHistoryRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__retrieveGetHistoryResponse(struct soap *soap, const struct __ns1__retrieveGetHistoryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RetrieveGetHistoryRequest(soap, &a->ns1__retrieveGetHistoryRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__retrieveGetHistoryResponse(struct soap *soap, const char *tag, int id, const struct __ns1__retrieveGetHistoryResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__RetrieveGetHistoryRequest(soap, "ns1:retrieveGetHistoryRequest", -1, &a->ns1__retrieveGetHistoryRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__retrieveGetHistoryResponse * SOAP_FMAC4 soap_in___ns1__retrieveGetHistoryResponse(struct soap *soap, const char *tag, struct __ns1__retrieveGetHistoryResponse *a, const char *type)
{
	size_t soap_flag_ns1__retrieveGetHistoryRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__retrieveGetHistoryResponse*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__retrieveGetHistoryResponse, sizeof(struct __ns1__retrieveGetHistoryResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__retrieveGetHistoryResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__retrieveGetHistoryRequest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__RetrieveGetHistoryRequest(soap, "ns1:retrieveGetHistoryRequest", &a->ns1__retrieveGetHistoryRequest, "ns1:RetrieveGetHistoryRequest"))
				{	soap_flag_ns1__retrieveGetHistoryRequest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__retrieveGetHistoryResponse * SOAP_FMAC2 soap_instantiate___ns1__retrieveGetHistoryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__retrieveGetHistoryResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__retrieveGetHistoryResponse *p;
	size_t k = sizeof(struct __ns1__retrieveGetHistoryResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__retrieveGetHistoryResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__retrieveGetHistoryResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__retrieveGetHistoryResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__retrieveGetHistoryResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__retrieveGetHistoryResponse(struct soap *soap, const struct __ns1__retrieveGetHistoryResponse *a, const char *tag, const char *type)
{
	if (soap_out___ns1__retrieveGetHistoryResponse(soap, tag ? tag : "-ns1:retrieveGetHistoryResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__retrieveGetHistoryResponse * SOAP_FMAC4 soap_get___ns1__retrieveGetHistoryResponse(struct soap *soap, struct __ns1__retrieveGetHistoryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__retrieveGetHistoryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__submitGetHistoryRequest(struct soap *soap, struct __ns1__submitGetHistoryRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__submitGetHistoryRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__submitGetHistoryRequest(struct soap *soap, const struct __ns1__submitGetHistoryRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SubmitGetHistoryRequest(soap, &a->ns1__submitGetHistoryRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__submitGetHistoryRequest(struct soap *soap, const char *tag, int id, const struct __ns1__submitGetHistoryRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SubmitGetHistoryRequest(soap, "ns1:submitGetHistoryRequest", -1, &a->ns1__submitGetHistoryRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__submitGetHistoryRequest * SOAP_FMAC4 soap_in___ns1__submitGetHistoryRequest(struct soap *soap, const char *tag, struct __ns1__submitGetHistoryRequest *a, const char *type)
{
	size_t soap_flag_ns1__submitGetHistoryRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__submitGetHistoryRequest*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__submitGetHistoryRequest, sizeof(struct __ns1__submitGetHistoryRequest), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__submitGetHistoryRequest(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__submitGetHistoryRequest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__SubmitGetHistoryRequest(soap, "ns1:submitGetHistoryRequest", &a->ns1__submitGetHistoryRequest, "ns1:SubmitGetHistoryRequest"))
				{	soap_flag_ns1__submitGetHistoryRequest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__submitGetHistoryRequest * SOAP_FMAC2 soap_instantiate___ns1__submitGetHistoryRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__submitGetHistoryRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__submitGetHistoryRequest *p;
	size_t k = sizeof(struct __ns1__submitGetHistoryRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__submitGetHistoryRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__submitGetHistoryRequest);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__submitGetHistoryRequest, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__submitGetHistoryRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__submitGetHistoryRequest(struct soap *soap, const struct __ns1__submitGetHistoryRequest *a, const char *tag, const char *type)
{
	if (soap_out___ns1__submitGetHistoryRequest(soap, tag ? tag : "-ns1:submitGetHistoryRequest", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__submitGetHistoryRequest * SOAP_FMAC4 soap_get___ns1__submitGetHistoryRequest(struct soap *soap, struct __ns1__submitGetHistoryRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__submitGetHistoryRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__retrieveGetDataResponse(struct soap *soap, struct __ns1__retrieveGetDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__retrieveGetDataRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__retrieveGetDataResponse(struct soap *soap, const struct __ns1__retrieveGetDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RetrieveGetDataRequest(soap, &a->ns1__retrieveGetDataRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__retrieveGetDataResponse(struct soap *soap, const char *tag, int id, const struct __ns1__retrieveGetDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__RetrieveGetDataRequest(soap, "ns1:retrieveGetDataRequest", -1, &a->ns1__retrieveGetDataRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__retrieveGetDataResponse * SOAP_FMAC4 soap_in___ns1__retrieveGetDataResponse(struct soap *soap, const char *tag, struct __ns1__retrieveGetDataResponse *a, const char *type)
{
	size_t soap_flag_ns1__retrieveGetDataRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__retrieveGetDataResponse*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__retrieveGetDataResponse, sizeof(struct __ns1__retrieveGetDataResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__retrieveGetDataResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__retrieveGetDataRequest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__RetrieveGetDataRequest(soap, "ns1:retrieveGetDataRequest", &a->ns1__retrieveGetDataRequest, "ns1:RetrieveGetDataRequest"))
				{	soap_flag_ns1__retrieveGetDataRequest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__retrieveGetDataResponse * SOAP_FMAC2 soap_instantiate___ns1__retrieveGetDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__retrieveGetDataResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__retrieveGetDataResponse *p;
	size_t k = sizeof(struct __ns1__retrieveGetDataResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__retrieveGetDataResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__retrieveGetDataResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__retrieveGetDataResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__retrieveGetDataResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__retrieveGetDataResponse(struct soap *soap, const struct __ns1__retrieveGetDataResponse *a, const char *tag, const char *type)
{
	if (soap_out___ns1__retrieveGetDataResponse(soap, tag ? tag : "-ns1:retrieveGetDataResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__retrieveGetDataResponse * SOAP_FMAC4 soap_get___ns1__retrieveGetDataResponse(struct soap *soap, struct __ns1__retrieveGetDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__retrieveGetDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__submitGetDataRequest(struct soap *soap, struct __ns1__submitGetDataRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__submitGetDataRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__submitGetDataRequest(struct soap *soap, const struct __ns1__submitGetDataRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SubmitGetDataRequest(soap, &a->ns1__submitGetDataRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__submitGetDataRequest(struct soap *soap, const char *tag, int id, const struct __ns1__submitGetDataRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SubmitGetDataRequest(soap, "ns1:submitGetDataRequest", -1, &a->ns1__submitGetDataRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__submitGetDataRequest * SOAP_FMAC4 soap_in___ns1__submitGetDataRequest(struct soap *soap, const char *tag, struct __ns1__submitGetDataRequest *a, const char *type)
{
	size_t soap_flag_ns1__submitGetDataRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__submitGetDataRequest*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__submitGetDataRequest, sizeof(struct __ns1__submitGetDataRequest), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__submitGetDataRequest(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__submitGetDataRequest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__SubmitGetDataRequest(soap, "ns1:submitGetDataRequest", &a->ns1__submitGetDataRequest, "ns1:SubmitGetDataRequest"))
				{	soap_flag_ns1__submitGetDataRequest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__submitGetDataRequest * SOAP_FMAC2 soap_instantiate___ns1__submitGetDataRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__submitGetDataRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__submitGetDataRequest *p;
	size_t k = sizeof(struct __ns1__submitGetDataRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__submitGetDataRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__submitGetDataRequest);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__submitGetDataRequest, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__submitGetDataRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__submitGetDataRequest(struct soap *soap, const struct __ns1__submitGetDataRequest *a, const char *tag, const char *type)
{
	if (soap_out___ns1__submitGetDataRequest(soap, tag ? tag : "-ns1:submitGetDataRequest", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__submitGetDataRequest * SOAP_FMAC4 soap_get___ns1__submitGetDataRequest(struct soap *soap, struct __ns1__submitGetDataRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__submitGetDataRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	(void)soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RetrieveMmktBvalDealsUploadRequest(struct soap *soap, ns1__RetrieveMmktBvalDealsUploadRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__RetrieveMmktBvalDealsUploadRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RetrieveMmktBvalDealsUploadRequest(struct soap *soap, const char *tag, int id, ns1__RetrieveMmktBvalDealsUploadRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__RetrieveMmktBvalDealsUploadRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__RetrieveMmktBvalDealsUploadRequest ? type : NULL);
}

SOAP_FMAC3 ns1__RetrieveMmktBvalDealsUploadRequest ** SOAP_FMAC4 soap_in_PointerTons1__RetrieveMmktBvalDealsUploadRequest(struct soap *soap, const char *tag, ns1__RetrieveMmktBvalDealsUploadRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__RetrieveMmktBvalDealsUploadRequest **)soap_malloc(soap, sizeof(ns1__RetrieveMmktBvalDealsUploadRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__RetrieveMmktBvalDealsUploadRequest *)soap_instantiate_ns1__RetrieveMmktBvalDealsUploadRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__RetrieveMmktBvalDealsUploadRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__RetrieveMmktBvalDealsUploadRequest, sizeof(ns1__RetrieveMmktBvalDealsUploadRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RetrieveMmktBvalDealsUploadRequest(struct soap *soap, ns1__RetrieveMmktBvalDealsUploadRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__RetrieveMmktBvalDealsUploadRequest(soap, tag ? tag : "ns1:RetrieveMmktBvalDealsUploadRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__RetrieveMmktBvalDealsUploadRequest ** SOAP_FMAC4 soap_get_PointerTons1__RetrieveMmktBvalDealsUploadRequest(struct soap *soap, ns1__RetrieveMmktBvalDealsUploadRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RetrieveMmktBvalDealsUploadRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SubmitMmktBvalDealsUploadRequest(struct soap *soap, ns1__SubmitMmktBvalDealsUploadRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SubmitMmktBvalDealsUploadRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SubmitMmktBvalDealsUploadRequest(struct soap *soap, const char *tag, int id, ns1__SubmitMmktBvalDealsUploadRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SubmitMmktBvalDealsUploadRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__SubmitMmktBvalDealsUploadRequest ? type : NULL);
}

SOAP_FMAC3 ns1__SubmitMmktBvalDealsUploadRequest ** SOAP_FMAC4 soap_in_PointerTons1__SubmitMmktBvalDealsUploadRequest(struct soap *soap, const char *tag, ns1__SubmitMmktBvalDealsUploadRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SubmitMmktBvalDealsUploadRequest **)soap_malloc(soap, sizeof(ns1__SubmitMmktBvalDealsUploadRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SubmitMmktBvalDealsUploadRequest *)soap_instantiate_ns1__SubmitMmktBvalDealsUploadRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__SubmitMmktBvalDealsUploadRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SubmitMmktBvalDealsUploadRequest, sizeof(ns1__SubmitMmktBvalDealsUploadRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SubmitMmktBvalDealsUploadRequest(struct soap *soap, ns1__SubmitMmktBvalDealsUploadRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SubmitMmktBvalDealsUploadRequest(soap, tag ? tag : "ns1:SubmitMmktBvalDealsUploadRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SubmitMmktBvalDealsUploadRequest ** SOAP_FMAC4 soap_get_PointerTons1__SubmitMmktBvalDealsUploadRequest(struct soap *soap, ns1__SubmitMmktBvalDealsUploadRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SubmitMmktBvalDealsUploadRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__GetFieldsRequest(struct soap *soap, ns1__GetFieldsRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__GetFieldsRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__GetFieldsRequest(struct soap *soap, const char *tag, int id, ns1__GetFieldsRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__GetFieldsRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__GetFieldsRequest ? type : NULL);
}

SOAP_FMAC3 ns1__GetFieldsRequest ** SOAP_FMAC4 soap_in_PointerTons1__GetFieldsRequest(struct soap *soap, const char *tag, ns1__GetFieldsRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__GetFieldsRequest **)soap_malloc(soap, sizeof(ns1__GetFieldsRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__GetFieldsRequest *)soap_instantiate_ns1__GetFieldsRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__GetFieldsRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__GetFieldsRequest, sizeof(ns1__GetFieldsRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__GetFieldsRequest(struct soap *soap, ns1__GetFieldsRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__GetFieldsRequest(soap, tag ? tag : "ns1:GetFieldsRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__GetFieldsRequest ** SOAP_FMAC4 soap_get_PointerTons1__GetFieldsRequest(struct soap *soap, ns1__GetFieldsRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__GetFieldsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RetrieveOtcBvalDealsUploadRequest(struct soap *soap, ns1__RetrieveOtcBvalDealsUploadRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__RetrieveOtcBvalDealsUploadRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RetrieveOtcBvalDealsUploadRequest(struct soap *soap, const char *tag, int id, ns1__RetrieveOtcBvalDealsUploadRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__RetrieveOtcBvalDealsUploadRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__RetrieveOtcBvalDealsUploadRequest ? type : NULL);
}

SOAP_FMAC3 ns1__RetrieveOtcBvalDealsUploadRequest ** SOAP_FMAC4 soap_in_PointerTons1__RetrieveOtcBvalDealsUploadRequest(struct soap *soap, const char *tag, ns1__RetrieveOtcBvalDealsUploadRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__RetrieveOtcBvalDealsUploadRequest **)soap_malloc(soap, sizeof(ns1__RetrieveOtcBvalDealsUploadRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__RetrieveOtcBvalDealsUploadRequest *)soap_instantiate_ns1__RetrieveOtcBvalDealsUploadRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__RetrieveOtcBvalDealsUploadRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__RetrieveOtcBvalDealsUploadRequest, sizeof(ns1__RetrieveOtcBvalDealsUploadRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RetrieveOtcBvalDealsUploadRequest(struct soap *soap, ns1__RetrieveOtcBvalDealsUploadRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__RetrieveOtcBvalDealsUploadRequest(soap, tag ? tag : "ns1:RetrieveOtcBvalDealsUploadRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__RetrieveOtcBvalDealsUploadRequest ** SOAP_FMAC4 soap_get_PointerTons1__RetrieveOtcBvalDealsUploadRequest(struct soap *soap, ns1__RetrieveOtcBvalDealsUploadRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RetrieveOtcBvalDealsUploadRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SubmitOtcBvalDealsUploadRequest(struct soap *soap, ns1__SubmitOtcBvalDealsUploadRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SubmitOtcBvalDealsUploadRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SubmitOtcBvalDealsUploadRequest(struct soap *soap, const char *tag, int id, ns1__SubmitOtcBvalDealsUploadRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SubmitOtcBvalDealsUploadRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__SubmitOtcBvalDealsUploadRequest ? type : NULL);
}

SOAP_FMAC3 ns1__SubmitOtcBvalDealsUploadRequest ** SOAP_FMAC4 soap_in_PointerTons1__SubmitOtcBvalDealsUploadRequest(struct soap *soap, const char *tag, ns1__SubmitOtcBvalDealsUploadRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SubmitOtcBvalDealsUploadRequest **)soap_malloc(soap, sizeof(ns1__SubmitOtcBvalDealsUploadRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SubmitOtcBvalDealsUploadRequest *)soap_instantiate_ns1__SubmitOtcBvalDealsUploadRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__SubmitOtcBvalDealsUploadRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SubmitOtcBvalDealsUploadRequest, sizeof(ns1__SubmitOtcBvalDealsUploadRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SubmitOtcBvalDealsUploadRequest(struct soap *soap, ns1__SubmitOtcBvalDealsUploadRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SubmitOtcBvalDealsUploadRequest(soap, tag ? tag : "ns1:SubmitOtcBvalDealsUploadRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SubmitOtcBvalDealsUploadRequest ** SOAP_FMAC4 soap_get_PointerTons1__SubmitOtcBvalDealsUploadRequest(struct soap *soap, ns1__SubmitOtcBvalDealsUploadRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SubmitOtcBvalDealsUploadRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RetrieveOtcbvalUploadRequest(struct soap *soap, ns1__RetrieveOtcbvalUploadRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__RetrieveOtcbvalUploadRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RetrieveOtcbvalUploadRequest(struct soap *soap, const char *tag, int id, ns1__RetrieveOtcbvalUploadRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__RetrieveOtcbvalUploadRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__RetrieveOtcbvalUploadRequest ? type : NULL);
}

SOAP_FMAC3 ns1__RetrieveOtcbvalUploadRequest ** SOAP_FMAC4 soap_in_PointerTons1__RetrieveOtcbvalUploadRequest(struct soap *soap, const char *tag, ns1__RetrieveOtcbvalUploadRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__RetrieveOtcbvalUploadRequest **)soap_malloc(soap, sizeof(ns1__RetrieveOtcbvalUploadRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__RetrieveOtcbvalUploadRequest *)soap_instantiate_ns1__RetrieveOtcbvalUploadRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__RetrieveOtcbvalUploadRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__RetrieveOtcbvalUploadRequest, sizeof(ns1__RetrieveOtcbvalUploadRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RetrieveOtcbvalUploadRequest(struct soap *soap, ns1__RetrieveOtcbvalUploadRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__RetrieveOtcbvalUploadRequest(soap, tag ? tag : "ns1:RetrieveOtcbvalUploadRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__RetrieveOtcbvalUploadRequest ** SOAP_FMAC4 soap_get_PointerTons1__RetrieveOtcbvalUploadRequest(struct soap *soap, ns1__RetrieveOtcbvalUploadRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RetrieveOtcbvalUploadRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SubmitOtcbvalUploadRequest(struct soap *soap, ns1__SubmitOtcbvalUploadRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SubmitOtcbvalUploadRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SubmitOtcbvalUploadRequest(struct soap *soap, const char *tag, int id, ns1__SubmitOtcbvalUploadRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SubmitOtcbvalUploadRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__SubmitOtcbvalUploadRequest ? type : NULL);
}

SOAP_FMAC3 ns1__SubmitOtcbvalUploadRequest ** SOAP_FMAC4 soap_in_PointerTons1__SubmitOtcbvalUploadRequest(struct soap *soap, const char *tag, ns1__SubmitOtcbvalUploadRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SubmitOtcbvalUploadRequest **)soap_malloc(soap, sizeof(ns1__SubmitOtcbvalUploadRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SubmitOtcbvalUploadRequest *)soap_instantiate_ns1__SubmitOtcbvalUploadRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__SubmitOtcbvalUploadRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SubmitOtcbvalUploadRequest, sizeof(ns1__SubmitOtcbvalUploadRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SubmitOtcbvalUploadRequest(struct soap *soap, ns1__SubmitOtcbvalUploadRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SubmitOtcbvalUploadRequest(soap, tag ? tag : "ns1:SubmitOtcbvalUploadRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SubmitOtcbvalUploadRequest ** SOAP_FMAC4 soap_get_PointerTons1__SubmitOtcbvalUploadRequest(struct soap *soap, ns1__SubmitOtcbvalUploadRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SubmitOtcbvalUploadRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RetrieveGetAllQuotesRequest(struct soap *soap, ns1__RetrieveGetAllQuotesRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__RetrieveGetAllQuotesRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RetrieveGetAllQuotesRequest(struct soap *soap, const char *tag, int id, ns1__RetrieveGetAllQuotesRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__RetrieveGetAllQuotesRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__RetrieveGetAllQuotesRequest ? type : NULL);
}

SOAP_FMAC3 ns1__RetrieveGetAllQuotesRequest ** SOAP_FMAC4 soap_in_PointerTons1__RetrieveGetAllQuotesRequest(struct soap *soap, const char *tag, ns1__RetrieveGetAllQuotesRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__RetrieveGetAllQuotesRequest **)soap_malloc(soap, sizeof(ns1__RetrieveGetAllQuotesRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__RetrieveGetAllQuotesRequest *)soap_instantiate_ns1__RetrieveGetAllQuotesRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__RetrieveGetAllQuotesRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__RetrieveGetAllQuotesRequest, sizeof(ns1__RetrieveGetAllQuotesRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RetrieveGetAllQuotesRequest(struct soap *soap, ns1__RetrieveGetAllQuotesRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__RetrieveGetAllQuotesRequest(soap, tag ? tag : "ns1:RetrieveGetAllQuotesRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__RetrieveGetAllQuotesRequest ** SOAP_FMAC4 soap_get_PointerTons1__RetrieveGetAllQuotesRequest(struct soap *soap, ns1__RetrieveGetAllQuotesRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RetrieveGetAllQuotesRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SubmitGetAllQuotesRequest(struct soap *soap, ns1__SubmitGetAllQuotesRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SubmitGetAllQuotesRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SubmitGetAllQuotesRequest(struct soap *soap, const char *tag, int id, ns1__SubmitGetAllQuotesRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SubmitGetAllQuotesRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__SubmitGetAllQuotesRequest ? type : NULL);
}

SOAP_FMAC3 ns1__SubmitGetAllQuotesRequest ** SOAP_FMAC4 soap_in_PointerTons1__SubmitGetAllQuotesRequest(struct soap *soap, const char *tag, ns1__SubmitGetAllQuotesRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SubmitGetAllQuotesRequest **)soap_malloc(soap, sizeof(ns1__SubmitGetAllQuotesRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SubmitGetAllQuotesRequest *)soap_instantiate_ns1__SubmitGetAllQuotesRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__SubmitGetAllQuotesRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SubmitGetAllQuotesRequest, sizeof(ns1__SubmitGetAllQuotesRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SubmitGetAllQuotesRequest(struct soap *soap, ns1__SubmitGetAllQuotesRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SubmitGetAllQuotesRequest(soap, tag ? tag : "ns1:SubmitGetAllQuotesRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SubmitGetAllQuotesRequest ** SOAP_FMAC4 soap_get_PointerTons1__SubmitGetAllQuotesRequest(struct soap *soap, ns1__SubmitGetAllQuotesRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SubmitGetAllQuotesRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RetrieveGetQuotesRequest(struct soap *soap, ns1__RetrieveGetQuotesRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__RetrieveGetQuotesRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RetrieveGetQuotesRequest(struct soap *soap, const char *tag, int id, ns1__RetrieveGetQuotesRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__RetrieveGetQuotesRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__RetrieveGetQuotesRequest ? type : NULL);
}

SOAP_FMAC3 ns1__RetrieveGetQuotesRequest ** SOAP_FMAC4 soap_in_PointerTons1__RetrieveGetQuotesRequest(struct soap *soap, const char *tag, ns1__RetrieveGetQuotesRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__RetrieveGetQuotesRequest **)soap_malloc(soap, sizeof(ns1__RetrieveGetQuotesRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__RetrieveGetQuotesRequest *)soap_instantiate_ns1__RetrieveGetQuotesRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__RetrieveGetQuotesRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__RetrieveGetQuotesRequest, sizeof(ns1__RetrieveGetQuotesRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RetrieveGetQuotesRequest(struct soap *soap, ns1__RetrieveGetQuotesRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__RetrieveGetQuotesRequest(soap, tag ? tag : "ns1:RetrieveGetQuotesRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__RetrieveGetQuotesRequest ** SOAP_FMAC4 soap_get_PointerTons1__RetrieveGetQuotesRequest(struct soap *soap, ns1__RetrieveGetQuotesRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RetrieveGetQuotesRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SubmitGetQuotesRequest(struct soap *soap, ns1__SubmitGetQuotesRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SubmitGetQuotesRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SubmitGetQuotesRequest(struct soap *soap, const char *tag, int id, ns1__SubmitGetQuotesRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SubmitGetQuotesRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__SubmitGetQuotesRequest ? type : NULL);
}

SOAP_FMAC3 ns1__SubmitGetQuotesRequest ** SOAP_FMAC4 soap_in_PointerTons1__SubmitGetQuotesRequest(struct soap *soap, const char *tag, ns1__SubmitGetQuotesRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SubmitGetQuotesRequest **)soap_malloc(soap, sizeof(ns1__SubmitGetQuotesRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SubmitGetQuotesRequest *)soap_instantiate_ns1__SubmitGetQuotesRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__SubmitGetQuotesRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SubmitGetQuotesRequest, sizeof(ns1__SubmitGetQuotesRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SubmitGetQuotesRequest(struct soap *soap, ns1__SubmitGetQuotesRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SubmitGetQuotesRequest(soap, tag ? tag : "ns1:SubmitGetQuotesRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SubmitGetQuotesRequest ** SOAP_FMAC4 soap_get_PointerTons1__SubmitGetQuotesRequest(struct soap *soap, ns1__SubmitGetQuotesRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SubmitGetQuotesRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__GetPortfolioValidationRequest(struct soap *soap, ns1__GetPortfolioValidationRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__GetPortfolioValidationRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__GetPortfolioValidationRequest(struct soap *soap, const char *tag, int id, ns1__GetPortfolioValidationRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__GetPortfolioValidationRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__GetPortfolioValidationRequest ? type : NULL);
}

SOAP_FMAC3 ns1__GetPortfolioValidationRequest ** SOAP_FMAC4 soap_in_PointerTons1__GetPortfolioValidationRequest(struct soap *soap, const char *tag, ns1__GetPortfolioValidationRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__GetPortfolioValidationRequest **)soap_malloc(soap, sizeof(ns1__GetPortfolioValidationRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__GetPortfolioValidationRequest *)soap_instantiate_ns1__GetPortfolioValidationRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__GetPortfolioValidationRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__GetPortfolioValidationRequest, sizeof(ns1__GetPortfolioValidationRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__GetPortfolioValidationRequest(struct soap *soap, ns1__GetPortfolioValidationRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__GetPortfolioValidationRequest(soap, tag ? tag : "ns1:GetPortfolioValidationRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__GetPortfolioValidationRequest ** SOAP_FMAC4 soap_get_PointerTons1__GetPortfolioValidationRequest(struct soap *soap, ns1__GetPortfolioValidationRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__GetPortfolioValidationRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RetrieveGetActionsRequest(struct soap *soap, ns1__RetrieveGetActionsRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__RetrieveGetActionsRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RetrieveGetActionsRequest(struct soap *soap, const char *tag, int id, ns1__RetrieveGetActionsRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__RetrieveGetActionsRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__RetrieveGetActionsRequest ? type : NULL);
}

SOAP_FMAC3 ns1__RetrieveGetActionsRequest ** SOAP_FMAC4 soap_in_PointerTons1__RetrieveGetActionsRequest(struct soap *soap, const char *tag, ns1__RetrieveGetActionsRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__RetrieveGetActionsRequest **)soap_malloc(soap, sizeof(ns1__RetrieveGetActionsRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__RetrieveGetActionsRequest *)soap_instantiate_ns1__RetrieveGetActionsRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__RetrieveGetActionsRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__RetrieveGetActionsRequest, sizeof(ns1__RetrieveGetActionsRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RetrieveGetActionsRequest(struct soap *soap, ns1__RetrieveGetActionsRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__RetrieveGetActionsRequest(soap, tag ? tag : "ns1:RetrieveGetActionsRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__RetrieveGetActionsRequest ** SOAP_FMAC4 soap_get_PointerTons1__RetrieveGetActionsRequest(struct soap *soap, ns1__RetrieveGetActionsRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RetrieveGetActionsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SubmitGetActionsRequest(struct soap *soap, ns1__SubmitGetActionsRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SubmitGetActionsRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SubmitGetActionsRequest(struct soap *soap, const char *tag, int id, ns1__SubmitGetActionsRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SubmitGetActionsRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__SubmitGetActionsRequest ? type : NULL);
}

SOAP_FMAC3 ns1__SubmitGetActionsRequest ** SOAP_FMAC4 soap_in_PointerTons1__SubmitGetActionsRequest(struct soap *soap, const char *tag, ns1__SubmitGetActionsRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SubmitGetActionsRequest **)soap_malloc(soap, sizeof(ns1__SubmitGetActionsRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SubmitGetActionsRequest *)soap_instantiate_ns1__SubmitGetActionsRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__SubmitGetActionsRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SubmitGetActionsRequest, sizeof(ns1__SubmitGetActionsRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SubmitGetActionsRequest(struct soap *soap, ns1__SubmitGetActionsRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SubmitGetActionsRequest(soap, tag ? tag : "ns1:SubmitGetActionsRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SubmitGetActionsRequest ** SOAP_FMAC4 soap_get_PointerTons1__SubmitGetActionsRequest(struct soap *soap, ns1__SubmitGetActionsRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SubmitGetActionsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RetrieveGetCompanyRequest(struct soap *soap, ns1__RetrieveGetCompanyRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__RetrieveGetCompanyRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RetrieveGetCompanyRequest(struct soap *soap, const char *tag, int id, ns1__RetrieveGetCompanyRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__RetrieveGetCompanyRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__RetrieveGetCompanyRequest ? type : NULL);
}

SOAP_FMAC3 ns1__RetrieveGetCompanyRequest ** SOAP_FMAC4 soap_in_PointerTons1__RetrieveGetCompanyRequest(struct soap *soap, const char *tag, ns1__RetrieveGetCompanyRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__RetrieveGetCompanyRequest **)soap_malloc(soap, sizeof(ns1__RetrieveGetCompanyRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__RetrieveGetCompanyRequest *)soap_instantiate_ns1__RetrieveGetCompanyRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__RetrieveGetCompanyRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__RetrieveGetCompanyRequest, sizeof(ns1__RetrieveGetCompanyRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RetrieveGetCompanyRequest(struct soap *soap, ns1__RetrieveGetCompanyRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__RetrieveGetCompanyRequest(soap, tag ? tag : "ns1:RetrieveGetCompanyRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__RetrieveGetCompanyRequest ** SOAP_FMAC4 soap_get_PointerTons1__RetrieveGetCompanyRequest(struct soap *soap, ns1__RetrieveGetCompanyRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RetrieveGetCompanyRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SubmitGetCompanyRequest(struct soap *soap, ns1__SubmitGetCompanyRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SubmitGetCompanyRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SubmitGetCompanyRequest(struct soap *soap, const char *tag, int id, ns1__SubmitGetCompanyRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SubmitGetCompanyRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__SubmitGetCompanyRequest ? type : NULL);
}

SOAP_FMAC3 ns1__SubmitGetCompanyRequest ** SOAP_FMAC4 soap_in_PointerTons1__SubmitGetCompanyRequest(struct soap *soap, const char *tag, ns1__SubmitGetCompanyRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SubmitGetCompanyRequest **)soap_malloc(soap, sizeof(ns1__SubmitGetCompanyRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SubmitGetCompanyRequest *)soap_instantiate_ns1__SubmitGetCompanyRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__SubmitGetCompanyRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SubmitGetCompanyRequest, sizeof(ns1__SubmitGetCompanyRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SubmitGetCompanyRequest(struct soap *soap, ns1__SubmitGetCompanyRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SubmitGetCompanyRequest(soap, tag ? tag : "ns1:SubmitGetCompanyRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SubmitGetCompanyRequest ** SOAP_FMAC4 soap_get_PointerTons1__SubmitGetCompanyRequest(struct soap *soap, ns1__SubmitGetCompanyRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SubmitGetCompanyRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RetrieveGetFundamentalsRequest(struct soap *soap, ns1__RetrieveGetFundamentalsRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__RetrieveGetFundamentalsRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RetrieveGetFundamentalsRequest(struct soap *soap, const char *tag, int id, ns1__RetrieveGetFundamentalsRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__RetrieveGetFundamentalsRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__RetrieveGetFundamentalsRequest ? type : NULL);
}

SOAP_FMAC3 ns1__RetrieveGetFundamentalsRequest ** SOAP_FMAC4 soap_in_PointerTons1__RetrieveGetFundamentalsRequest(struct soap *soap, const char *tag, ns1__RetrieveGetFundamentalsRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__RetrieveGetFundamentalsRequest **)soap_malloc(soap, sizeof(ns1__RetrieveGetFundamentalsRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__RetrieveGetFundamentalsRequest *)soap_instantiate_ns1__RetrieveGetFundamentalsRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__RetrieveGetFundamentalsRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__RetrieveGetFundamentalsRequest, sizeof(ns1__RetrieveGetFundamentalsRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RetrieveGetFundamentalsRequest(struct soap *soap, ns1__RetrieveGetFundamentalsRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__RetrieveGetFundamentalsRequest(soap, tag ? tag : "ns1:RetrieveGetFundamentalsRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__RetrieveGetFundamentalsRequest ** SOAP_FMAC4 soap_get_PointerTons1__RetrieveGetFundamentalsRequest(struct soap *soap, ns1__RetrieveGetFundamentalsRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RetrieveGetFundamentalsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SubmitGetFundamentalsRequest(struct soap *soap, ns1__SubmitGetFundamentalsRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SubmitGetFundamentalsRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SubmitGetFundamentalsRequest(struct soap *soap, const char *tag, int id, ns1__SubmitGetFundamentalsRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SubmitGetFundamentalsRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__SubmitGetFundamentalsRequest ? type : NULL);
}

SOAP_FMAC3 ns1__SubmitGetFundamentalsRequest ** SOAP_FMAC4 soap_in_PointerTons1__SubmitGetFundamentalsRequest(struct soap *soap, const char *tag, ns1__SubmitGetFundamentalsRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SubmitGetFundamentalsRequest **)soap_malloc(soap, sizeof(ns1__SubmitGetFundamentalsRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SubmitGetFundamentalsRequest *)soap_instantiate_ns1__SubmitGetFundamentalsRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__SubmitGetFundamentalsRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SubmitGetFundamentalsRequest, sizeof(ns1__SubmitGetFundamentalsRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SubmitGetFundamentalsRequest(struct soap *soap, ns1__SubmitGetFundamentalsRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SubmitGetFundamentalsRequest(soap, tag ? tag : "ns1:SubmitGetFundamentalsRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SubmitGetFundamentalsRequest ** SOAP_FMAC4 soap_get_PointerTons1__SubmitGetFundamentalsRequest(struct soap *soap, ns1__SubmitGetFundamentalsRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SubmitGetFundamentalsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__GetCorrectionsRequest(struct soap *soap, ns1__GetCorrectionsRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__GetCorrectionsRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__GetCorrectionsRequest(struct soap *soap, const char *tag, int id, ns1__GetCorrectionsRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__GetCorrectionsRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__GetCorrectionsRequest ? type : NULL);
}

SOAP_FMAC3 ns1__GetCorrectionsRequest ** SOAP_FMAC4 soap_in_PointerTons1__GetCorrectionsRequest(struct soap *soap, const char *tag, ns1__GetCorrectionsRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__GetCorrectionsRequest **)soap_malloc(soap, sizeof(ns1__GetCorrectionsRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__GetCorrectionsRequest *)soap_instantiate_ns1__GetCorrectionsRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__GetCorrectionsRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__GetCorrectionsRequest, sizeof(ns1__GetCorrectionsRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__GetCorrectionsRequest(struct soap *soap, ns1__GetCorrectionsRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__GetCorrectionsRequest(soap, tag ? tag : "ns1:GetCorrectionsRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__GetCorrectionsRequest ** SOAP_FMAC4 soap_get_PointerTons1__GetCorrectionsRequest(struct soap *soap, ns1__GetCorrectionsRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__GetCorrectionsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RetrieveCancelRequest(struct soap *soap, ns1__RetrieveCancelRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__RetrieveCancelRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RetrieveCancelRequest(struct soap *soap, const char *tag, int id, ns1__RetrieveCancelRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__RetrieveCancelRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__RetrieveCancelRequest ? type : NULL);
}

SOAP_FMAC3 ns1__RetrieveCancelRequest ** SOAP_FMAC4 soap_in_PointerTons1__RetrieveCancelRequest(struct soap *soap, const char *tag, ns1__RetrieveCancelRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__RetrieveCancelRequest **)soap_malloc(soap, sizeof(ns1__RetrieveCancelRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__RetrieveCancelRequest *)soap_instantiate_ns1__RetrieveCancelRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__RetrieveCancelRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__RetrieveCancelRequest, sizeof(ns1__RetrieveCancelRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RetrieveCancelRequest(struct soap *soap, ns1__RetrieveCancelRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__RetrieveCancelRequest(soap, tag ? tag : "ns1:RetrieveCancelRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__RetrieveCancelRequest ** SOAP_FMAC4 soap_get_PointerTons1__RetrieveCancelRequest(struct soap *soap, ns1__RetrieveCancelRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RetrieveCancelRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SubmitCancelRequest(struct soap *soap, ns1__SubmitCancelRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SubmitCancelRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SubmitCancelRequest(struct soap *soap, const char *tag, int id, ns1__SubmitCancelRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SubmitCancelRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__SubmitCancelRequest ? type : NULL);
}

SOAP_FMAC3 ns1__SubmitCancelRequest ** SOAP_FMAC4 soap_in_PointerTons1__SubmitCancelRequest(struct soap *soap, const char *tag, ns1__SubmitCancelRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SubmitCancelRequest **)soap_malloc(soap, sizeof(ns1__SubmitCancelRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SubmitCancelRequest *)soap_instantiate_ns1__SubmitCancelRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__SubmitCancelRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SubmitCancelRequest, sizeof(ns1__SubmitCancelRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SubmitCancelRequest(struct soap *soap, ns1__SubmitCancelRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SubmitCancelRequest(soap, tag ? tag : "ns1:SubmitCancelRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SubmitCancelRequest ** SOAP_FMAC4 soap_get_PointerTons1__SubmitCancelRequest(struct soap *soap, ns1__SubmitCancelRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SubmitCancelRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RetrieveScheduledRequest(struct soap *soap, ns1__RetrieveScheduledRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__RetrieveScheduledRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RetrieveScheduledRequest(struct soap *soap, const char *tag, int id, ns1__RetrieveScheduledRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__RetrieveScheduledRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__RetrieveScheduledRequest ? type : NULL);
}

SOAP_FMAC3 ns1__RetrieveScheduledRequest ** SOAP_FMAC4 soap_in_PointerTons1__RetrieveScheduledRequest(struct soap *soap, const char *tag, ns1__RetrieveScheduledRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__RetrieveScheduledRequest **)soap_malloc(soap, sizeof(ns1__RetrieveScheduledRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__RetrieveScheduledRequest *)soap_instantiate_ns1__RetrieveScheduledRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__RetrieveScheduledRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__RetrieveScheduledRequest, sizeof(ns1__RetrieveScheduledRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RetrieveScheduledRequest(struct soap *soap, ns1__RetrieveScheduledRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__RetrieveScheduledRequest(soap, tag ? tag : "ns1:RetrieveScheduledRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__RetrieveScheduledRequest ** SOAP_FMAC4 soap_get_PointerTons1__RetrieveScheduledRequest(struct soap *soap, ns1__RetrieveScheduledRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RetrieveScheduledRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SubmitScheduledRequest(struct soap *soap, ns1__SubmitScheduledRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SubmitScheduledRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SubmitScheduledRequest(struct soap *soap, const char *tag, int id, ns1__SubmitScheduledRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SubmitScheduledRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__SubmitScheduledRequest ? type : NULL);
}

SOAP_FMAC3 ns1__SubmitScheduledRequest ** SOAP_FMAC4 soap_in_PointerTons1__SubmitScheduledRequest(struct soap *soap, const char *tag, ns1__SubmitScheduledRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SubmitScheduledRequest **)soap_malloc(soap, sizeof(ns1__SubmitScheduledRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SubmitScheduledRequest *)soap_instantiate_ns1__SubmitScheduledRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__SubmitScheduledRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SubmitScheduledRequest, sizeof(ns1__SubmitScheduledRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SubmitScheduledRequest(struct soap *soap, ns1__SubmitScheduledRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SubmitScheduledRequest(soap, tag ? tag : "ns1:SubmitScheduledRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SubmitScheduledRequest ** SOAP_FMAC4 soap_get_PointerTons1__SubmitScheduledRequest(struct soap *soap, ns1__SubmitScheduledRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SubmitScheduledRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RetrieveGetHistoryRequest(struct soap *soap, ns1__RetrieveGetHistoryRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__RetrieveGetHistoryRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RetrieveGetHistoryRequest(struct soap *soap, const char *tag, int id, ns1__RetrieveGetHistoryRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__RetrieveGetHistoryRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__RetrieveGetHistoryRequest ? type : NULL);
}

SOAP_FMAC3 ns1__RetrieveGetHistoryRequest ** SOAP_FMAC4 soap_in_PointerTons1__RetrieveGetHistoryRequest(struct soap *soap, const char *tag, ns1__RetrieveGetHistoryRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__RetrieveGetHistoryRequest **)soap_malloc(soap, sizeof(ns1__RetrieveGetHistoryRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__RetrieveGetHistoryRequest *)soap_instantiate_ns1__RetrieveGetHistoryRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__RetrieveGetHistoryRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__RetrieveGetHistoryRequest, sizeof(ns1__RetrieveGetHistoryRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RetrieveGetHistoryRequest(struct soap *soap, ns1__RetrieveGetHistoryRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__RetrieveGetHistoryRequest(soap, tag ? tag : "ns1:RetrieveGetHistoryRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__RetrieveGetHistoryRequest ** SOAP_FMAC4 soap_get_PointerTons1__RetrieveGetHistoryRequest(struct soap *soap, ns1__RetrieveGetHistoryRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RetrieveGetHistoryRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SubmitGetHistoryRequest(struct soap *soap, ns1__SubmitGetHistoryRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SubmitGetHistoryRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SubmitGetHistoryRequest(struct soap *soap, const char *tag, int id, ns1__SubmitGetHistoryRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SubmitGetHistoryRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__SubmitGetHistoryRequest ? type : NULL);
}

SOAP_FMAC3 ns1__SubmitGetHistoryRequest ** SOAP_FMAC4 soap_in_PointerTons1__SubmitGetHistoryRequest(struct soap *soap, const char *tag, ns1__SubmitGetHistoryRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SubmitGetHistoryRequest **)soap_malloc(soap, sizeof(ns1__SubmitGetHistoryRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SubmitGetHistoryRequest *)soap_instantiate_ns1__SubmitGetHistoryRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__SubmitGetHistoryRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SubmitGetHistoryRequest, sizeof(ns1__SubmitGetHistoryRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SubmitGetHistoryRequest(struct soap *soap, ns1__SubmitGetHistoryRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SubmitGetHistoryRequest(soap, tag ? tag : "ns1:SubmitGetHistoryRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SubmitGetHistoryRequest ** SOAP_FMAC4 soap_get_PointerTons1__SubmitGetHistoryRequest(struct soap *soap, ns1__SubmitGetHistoryRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SubmitGetHistoryRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RetrieveGetDataRequest(struct soap *soap, ns1__RetrieveGetDataRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__RetrieveGetDataRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RetrieveGetDataRequest(struct soap *soap, const char *tag, int id, ns1__RetrieveGetDataRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__RetrieveGetDataRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__RetrieveGetDataRequest ? type : NULL);
}

SOAP_FMAC3 ns1__RetrieveGetDataRequest ** SOAP_FMAC4 soap_in_PointerTons1__RetrieveGetDataRequest(struct soap *soap, const char *tag, ns1__RetrieveGetDataRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__RetrieveGetDataRequest **)soap_malloc(soap, sizeof(ns1__RetrieveGetDataRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__RetrieveGetDataRequest *)soap_instantiate_ns1__RetrieveGetDataRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__RetrieveGetDataRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__RetrieveGetDataRequest, sizeof(ns1__RetrieveGetDataRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RetrieveGetDataRequest(struct soap *soap, ns1__RetrieveGetDataRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__RetrieveGetDataRequest(soap, tag ? tag : "ns1:RetrieveGetDataRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__RetrieveGetDataRequest ** SOAP_FMAC4 soap_get_PointerTons1__RetrieveGetDataRequest(struct soap *soap, ns1__RetrieveGetDataRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RetrieveGetDataRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SubmitGetDataRequest(struct soap *soap, ns1__SubmitGetDataRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SubmitGetDataRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SubmitGetDataRequest(struct soap *soap, const char *tag, int id, ns1__SubmitGetDataRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SubmitGetDataRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__SubmitGetDataRequest ? type : NULL);
}

SOAP_FMAC3 ns1__SubmitGetDataRequest ** SOAP_FMAC4 soap_in_PointerTons1__SubmitGetDataRequest(struct soap *soap, const char *tag, ns1__SubmitGetDataRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SubmitGetDataRequest **)soap_malloc(soap, sizeof(ns1__SubmitGetDataRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SubmitGetDataRequest *)soap_instantiate_ns1__SubmitGetDataRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__SubmitGetDataRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SubmitGetDataRequest, sizeof(ns1__SubmitGetDataRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SubmitGetDataRequest(struct soap *soap, ns1__SubmitGetDataRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SubmitGetDataRequest(soap, tag ? tag : "ns1:SubmitGetDataRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SubmitGetDataRequest ** SOAP_FMAC4 soap_get_PointerTons1__SubmitGetDataRequest(struct soap *soap, ns1__SubmitGetDataRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SubmitGetDataRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__MmktBvalDealInfos(struct soap *soap, ns1__MmktBvalDealInfos *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__MmktBvalDealInfos))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__MmktBvalDealInfos(struct soap *soap, const char *tag, int id, ns1__MmktBvalDealInfos *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__MmktBvalDealInfos, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__MmktBvalDealInfos ? type : NULL);
}

SOAP_FMAC3 ns1__MmktBvalDealInfos ** SOAP_FMAC4 soap_in_PointerTons1__MmktBvalDealInfos(struct soap *soap, const char *tag, ns1__MmktBvalDealInfos **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__MmktBvalDealInfos **)soap_malloc(soap, sizeof(ns1__MmktBvalDealInfos *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__MmktBvalDealInfos *)soap_instantiate_ns1__MmktBvalDealInfos(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__MmktBvalDealInfos **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__MmktBvalDealInfos, sizeof(ns1__MmktBvalDealInfos), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__MmktBvalDealInfos(struct soap *soap, ns1__MmktBvalDealInfos *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__MmktBvalDealInfos(soap, tag ? tag : "ns1:MmktBvalDealInfos", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__MmktBvalDealInfos ** SOAP_FMAC4 soap_get_PointerTons1__MmktBvalDealInfos(struct soap *soap, ns1__MmktBvalDealInfos **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__MmktBvalDealInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__FieldInfos(struct soap *soap, ns1__FieldInfos *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__FieldInfos))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__FieldInfos(struct soap *soap, const char *tag, int id, ns1__FieldInfos *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__FieldInfos, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__FieldInfos ? type : NULL);
}

SOAP_FMAC3 ns1__FieldInfos ** SOAP_FMAC4 soap_in_PointerTons1__FieldInfos(struct soap *soap, const char *tag, ns1__FieldInfos **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__FieldInfos **)soap_malloc(soap, sizeof(ns1__FieldInfos *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__FieldInfos *)soap_instantiate_ns1__FieldInfos(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__FieldInfos **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__FieldInfos, sizeof(ns1__FieldInfos), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__FieldInfos(struct soap *soap, ns1__FieldInfos *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__FieldInfos(soap, tag ? tag : "ns1:FieldInfos", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__FieldInfos ** SOAP_FMAC4 soap_get_PointerTons1__FieldInfos(struct soap *soap, ns1__FieldInfos **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__FieldInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__OtcDealInfos(struct soap *soap, ns1__OtcDealInfos *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__OtcDealInfos))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__OtcDealInfos(struct soap *soap, const char *tag, int id, ns1__OtcDealInfos *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__OtcDealInfos, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__OtcDealInfos ? type : NULL);
}

SOAP_FMAC3 ns1__OtcDealInfos ** SOAP_FMAC4 soap_in_PointerTons1__OtcDealInfos(struct soap *soap, const char *tag, ns1__OtcDealInfos **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__OtcDealInfos **)soap_malloc(soap, sizeof(ns1__OtcDealInfos *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__OtcDealInfos *)soap_instantiate_ns1__OtcDealInfos(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__OtcDealInfos **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__OtcDealInfos, sizeof(ns1__OtcDealInfos), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__OtcDealInfos(struct soap *soap, ns1__OtcDealInfos *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__OtcDealInfos(soap, tag ? tag : "ns1:OtcDealInfos", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__OtcDealInfos ** SOAP_FMAC4 soap_get_PointerTons1__OtcDealInfos(struct soap *soap, ns1__OtcDealInfos **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__OtcDealInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AllQuotesInstrumentDatas(struct soap *soap, ns1__AllQuotesInstrumentDatas *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AllQuotesInstrumentDatas))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AllQuotesInstrumentDatas(struct soap *soap, const char *tag, int id, ns1__AllQuotesInstrumentDatas *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AllQuotesInstrumentDatas, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__AllQuotesInstrumentDatas ? type : NULL);
}

SOAP_FMAC3 ns1__AllQuotesInstrumentDatas ** SOAP_FMAC4 soap_in_PointerTons1__AllQuotesInstrumentDatas(struct soap *soap, const char *tag, ns1__AllQuotesInstrumentDatas **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AllQuotesInstrumentDatas **)soap_malloc(soap, sizeof(ns1__AllQuotesInstrumentDatas *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__AllQuotesInstrumentDatas *)soap_instantiate_ns1__AllQuotesInstrumentDatas(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__AllQuotesInstrumentDatas **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AllQuotesInstrumentDatas, sizeof(ns1__AllQuotesInstrumentDatas), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AllQuotesInstrumentDatas(struct soap *soap, ns1__AllQuotesInstrumentDatas *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__AllQuotesInstrumentDatas(soap, tag ? tag : "ns1:AllQuotesInstrumentDatas", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__AllQuotesInstrumentDatas ** SOAP_FMAC4 soap_get_PointerTons1__AllQuotesInstrumentDatas(struct soap *soap, ns1__AllQuotesInstrumentDatas **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AllQuotesInstrumentDatas(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__QuotesInstrumentDatas(struct soap *soap, ns1__QuotesInstrumentDatas *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__QuotesInstrumentDatas))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__QuotesInstrumentDatas(struct soap *soap, const char *tag, int id, ns1__QuotesInstrumentDatas *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__QuotesInstrumentDatas, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__QuotesInstrumentDatas ? type : NULL);
}

SOAP_FMAC3 ns1__QuotesInstrumentDatas ** SOAP_FMAC4 soap_in_PointerTons1__QuotesInstrumentDatas(struct soap *soap, const char *tag, ns1__QuotesInstrumentDatas **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__QuotesInstrumentDatas **)soap_malloc(soap, sizeof(ns1__QuotesInstrumentDatas *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__QuotesInstrumentDatas *)soap_instantiate_ns1__QuotesInstrumentDatas(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__QuotesInstrumentDatas **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__QuotesInstrumentDatas, sizeof(ns1__QuotesInstrumentDatas), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__QuotesInstrumentDatas(struct soap *soap, ns1__QuotesInstrumentDatas *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__QuotesInstrumentDatas(soap, tag ? tag : "ns1:QuotesInstrumentDatas", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__QuotesInstrumentDatas ** SOAP_FMAC4 soap_get_PointerTons1__QuotesInstrumentDatas(struct soap *soap, ns1__QuotesInstrumentDatas **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__QuotesInstrumentDatas(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ActionsInstrumentDatas(struct soap *soap, ns1__ActionsInstrumentDatas *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ActionsInstrumentDatas))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ActionsInstrumentDatas(struct soap *soap, const char *tag, int id, ns1__ActionsInstrumentDatas *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ActionsInstrumentDatas, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ActionsInstrumentDatas ? type : NULL);
}

SOAP_FMAC3 ns1__ActionsInstrumentDatas ** SOAP_FMAC4 soap_in_PointerTons1__ActionsInstrumentDatas(struct soap *soap, const char *tag, ns1__ActionsInstrumentDatas **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ActionsInstrumentDatas **)soap_malloc(soap, sizeof(ns1__ActionsInstrumentDatas *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ActionsInstrumentDatas *)soap_instantiate_ns1__ActionsInstrumentDatas(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ActionsInstrumentDatas **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ActionsInstrumentDatas, sizeof(ns1__ActionsInstrumentDatas), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ActionsInstrumentDatas(struct soap *soap, ns1__ActionsInstrumentDatas *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ActionsInstrumentDatas(soap, tag ? tag : "ns1:ActionsInstrumentDatas", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ActionsInstrumentDatas ** SOAP_FMAC4 soap_get_PointerTons1__ActionsInstrumentDatas(struct soap *soap, ns1__ActionsInstrumentDatas **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ActionsInstrumentDatas(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__GetPortfolioValidationHeaders(struct soap *soap, ns1__GetPortfolioValidationHeaders *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__GetPortfolioValidationHeaders))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__GetPortfolioValidationHeaders(struct soap *soap, const char *tag, int id, ns1__GetPortfolioValidationHeaders *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__GetPortfolioValidationHeaders, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__GetPortfolioValidationHeaders ? type : NULL);
}

SOAP_FMAC3 ns1__GetPortfolioValidationHeaders ** SOAP_FMAC4 soap_in_PointerTons1__GetPortfolioValidationHeaders(struct soap *soap, const char *tag, ns1__GetPortfolioValidationHeaders **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__GetPortfolioValidationHeaders **)soap_malloc(soap, sizeof(ns1__GetPortfolioValidationHeaders *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__GetPortfolioValidationHeaders *)soap_instantiate_ns1__GetPortfolioValidationHeaders(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__GetPortfolioValidationHeaders **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__GetPortfolioValidationHeaders, sizeof(ns1__GetPortfolioValidationHeaders), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__GetPortfolioValidationHeaders(struct soap *soap, ns1__GetPortfolioValidationHeaders *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__GetPortfolioValidationHeaders(soap, tag ? tag : "ns1:GetPortfolioValidationHeaders", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__GetPortfolioValidationHeaders ** SOAP_FMAC4 soap_get_PointerTons1__GetPortfolioValidationHeaders(struct soap *soap, ns1__GetPortfolioValidationHeaders **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__GetPortfolioValidationHeaders(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__FundInstrumentDatas(struct soap *soap, ns1__FundInstrumentDatas *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__FundInstrumentDatas))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__FundInstrumentDatas(struct soap *soap, const char *tag, int id, ns1__FundInstrumentDatas *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__FundInstrumentDatas, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__FundInstrumentDatas ? type : NULL);
}

SOAP_FMAC3 ns1__FundInstrumentDatas ** SOAP_FMAC4 soap_in_PointerTons1__FundInstrumentDatas(struct soap *soap, const char *tag, ns1__FundInstrumentDatas **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__FundInstrumentDatas **)soap_malloc(soap, sizeof(ns1__FundInstrumentDatas *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__FundInstrumentDatas *)soap_instantiate_ns1__FundInstrumentDatas(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__FundInstrumentDatas **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__FundInstrumentDatas, sizeof(ns1__FundInstrumentDatas), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__FundInstrumentDatas(struct soap *soap, ns1__FundInstrumentDatas *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__FundInstrumentDatas(soap, tag ? tag : "ns1:FundInstrumentDatas", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__FundInstrumentDatas ** SOAP_FMAC4 soap_get_PointerTons1__FundInstrumentDatas(struct soap *soap, ns1__FundInstrumentDatas **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__FundInstrumentDatas(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ScheduledResponses(struct soap *soap, ns1__ScheduledResponses *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ScheduledResponses))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ScheduledResponses(struct soap *soap, const char *tag, int id, ns1__ScheduledResponses *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ScheduledResponses, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ScheduledResponses ? type : NULL);
}

SOAP_FMAC3 ns1__ScheduledResponses ** SOAP_FMAC4 soap_in_PointerTons1__ScheduledResponses(struct soap *soap, const char *tag, ns1__ScheduledResponses **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ScheduledResponses **)soap_malloc(soap, sizeof(ns1__ScheduledResponses *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ScheduledResponses *)soap_instantiate_ns1__ScheduledResponses(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ScheduledResponses **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ScheduledResponses, sizeof(ns1__ScheduledResponses), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ScheduledResponses(struct soap *soap, ns1__ScheduledResponses *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ScheduledResponses(soap, tag ? tag : "ns1:ScheduledResponses", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ScheduledResponses ** SOAP_FMAC4 soap_get_PointerTons1__ScheduledResponses(struct soap *soap, ns1__ScheduledResponses **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ScheduledResponses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CorrectionRecords(struct soap *soap, ns1__CorrectionRecords *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CorrectionRecords))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CorrectionRecords(struct soap *soap, const char *tag, int id, ns1__CorrectionRecords *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CorrectionRecords, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__CorrectionRecords ? type : NULL);
}

SOAP_FMAC3 ns1__CorrectionRecords ** SOAP_FMAC4 soap_in_PointerTons1__CorrectionRecords(struct soap *soap, const char *tag, ns1__CorrectionRecords **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CorrectionRecords **)soap_malloc(soap, sizeof(ns1__CorrectionRecords *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CorrectionRecords *)soap_instantiate_ns1__CorrectionRecords(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__CorrectionRecords **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CorrectionRecords, sizeof(ns1__CorrectionRecords), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CorrectionRecords(struct soap *soap, ns1__CorrectionRecords *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__CorrectionRecords(soap, tag ? tag : "ns1:CorrectionRecords", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CorrectionRecords ** SOAP_FMAC4 soap_get_PointerTons1__CorrectionRecords(struct soap *soap, ns1__CorrectionRecords **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CorrectionRecords(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__GetCorrectionsHeaders(struct soap *soap, ns1__GetCorrectionsHeaders *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__GetCorrectionsHeaders))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__GetCorrectionsHeaders(struct soap *soap, const char *tag, int id, ns1__GetCorrectionsHeaders *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__GetCorrectionsHeaders, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__GetCorrectionsHeaders ? type : NULL);
}

SOAP_FMAC3 ns1__GetCorrectionsHeaders ** SOAP_FMAC4 soap_in_PointerTons1__GetCorrectionsHeaders(struct soap *soap, const char *tag, ns1__GetCorrectionsHeaders **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__GetCorrectionsHeaders **)soap_malloc(soap, sizeof(ns1__GetCorrectionsHeaders *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__GetCorrectionsHeaders *)soap_instantiate_ns1__GetCorrectionsHeaders(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__GetCorrectionsHeaders **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__GetCorrectionsHeaders, sizeof(ns1__GetCorrectionsHeaders), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__GetCorrectionsHeaders(struct soap *soap, ns1__GetCorrectionsHeaders *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__GetCorrectionsHeaders(soap, tag ? tag : "ns1:GetCorrectionsHeaders", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__GetCorrectionsHeaders ** SOAP_FMAC4 soap_get_PointerTons1__GetCorrectionsHeaders(struct soap *soap, ns1__GetCorrectionsHeaders **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__GetCorrectionsHeaders(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CancelResponseStatus(struct soap *soap, ns1__CancelResponseStatus *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CancelResponseStatus))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CancelResponseStatus(struct soap *soap, const char *tag, int id, ns1__CancelResponseStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CancelResponseStatus, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__CancelResponseStatus ? type : NULL);
}

SOAP_FMAC3 ns1__CancelResponseStatus ** SOAP_FMAC4 soap_in_PointerTons1__CancelResponseStatus(struct soap *soap, const char *tag, ns1__CancelResponseStatus **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CancelResponseStatus **)soap_malloc(soap, sizeof(ns1__CancelResponseStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CancelResponseStatus *)soap_instantiate_ns1__CancelResponseStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__CancelResponseStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CancelResponseStatus, sizeof(ns1__CancelResponseStatus), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CancelResponseStatus(struct soap *soap, ns1__CancelResponseStatus *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__CancelResponseStatus(soap, tag ? tag : "ns1:CancelResponseStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CancelResponseStatus ** SOAP_FMAC4 soap_get_PointerTons1__CancelResponseStatus(struct soap *soap, ns1__CancelResponseStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CancelResponseStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__HistInstrumentDatas(struct soap *soap, ns1__HistInstrumentDatas *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__HistInstrumentDatas))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__HistInstrumentDatas(struct soap *soap, const char *tag, int id, ns1__HistInstrumentDatas *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__HistInstrumentDatas, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__HistInstrumentDatas ? type : NULL);
}

SOAP_FMAC3 ns1__HistInstrumentDatas ** SOAP_FMAC4 soap_in_PointerTons1__HistInstrumentDatas(struct soap *soap, const char *tag, ns1__HistInstrumentDatas **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__HistInstrumentDatas **)soap_malloc(soap, sizeof(ns1__HistInstrumentDatas *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__HistInstrumentDatas *)soap_instantiate_ns1__HistInstrumentDatas(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__HistInstrumentDatas **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__HistInstrumentDatas, sizeof(ns1__HistInstrumentDatas), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__HistInstrumentDatas(struct soap *soap, ns1__HistInstrumentDatas *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__HistInstrumentDatas(soap, tag ? tag : "ns1:HistInstrumentDatas", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__HistInstrumentDatas ** SOAP_FMAC4 soap_get_PointerTons1__HistInstrumentDatas(struct soap *soap, ns1__HistInstrumentDatas **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__HistInstrumentDatas(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__InstrumentDatas(struct soap *soap, ns1__InstrumentDatas *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__InstrumentDatas))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__InstrumentDatas(struct soap *soap, const char *tag, int id, ns1__InstrumentDatas *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__InstrumentDatas, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__InstrumentDatas ? type : NULL);
}

SOAP_FMAC3 ns1__InstrumentDatas ** SOAP_FMAC4 soap_in_PointerTons1__InstrumentDatas(struct soap *soap, const char *tag, ns1__InstrumentDatas **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__InstrumentDatas **)soap_malloc(soap, sizeof(ns1__InstrumentDatas *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__InstrumentDatas *)soap_instantiate_ns1__InstrumentDatas(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__InstrumentDatas **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__InstrumentDatas, sizeof(ns1__InstrumentDatas), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__InstrumentDatas(struct soap *soap, ns1__InstrumentDatas *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__InstrumentDatas(soap, tag ? tag : "ns1:InstrumentDatas", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__InstrumentDatas ** SOAP_FMAC4 soap_get_PointerTons1__InstrumentDatas(struct soap *soap, ns1__InstrumentDatas **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__InstrumentDatas(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__MmktBvalDealInformation(struct soap *soap, ns1__MmktBvalDealInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__MmktBvalDealInformation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__MmktBvalDealInformation(struct soap *soap, const char *tag, int id, ns1__MmktBvalDealInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__MmktBvalDealInformation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__MmktBvalDealInformation ? type : NULL);
}

SOAP_FMAC3 ns1__MmktBvalDealInformation ** SOAP_FMAC4 soap_in_PointerTons1__MmktBvalDealInformation(struct soap *soap, const char *tag, ns1__MmktBvalDealInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__MmktBvalDealInformation **)soap_malloc(soap, sizeof(ns1__MmktBvalDealInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__MmktBvalDealInformation *)soap_instantiate_ns1__MmktBvalDealInformation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__MmktBvalDealInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__MmktBvalDealInformation, sizeof(ns1__MmktBvalDealInformation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__MmktBvalDealInformation(struct soap *soap, ns1__MmktBvalDealInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__MmktBvalDealInformation(soap, tag ? tag : "ns1:MmktBvalDealInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__MmktBvalDealInformation ** SOAP_FMAC4 soap_get_PointerTons1__MmktBvalDealInformation(struct soap *soap, ns1__MmktBvalDealInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__MmktBvalDealInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__MmktBvalHeaders(struct soap *soap, ns1__MmktBvalHeaders *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__MmktBvalHeaders))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__MmktBvalHeaders(struct soap *soap, const char *tag, int id, ns1__MmktBvalHeaders *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__MmktBvalHeaders, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__MmktBvalHeaders ? type : NULL);
}

SOAP_FMAC3 ns1__MmktBvalHeaders ** SOAP_FMAC4 soap_in_PointerTons1__MmktBvalHeaders(struct soap *soap, const char *tag, ns1__MmktBvalHeaders **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__MmktBvalHeaders **)soap_malloc(soap, sizeof(ns1__MmktBvalHeaders *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__MmktBvalHeaders *)soap_instantiate_ns1__MmktBvalHeaders(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__MmktBvalHeaders **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__MmktBvalHeaders, sizeof(ns1__MmktBvalHeaders), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__MmktBvalHeaders(struct soap *soap, ns1__MmktBvalHeaders *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__MmktBvalHeaders(soap, tag ? tag : "ns1:MmktBvalHeaders", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__MmktBvalHeaders ** SOAP_FMAC4 soap_get_PointerTons1__MmktBvalHeaders(struct soap *soap, ns1__MmktBvalHeaders **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__MmktBvalHeaders(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__FieldSearchCriteria(struct soap *soap, ns1__FieldSearchCriteria *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__FieldSearchCriteria))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__FieldSearchCriteria(struct soap *soap, const char *tag, int id, ns1__FieldSearchCriteria *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__FieldSearchCriteria, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__FieldSearchCriteria ? type : NULL);
}

SOAP_FMAC3 ns1__FieldSearchCriteria ** SOAP_FMAC4 soap_in_PointerTons1__FieldSearchCriteria(struct soap *soap, const char *tag, ns1__FieldSearchCriteria **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__FieldSearchCriteria **)soap_malloc(soap, sizeof(ns1__FieldSearchCriteria *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__FieldSearchCriteria *)soap_instantiate_ns1__FieldSearchCriteria(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__FieldSearchCriteria **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__FieldSearchCriteria, sizeof(ns1__FieldSearchCriteria), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__FieldSearchCriteria(struct soap *soap, ns1__FieldSearchCriteria *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__FieldSearchCriteria(soap, tag ? tag : "ns1:FieldSearchCriteria", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__FieldSearchCriteria ** SOAP_FMAC4 soap_get_PointerTons1__FieldSearchCriteria(struct soap *soap, ns1__FieldSearchCriteria **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__FieldSearchCriteria(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__OtcBvalHeaders(struct soap *soap, ns1__OtcBvalHeaders *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__OtcBvalHeaders))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__OtcBvalHeaders(struct soap *soap, const char *tag, int id, ns1__OtcBvalHeaders *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__OtcBvalHeaders, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__OtcBvalHeaders ? type : NULL);
}

SOAP_FMAC3 ns1__OtcBvalHeaders ** SOAP_FMAC4 soap_in_PointerTons1__OtcBvalHeaders(struct soap *soap, const char *tag, ns1__OtcBvalHeaders **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__OtcBvalHeaders **)soap_malloc(soap, sizeof(ns1__OtcBvalHeaders *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__OtcBvalHeaders *)soap_instantiate_ns1__OtcBvalHeaders(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__OtcBvalHeaders **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__OtcBvalHeaders, sizeof(ns1__OtcBvalHeaders), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__OtcBvalHeaders(struct soap *soap, ns1__OtcBvalHeaders *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__OtcBvalHeaders(soap, tag ? tag : "ns1:OtcBvalHeaders", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__OtcBvalHeaders ** SOAP_FMAC4 soap_get_PointerTons1__OtcBvalHeaders(struct soap *soap, ns1__OtcBvalHeaders **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__OtcBvalHeaders(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__FundInstruments(struct soap *soap, ns1__FundInstruments *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__FundInstruments))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__FundInstruments(struct soap *soap, const char *tag, int id, ns1__FundInstruments *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__FundInstruments, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__FundInstruments ? type : NULL);
}

SOAP_FMAC3 ns1__FundInstruments ** SOAP_FMAC4 soap_in_PointerTons1__FundInstruments(struct soap *soap, const char *tag, ns1__FundInstruments **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__FundInstruments **)soap_malloc(soap, sizeof(ns1__FundInstruments *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__FundInstruments *)soap_instantiate_ns1__FundInstruments(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__FundInstruments **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__FundInstruments, sizeof(ns1__FundInstruments), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__FundInstruments(struct soap *soap, ns1__FundInstruments *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__FundInstruments(soap, tag ? tag : "ns1:FundInstruments", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__FundInstruments ** SOAP_FMAC4 soap_get_PointerTons1__FundInstruments(struct soap *soap, ns1__FundInstruments **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__FundInstruments(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__time(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__time))
		soap_serialize_xsd__time(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__time(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__time, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__time(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__time(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__time(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__time, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__time(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__time(soap, tag ? tag : "xsd:time", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__time(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__FieldSets(struct soap *soap, ns1__FieldSets *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__FieldSets))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__FieldSets(struct soap *soap, const char *tag, int id, ns1__FieldSets *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__FieldSets, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__FieldSets ? type : NULL);
}

SOAP_FMAC3 ns1__FieldSets ** SOAP_FMAC4 soap_in_PointerTons1__FieldSets(struct soap *soap, const char *tag, ns1__FieldSets **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__FieldSets **)soap_malloc(soap, sizeof(ns1__FieldSets *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__FieldSets *)soap_instantiate_ns1__FieldSets(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__FieldSets **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__FieldSets, sizeof(ns1__FieldSets), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__FieldSets(struct soap *soap, ns1__FieldSets *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__FieldSets(soap, tag ? tag : "ns1:FieldSets", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__FieldSets ** SOAP_FMAC4 soap_get_PointerTons1__FieldSets(struct soap *soap, ns1__FieldSets **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__FieldSets(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ScheduledHeaders(struct soap *soap, ns1__ScheduledHeaders *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ScheduledHeaders))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ScheduledHeaders(struct soap *soap, const char *tag, int id, ns1__ScheduledHeaders *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ScheduledHeaders, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ScheduledHeaders ? type : NULL);
}

SOAP_FMAC3 ns1__ScheduledHeaders ** SOAP_FMAC4 soap_in_PointerTons1__ScheduledHeaders(struct soap *soap, const char *tag, ns1__ScheduledHeaders **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ScheduledHeaders **)soap_malloc(soap, sizeof(ns1__ScheduledHeaders *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ScheduledHeaders *)soap_instantiate_ns1__ScheduledHeaders(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ScheduledHeaders **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ScheduledHeaders, sizeof(ns1__ScheduledHeaders), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ScheduledHeaders(struct soap *soap, ns1__ScheduledHeaders *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ScheduledHeaders(soap, tag ? tag : "ns1:ScheduledHeaders", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ScheduledHeaders ** SOAP_FMAC4 soap_get_PointerTons1__ScheduledHeaders(struct soap *soap, ns1__ScheduledHeaders **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ScheduledHeaders(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ScheduledResponse(struct soap *soap, ns1__ScheduledResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ScheduledResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ScheduledResponse(struct soap *soap, const char *tag, int id, ns1__ScheduledResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ScheduledResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ScheduledResponse ? type : NULL);
}

SOAP_FMAC3 ns1__ScheduledResponse ** SOAP_FMAC4 soap_in_PointerTons1__ScheduledResponse(struct soap *soap, const char *tag, ns1__ScheduledResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ScheduledResponse **)soap_malloc(soap, sizeof(ns1__ScheduledResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ScheduledResponse *)soap_instantiate_ns1__ScheduledResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ScheduledResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ScheduledResponse, sizeof(ns1__ScheduledResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ScheduledResponse(struct soap *soap, ns1__ScheduledResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ScheduledResponse(soap, tag ? tag : "ns1:ScheduledResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ScheduledResponse ** SOAP_FMAC4 soap_get_PointerTons1__ScheduledResponse(struct soap *soap, ns1__ScheduledResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ScheduledResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CancelHeaders(struct soap *soap, ns1__CancelHeaders *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CancelHeaders))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CancelHeaders(struct soap *soap, const char *tag, int id, ns1__CancelHeaders *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CancelHeaders, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__CancelHeaders ? type : NULL);
}

SOAP_FMAC3 ns1__CancelHeaders ** SOAP_FMAC4 soap_in_PointerTons1__CancelHeaders(struct soap *soap, const char *tag, ns1__CancelHeaders **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CancelHeaders **)soap_malloc(soap, sizeof(ns1__CancelHeaders *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CancelHeaders *)soap_instantiate_ns1__CancelHeaders(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__CancelHeaders **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CancelHeaders, sizeof(ns1__CancelHeaders), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CancelHeaders(struct soap *soap, ns1__CancelHeaders *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__CancelHeaders(soap, tag ? tag : "ns1:CancelHeaders", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CancelHeaders ** SOAP_FMAC4 soap_get_PointerTons1__CancelHeaders(struct soap *soap, ns1__CancelHeaders **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CancelHeaders(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Instruments(struct soap *soap, ns1__Instruments *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Instruments))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Instruments(struct soap *soap, const char *tag, int id, ns1__Instruments *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Instruments, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__Instruments ? type : NULL);
}

SOAP_FMAC3 ns1__Instruments ** SOAP_FMAC4 soap_in_PointerTons1__Instruments(struct soap *soap, const char *tag, ns1__Instruments **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Instruments **)soap_malloc(soap, sizeof(ns1__Instruments *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Instruments *)soap_instantiate_ns1__Instruments(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__Instruments **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Instruments, sizeof(ns1__Instruments), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Instruments(struct soap *soap, ns1__Instruments *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Instruments(soap, tag ? tag : "ns1:Instruments", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Instruments ** SOAP_FMAC4 soap_get_PointerTons1__Instruments(struct soap *soap, ns1__Instruments **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Instruments(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Fields(struct soap *soap, ns1__Fields *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Fields))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Fields(struct soap *soap, const char *tag, int id, ns1__Fields *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Fields, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__Fields ? type : NULL);
}

SOAP_FMAC3 ns1__Fields ** SOAP_FMAC4 soap_in_PointerTons1__Fields(struct soap *soap, const char *tag, ns1__Fields **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Fields **)soap_malloc(soap, sizeof(ns1__Fields *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Fields *)soap_instantiate_ns1__Fields(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__Fields **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Fields, sizeof(ns1__Fields), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Fields(struct soap *soap, ns1__Fields *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Fields(soap, tag ? tag : "ns1:Fields", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Fields ** SOAP_FMAC4 soap_get_PointerTons1__Fields(struct soap *soap, ns1__Fields **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Fields(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__BvalFieldSets(struct soap *soap, ns1__BvalFieldSets *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__BvalFieldSets))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__BvalFieldSets(struct soap *soap, const char *tag, int id, ns1__BvalFieldSets *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__BvalFieldSets, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__BvalFieldSets ? type : NULL);
}

SOAP_FMAC3 ns1__BvalFieldSets ** SOAP_FMAC4 soap_in_PointerTons1__BvalFieldSets(struct soap *soap, const char *tag, ns1__BvalFieldSets **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__BvalFieldSets **)soap_malloc(soap, sizeof(ns1__BvalFieldSets *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__BvalFieldSets *)soap_instantiate_ns1__BvalFieldSets(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__BvalFieldSets **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__BvalFieldSets, sizeof(ns1__BvalFieldSets), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__BvalFieldSets(struct soap *soap, ns1__BvalFieldSets *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__BvalFieldSets(soap, tag ? tag : "ns1:BvalFieldSets", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__BvalFieldSets ** SOAP_FMAC4 soap_get_PointerTons1__BvalFieldSets(struct soap *soap, ns1__BvalFieldSets **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__BvalFieldSets(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__OtcDealInformation(struct soap *soap, ns1__OtcDealInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__OtcDealInformation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__OtcDealInformation(struct soap *soap, const char *tag, int id, ns1__OtcDealInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__OtcDealInformation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__OtcDealInformation ? type : NULL);
}

SOAP_FMAC3 ns1__OtcDealInformation ** SOAP_FMAC4 soap_in_PointerTons1__OtcDealInformation(struct soap *soap, const char *tag, ns1__OtcDealInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__OtcDealInformation **)soap_malloc(soap, sizeof(ns1__OtcDealInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__OtcDealInformation *)soap_instantiate_ns1__OtcDealInformation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__OtcDealInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__OtcDealInformation, sizeof(ns1__OtcDealInformation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__OtcDealInformation(struct soap *soap, ns1__OtcDealInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__OtcDealInformation(soap, tag ? tag : "ns1:OtcDealInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__OtcDealInformation ** SOAP_FMAC4 soap_get_PointerTons1__OtcDealInformation(struct soap *soap, ns1__OtcDealInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__OtcDealInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__OtcBvalAction(struct soap *soap, enum ns1__OtcBvalAction *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns1__OtcBvalAction);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__OtcBvalAction(struct soap *soap, const char *tag, int id, enum ns1__OtcBvalAction *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__OtcBvalAction, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__OtcBvalAction(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__OtcBvalAction ** SOAP_FMAC4 soap_in_PointerTons1__OtcBvalAction(struct soap *soap, const char *tag, enum ns1__OtcBvalAction **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__OtcBvalAction **)soap_malloc(soap, sizeof(enum ns1__OtcBvalAction *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__OtcBvalAction(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__OtcBvalAction **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__OtcBvalAction, sizeof(enum ns1__OtcBvalAction), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__OtcBvalAction(struct soap *soap, enum ns1__OtcBvalAction *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__OtcBvalAction(soap, tag ? tag : "ns1:OtcBvalAction", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__OtcBvalAction ** SOAP_FMAC4 soap_get_PointerTons1__OtcBvalAction(struct soap *soap, enum ns1__OtcBvalAction **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__OtcBvalAction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ResponseStatus(struct soap *soap, ns1__ResponseStatus *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ResponseStatus))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ResponseStatus(struct soap *soap, const char *tag, int id, ns1__ResponseStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ResponseStatus, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ResponseStatus ? type : NULL);
}

SOAP_FMAC3 ns1__ResponseStatus ** SOAP_FMAC4 soap_in_PointerTons1__ResponseStatus(struct soap *soap, const char *tag, ns1__ResponseStatus **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ResponseStatus **)soap_malloc(soap, sizeof(ns1__ResponseStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ResponseStatus *)soap_instantiate_ns1__ResponseStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ResponseStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ResponseStatus, sizeof(ns1__ResponseStatus), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ResponseStatus(struct soap *soap, ns1__ResponseStatus *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ResponseStatus(soap, tag ? tag : "ns1:ResponseStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ResponseStatus ** SOAP_FMAC4 soap_get_PointerTons1__ResponseStatus(struct soap *soap, ns1__ResponseStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ResponseStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DLCategory2(struct soap *soap, enum ns1__DLCategory2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns1__DLCategory2);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DLCategory2(struct soap *soap, const char *tag, int id, enum ns1__DLCategory2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__DLCategory2, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__DLCategory2(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__DLCategory2 ** SOAP_FMAC4 soap_in_PointerTons1__DLCategory2(struct soap *soap, const char *tag, enum ns1__DLCategory2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__DLCategory2 **)soap_malloc(soap, sizeof(enum ns1__DLCategory2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__DLCategory2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__DLCategory2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DLCategory2, sizeof(enum ns1__DLCategory2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DLCategory2(struct soap *soap, enum ns1__DLCategory2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__DLCategory2(soap, tag ? tag : "ns1:DLCategory2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__DLCategory2 ** SOAP_FMAC4 soap_get_PointerTons1__DLCategory2(struct soap *soap, enum ns1__DLCategory2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DLCategory2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DLCategory(struct soap *soap, enum ns1__DLCategory *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns1__DLCategory);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DLCategory(struct soap *soap, const char *tag, int id, enum ns1__DLCategory *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__DLCategory, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__DLCategory(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__DLCategory ** SOAP_FMAC4 soap_in_PointerTons1__DLCategory(struct soap *soap, const char *tag, enum ns1__DLCategory **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__DLCategory **)soap_malloc(soap, sizeof(enum ns1__DLCategory *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__DLCategory(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__DLCategory **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DLCategory, sizeof(enum ns1__DLCategory), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DLCategory(struct soap *soap, enum ns1__DLCategory *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__DLCategory(soap, tag ? tag : "ns1:DLCategory", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__DLCategory ** SOAP_FMAC4 soap_get_PointerTons1__DLCategory(struct soap *soap, enum ns1__DLCategory **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DLCategory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__FieldInfo(struct soap *soap, ns1__FieldInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__FieldInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__FieldInfo(struct soap *soap, const char *tag, int id, ns1__FieldInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__FieldInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__FieldInfo ? type : NULL);
}

SOAP_FMAC3 ns1__FieldInfo ** SOAP_FMAC4 soap_in_PointerTons1__FieldInfo(struct soap *soap, const char *tag, ns1__FieldInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__FieldInfo **)soap_malloc(soap, sizeof(ns1__FieldInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__FieldInfo *)soap_instantiate_ns1__FieldInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__FieldInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__FieldInfo, sizeof(ns1__FieldInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__FieldInfo(struct soap *soap, ns1__FieldInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__FieldInfo(soap, tag ? tag : "ns1:FieldInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__FieldInfo ** SOAP_FMAC4 soap_get_PointerTons1__FieldInfo(struct soap *soap, ns1__FieldInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__FieldInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__FieldType(struct soap *soap, enum ns1__FieldType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns1__FieldType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__FieldType(struct soap *soap, const char *tag, int id, enum ns1__FieldType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__FieldType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__FieldType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__FieldType ** SOAP_FMAC4 soap_in_PointerTons1__FieldType(struct soap *soap, const char *tag, enum ns1__FieldType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__FieldType **)soap_malloc(soap, sizeof(enum ns1__FieldType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__FieldType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__FieldType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__FieldType, sizeof(enum ns1__FieldType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__FieldType(struct soap *soap, enum ns1__FieldType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__FieldType(soap, tag ? tag : "ns1:FieldType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__FieldType ** SOAP_FMAC4 soap_get_PointerTons1__FieldType(struct soap *soap, enum ns1__FieldType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__FieldType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__BulkArrayEntry(struct soap *soap, ns1__BulkArrayEntry *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__BulkArrayEntry))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__BulkArrayEntry(struct soap *soap, const char *tag, int id, ns1__BulkArrayEntry *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__BulkArrayEntry, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__BulkArrayEntry ? type : NULL);
}

SOAP_FMAC3 ns1__BulkArrayEntry ** SOAP_FMAC4 soap_in_PointerTons1__BulkArrayEntry(struct soap *soap, const char *tag, ns1__BulkArrayEntry **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__BulkArrayEntry **)soap_malloc(soap, sizeof(ns1__BulkArrayEntry *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__BulkArrayEntry *)soap_instantiate_ns1__BulkArrayEntry(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__BulkArrayEntry **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__BulkArrayEntry, sizeof(ns1__BulkArrayEntry), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__BulkArrayEntry(struct soap *soap, ns1__BulkArrayEntry *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__BulkArrayEntry(soap, tag ? tag : "ns1:BulkArrayEntry", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__BulkArrayEntry ** SOAP_FMAC4 soap_get_PointerTons1__BulkArrayEntry(struct soap *soap, ns1__BulkArrayEntry **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__BulkArrayEntry(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__QRMQuoteData(struct soap *soap, ns1__QRMQuoteData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__QRMQuoteData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__QRMQuoteData(struct soap *soap, const char *tag, int id, ns1__QRMQuoteData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__QRMQuoteData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__QRMQuoteData ? type : NULL);
}

SOAP_FMAC3 ns1__QRMQuoteData ** SOAP_FMAC4 soap_in_PointerTons1__QRMQuoteData(struct soap *soap, const char *tag, ns1__QRMQuoteData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__QRMQuoteData **)soap_malloc(soap, sizeof(ns1__QRMQuoteData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__QRMQuoteData *)soap_instantiate_ns1__QRMQuoteData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__QRMQuoteData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__QRMQuoteData, sizeof(ns1__QRMQuoteData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__QRMQuoteData(struct soap *soap, ns1__QRMQuoteData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__QRMQuoteData(soap, tag ? tag : "ns1:QRMQuoteData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__QRMQuoteData ** SOAP_FMAC4 soap_get_PointerTons1__QRMQuoteData(struct soap *soap, ns1__QRMQuoteData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__QRMQuoteData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodateTime(struct soap *soap, time_t *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_dateTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodateTime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dateTime, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_dateTime(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTodateTime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_dateTime(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dateTime, sizeof(time_t), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodateTime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTodateTime(soap, tag ? tag : "dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTodateTime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__QRMQuote(struct soap *soap, ns1__QRMQuote *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__QRMQuote))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__QRMQuote(struct soap *soap, const char *tag, int id, ns1__QRMQuote *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__QRMQuote, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__QRMQuote ? type : NULL);
}

SOAP_FMAC3 ns1__QRMQuote ** SOAP_FMAC4 soap_in_PointerTons1__QRMQuote(struct soap *soap, const char *tag, ns1__QRMQuote **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__QRMQuote **)soap_malloc(soap, sizeof(ns1__QRMQuote *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__QRMQuote *)soap_instantiate_ns1__QRMQuote(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__QRMQuote **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__QRMQuote, sizeof(ns1__QRMQuote), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__QRMQuote(struct soap *soap, ns1__QRMQuote *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__QRMQuote(soap, tag ? tag : "ns1:QRMQuote", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__QRMQuote ** SOAP_FMAC4 soap_get_PointerTons1__QRMQuote(struct soap *soap, ns1__QRMQuote **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__QRMQuote(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__QRQuote(struct soap *soap, ns1__QRQuote *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__QRQuote))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__QRQuote(struct soap *soap, const char *tag, int id, ns1__QRQuote *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__QRQuote, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__QRQuote ? type : NULL);
}

SOAP_FMAC3 ns1__QRQuote ** SOAP_FMAC4 soap_in_PointerTons1__QRQuote(struct soap *soap, const char *tag, ns1__QRQuote **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__QRQuote **)soap_malloc(soap, sizeof(ns1__QRQuote *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__QRQuote *)soap_instantiate_ns1__QRQuote(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__QRQuote **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__QRQuote, sizeof(ns1__QRQuote), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__QRQuote(struct soap *soap, ns1__QRQuote *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__QRQuote(soap, tag ? tag : "ns1:QRQuote", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__QRQuote ** SOAP_FMAC4 soap_get_PointerTons1__QRQuote(struct soap *soap, ns1__QRQuote **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__QRQuote(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__BulkArray(struct soap *soap, ns1__BulkArray *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__BulkArray))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__BulkArray(struct soap *soap, const char *tag, int id, ns1__BulkArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__BulkArray, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__BulkArray ? type : NULL);
}

SOAP_FMAC3 ns1__BulkArray ** SOAP_FMAC4 soap_in_PointerTons1__BulkArray(struct soap *soap, const char *tag, ns1__BulkArray **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__BulkArray **)soap_malloc(soap, sizeof(ns1__BulkArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__BulkArray *)soap_instantiate_ns1__BulkArray(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__BulkArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__BulkArray, sizeof(ns1__BulkArray), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__BulkArray(struct soap *soap, ns1__BulkArray *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__BulkArray(soap, tag ? tag : "ns1:BulkArray", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__BulkArray ** SOAP_FMAC4 soap_get_PointerTons1__BulkArray(struct soap *soap, ns1__BulkArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__BulkArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ActionStandardFields(struct soap *soap, ns1__ActionStandardFields *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ActionStandardFields))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ActionStandardFields(struct soap *soap, const char *tag, int id, ns1__ActionStandardFields *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ActionStandardFields, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ActionStandardFields ? type : NULL);
}

SOAP_FMAC3 ns1__ActionStandardFields ** SOAP_FMAC4 soap_in_PointerTons1__ActionStandardFields(struct soap *soap, const char *tag, ns1__ActionStandardFields **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ActionStandardFields **)soap_malloc(soap, sizeof(ns1__ActionStandardFields *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ActionStandardFields *)soap_instantiate_ns1__ActionStandardFields(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ActionStandardFields **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ActionStandardFields, sizeof(ns1__ActionStandardFields), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ActionStandardFields(struct soap *soap, ns1__ActionStandardFields *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ActionStandardFields(soap, tag ? tag : "ns1:ActionStandardFields", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ActionStandardFields ** SOAP_FMAC4 soap_get_PointerTons1__ActionStandardFields(struct soap *soap, ns1__ActionStandardFields **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ActionStandardFields(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__QRMQuotes(struct soap *soap, ns1__QRMQuotes *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__QRMQuotes))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__QRMQuotes(struct soap *soap, const char *tag, int id, ns1__QRMQuotes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__QRMQuotes, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__QRMQuotes ? type : NULL);
}

SOAP_FMAC3 ns1__QRMQuotes ** SOAP_FMAC4 soap_in_PointerTons1__QRMQuotes(struct soap *soap, const char *tag, ns1__QRMQuotes **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__QRMQuotes **)soap_malloc(soap, sizeof(ns1__QRMQuotes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__QRMQuotes *)soap_instantiate_ns1__QRMQuotes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__QRMQuotes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__QRMQuotes, sizeof(ns1__QRMQuotes), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__QRMQuotes(struct soap *soap, ns1__QRMQuotes *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__QRMQuotes(soap, tag ? tag : "ns1:QRMQuotes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__QRMQuotes ** SOAP_FMAC4 soap_get_PointerTons1__QRMQuotes(struct soap *soap, ns1__QRMQuotes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__QRMQuotes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__QRQuotes(struct soap *soap, ns1__QRQuotes *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__QRQuotes))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__QRQuotes(struct soap *soap, const char *tag, int id, ns1__QRQuotes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__QRQuotes, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__QRQuotes ? type : NULL);
}

SOAP_FMAC3 ns1__QRQuotes ** SOAP_FMAC4 soap_in_PointerTons1__QRQuotes(struct soap *soap, const char *tag, ns1__QRQuotes **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__QRQuotes **)soap_malloc(soap, sizeof(ns1__QRQuotes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__QRQuotes *)soap_instantiate_ns1__QRQuotes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__QRQuotes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__QRQuotes, sizeof(ns1__QRQuotes), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__QRQuotes(struct soap *soap, ns1__QRQuotes *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__QRQuotes(soap, tag ? tag : "ns1:QRQuotes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__QRQuotes ** SOAP_FMAC4 soap_get_PointerTons1__QRQuotes(struct soap *soap, ns1__QRQuotes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__QRQuotes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__HistData(struct soap *soap, ns1__HistData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__HistData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__HistData(struct soap *soap, const char *tag, int id, ns1__HistData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__HistData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__HistData ? type : NULL);
}

SOAP_FMAC3 ns1__HistData ** SOAP_FMAC4 soap_in_PointerTons1__HistData(struct soap *soap, const char *tag, ns1__HistData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__HistData **)soap_malloc(soap, sizeof(ns1__HistData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__HistData *)soap_instantiate_ns1__HistData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__HistData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__HistData, sizeof(ns1__HistData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__HistData(struct soap *soap, ns1__HistData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__HistData(soap, tag ? tag : "ns1:HistData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__HistData ** SOAP_FMAC4 soap_get_PointerTons1__HistData(struct soap *soap, ns1__HistData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__HistData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Data(struct soap *soap, ns1__Data *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Data))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Data(struct soap *soap, const char *tag, int id, ns1__Data *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Data, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__Data ? type : NULL);
}

SOAP_FMAC3 ns1__Data ** SOAP_FMAC4 soap_in_PointerTons1__Data(struct soap *soap, const char *tag, ns1__Data **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Data **)soap_malloc(soap, sizeof(ns1__Data *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Data *)soap_instantiate_ns1__Data(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__Data **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Data, sizeof(ns1__Data), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Data(struct soap *soap, ns1__Data *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Data(soap, tag ? tag : "ns1:Data", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Data ** SOAP_FMAC4 soap_get_PointerTons1__Data(struct soap *soap, ns1__Data **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Data(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SecondaryQualifier(struct soap *soap, ns1__SecondaryQualifier *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SecondaryQualifier))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SecondaryQualifier(struct soap *soap, const char *tag, int id, ns1__SecondaryQualifier *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SecondaryQualifier, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__SecondaryQualifier ? type : NULL);
}

SOAP_FMAC3 ns1__SecondaryQualifier ** SOAP_FMAC4 soap_in_PointerTons1__SecondaryQualifier(struct soap *soap, const char *tag, ns1__SecondaryQualifier **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SecondaryQualifier **)soap_malloc(soap, sizeof(ns1__SecondaryQualifier *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SecondaryQualifier *)soap_instantiate_ns1__SecondaryQualifier(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__SecondaryQualifier **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SecondaryQualifier, sizeof(ns1__SecondaryQualifier), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SecondaryQualifier(struct soap *soap, ns1__SecondaryQualifier *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SecondaryQualifier(soap, tag ? tag : "ns1:SecondaryQualifier", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SecondaryQualifier ** SOAP_FMAC4 soap_get_PointerTons1__SecondaryQualifier(struct soap *soap, ns1__SecondaryQualifier **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SecondaryQualifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PrimaryQualifier(struct soap *soap, ns1__PrimaryQualifier *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PrimaryQualifier))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PrimaryQualifier(struct soap *soap, const char *tag, int id, ns1__PrimaryQualifier *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__PrimaryQualifier, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__PrimaryQualifier ? type : NULL);
}

SOAP_FMAC3 ns1__PrimaryQualifier ** SOAP_FMAC4 soap_in_PointerTons1__PrimaryQualifier(struct soap *soap, const char *tag, ns1__PrimaryQualifier **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__PrimaryQualifier **)soap_malloc(soap, sizeof(ns1__PrimaryQualifier *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__PrimaryQualifier *)soap_instantiate_ns1__PrimaryQualifier(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__PrimaryQualifier **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PrimaryQualifier, sizeof(ns1__PrimaryQualifier), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PrimaryQualifier(struct soap *soap, ns1__PrimaryQualifier *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__PrimaryQualifier(soap, tag ? tag : "ns1:PrimaryQualifier", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__PrimaryQualifier ** SOAP_FMAC4 soap_get_PointerTons1__PrimaryQualifier(struct soap *soap, ns1__PrimaryQualifier **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PrimaryQualifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Overrides(struct soap *soap, ns1__Overrides *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Overrides))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Overrides(struct soap *soap, const char *tag, int id, ns1__Overrides *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Overrides, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__Overrides ? type : NULL);
}

SOAP_FMAC3 ns1__Overrides ** SOAP_FMAC4 soap_in_PointerTons1__Overrides(struct soap *soap, const char *tag, ns1__Overrides **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Overrides **)soap_malloc(soap, sizeof(ns1__Overrides *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Overrides *)soap_instantiate_ns1__Overrides(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__Overrides **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Overrides, sizeof(ns1__Overrides), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Overrides(struct soap *soap, ns1__Overrides *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Overrides(soap, tag ? tag : "ns1:Overrides", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Overrides ** SOAP_FMAC4 soap_get_PointerTons1__Overrides(struct soap *soap, ns1__Overrides **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Overrides(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AllQuotesInstrumentData(struct soap *soap, ns1__AllQuotesInstrumentData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AllQuotesInstrumentData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AllQuotesInstrumentData(struct soap *soap, const char *tag, int id, ns1__AllQuotesInstrumentData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AllQuotesInstrumentData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__AllQuotesInstrumentData ? type : NULL);
}

SOAP_FMAC3 ns1__AllQuotesInstrumentData ** SOAP_FMAC4 soap_in_PointerTons1__AllQuotesInstrumentData(struct soap *soap, const char *tag, ns1__AllQuotesInstrumentData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AllQuotesInstrumentData **)soap_malloc(soap, sizeof(ns1__AllQuotesInstrumentData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__AllQuotesInstrumentData *)soap_instantiate_ns1__AllQuotesInstrumentData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__AllQuotesInstrumentData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AllQuotesInstrumentData, sizeof(ns1__AllQuotesInstrumentData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AllQuotesInstrumentData(struct soap *soap, ns1__AllQuotesInstrumentData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__AllQuotesInstrumentData(soap, tag ? tag : "ns1:AllQuotesInstrumentData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__AllQuotesInstrumentData ** SOAP_FMAC4 soap_get_PointerTons1__AllQuotesInstrumentData(struct soap *soap, ns1__AllQuotesInstrumentData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AllQuotesInstrumentData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__QuotesInstrumentData(struct soap *soap, ns1__QuotesInstrumentData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__QuotesInstrumentData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__QuotesInstrumentData(struct soap *soap, const char *tag, int id, ns1__QuotesInstrumentData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__QuotesInstrumentData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__QuotesInstrumentData ? type : NULL);
}

SOAP_FMAC3 ns1__QuotesInstrumentData ** SOAP_FMAC4 soap_in_PointerTons1__QuotesInstrumentData(struct soap *soap, const char *tag, ns1__QuotesInstrumentData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__QuotesInstrumentData **)soap_malloc(soap, sizeof(ns1__QuotesInstrumentData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__QuotesInstrumentData *)soap_instantiate_ns1__QuotesInstrumentData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__QuotesInstrumentData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__QuotesInstrumentData, sizeof(ns1__QuotesInstrumentData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__QuotesInstrumentData(struct soap *soap, ns1__QuotesInstrumentData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__QuotesInstrumentData(soap, tag ? tag : "ns1:QuotesInstrumentData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__QuotesInstrumentData ** SOAP_FMAC4 soap_get_PointerTons1__QuotesInstrumentData(struct soap *soap, ns1__QuotesInstrumentData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__QuotesInstrumentData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CorrectionRecord(struct soap *soap, ns1__CorrectionRecord *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CorrectionRecord))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CorrectionRecord(struct soap *soap, const char *tag, int id, ns1__CorrectionRecord *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CorrectionRecord, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__CorrectionRecord ? type : NULL);
}

SOAP_FMAC3 ns1__CorrectionRecord ** SOAP_FMAC4 soap_in_PointerTons1__CorrectionRecord(struct soap *soap, const char *tag, ns1__CorrectionRecord **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CorrectionRecord **)soap_malloc(soap, sizeof(ns1__CorrectionRecord *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CorrectionRecord *)soap_instantiate_ns1__CorrectionRecord(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__CorrectionRecord **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CorrectionRecord, sizeof(ns1__CorrectionRecord), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CorrectionRecord(struct soap *soap, ns1__CorrectionRecord *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__CorrectionRecord(soap, tag ? tag : "ns1:CorrectionRecord", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CorrectionRecord ** SOAP_FMAC4 soap_get_PointerTons1__CorrectionRecord(struct soap *soap, ns1__CorrectionRecord **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CorrectionRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ActionsInstrumentData(struct soap *soap, ns1__ActionsInstrumentData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ActionsInstrumentData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ActionsInstrumentData(struct soap *soap, const char *tag, int id, ns1__ActionsInstrumentData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ActionsInstrumentData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ActionsInstrumentData ? type : NULL);
}

SOAP_FMAC3 ns1__ActionsInstrumentData ** SOAP_FMAC4 soap_in_PointerTons1__ActionsInstrumentData(struct soap *soap, const char *tag, ns1__ActionsInstrumentData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ActionsInstrumentData **)soap_malloc(soap, sizeof(ns1__ActionsInstrumentData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ActionsInstrumentData *)soap_instantiate_ns1__ActionsInstrumentData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ActionsInstrumentData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ActionsInstrumentData, sizeof(ns1__ActionsInstrumentData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ActionsInstrumentData(struct soap *soap, ns1__ActionsInstrumentData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ActionsInstrumentData(soap, tag ? tag : "ns1:ActionsInstrumentData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ActionsInstrumentData ** SOAP_FMAC4 soap_get_PointerTons1__ActionsInstrumentData(struct soap *soap, ns1__ActionsInstrumentData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ActionsInstrumentData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__FundInstrumentData(struct soap *soap, ns1__FundInstrumentData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__FundInstrumentData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__FundInstrumentData(struct soap *soap, const char *tag, int id, ns1__FundInstrumentData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__FundInstrumentData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__FundInstrumentData ? type : NULL);
}

SOAP_FMAC3 ns1__FundInstrumentData ** SOAP_FMAC4 soap_in_PointerTons1__FundInstrumentData(struct soap *soap, const char *tag, ns1__FundInstrumentData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__FundInstrumentData **)soap_malloc(soap, sizeof(ns1__FundInstrumentData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__FundInstrumentData *)soap_instantiate_ns1__FundInstrumentData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__FundInstrumentData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__FundInstrumentData, sizeof(ns1__FundInstrumentData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__FundInstrumentData(struct soap *soap, ns1__FundInstrumentData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__FundInstrumentData(soap, tag ? tag : "ns1:FundInstrumentData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__FundInstrumentData ** SOAP_FMAC4 soap_get_PointerTons1__FundInstrumentData(struct soap *soap, ns1__FundInstrumentData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__FundInstrumentData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__HistInstrumentData(struct soap *soap, ns1__HistInstrumentData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__HistInstrumentData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__HistInstrumentData(struct soap *soap, const char *tag, int id, ns1__HistInstrumentData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__HistInstrumentData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__HistInstrumentData ? type : NULL);
}

SOAP_FMAC3 ns1__HistInstrumentData ** SOAP_FMAC4 soap_in_PointerTons1__HistInstrumentData(struct soap *soap, const char *tag, ns1__HistInstrumentData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__HistInstrumentData **)soap_malloc(soap, sizeof(ns1__HistInstrumentData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__HistInstrumentData *)soap_instantiate_ns1__HistInstrumentData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__HistInstrumentData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__HistInstrumentData, sizeof(ns1__HistInstrumentData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__HistInstrumentData(struct soap *soap, ns1__HistInstrumentData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__HistInstrumentData(soap, tag ? tag : "ns1:HistInstrumentData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__HistInstrumentData ** SOAP_FMAC4 soap_get_PointerTons1__HistInstrumentData(struct soap *soap, ns1__HistInstrumentData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__HistInstrumentData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__InstrumentData(struct soap *soap, ns1__InstrumentData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__InstrumentData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__InstrumentData(struct soap *soap, const char *tag, int id, ns1__InstrumentData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__InstrumentData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__InstrumentData ? type : NULL);
}

SOAP_FMAC3 ns1__InstrumentData ** SOAP_FMAC4 soap_in_PointerTons1__InstrumentData(struct soap *soap, const char *tag, ns1__InstrumentData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__InstrumentData **)soap_malloc(soap, sizeof(ns1__InstrumentData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__InstrumentData *)soap_instantiate_ns1__InstrumentData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__InstrumentData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__InstrumentData, sizeof(ns1__InstrumentData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__InstrumentData(struct soap *soap, ns1__InstrumentData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__InstrumentData(soap, tag ? tag : "ns1:InstrumentData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__InstrumentData ** SOAP_FMAC4 soap_get_PointerTons1__InstrumentData(struct soap *soap, ns1__InstrumentData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__InstrumentData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__FundInstrument(struct soap *soap, ns1__FundInstrument *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__FundInstrument))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__FundInstrument(struct soap *soap, const char *tag, int id, ns1__FundInstrument *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__FundInstrument, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__FundInstrument ? type : NULL);
}

SOAP_FMAC3 ns1__FundInstrument ** SOAP_FMAC4 soap_in_PointerTons1__FundInstrument(struct soap *soap, const char *tag, ns1__FundInstrument **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__FundInstrument **)soap_malloc(soap, sizeof(ns1__FundInstrument *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__FundInstrument *)soap_instantiate_ns1__FundInstrument(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__FundInstrument **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__FundInstrument, sizeof(ns1__FundInstrument), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__FundInstrument(struct soap *soap, ns1__FundInstrument *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__FundInstrument(soap, tag ? tag : "ns1:FundInstrument", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__FundInstrument ** SOAP_FMAC4 soap_get_PointerTons1__FundInstrument(struct soap *soap, ns1__FundInstrument **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__FundInstrument(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Macro(struct soap *soap, ns1__Macro *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Macro))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Macro(struct soap *soap, const char *tag, int id, ns1__Macro *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Macro, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__Macro ? type : NULL);
}

SOAP_FMAC3 ns1__Macro ** SOAP_FMAC4 soap_in_PointerTons1__Macro(struct soap *soap, const char *tag, ns1__Macro **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Macro **)soap_malloc(soap, sizeof(ns1__Macro *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Macro *)soap_instantiate_ns1__Macro(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__Macro **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Macro, sizeof(ns1__Macro), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Macro(struct soap *soap, ns1__Macro *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Macro(soap, tag ? tag : "ns1:Macro", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Macro ** SOAP_FMAC4 soap_get_PointerTons1__Macro(struct soap *soap, ns1__Macro **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Macro(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Instrument(struct soap *soap, ns1__Instrument *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Instrument))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Instrument(struct soap *soap, const char *tag, int id, ns1__Instrument *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Instrument, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__Instrument ? type : NULL);
}

SOAP_FMAC3 ns1__Instrument ** SOAP_FMAC4 soap_in_PointerTons1__Instrument(struct soap *soap, const char *tag, ns1__Instrument **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Instrument **)soap_malloc(soap, sizeof(ns1__Instrument *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Instrument *)soap_instantiate_ns1__Instrument(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__Instrument **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Instrument, sizeof(ns1__Instrument), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Instrument(struct soap *soap, ns1__Instrument *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Instrument(soap, tag ? tag : "ns1:Instrument", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Instrument ** SOAP_FMAC4 soap_get_PointerTons1__Instrument(struct soap *soap, ns1__Instrument **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Instrument(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Override(struct soap *soap, ns1__Override *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Override))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Override(struct soap *soap, const char *tag, int id, ns1__Override *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Override, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__Override ? type : NULL);
}

SOAP_FMAC3 ns1__Override ** SOAP_FMAC4 soap_in_PointerTons1__Override(struct soap *soap, const char *tag, ns1__Override **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Override **)soap_malloc(soap, sizeof(ns1__Override *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Override *)soap_instantiate_ns1__Override(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__Override **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Override, sizeof(ns1__Override), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Override(struct soap *soap, ns1__Override *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Override(soap, tag ? tag : "ns1:Override", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Override ** SOAP_FMAC4 soap_get_PointerTons1__Override(struct soap *soap, ns1__Override **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Override(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__QuotesHeaders(struct soap *soap, ns1__QuotesHeaders *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__QuotesHeaders))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__QuotesHeaders(struct soap *soap, const char *tag, int id, ns1__QuotesHeaders *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__QuotesHeaders, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__QuotesHeaders ? type : NULL);
}

SOAP_FMAC3 ns1__QuotesHeaders ** SOAP_FMAC4 soap_in_PointerTons1__QuotesHeaders(struct soap *soap, const char *tag, ns1__QuotesHeaders **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__QuotesHeaders **)soap_malloc(soap, sizeof(ns1__QuotesHeaders *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__QuotesHeaders *)soap_instantiate_ns1__QuotesHeaders(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__QuotesHeaders **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__QuotesHeaders, sizeof(ns1__QuotesHeaders), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__QuotesHeaders(struct soap *soap, ns1__QuotesHeaders *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__QuotesHeaders(soap, tag ? tag : "ns1:QuotesHeaders", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__QuotesHeaders ** SOAP_FMAC4 soap_get_PointerTons1__QuotesHeaders(struct soap *soap, ns1__QuotesHeaders **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__QuotesHeaders(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__GetActionsHeaders(struct soap *soap, ns1__GetActionsHeaders *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__GetActionsHeaders))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__GetActionsHeaders(struct soap *soap, const char *tag, int id, ns1__GetActionsHeaders *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__GetActionsHeaders, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__GetActionsHeaders ? type : NULL);
}

SOAP_FMAC3 ns1__GetActionsHeaders ** SOAP_FMAC4 soap_in_PointerTons1__GetActionsHeaders(struct soap *soap, const char *tag, ns1__GetActionsHeaders **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__GetActionsHeaders **)soap_malloc(soap, sizeof(ns1__GetActionsHeaders *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__GetActionsHeaders *)soap_instantiate_ns1__GetActionsHeaders(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__GetActionsHeaders **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__GetActionsHeaders, sizeof(ns1__GetActionsHeaders), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__GetActionsHeaders(struct soap *soap, ns1__GetActionsHeaders *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__GetActionsHeaders(soap, tag ? tag : "ns1:GetActionsHeaders", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__GetActionsHeaders ** SOAP_FMAC4 soap_get_PointerTons1__GetActionsHeaders(struct soap *soap, ns1__GetActionsHeaders **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__GetActionsHeaders(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__GetCompanyHeaders(struct soap *soap, ns1__GetCompanyHeaders *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__GetCompanyHeaders))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__GetCompanyHeaders(struct soap *soap, const char *tag, int id, ns1__GetCompanyHeaders *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__GetCompanyHeaders, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__GetCompanyHeaders ? type : NULL);
}

SOAP_FMAC3 ns1__GetCompanyHeaders ** SOAP_FMAC4 soap_in_PointerTons1__GetCompanyHeaders(struct soap *soap, const char *tag, ns1__GetCompanyHeaders **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__GetCompanyHeaders **)soap_malloc(soap, sizeof(ns1__GetCompanyHeaders *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__GetCompanyHeaders *)soap_instantiate_ns1__GetCompanyHeaders(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__GetCompanyHeaders **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__GetCompanyHeaders, sizeof(ns1__GetCompanyHeaders), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__GetCompanyHeaders(struct soap *soap, ns1__GetCompanyHeaders *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__GetCompanyHeaders(soap, tag ? tag : "ns1:GetCompanyHeaders", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__GetCompanyHeaders ** SOAP_FMAC4 soap_get_PointerTons1__GetCompanyHeaders(struct soap *soap, ns1__GetCompanyHeaders **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__GetCompanyHeaders(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__GetFundamentalsHeaders(struct soap *soap, ns1__GetFundamentalsHeaders *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__GetFundamentalsHeaders))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__GetFundamentalsHeaders(struct soap *soap, const char *tag, int id, ns1__GetFundamentalsHeaders *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__GetFundamentalsHeaders, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__GetFundamentalsHeaders ? type : NULL);
}

SOAP_FMAC3 ns1__GetFundamentalsHeaders ** SOAP_FMAC4 soap_in_PointerTons1__GetFundamentalsHeaders(struct soap *soap, const char *tag, ns1__GetFundamentalsHeaders **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__GetFundamentalsHeaders **)soap_malloc(soap, sizeof(ns1__GetFundamentalsHeaders *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__GetFundamentalsHeaders *)soap_instantiate_ns1__GetFundamentalsHeaders(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__GetFundamentalsHeaders **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__GetFundamentalsHeaders, sizeof(ns1__GetFundamentalsHeaders), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__GetFundamentalsHeaders(struct soap *soap, ns1__GetFundamentalsHeaders *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__GetFundamentalsHeaders(soap, tag ? tag : "ns1:GetFundamentalsHeaders", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__GetFundamentalsHeaders ** SOAP_FMAC4 soap_get_PointerTons1__GetFundamentalsHeaders(struct soap *soap, ns1__GetFundamentalsHeaders **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__GetFundamentalsHeaders(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__GetHistoryHeaders(struct soap *soap, ns1__GetHistoryHeaders *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__GetHistoryHeaders))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__GetHistoryHeaders(struct soap *soap, const char *tag, int id, ns1__GetHistoryHeaders *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__GetHistoryHeaders, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__GetHistoryHeaders ? type : NULL);
}

SOAP_FMAC3 ns1__GetHistoryHeaders ** SOAP_FMAC4 soap_in_PointerTons1__GetHistoryHeaders(struct soap *soap, const char *tag, ns1__GetHistoryHeaders **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__GetHistoryHeaders **)soap_malloc(soap, sizeof(ns1__GetHistoryHeaders *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__GetHistoryHeaders *)soap_instantiate_ns1__GetHistoryHeaders(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__GetHistoryHeaders **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__GetHistoryHeaders, sizeof(ns1__GetHistoryHeaders), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__GetHistoryHeaders(struct soap *soap, ns1__GetHistoryHeaders *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__GetHistoryHeaders(soap, tag ? tag : "ns1:GetHistoryHeaders", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__GetHistoryHeaders ** SOAP_FMAC4 soap_get_PointerTons1__GetHistoryHeaders(struct soap *soap, ns1__GetHistoryHeaders **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__GetHistoryHeaders(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__GetDataHeaders(struct soap *soap, ns1__GetDataHeaders *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__GetDataHeaders))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__GetDataHeaders(struct soap *soap, const char *tag, int id, ns1__GetDataHeaders *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__GetDataHeaders, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__GetDataHeaders ? type : NULL);
}

SOAP_FMAC3 ns1__GetDataHeaders ** SOAP_FMAC4 soap_in_PointerTons1__GetDataHeaders(struct soap *soap, const char *tag, ns1__GetDataHeaders **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__GetDataHeaders **)soap_malloc(soap, sizeof(ns1__GetDataHeaders *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__GetDataHeaders *)soap_instantiate_ns1__GetDataHeaders(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__GetDataHeaders **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__GetDataHeaders, sizeof(ns1__GetDataHeaders), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__GetDataHeaders(struct soap *soap, ns1__GetDataHeaders *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__GetDataHeaders(soap, tag ? tag : "ns1:GetDataHeaders", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__GetDataHeaders ** SOAP_FMAC4 soap_get_PointerTons1__GetDataHeaders(struct soap *soap, ns1__GetDataHeaders **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__GetDataHeaders(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__BvalFieldSet(struct soap *soap, ns1__BvalFieldSet *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__BvalFieldSet))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__BvalFieldSet(struct soap *soap, const char *tag, int id, ns1__BvalFieldSet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__BvalFieldSet, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__BvalFieldSet ? type : NULL);
}

SOAP_FMAC3 ns1__BvalFieldSet ** SOAP_FMAC4 soap_in_PointerTons1__BvalFieldSet(struct soap *soap, const char *tag, ns1__BvalFieldSet **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__BvalFieldSet **)soap_malloc(soap, sizeof(ns1__BvalFieldSet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__BvalFieldSet *)soap_instantiate_ns1__BvalFieldSet(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__BvalFieldSet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__BvalFieldSet, sizeof(ns1__BvalFieldSet), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__BvalFieldSet(struct soap *soap, ns1__BvalFieldSet *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__BvalFieldSet(soap, tag ? tag : "ns1:BvalFieldSet", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__BvalFieldSet ** SOAP_FMAC4 soap_get_PointerTons1__BvalFieldSet(struct soap *soap, ns1__BvalFieldSet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__BvalFieldSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__date(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__date))
		soap_serialize_xsd__date(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__date(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__date, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__date(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__date(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__date(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__date, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__date(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__date(soap, tag ? tag : "xsd:date", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__date(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__date(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__FieldSet(struct soap *soap, ns1__FieldSet *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__FieldSet))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__FieldSet(struct soap *soap, const char *tag, int id, ns1__FieldSet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__FieldSet, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__FieldSet ? type : NULL);
}

SOAP_FMAC3 ns1__FieldSet ** SOAP_FMAC4 soap_in_PointerTons1__FieldSet(struct soap *soap, const char *tag, ns1__FieldSet **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__FieldSet **)soap_malloc(soap, sizeof(ns1__FieldSet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__FieldSet *)soap_instantiate_ns1__FieldSet(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__FieldSet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__FieldSet, sizeof(ns1__FieldSet), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__FieldSet(struct soap *soap, ns1__FieldSet *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__FieldSet(soap, tag ? tag : "ns1:FieldSet", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__FieldSet ** SOAP_FMAC4 soap_get_PointerTons1__FieldSet(struct soap *soap, ns1__FieldSet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__FieldSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TickOutputTz(struct soap *soap, ns1__TickOutputTz *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TickOutputTz))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TickOutputTz(struct soap *soap, const char *tag, int id, ns1__TickOutputTz *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TickOutputTz, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__TickOutputTz ? type : NULL);
}

SOAP_FMAC3 ns1__TickOutputTz ** SOAP_FMAC4 soap_in_PointerTons1__TickOutputTz(struct soap *soap, const char *tag, ns1__TickOutputTz **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__TickOutputTz **)soap_malloc(soap, sizeof(ns1__TickOutputTz *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__TickOutputTz *)soap_instantiate_ns1__TickOutputTz(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__TickOutputTz **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TickOutputTz, sizeof(ns1__TickOutputTz), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TickOutputTz(struct soap *soap, ns1__TickOutputTz *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__TickOutputTz(soap, tag ? tag : "ns1:TickOutputTz", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__TickOutputTz ** SOAP_FMAC4 soap_get_PointerTons1__TickOutputTz(struct soap *soap, ns1__TickOutputTz **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TickOutputTz(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DateTimeRange(struct soap *soap, ns1__DateTimeRange *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__DateTimeRange))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DateTimeRange(struct soap *soap, const char *tag, int id, ns1__DateTimeRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__DateTimeRange, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__DateTimeRange ? type : NULL);
}

SOAP_FMAC3 ns1__DateTimeRange ** SOAP_FMAC4 soap_in_PointerTons1__DateTimeRange(struct soap *soap, const char *tag, ns1__DateTimeRange **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__DateTimeRange **)soap_malloc(soap, sizeof(ns1__DateTimeRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__DateTimeRange *)soap_instantiate_ns1__DateTimeRange(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__DateTimeRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DateTimeRange, sizeof(ns1__DateTimeRange), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DateTimeRange(struct soap *soap, ns1__DateTimeRange *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__DateTimeRange(soap, tag ? tag : "ns1:DateTimeRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__DateTimeRange ** SOAP_FMAC4 soap_get_PointerTons1__DateTimeRange(struct soap *soap, ns1__DateTimeRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DateTimeRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ActionsDate(struct soap *soap, enum ns1__ActionsDate *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns1__ActionsDate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ActionsDate(struct soap *soap, const char *tag, int id, enum ns1__ActionsDate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ActionsDate, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ActionsDate(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__ActionsDate ** SOAP_FMAC4 soap_in_PointerTons1__ActionsDate(struct soap *soap, const char *tag, enum ns1__ActionsDate **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__ActionsDate **)soap_malloc(soap, sizeof(enum ns1__ActionsDate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ActionsDate(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__ActionsDate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ActionsDate, sizeof(enum ns1__ActionsDate), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ActionsDate(struct soap *soap, enum ns1__ActionsDate *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ActionsDate(soap, tag ? tag : "ns1:ActionsDate", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__ActionsDate ** SOAP_FMAC4 soap_get_PointerTons1__ActionsDate(struct soap *soap, enum ns1__ActionsDate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ActionsDate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Actions(struct soap *soap, ns1__Actions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Actions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Actions(struct soap *soap, const char *tag, int id, ns1__Actions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Actions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__Actions ? type : NULL);
}

SOAP_FMAC3 ns1__Actions ** SOAP_FMAC4 soap_in_PointerTons1__Actions(struct soap *soap, const char *tag, ns1__Actions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Actions **)soap_malloc(soap, sizeof(ns1__Actions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Actions *)soap_instantiate_ns1__Actions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__Actions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Actions, sizeof(ns1__Actions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Actions(struct soap *soap, ns1__Actions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Actions(soap, tag ? tag : "ns1:Actions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Actions ** SOAP_FMAC4 soap_get_PointerTons1__Actions(struct soap *soap, ns1__Actions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Actions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Periodicity(struct soap *soap, enum ns1__Periodicity *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns1__Periodicity);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Periodicity(struct soap *soap, const char *tag, int id, enum ns1__Periodicity *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Periodicity, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__Periodicity(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__Periodicity ** SOAP_FMAC4 soap_in_PointerTons1__Periodicity(struct soap *soap, const char *tag, enum ns1__Periodicity **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__Periodicity **)soap_malloc(soap, sizeof(enum ns1__Periodicity *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__Periodicity(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__Periodicity **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Periodicity, sizeof(enum ns1__Periodicity), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Periodicity(struct soap *soap, enum ns1__Periodicity *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Periodicity(soap, tag ? tag : "ns1:Periodicity", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__Periodicity ** SOAP_FMAC4 soap_get_PointerTons1__Periodicity(struct soap *soap, enum ns1__Periodicity **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Periodicity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__FilingStatus(struct soap *soap, enum ns1__FilingStatus *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns1__FilingStatus);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__FilingStatus(struct soap *soap, const char *tag, int id, enum ns1__FilingStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__FilingStatus, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__FilingStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__FilingStatus ** SOAP_FMAC4 soap_in_PointerTons1__FilingStatus(struct soap *soap, const char *tag, enum ns1__FilingStatus **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__FilingStatus **)soap_malloc(soap, sizeof(enum ns1__FilingStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__FilingStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__FilingStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__FilingStatus, sizeof(enum ns1__FilingStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__FilingStatus(struct soap *soap, enum ns1__FilingStatus *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__FilingStatus(soap, tag ? tag : "ns1:FilingStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__FilingStatus ** SOAP_FMAC4 soap_get_PointerTons1__FilingStatus(struct soap *soap, enum ns1__FilingStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__FilingStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__HistOption(struct soap *soap, enum ns1__HistOption *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns1__HistOption);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__HistOption(struct soap *soap, const char *tag, int id, enum ns1__HistOption *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__HistOption, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__HistOption(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__HistOption ** SOAP_FMAC4 soap_in_PointerTons1__HistOption(struct soap *soap, const char *tag, enum ns1__HistOption **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__HistOption **)soap_malloc(soap, sizeof(enum ns1__HistOption *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__HistOption(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__HistOption **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__HistOption, sizeof(enum ns1__HistOption), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__HistOption(struct soap *soap, enum ns1__HistOption *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__HistOption(soap, tag ? tag : "ns1:HistOption", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__HistOption ** SOAP_FMAC4 soap_get_PointerTons1__HistOption(struct soap *soap, enum ns1__HistOption **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__HistOption(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__HistPeriod(struct soap *soap, enum ns1__HistPeriod *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns1__HistPeriod);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__HistPeriod(struct soap *soap, const char *tag, int id, enum ns1__HistPeriod *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__HistPeriod, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__HistPeriod(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__HistPeriod ** SOAP_FMAC4 soap_in_PointerTons1__HistPeriod(struct soap *soap, const char *tag, enum ns1__HistPeriod **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__HistPeriod **)soap_malloc(soap, sizeof(enum ns1__HistPeriod *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__HistPeriod(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__HistPeriod **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__HistPeriod, sizeof(enum ns1__HistPeriod), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__HistPeriod(struct soap *soap, enum ns1__HistPeriod *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__HistPeriod(soap, tag ? tag : "ns1:HistPeriod", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__HistPeriod ** SOAP_FMAC4 soap_get_PointerTons1__HistPeriod(struct soap *soap, enum ns1__HistPeriod **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__HistPeriod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DateRange(struct soap *soap, ns1__DateRange *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__DateRange))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DateRange(struct soap *soap, const char *tag, int id, ns1__DateRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__DateRange, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__DateRange ? type : NULL);
}

SOAP_FMAC3 ns1__DateRange ** SOAP_FMAC4 soap_in_PointerTons1__DateRange(struct soap *soap, const char *tag, ns1__DateRange **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__DateRange **)soap_malloc(soap, sizeof(ns1__DateRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__DateRange *)soap_instantiate_ns1__DateRange(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__DateRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DateRange, sizeof(ns1__DateRange), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DateRange(struct soap *soap, ns1__DateRange *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__DateRange(soap, tag ? tag : "ns1:DateRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__DateRange ** SOAP_FMAC4 soap_get_PointerTons1__DateRange(struct soap *soap, ns1__DateRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DateRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Duration(struct soap *soap, ns1__Duration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Duration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Duration(struct soap *soap, const char *tag, int id, ns1__Duration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Duration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__Duration ? type : NULL);
}

SOAP_FMAC3 ns1__Duration ** SOAP_FMAC4 soap_in_PointerTons1__Duration(struct soap *soap, const char *tag, ns1__Duration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Duration **)soap_malloc(soap, sizeof(ns1__Duration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Duration *)soap_instantiate_ns1__Duration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__Duration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Duration, sizeof(ns1__Duration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Duration(struct soap *soap, ns1__Duration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Duration(soap, tag ? tag : "ns1:Duration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Duration ** SOAP_FMAC4 soap_get_PointerTons1__Duration(struct soap *soap, ns1__Duration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Duration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Period(struct soap *soap, ns1__Period *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Period))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Period(struct soap *soap, const char *tag, int id, ns1__Period *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Period, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__Period ? type : NULL);
}

SOAP_FMAC3 ns1__Period ** SOAP_FMAC4 soap_in_PointerTons1__Period(struct soap *soap, const char *tag, ns1__Period **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Period **)soap_malloc(soap, sizeof(ns1__Period *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Period *)soap_instantiate_ns1__Period(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__Period **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Period, sizeof(ns1__Period), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Period(struct soap *soap, ns1__Period *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Period(soap, tag ? tag : "ns1:Period", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Period ** SOAP_FMAC4 soap_get_PointerTons1__Period(struct soap *soap, ns1__Period **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Period(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RegSolvency(struct soap *soap, enum ns1__RegSolvency *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns1__RegSolvency);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RegSolvency(struct soap *soap, const char *tag, int id, enum ns1__RegSolvency *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__RegSolvency, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__RegSolvency(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__RegSolvency ** SOAP_FMAC4 soap_in_PointerTons1__RegSolvency(struct soap *soap, const char *tag, enum ns1__RegSolvency **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__RegSolvency **)soap_malloc(soap, sizeof(enum ns1__RegSolvency *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__RegSolvency(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__RegSolvency **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__RegSolvency, sizeof(enum ns1__RegSolvency), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RegSolvency(struct soap *soap, enum ns1__RegSolvency *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__RegSolvency(soap, tag ? tag : "ns1:RegSolvency", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__RegSolvency ** SOAP_FMAC4 soap_get_PointerTons1__RegSolvency(struct soap *soap, enum ns1__RegSolvency **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RegSolvency(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PortSecDes(struct soap *soap, enum ns1__PortSecDes *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns1__PortSecDes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PortSecDes(struct soap *soap, const char *tag, int id, enum ns1__PortSecDes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__PortSecDes, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__PortSecDes(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__PortSecDes ** SOAP_FMAC4 soap_in_PointerTons1__PortSecDes(struct soap *soap, const char *tag, enum ns1__PortSecDes **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__PortSecDes **)soap_malloc(soap, sizeof(enum ns1__PortSecDes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__PortSecDes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__PortSecDes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PortSecDes, sizeof(enum ns1__PortSecDes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PortSecDes(struct soap *soap, enum ns1__PortSecDes *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__PortSecDes(soap, tag ? tag : "ns1:PortSecDes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__PortSecDes ** SOAP_FMAC4 soap_get_PointerTons1__PortSecDes(struct soap *soap, enum ns1__PortSecDes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PortSecDes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__BvalSnapshot(struct soap *soap, enum ns1__BvalSnapshot *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns1__BvalSnapshot);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__BvalSnapshot(struct soap *soap, const char *tag, int id, enum ns1__BvalSnapshot *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__BvalSnapshot, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__BvalSnapshot(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__BvalSnapshot ** SOAP_FMAC4 soap_in_PointerTons1__BvalSnapshot(struct soap *soap, const char *tag, enum ns1__BvalSnapshot **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__BvalSnapshot **)soap_malloc(soap, sizeof(enum ns1__BvalSnapshot *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__BvalSnapshot(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__BvalSnapshot **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__BvalSnapshot, sizeof(enum ns1__BvalSnapshot), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__BvalSnapshot(struct soap *soap, enum ns1__BvalSnapshot *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__BvalSnapshot(soap, tag ? tag : "ns1:BvalSnapshot", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__BvalSnapshot ** SOAP_FMAC4 soap_get_PointerTons1__BvalSnapshot(struct soap *soap, enum ns1__BvalSnapshot **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__BvalSnapshot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__BvalTier(struct soap *soap, enum ns1__BvalTier *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns1__BvalTier);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__BvalTier(struct soap *soap, const char *tag, int id, enum ns1__BvalTier *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__BvalTier, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__BvalTier(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__BvalTier ** SOAP_FMAC4 soap_in_PointerTons1__BvalTier(struct soap *soap, const char *tag, enum ns1__BvalTier **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__BvalTier **)soap_malloc(soap, sizeof(enum ns1__BvalTier *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__BvalTier(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__BvalTier **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__BvalTier, sizeof(enum ns1__BvalTier), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__BvalTier(struct soap *soap, enum ns1__BvalTier *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__BvalTier(soap, tag ? tag : "ns1:BvalTier", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__BvalTier ** SOAP_FMAC4 soap_get_PointerTons1__BvalTier(struct soap *soap, enum ns1__BvalTier **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__BvalTier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__MarketSector(struct soap *soap, enum ns1__MarketSector *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns1__MarketSector);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__MarketSector(struct soap *soap, const char *tag, int id, enum ns1__MarketSector *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__MarketSector, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__MarketSector(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__MarketSector ** SOAP_FMAC4 soap_in_PointerTons1__MarketSector(struct soap *soap, const char *tag, enum ns1__MarketSector **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__MarketSector **)soap_malloc(soap, sizeof(enum ns1__MarketSector *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__MarketSector(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__MarketSector **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__MarketSector, sizeof(enum ns1__MarketSector), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__MarketSector(struct soap *soap, enum ns1__MarketSector *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__MarketSector(soap, tag ? tag : "ns1:MarketSector", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__MarketSector ** SOAP_FMAC4 soap_get_PointerTons1__MarketSector(struct soap *soap, enum ns1__MarketSector **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__MarketSector(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Version(struct soap *soap, enum ns1__Version *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns1__Version);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Version(struct soap *soap, const char *tag, int id, enum ns1__Version *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Version, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__Version(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__Version ** SOAP_FMAC4 soap_in_PointerTons1__Version(struct soap *soap, const char *tag, enum ns1__Version **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__Version **)soap_malloc(soap, sizeof(enum ns1__Version *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__Version(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__Version **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Version, sizeof(enum ns1__Version), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Version(struct soap *soap, enum ns1__Version *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Version(soap, tag ? tag : "ns1:Version", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__Version ** SOAP_FMAC4 soap_get_PointerTons1__Version(struct soap *soap, enum ns1__Version **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Version(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SpecialChar(struct soap *soap, enum ns1__SpecialChar *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns1__SpecialChar);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SpecialChar(struct soap *soap, const char *tag, int id, enum ns1__SpecialChar *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SpecialChar, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SpecialChar(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__SpecialChar ** SOAP_FMAC4 soap_in_PointerTons1__SpecialChar(struct soap *soap, const char *tag, enum ns1__SpecialChar **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__SpecialChar **)soap_malloc(soap, sizeof(enum ns1__SpecialChar *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SpecialChar(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__SpecialChar **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SpecialChar, sizeof(enum ns1__SpecialChar), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SpecialChar(struct soap *soap, enum ns1__SpecialChar *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SpecialChar(soap, tag ? tag : "ns1:SpecialChar", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__SpecialChar ** SOAP_FMAC4 soap_get_PointerTons1__SpecialChar(struct soap *soap, enum ns1__SpecialChar **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SpecialChar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToint(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__InstrumentType(struct soap *soap, enum ns1__InstrumentType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns1__InstrumentType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__InstrumentType(struct soap *soap, const char *tag, int id, enum ns1__InstrumentType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__InstrumentType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__InstrumentType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__InstrumentType ** SOAP_FMAC4 soap_in_PointerTons1__InstrumentType(struct soap *soap, const char *tag, enum ns1__InstrumentType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__InstrumentType **)soap_malloc(soap, sizeof(enum ns1__InstrumentType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__InstrumentType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__InstrumentType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__InstrumentType, sizeof(enum ns1__InstrumentType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__InstrumentType(struct soap *soap, enum ns1__InstrumentType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__InstrumentType(soap, tag ? tag : "ns1:InstrumentType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__InstrumentType ** SOAP_FMAC4 soap_get_PointerTons1__InstrumentType(struct soap *soap, enum ns1__InstrumentType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__InstrumentType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ProgramFlag(struct soap *soap, enum ns1__ProgramFlag *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns1__ProgramFlag);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ProgramFlag(struct soap *soap, const char *tag, int id, enum ns1__ProgramFlag *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ProgramFlag, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ProgramFlag(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__ProgramFlag ** SOAP_FMAC4 soap_in_PointerTons1__ProgramFlag(struct soap *soap, const char *tag, enum ns1__ProgramFlag **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__ProgramFlag **)soap_malloc(soap, sizeof(enum ns1__ProgramFlag *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ProgramFlag(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__ProgramFlag **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ProgramFlag, sizeof(enum ns1__ProgramFlag), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ProgramFlag(struct soap *soap, enum ns1__ProgramFlag *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ProgramFlag(soap, tag ? tag : "ns1:ProgramFlag", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__ProgramFlag ** SOAP_FMAC4 soap_get_PointerTons1__ProgramFlag(struct soap *soap, enum ns1__ProgramFlag **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ProgramFlag(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTostd__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DiffFlag(struct soap *soap, enum ns1__DiffFlag *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns1__DiffFlag);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DiffFlag(struct soap *soap, const char *tag, int id, enum ns1__DiffFlag *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__DiffFlag, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__DiffFlag(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__DiffFlag ** SOAP_FMAC4 soap_in_PointerTons1__DiffFlag(struct soap *soap, const char *tag, enum ns1__DiffFlag **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__DiffFlag **)soap_malloc(soap, sizeof(enum ns1__DiffFlag *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__DiffFlag(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__DiffFlag **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DiffFlag, sizeof(enum ns1__DiffFlag), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DiffFlag(struct soap *soap, enum ns1__DiffFlag *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__DiffFlag(soap, tag ? tag : "ns1:DiffFlag", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__DiffFlag ** SOAP_FMAC4 soap_get_PointerTons1__DiffFlag(struct soap *soap, enum ns1__DiffFlag **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DiffFlag(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobool(struct soap *soap, bool *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobool(struct soap *soap, const char *tag, int id, bool *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bool, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_bool(soap, tag, id, *a, type);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_in_PointerTobool(struct soap *soap, const char *tag, bool **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bool **)soap_malloc(soap, sizeof(bool *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bool(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (bool **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bool, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobool(struct soap *soap, bool *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTobool(soap, tag ? tag : "boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_get_PointerTobool(struct soap *soap, bool **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DateFormat(struct soap *soap, enum ns1__DateFormat *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns1__DateFormat);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DateFormat(struct soap *soap, const char *tag, int id, enum ns1__DateFormat *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__DateFormat, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__DateFormat(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__DateFormat ** SOAP_FMAC4 soap_in_PointerTons1__DateFormat(struct soap *soap, const char *tag, enum ns1__DateFormat **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__DateFormat **)soap_malloc(soap, sizeof(enum ns1__DateFormat *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__DateFormat(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__DateFormat **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DateFormat, sizeof(enum ns1__DateFormat), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DateFormat(struct soap *soap, enum ns1__DateFormat *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__DateFormat(soap, tag ? tag : "ns1:DateFormat", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__DateFormat ** SOAP_FMAC4 soap_get_PointerTons1__DateFormat(struct soap *soap, enum ns1__DateFormat **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DateFormat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *a = static_cast<char * *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char *)));
	for (char * *p = a; p && n--; ++p)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__CancelResponseStatus(struct soap *soap, std::vector<ns1__CancelResponseStatus *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__CancelResponseStatus(struct soap *soap, const std::vector<ns1__CancelResponseStatus *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__CancelResponseStatus *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__CancelResponseStatus(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__CancelResponseStatus(struct soap *soap, const char *tag, int id, const std::vector<ns1__CancelResponseStatus *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__CancelResponseStatus *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__CancelResponseStatus(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__CancelResponseStatus *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__CancelResponseStatus(struct soap *soap, const char *tag, std::vector<ns1__CancelResponseStatus *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__CancelResponseStatus(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__CancelResponseStatus *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__CancelResponseStatus, SOAP_TYPE_std__vectorTemplateOfPointerTons1__CancelResponseStatus, sizeof(ns1__CancelResponseStatus), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__CancelResponseStatus(soap, tag, NULL, "ns1:CancelResponseStatus"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__CancelResponseStatus(soap, tag, &n, "ns1:CancelResponseStatus"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__CancelResponseStatus *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__CancelResponseStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__CancelResponseStatus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__CancelResponseStatus *> *p;
	size_t k = sizeof(std::vector<ns1__CancelResponseStatus *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__CancelResponseStatus, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__CancelResponseStatus *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__CancelResponseStatus *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__CancelResponseStatus *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__MmktBvalDealInformation(struct soap *soap, std::vector<ns1__MmktBvalDealInformation *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__MmktBvalDealInformation(struct soap *soap, const std::vector<ns1__MmktBvalDealInformation *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__MmktBvalDealInformation *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__MmktBvalDealInformation(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__MmktBvalDealInformation(struct soap *soap, const char *tag, int id, const std::vector<ns1__MmktBvalDealInformation *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__MmktBvalDealInformation *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__MmktBvalDealInformation(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__MmktBvalDealInformation *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__MmktBvalDealInformation(struct soap *soap, const char *tag, std::vector<ns1__MmktBvalDealInformation *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__MmktBvalDealInformation(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__MmktBvalDealInformation *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__MmktBvalDealInformation, SOAP_TYPE_std__vectorTemplateOfPointerTons1__MmktBvalDealInformation, sizeof(ns1__MmktBvalDealInformation), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__MmktBvalDealInformation(soap, tag, NULL, "ns1:MmktBvalDealInformation"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__MmktBvalDealInformation(soap, tag, &n, "ns1:MmktBvalDealInformation"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__MmktBvalDealInformation *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__MmktBvalDealInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__MmktBvalDealInformation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__MmktBvalDealInformation *> *p;
	size_t k = sizeof(std::vector<ns1__MmktBvalDealInformation *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__MmktBvalDealInformation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__MmktBvalDealInformation *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__MmktBvalDealInformation *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__MmktBvalDealInformation *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__ScheduledResponse(struct soap *soap, std::vector<ns1__ScheduledResponse *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__ScheduledResponse(struct soap *soap, const std::vector<ns1__ScheduledResponse *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__ScheduledResponse *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__ScheduledResponse(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__ScheduledResponse(struct soap *soap, const char *tag, int id, const std::vector<ns1__ScheduledResponse *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__ScheduledResponse *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__ScheduledResponse(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__ScheduledResponse *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__ScheduledResponse(struct soap *soap, const char *tag, std::vector<ns1__ScheduledResponse *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__ScheduledResponse(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__ScheduledResponse *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__ScheduledResponse, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ScheduledResponse, sizeof(ns1__ScheduledResponse), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__ScheduledResponse(soap, tag, NULL, "ns1:ScheduledResponse"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__ScheduledResponse(soap, tag, &n, "ns1:ScheduledResponse"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__ScheduledResponse *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__ScheduledResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__ScheduledResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__ScheduledResponse *> *p;
	size_t k = sizeof(std::vector<ns1__ScheduledResponse *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ScheduledResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__ScheduledResponse *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__ScheduledResponse *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__ScheduledResponse *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__OtcDealInformation(struct soap *soap, std::vector<ns1__OtcDealInformation *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__OtcDealInformation(struct soap *soap, const std::vector<ns1__OtcDealInformation *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__OtcDealInformation *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__OtcDealInformation(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__OtcDealInformation(struct soap *soap, const char *tag, int id, const std::vector<ns1__OtcDealInformation *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__OtcDealInformation *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__OtcDealInformation(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__OtcDealInformation *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__OtcDealInformation(struct soap *soap, const char *tag, std::vector<ns1__OtcDealInformation *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__OtcDealInformation(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__OtcDealInformation *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__OtcDealInformation, SOAP_TYPE_std__vectorTemplateOfPointerTons1__OtcDealInformation, sizeof(ns1__OtcDealInformation), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__OtcDealInformation(soap, tag, NULL, "ns1:OtcDealInformation"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__OtcDealInformation(soap, tag, &n, "ns1:OtcDealInformation"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__OtcDealInformation *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__OtcDealInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__OtcDealInformation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__OtcDealInformation *> *p;
	size_t k = sizeof(std::vector<ns1__OtcDealInformation *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__OtcDealInformation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__OtcDealInformation *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__OtcDealInformation *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__OtcDealInformation *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__FieldInfo(struct soap *soap, std::vector<ns1__FieldInfo *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__FieldInfo(struct soap *soap, const std::vector<ns1__FieldInfo *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__FieldInfo *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__FieldInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__FieldInfo(struct soap *soap, const char *tag, int id, const std::vector<ns1__FieldInfo *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__FieldInfo *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__FieldInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__FieldInfo *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__FieldInfo(struct soap *soap, const char *tag, std::vector<ns1__FieldInfo *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__FieldInfo(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__FieldInfo *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__FieldInfo, SOAP_TYPE_std__vectorTemplateOfPointerTons1__FieldInfo, sizeof(ns1__FieldInfo), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__FieldInfo(soap, tag, NULL, "ns1:FieldInfo"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__FieldInfo(soap, tag, &n, "ns1:FieldInfo"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__FieldInfo *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__FieldInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__FieldInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__FieldInfo *> *p;
	size_t k = sizeof(std::vector<ns1__FieldInfo *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__FieldInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__FieldInfo *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__FieldInfo *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__FieldInfo *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns1__DLCategory2(struct soap *soap, std::vector<enum ns1__DLCategory2> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns1__DLCategory2(struct soap *soap, const std::vector<enum ns1__DLCategory2> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns1__DLCategory2(struct soap *soap, const char *tag, int id, const std::vector<enum ns1__DLCategory2> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<enum ns1__DLCategory2> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_ns1__DLCategory2(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum ns1__DLCategory2> * SOAP_FMAC4 soap_in_std__vectorTemplateOfns1__DLCategory2(struct soap *soap, const char *tag, std::vector<enum ns1__DLCategory2> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfns1__DLCategory2(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		enum ns1__DLCategory2 n;
		soap_default_ns1__DLCategory2(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__DLCategory2, SOAP_TYPE_std__vectorTemplateOfns1__DLCategory2, sizeof(enum ns1__DLCategory2), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_ns1__DLCategory2(soap, tag, NULL, "ns1:DLCategory2"))
				break;
		}
		else
		{	if (!soap_in_ns1__DLCategory2(soap, tag, &n, "ns1:DLCategory2"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum ns1__DLCategory2>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfns1__DLCategory2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfns1__DLCategory2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<enum ns1__DLCategory2> *p;
	size_t k = sizeof(std::vector<enum ns1__DLCategory2> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfns1__DLCategory2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<enum ns1__DLCategory2> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<enum ns1__DLCategory2> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<enum ns1__DLCategory2>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns1__MarketSector(struct soap *soap, std::vector<enum ns1__MarketSector> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns1__MarketSector(struct soap *soap, const std::vector<enum ns1__MarketSector> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns1__MarketSector(struct soap *soap, const char *tag, int id, const std::vector<enum ns1__MarketSector> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<enum ns1__MarketSector> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_ns1__MarketSector(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum ns1__MarketSector> * SOAP_FMAC4 soap_in_std__vectorTemplateOfns1__MarketSector(struct soap *soap, const char *tag, std::vector<enum ns1__MarketSector> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfns1__MarketSector(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		enum ns1__MarketSector n;
		soap_default_ns1__MarketSector(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__MarketSector, SOAP_TYPE_std__vectorTemplateOfns1__MarketSector, sizeof(enum ns1__MarketSector), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_ns1__MarketSector(soap, tag, NULL, "ns1:MarketSector"))
				break;
		}
		else
		{	if (!soap_in_ns1__MarketSector(soap, tag, &n, "ns1:MarketSector"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum ns1__MarketSector>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfns1__MarketSector(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfns1__MarketSector(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<enum ns1__MarketSector> *p;
	size_t k = sizeof(std::vector<enum ns1__MarketSector> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfns1__MarketSector, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<enum ns1__MarketSector> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<enum ns1__MarketSector> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<enum ns1__MarketSector>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns1__DLCategory(struct soap *soap, std::vector<enum ns1__DLCategory> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns1__DLCategory(struct soap *soap, const std::vector<enum ns1__DLCategory> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns1__DLCategory(struct soap *soap, const char *tag, int id, const std::vector<enum ns1__DLCategory> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<enum ns1__DLCategory> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_ns1__DLCategory(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum ns1__DLCategory> * SOAP_FMAC4 soap_in_std__vectorTemplateOfns1__DLCategory(struct soap *soap, const char *tag, std::vector<enum ns1__DLCategory> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfns1__DLCategory(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		enum ns1__DLCategory n;
		soap_default_ns1__DLCategory(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__DLCategory, SOAP_TYPE_std__vectorTemplateOfns1__DLCategory, sizeof(enum ns1__DLCategory), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_ns1__DLCategory(soap, tag, NULL, "ns1:DLCategory"))
				break;
		}
		else
		{	if (!soap_in_ns1__DLCategory(soap, tag, &n, "ns1:DLCategory"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum ns1__DLCategory>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfns1__DLCategory(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfns1__DLCategory(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<enum ns1__DLCategory> *p;
	size_t k = sizeof(std::vector<enum ns1__DLCategory> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfns1__DLCategory, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<enum ns1__DLCategory> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<enum ns1__DLCategory> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<enum ns1__DLCategory>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__BulkArrayEntry(struct soap *soap, std::vector<ns1__BulkArrayEntry *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__BulkArrayEntry(struct soap *soap, const std::vector<ns1__BulkArrayEntry *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__BulkArrayEntry *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__BulkArrayEntry(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__BulkArrayEntry(struct soap *soap, const char *tag, int id, const std::vector<ns1__BulkArrayEntry *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__BulkArrayEntry *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__BulkArrayEntry(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__BulkArrayEntry *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__BulkArrayEntry(struct soap *soap, const char *tag, std::vector<ns1__BulkArrayEntry *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__BulkArrayEntry(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__BulkArrayEntry *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__BulkArrayEntry, SOAP_TYPE_std__vectorTemplateOfPointerTons1__BulkArrayEntry, sizeof(ns1__BulkArrayEntry), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__BulkArrayEntry(soap, tag, NULL, "ns1:BulkArrayEntry"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__BulkArrayEntry(soap, tag, &n, "ns1:BulkArrayEntry"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__BulkArrayEntry *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__BulkArrayEntry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__BulkArrayEntry(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__BulkArrayEntry *> *p;
	size_t k = sizeof(std::vector<ns1__BulkArrayEntry *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__BulkArrayEntry, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__BulkArrayEntry *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__BulkArrayEntry *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__BulkArrayEntry *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__QRMQuoteData(struct soap *soap, std::vector<ns1__QRMQuoteData *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__QRMQuoteData(struct soap *soap, const std::vector<ns1__QRMQuoteData *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__QRMQuoteData *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__QRMQuoteData(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__QRMQuoteData(struct soap *soap, const char *tag, int id, const std::vector<ns1__QRMQuoteData *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__QRMQuoteData *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__QRMQuoteData(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__QRMQuoteData *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__QRMQuoteData(struct soap *soap, const char *tag, std::vector<ns1__QRMQuoteData *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__QRMQuoteData(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__QRMQuoteData *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__QRMQuoteData, SOAP_TYPE_std__vectorTemplateOfPointerTons1__QRMQuoteData, sizeof(ns1__QRMQuoteData), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__QRMQuoteData(soap, tag, NULL, "ns1:QRMQuoteData"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__QRMQuoteData(soap, tag, &n, "ns1:QRMQuoteData"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__QRMQuoteData *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__QRMQuoteData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__QRMQuoteData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__QRMQuoteData *> *p;
	size_t k = sizeof(std::vector<ns1__QRMQuoteData *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__QRMQuoteData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__QRMQuoteData *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__QRMQuoteData *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__QRMQuoteData *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__QRMQuote(struct soap *soap, std::vector<ns1__QRMQuote *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__QRMQuote(struct soap *soap, const std::vector<ns1__QRMQuote *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__QRMQuote *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__QRMQuote(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__QRMQuote(struct soap *soap, const char *tag, int id, const std::vector<ns1__QRMQuote *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__QRMQuote *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__QRMQuote(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__QRMQuote *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__QRMQuote(struct soap *soap, const char *tag, std::vector<ns1__QRMQuote *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__QRMQuote(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__QRMQuote *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__QRMQuote, SOAP_TYPE_std__vectorTemplateOfPointerTons1__QRMQuote, sizeof(ns1__QRMQuote), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__QRMQuote(soap, tag, NULL, "ns1:QRMQuote"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__QRMQuote(soap, tag, &n, "ns1:QRMQuote"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__QRMQuote *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__QRMQuote(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__QRMQuote(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__QRMQuote *> *p;
	size_t k = sizeof(std::vector<ns1__QRMQuote *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__QRMQuote, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__QRMQuote *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__QRMQuote *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__QRMQuote *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__QRQuote(struct soap *soap, std::vector<ns1__QRQuote *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__QRQuote(struct soap *soap, const std::vector<ns1__QRQuote *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__QRQuote *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__QRQuote(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__QRQuote(struct soap *soap, const char *tag, int id, const std::vector<ns1__QRQuote *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__QRQuote *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__QRQuote(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__QRQuote *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__QRQuote(struct soap *soap, const char *tag, std::vector<ns1__QRQuote *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__QRQuote(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__QRQuote *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__QRQuote, SOAP_TYPE_std__vectorTemplateOfPointerTons1__QRQuote, sizeof(ns1__QRQuote), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__QRQuote(soap, tag, NULL, "ns1:QRQuote"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__QRQuote(soap, tag, &n, "ns1:QRQuote"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__QRQuote *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__QRQuote(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__QRQuote(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__QRQuote *> *p;
	size_t k = sizeof(std::vector<ns1__QRQuote *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__QRQuote, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__QRQuote *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__QRQuote *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__QRQuote *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__BulkArray(struct soap *soap, std::vector<ns1__BulkArray *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__BulkArray(struct soap *soap, const std::vector<ns1__BulkArray *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__BulkArray *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__BulkArray(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__BulkArray(struct soap *soap, const char *tag, int id, const std::vector<ns1__BulkArray *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__BulkArray *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__BulkArray(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__BulkArray *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__BulkArray(struct soap *soap, const char *tag, std::vector<ns1__BulkArray *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__BulkArray(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__BulkArray *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__BulkArray, SOAP_TYPE_std__vectorTemplateOfPointerTons1__BulkArray, sizeof(ns1__BulkArray), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__BulkArray(soap, tag, NULL, "ns1:BulkArray"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__BulkArray(soap, tag, &n, "ns1:BulkArray"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__BulkArray *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__BulkArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__BulkArray(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__BulkArray *> *p;
	size_t k = sizeof(std::vector<ns1__BulkArray *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__BulkArray, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__BulkArray *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__BulkArray *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__BulkArray *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__HistData(struct soap *soap, std::vector<ns1__HistData *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__HistData(struct soap *soap, const std::vector<ns1__HistData *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__HistData *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__HistData(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__HistData(struct soap *soap, const char *tag, int id, const std::vector<ns1__HistData *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__HistData *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__HistData(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__HistData *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__HistData(struct soap *soap, const char *tag, std::vector<ns1__HistData *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__HistData(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__HistData *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__HistData, SOAP_TYPE_std__vectorTemplateOfPointerTons1__HistData, sizeof(ns1__HistData), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__HistData(soap, tag, NULL, "ns1:HistData"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__HistData(soap, tag, &n, "ns1:HistData"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__HistData *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__HistData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__HistData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__HistData *> *p;
	size_t k = sizeof(std::vector<ns1__HistData *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__HistData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__HistData *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__HistData *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__HistData *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__Data(struct soap *soap, std::vector<ns1__Data *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__Data(struct soap *soap, const std::vector<ns1__Data *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__Data *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__Data(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__Data(struct soap *soap, const char *tag, int id, const std::vector<ns1__Data *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__Data *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__Data(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__Data *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__Data(struct soap *soap, const char *tag, std::vector<ns1__Data *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__Data(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__Data *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__Data, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Data, sizeof(ns1__Data), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__Data(soap, tag, NULL, "ns1:Data"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__Data(soap, tag, &n, "ns1:Data"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__Data *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__Data(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__Data(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__Data *> *p;
	size_t k = sizeof(std::vector<ns1__Data *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Data, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__Data *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__Data *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__Data *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__SecondaryQualifier(struct soap *soap, std::vector<ns1__SecondaryQualifier *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__SecondaryQualifier(struct soap *soap, const std::vector<ns1__SecondaryQualifier *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__SecondaryQualifier *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__SecondaryQualifier(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__SecondaryQualifier(struct soap *soap, const char *tag, int id, const std::vector<ns1__SecondaryQualifier *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__SecondaryQualifier *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__SecondaryQualifier(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__SecondaryQualifier *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__SecondaryQualifier(struct soap *soap, const char *tag, std::vector<ns1__SecondaryQualifier *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__SecondaryQualifier(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__SecondaryQualifier *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__SecondaryQualifier, SOAP_TYPE_std__vectorTemplateOfPointerTons1__SecondaryQualifier, sizeof(ns1__SecondaryQualifier), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__SecondaryQualifier(soap, tag, NULL, "ns1:SecondaryQualifier"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__SecondaryQualifier(soap, tag, &n, "ns1:SecondaryQualifier"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__SecondaryQualifier *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__SecondaryQualifier(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__SecondaryQualifier(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__SecondaryQualifier *> *p;
	size_t k = sizeof(std::vector<ns1__SecondaryQualifier *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__SecondaryQualifier, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__SecondaryQualifier *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__SecondaryQualifier *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__SecondaryQualifier *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__AllQuotesInstrumentData(struct soap *soap, std::vector<ns1__AllQuotesInstrumentData *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__AllQuotesInstrumentData(struct soap *soap, const std::vector<ns1__AllQuotesInstrumentData *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__AllQuotesInstrumentData *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__AllQuotesInstrumentData(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__AllQuotesInstrumentData(struct soap *soap, const char *tag, int id, const std::vector<ns1__AllQuotesInstrumentData *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__AllQuotesInstrumentData *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__AllQuotesInstrumentData(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__AllQuotesInstrumentData *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__AllQuotesInstrumentData(struct soap *soap, const char *tag, std::vector<ns1__AllQuotesInstrumentData *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__AllQuotesInstrumentData(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__AllQuotesInstrumentData *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__AllQuotesInstrumentData, SOAP_TYPE_std__vectorTemplateOfPointerTons1__AllQuotesInstrumentData, sizeof(ns1__AllQuotesInstrumentData), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__AllQuotesInstrumentData(soap, tag, NULL, "ns1:AllQuotesInstrumentData"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__AllQuotesInstrumentData(soap, tag, &n, "ns1:AllQuotesInstrumentData"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__AllQuotesInstrumentData *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__AllQuotesInstrumentData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__AllQuotesInstrumentData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__AllQuotesInstrumentData *> *p;
	size_t k = sizeof(std::vector<ns1__AllQuotesInstrumentData *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__AllQuotesInstrumentData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__AllQuotesInstrumentData *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__AllQuotesInstrumentData *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__AllQuotesInstrumentData *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__QuotesInstrumentData(struct soap *soap, std::vector<ns1__QuotesInstrumentData *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__QuotesInstrumentData(struct soap *soap, const std::vector<ns1__QuotesInstrumentData *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__QuotesInstrumentData *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__QuotesInstrumentData(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__QuotesInstrumentData(struct soap *soap, const char *tag, int id, const std::vector<ns1__QuotesInstrumentData *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__QuotesInstrumentData *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__QuotesInstrumentData(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__QuotesInstrumentData *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__QuotesInstrumentData(struct soap *soap, const char *tag, std::vector<ns1__QuotesInstrumentData *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__QuotesInstrumentData(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__QuotesInstrumentData *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__QuotesInstrumentData, SOAP_TYPE_std__vectorTemplateOfPointerTons1__QuotesInstrumentData, sizeof(ns1__QuotesInstrumentData), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__QuotesInstrumentData(soap, tag, NULL, "ns1:QuotesInstrumentData"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__QuotesInstrumentData(soap, tag, &n, "ns1:QuotesInstrumentData"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__QuotesInstrumentData *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__QuotesInstrumentData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__QuotesInstrumentData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__QuotesInstrumentData *> *p;
	size_t k = sizeof(std::vector<ns1__QuotesInstrumentData *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__QuotesInstrumentData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__QuotesInstrumentData *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__QuotesInstrumentData *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__QuotesInstrumentData *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__CorrectionRecord(struct soap *soap, std::vector<ns1__CorrectionRecord *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__CorrectionRecord(struct soap *soap, const std::vector<ns1__CorrectionRecord *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__CorrectionRecord *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__CorrectionRecord(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__CorrectionRecord(struct soap *soap, const char *tag, int id, const std::vector<ns1__CorrectionRecord *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__CorrectionRecord *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__CorrectionRecord(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__CorrectionRecord *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__CorrectionRecord(struct soap *soap, const char *tag, std::vector<ns1__CorrectionRecord *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__CorrectionRecord(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__CorrectionRecord *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__CorrectionRecord, SOAP_TYPE_std__vectorTemplateOfPointerTons1__CorrectionRecord, sizeof(ns1__CorrectionRecord), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__CorrectionRecord(soap, tag, NULL, "ns1:CorrectionRecord"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__CorrectionRecord(soap, tag, &n, "ns1:CorrectionRecord"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__CorrectionRecord *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__CorrectionRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__CorrectionRecord(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__CorrectionRecord *> *p;
	size_t k = sizeof(std::vector<ns1__CorrectionRecord *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__CorrectionRecord, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__CorrectionRecord *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__CorrectionRecord *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__CorrectionRecord *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__ActionsInstrumentData(struct soap *soap, std::vector<ns1__ActionsInstrumentData *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__ActionsInstrumentData(struct soap *soap, const std::vector<ns1__ActionsInstrumentData *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__ActionsInstrumentData *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__ActionsInstrumentData(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__ActionsInstrumentData(struct soap *soap, const char *tag, int id, const std::vector<ns1__ActionsInstrumentData *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__ActionsInstrumentData *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__ActionsInstrumentData(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__ActionsInstrumentData *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__ActionsInstrumentData(struct soap *soap, const char *tag, std::vector<ns1__ActionsInstrumentData *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__ActionsInstrumentData(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__ActionsInstrumentData *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__ActionsInstrumentData, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ActionsInstrumentData, sizeof(ns1__ActionsInstrumentData), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__ActionsInstrumentData(soap, tag, NULL, "ns1:ActionsInstrumentData"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__ActionsInstrumentData(soap, tag, &n, "ns1:ActionsInstrumentData"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__ActionsInstrumentData *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__ActionsInstrumentData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__ActionsInstrumentData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__ActionsInstrumentData *> *p;
	size_t k = sizeof(std::vector<ns1__ActionsInstrumentData *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ActionsInstrumentData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__ActionsInstrumentData *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__ActionsInstrumentData *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__ActionsInstrumentData *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__FundInstrumentData(struct soap *soap, std::vector<ns1__FundInstrumentData *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__FundInstrumentData(struct soap *soap, const std::vector<ns1__FundInstrumentData *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__FundInstrumentData *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__FundInstrumentData(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__FundInstrumentData(struct soap *soap, const char *tag, int id, const std::vector<ns1__FundInstrumentData *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__FundInstrumentData *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__FundInstrumentData(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__FundInstrumentData *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__FundInstrumentData(struct soap *soap, const char *tag, std::vector<ns1__FundInstrumentData *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__FundInstrumentData(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__FundInstrumentData *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__FundInstrumentData, SOAP_TYPE_std__vectorTemplateOfPointerTons1__FundInstrumentData, sizeof(ns1__FundInstrumentData), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__FundInstrumentData(soap, tag, NULL, "ns1:FundInstrumentData"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__FundInstrumentData(soap, tag, &n, "ns1:FundInstrumentData"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__FundInstrumentData *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__FundInstrumentData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__FundInstrumentData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__FundInstrumentData *> *p;
	size_t k = sizeof(std::vector<ns1__FundInstrumentData *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__FundInstrumentData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__FundInstrumentData *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__FundInstrumentData *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__FundInstrumentData *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__HistInstrumentData(struct soap *soap, std::vector<ns1__HistInstrumentData *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__HistInstrumentData(struct soap *soap, const std::vector<ns1__HistInstrumentData *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__HistInstrumentData *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__HistInstrumentData(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__HistInstrumentData(struct soap *soap, const char *tag, int id, const std::vector<ns1__HistInstrumentData *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__HistInstrumentData *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__HistInstrumentData(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__HistInstrumentData *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__HistInstrumentData(struct soap *soap, const char *tag, std::vector<ns1__HistInstrumentData *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__HistInstrumentData(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__HistInstrumentData *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__HistInstrumentData, SOAP_TYPE_std__vectorTemplateOfPointerTons1__HistInstrumentData, sizeof(ns1__HistInstrumentData), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__HistInstrumentData(soap, tag, NULL, "ns1:HistInstrumentData"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__HistInstrumentData(soap, tag, &n, "ns1:HistInstrumentData"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__HistInstrumentData *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__HistInstrumentData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__HistInstrumentData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__HistInstrumentData *> *p;
	size_t k = sizeof(std::vector<ns1__HistInstrumentData *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__HistInstrumentData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__HistInstrumentData *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__HistInstrumentData *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__HistInstrumentData *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__InstrumentData(struct soap *soap, std::vector<ns1__InstrumentData *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__InstrumentData(struct soap *soap, const std::vector<ns1__InstrumentData *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__InstrumentData *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__InstrumentData(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__InstrumentData(struct soap *soap, const char *tag, int id, const std::vector<ns1__InstrumentData *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__InstrumentData *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__InstrumentData(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__InstrumentData *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__InstrumentData(struct soap *soap, const char *tag, std::vector<ns1__InstrumentData *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__InstrumentData(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__InstrumentData *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__InstrumentData, SOAP_TYPE_std__vectorTemplateOfPointerTons1__InstrumentData, sizeof(ns1__InstrumentData), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__InstrumentData(soap, tag, NULL, "ns1:InstrumentData"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__InstrumentData(soap, tag, &n, "ns1:InstrumentData"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__InstrumentData *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__InstrumentData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__InstrumentData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__InstrumentData *> *p;
	size_t k = sizeof(std::vector<ns1__InstrumentData *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__InstrumentData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__InstrumentData *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__InstrumentData *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__InstrumentData *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__FundInstrument(struct soap *soap, std::vector<ns1__FundInstrument *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__FundInstrument(struct soap *soap, const std::vector<ns1__FundInstrument *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__FundInstrument *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__FundInstrument(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__FundInstrument(struct soap *soap, const char *tag, int id, const std::vector<ns1__FundInstrument *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__FundInstrument *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__FundInstrument(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__FundInstrument *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__FundInstrument(struct soap *soap, const char *tag, std::vector<ns1__FundInstrument *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__FundInstrument(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__FundInstrument *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__FundInstrument, SOAP_TYPE_std__vectorTemplateOfPointerTons1__FundInstrument, sizeof(ns1__FundInstrument), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__FundInstrument(soap, tag, NULL, "ns1:FundInstrument"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__FundInstrument(soap, tag, &n, "ns1:FundInstrument"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__FundInstrument *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__FundInstrument(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__FundInstrument(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__FundInstrument *> *p;
	size_t k = sizeof(std::vector<ns1__FundInstrument *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__FundInstrument, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__FundInstrument *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__FundInstrument *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__FundInstrument *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__Macro(struct soap *soap, std::vector<ns1__Macro *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__Macro(struct soap *soap, const std::vector<ns1__Macro *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__Macro *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__Macro(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__Macro(struct soap *soap, const char *tag, int id, const std::vector<ns1__Macro *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__Macro *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__Macro(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__Macro *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__Macro(struct soap *soap, const char *tag, std::vector<ns1__Macro *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__Macro(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__Macro *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__Macro, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Macro, sizeof(ns1__Macro), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__Macro(soap, tag, NULL, "ns1:Macro"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__Macro(soap, tag, &n, "ns1:Macro"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__Macro *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__Macro(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__Macro(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__Macro *> *p;
	size_t k = sizeof(std::vector<ns1__Macro *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Macro, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__Macro *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__Macro *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__Macro *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__Instrument(struct soap *soap, std::vector<ns1__Instrument *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__Instrument(struct soap *soap, const std::vector<ns1__Instrument *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__Instrument *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__Instrument(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__Instrument(struct soap *soap, const char *tag, int id, const std::vector<ns1__Instrument *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__Instrument *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__Instrument(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__Instrument *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__Instrument(struct soap *soap, const char *tag, std::vector<ns1__Instrument *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__Instrument(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__Instrument *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__Instrument, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Instrument, sizeof(ns1__Instrument), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__Instrument(soap, tag, NULL, "ns1:Instrument"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__Instrument(soap, tag, &n, "ns1:Instrument"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__Instrument *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__Instrument(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__Instrument(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__Instrument *> *p;
	size_t k = sizeof(std::vector<ns1__Instrument *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Instrument, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__Instrument *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__Instrument *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__Instrument *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__Override(struct soap *soap, std::vector<ns1__Override *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__Override(struct soap *soap, const std::vector<ns1__Override *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__Override *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__Override(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__Override(struct soap *soap, const char *tag, int id, const std::vector<ns1__Override *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__Override *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__Override(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__Override *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__Override(struct soap *soap, const char *tag, std::vector<ns1__Override *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__Override(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__Override *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__Override, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Override, sizeof(ns1__Override), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__Override(soap, tag, NULL, "ns1:Override"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__Override(soap, tag, &n, "ns1:Override"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__Override *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__Override(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__Override(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__Override *> *p;
	size_t k = sizeof(std::vector<ns1__Override *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Override, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__Override *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__Override *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__Override *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__string(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		std::string n;
		soap_default_std__string(soap, &n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_std__string, SOAP_TYPE_std__vectorTemplateOfstd__string, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_std__string(soap, tag, NULL, "xsd:string"))
				break;
		}
		else
		{	if (!soap_in_std__string(soap, tag, &n, "xsd:string"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(std::string));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfstd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfstd__string, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__BvalFieldSet(struct soap *soap, std::vector<ns1__BvalFieldSet *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__BvalFieldSet(struct soap *soap, const std::vector<ns1__BvalFieldSet *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__BvalFieldSet *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__BvalFieldSet(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__BvalFieldSet(struct soap *soap, const char *tag, int id, const std::vector<ns1__BvalFieldSet *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__BvalFieldSet *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__BvalFieldSet(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__BvalFieldSet *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__BvalFieldSet(struct soap *soap, const char *tag, std::vector<ns1__BvalFieldSet *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__BvalFieldSet(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__BvalFieldSet *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__BvalFieldSet, SOAP_TYPE_std__vectorTemplateOfPointerTons1__BvalFieldSet, sizeof(ns1__BvalFieldSet), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__BvalFieldSet(soap, tag, NULL, "ns1:BvalFieldSet"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__BvalFieldSet(soap, tag, &n, "ns1:BvalFieldSet"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__BvalFieldSet *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__BvalFieldSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__BvalFieldSet(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__BvalFieldSet *> *p;
	size_t k = sizeof(std::vector<ns1__BvalFieldSet *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__BvalFieldSet, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__BvalFieldSet *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__BvalFieldSet *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__BvalFieldSet *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__FieldSet(struct soap *soap, std::vector<ns1__FieldSet *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__FieldSet(struct soap *soap, const std::vector<ns1__FieldSet *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__FieldSet *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__FieldSet(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__FieldSet(struct soap *soap, const char *tag, int id, const std::vector<ns1__FieldSet *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__FieldSet *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__FieldSet(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__FieldSet *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__FieldSet(struct soap *soap, const char *tag, std::vector<ns1__FieldSet *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__FieldSet(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__FieldSet *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__FieldSet, SOAP_TYPE_std__vectorTemplateOfPointerTons1__FieldSet, sizeof(ns1__FieldSet), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__FieldSet(soap, tag, NULL, "ns1:FieldSet"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__FieldSet(soap, tag, &n, "ns1:FieldSet"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__FieldSet *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__FieldSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__FieldSet(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__FieldSet *> *p;
	size_t k = sizeof(std::vector<ns1__FieldSet *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__FieldSet, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__FieldSet *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__FieldSet *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__FieldSet *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
